id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2014-125060,CWE-287,c_cpp,"A vulnerability, which was classified as critical, was found in holdennb CollabCal. Affected is the function handleGet of the file calenderServer.cpp. The manipulation leads to improper authentication. It is possible to launch the attack remotely. The patch is identified as b80f6d1893607c99e5113967592417d0fe310ce6. It is recommended to apply a patch to fix this issue. VDB-217614 is the identifier assigned to this vulnerability.",https://github.com/holdennb/CollabCal/commit/b80f6d1893607c99e5113967592417d0fe310ce6,Fixed Login Exploit,2,"[{""func_name"": ""handleGet"", ""file_path"": ""calenderServer.cpp"", ""func_code"": ""string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\""uri\""];\n  string body;\n  if (reqHeaders->count(\""Cookie\"") != 0) {\n    string cookies = (*reqHeaders)[\""Cookie\""];\n    string sessionIdString = cookies.substr(cookies.find(\""=\"") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \""Bad session ID, redirecting to login.\"" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\""Server\""] = \""CSE461\"";\n  resHeaders[\""Content-Type\""] = \""text/html; charset=UTF-8\"";\n\n  if (uri.compare(\""/cal\"") == 0 && uid == -1) {\n    cout << \""login page\"" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\""/cal\"") == 0 && uid != -1) {\n    cout << \""cal page\"" << endl;\n    // cal page\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n\n  } else if (uri.compare(\""/getEvents\"") == 0 && uid != -1) {\n    //cout << \""getevents\"" << endl;\n    // getEvents, has uid\n    body = getEventsJson(uid);\n    resHeaders[\""Content-Type\""] = \""application/json; charset=UTF-8\"";\n  } else {\n    // 404\n    cout << \""error page\"" << endl;\n\n    string message = \""404 Page Not Found\"";\n    return getResponseHeader(\""HTTP/1.1 404 Not Found\"", &resHeaders, body.size())\n      + \""\\r\\n\"" + message;\n  }\n  \n  return getResponseHeader(\""HTTP/1.1 200 OK\"", &resHeaders, body.size()) + \""\\r\\n\"" + body;\n}"", ""target"": 0}, {""func_name"": ""handlePost"", ""file_path"": ""calenderServer.cpp"", ""func_code"": ""string handlePost(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\""uri\""];\n  cout << \""handling post\"" << endl;\n  if (reqHeaders->count(\""Cookie\"") != 0) {\n    string cookies = (*reqHeaders)[\""Cookie\""];\n    string sessionIdString = cookies.substr(cookies.find(\""=\"") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\""Server\""] = \""CSE461\"";\n  resHeaders[\""Content-Type\""] = \""text/html; charset=UTF-8\"";\n\n  //cout << \""uri is \"" << uri << \"", uid is \"" << uid << endl;\n\n  string body;\n  if (uri.compare(\""/createUser\"") == 0) {\n    cout << \""create user\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string username = params.substr(9, params.find(\""&\"") - 9);\n    string password = params.substr(params.find(\""&\"") + 10);\n\n    cout << \""username is \"" << username << \"" password is \"" << password << endl;\n\n    long newId = makeUser(username, password);\n    stringstream bodyStream;\n\n    if (newId == -1) {\n      bodyStream << \""Error: Could not create user '\"" << username << \""'\"" << endl;\n    } else {\n      bodyStream << \""Successfully created user '\"" << username << \""'! Please log in.\"" << endl;\n    }\n\n    body = bodyStream.str();\n  } else if (uri.compare(\""/login\"") == 0) {\n    if (uid != -1)\n      logout(uid);\n    cout << \""login\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string username = params.substr(9, params.find(\""&\"") - 9);\n    string password = params.substr(params.find(\""&\"") + 10);\n\n    cout << \""username is \"" << username << \"" password is \"" << password << endl;\n\n    long long sess = login(username, password);\n\n    stringstream bodyStream;\n    if (sess == -1) {\n      bodyStream << getLogin();\n    } else {\n      stringstream cookie;\n      cookie << \""sessionId=\"" << sess;\n      resHeaders[\""Set-Cookie\""] = cookie.str();\n\n      bodyStream << getHeader(username);\n      bodyStream << getEmptyCalendar();\n      bodyStream << getFooter();\n    }\n\n\n    body = bodyStream.str();\n    \n\n  } else if (uri.compare(\""/createGroup\"") == 0 && uid != -1) {\n    cout << \""createGroup\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string groupName = params.substr(11);\n    replace(groupName.begin(), groupName.end(), '+', ' ');\n\n    stringstream bodyStream;\n    long groupId = makeGroup(uid, groupName);\n    if (groupId != -1) {\n      cout << \""made group!\"" << endl;\n      bodyStream << \""Successfully created group '\"" << groupName << \""'\"";\n    } else {\n      cout << \""makeGroup was -1.\"" << endl;\n      bodyStream << \""Error: could not create group '\"" << groupName << \""'\"";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\""/addToGroup\"") == 0 && uid != -1) {\n    cout << \""addToGroup\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string groupName = params.substr(11, params.find(\""&\"") - 11);\n    params = params.substr(params.find(\""&\"") + 1);\n    string addedName = params.substr(11, params.find(\""&\"") - 11);\n    params = params.substr(params.find(\""&\"") + 1);\n    bool admin = params.find(\""admin\"") != string::npos;\n    long groupId = groupIdByName(groupName);\n    long addedId = userIdByName(addedName);\n\n    stringstream bodyStream;\n    bool added = addToGroup(uid, addedId, groupId, admin);\n\n    if (added) {\n      cout << \""added to group!\"" << endl;\n      bodyStream << \""Successfully added '\"" << addedName << \""' to '\"" << groupName << \""'\"";\n    } else {\n      cout << \""Error: could not add '\"" << addedName << \""' to '\"" << groupName << \""'\"";\n      bodyStream << \""Error: could not add '\"" << addedName << \""' to '\"" << groupName << \""'\"";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\""/createEvent\"") == 0 && uid != -1) {\n    cout << \""createEvent\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string eventName = params.substr(5, params.find(\""&\"") - 5);\n    replace(eventName.begin(), eventName.end(), '+', ' ');\n    params = params.substr(params.find(\""&\"") + 1);\n    string timeString = params.substr(9, params.find(\""&\"") - 9);\n    params = params.substr(params.find(\""&\"") + 1);\n    bool withGroup = params.size() > 11;\n\n    cout << \""eName: \"" << eventName << \"" tS: \"" << timeString << \"" wG: \"" << withGroup << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    long eventId;\n    if (withGroup) {\n      string groupName = params.substr(11);\n      long groupId = groupIdByName(groupName);\n      cout << \""gName: \"" << groupName << \"" gID: \"" << groupId << endl;\n\n      eventId = makeEvent(uid, eventName, eventTime, groupId, true);\n    } else {\n      eventId = makeEvent(uid, eventName, eventTime);\n    }\n\n    stringstream bodyStream;\n    if (eventId != -1) {\n      cout << \""made event!\"" << endl;\n      bodyStream << \""Successfully created event '\"" << eventName << \""'\"";\n    } else {\n      cout << \""couldn't make event.\"" << endl;\n      bodyStream << \""Error: could not create event '\"" << eventName << \""'\"";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\""/editEvent\"") == 0 && uid != -1) {\n    cout << \""editEvent\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    long eventId = stol(params.substr(3, params.find(\""&\"") - 3), nullptr);\n    params = params.substr(params.find(\""&\"") + 1);\n    string eventName = params.substr(5, params.find(\""&\"") - 5);\n    params = params.substr(params.find(\""&\"") + 1);\n    string timeString = params.substr(9, params.find(\""&\"") - 9);\n\n    cout << \""eID: \"" << eventId << \"" eName: \"" << eventName << \"" dt: \"" << timeString << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    renameEvent(uid, eventId, eventName);\n    rescheduleEvent(uid, eventId, eventTime);\n\n    stringstream bodyStream;\n    cout << \""edited event!\"" << endl;\n    bodyStream << \""Successfully edited event.\"";\n\n    body = bodyStream.str();\n  } else {\n    // 404\n    cout << \""error page\"" << endl;\n\n    string message = \""404 Page Not Found\"";\n    return getResponseHeader(\""HTTP/1.1 404 Not Found\"", &resHeaders, body.size())\n      + \""\\r\\n\"" + message;\n  }\n  \n  return getResponseHeader(\""HTTP/1.1 200 OK\"", &resHeaders, body.size()) + \""\\r\\n\"" + body;\n}"", ""target"": 0}]","[{""func_name"": ""handleGet"", ""file_path"": ""calenderServer.cpp"", ""func_code"": ""string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\""uri\""];\n  string body;\n  if (reqHeaders->count(\""Cookie\"") != 0) {\n    string cookies = (*reqHeaders)[\""Cookie\""];\n    string sessionIdString = cookies.substr(cookies.find(\""=\"") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \""Bad session ID, redirecting to login.\"" << endl;\n      body = getLogin();\n    } else\n      uid = usersessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\""Server\""] = \""CSE461\"";\n  resHeaders[\""Content-Type\""] = \""text/html; charset=UTF-8\"";\n\n  if (uri.compare(\""/cal\"") == 0 && uid == -1) {\n    cout << \""login page\"" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\""/cal\"") == 0 && uid != -1) {\n    cout << \""cal page\"" << endl;\n    // cal page\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n\n  } else if (uri.compare(\""/getEvents\"") == 0 && uid != -1) {\n    //cout << \""getevents\"" << endl;\n    // getEvents, has uid\n    body = getEventsJson(uid);\n    resHeaders[\""Content-Type\""] = \""application/json; charset=UTF-8\"";\n  } else {\n    // 404\n    cout << \""error page\"" << endl;\n\n    string message = \""404 Page Not Found\"";\n    return getResponseHeader(\""HTTP/1.1 404 Not Found\"", &resHeaders, body.size())\n      + \""\\r\\n\"" + message;\n  }\n  \n  return getResponseHeader(\""HTTP/1.1 200 OK\"", &resHeaders, body.size()) + \""\\r\\n\"" + body;\n}""}, {""func_name"": ""handlePost"", ""file_path"": ""calenderServer.cpp"", ""func_code"": ""string handlePost(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\""uri\""];\n  cout << \""handling post\"" << endl;\n  if (reqHeaders->count(\""Cookie\"") != 0) {\n    string cookies = (*reqHeaders)[\""Cookie\""];\n    string sessionIdString = cookies.substr(cookies.find(\""=\"") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto sessionIt = sessionMap.find(sessionId);\n    if(sessionIt != sessionMap.end())\n      uid = sessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\""Server\""] = \""CSE461\"";\n  resHeaders[\""Content-Type\""] = \""text/html; charset=UTF-8\"";\n\n  //cout << \""uri is \"" << uri << \"", uid is \"" << uid << endl;\n\n  string body;\n  if (uri.compare(\""/createUser\"") == 0) {\n    cout << \""create user\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string username = params.substr(9, params.find(\""&\"") - 9);\n    string password = params.substr(params.find(\""&\"") + 10);\n\n    cout << \""username is \"" << username << \"" password is \"" << password << endl;\n\n    long newId = makeUser(username, password);\n    stringstream bodyStream;\n\n    if (newId == -1) {\n      bodyStream << \""Error: Could not create user '\"" << username << \""'\"" << endl;\n    } else {\n      bodyStream << \""Successfully created user '\"" << username << \""'! Please log in.\"" << endl;\n    }\n\n    body = bodyStream.str();\n  } else if (uri.compare(\""/login\"") == 0) {\n    if (uid != -1)\n      logout(uid);\n    cout << \""login\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string username = params.substr(9, params.find(\""&\"") - 9);\n    string password = params.substr(params.find(\""&\"") + 10);\n\n    cout << \""username is \"" << username << \"" password is \"" << password << endl;\n\n    long long sess = login(username, password);\n\n    stringstream bodyStream;\n    if (sess == -1) {\n      bodyStream << getLogin();\n    } else {\n      stringstream cookie;\n      cookie << \""sessionId=\"" << sess;\n      resHeaders[\""Set-Cookie\""] = cookie.str();\n\n      bodyStream << getHeader(username);\n      bodyStream << getEmptyCalendar();\n      bodyStream << getFooter();\n    }\n\n\n    body = bodyStream.str();\n    \n\n  } else if (uri.compare(\""/createGroup\"") == 0 && uid != -1) {\n    cout << \""createGroup\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string groupName = params.substr(11);\n    replace(groupName.begin(), groupName.end(), '+', ' ');\n\n    stringstream bodyStream;\n    long groupId = makeGroup(uid, groupName);\n    if (groupId != -1) {\n      cout << \""made group!\"" << endl;\n      bodyStream << \""Successfully created group '\"" << groupName << \""'\"";\n    } else {\n      cout << \""makeGroup was -1.\"" << endl;\n      bodyStream << \""Error: could not create group '\"" << groupName << \""'\"";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\""/addToGroup\"") == 0 && uid != -1) {\n    cout << \""addToGroup\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string groupName = params.substr(11, params.find(\""&\"") - 11);\n    params = params.substr(params.find(\""&\"") + 1);\n    string addedName = params.substr(11, params.find(\""&\"") - 11);\n    params = params.substr(params.find(\""&\"") + 1);\n    bool admin = params.find(\""admin\"") != string::npos;\n    long groupId = groupIdByName(groupName);\n    long addedId = userIdByName(addedName);\n\n    stringstream bodyStream;\n    bool added = addToGroup(uid, addedId, groupId, admin);\n\n    if (added) {\n      cout << \""added to group!\"" << endl;\n      bodyStream << \""Successfully added '\"" << addedName << \""' to '\"" << groupName << \""'\"";\n    } else {\n      cout << \""Error: could not add '\"" << addedName << \""' to '\"" << groupName << \""'\"";\n      bodyStream << \""Error: could not add '\"" << addedName << \""' to '\"" << groupName << \""'\"";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\""/createEvent\"") == 0 && uid != -1) {\n    cout << \""createEvent\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    string eventName = params.substr(5, params.find(\""&\"") - 5);\n    replace(eventName.begin(), eventName.end(), '+', ' ');\n    params = params.substr(params.find(\""&\"") + 1);\n    string timeString = params.substr(9, params.find(\""&\"") - 9);\n    params = params.substr(params.find(\""&\"") + 1);\n    bool withGroup = params.size() > 11;\n\n    cout << \""eName: \"" << eventName << \"" tS: \"" << timeString << \"" wG: \"" << withGroup << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    long eventId;\n    if (withGroup) {\n      string groupName = params.substr(11);\n      long groupId = groupIdByName(groupName);\n      cout << \""gName: \"" << groupName << \"" gID: \"" << groupId << endl;\n\n      eventId = makeEvent(uid, eventName, eventTime, groupId, true);\n    } else {\n      eventId = makeEvent(uid, eventName, eventTime);\n    }\n\n    stringstream bodyStream;\n    if (eventId != -1) {\n      cout << \""made event!\"" << endl;\n      bodyStream << \""Successfully created event '\"" << eventName << \""'\"";\n    } else {\n      cout << \""couldn't make event.\"" << endl;\n      bodyStream << \""Error: could not create event '\"" << eventName << \""'\"";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\""/editEvent\"") == 0 && uid != -1) {\n    cout << \""editEvent\"" << endl;\n    string params = (*reqHeaders)[\""params\""];\n    long eventId = stol(params.substr(3, params.find(\""&\"") - 3), nullptr);\n    params = params.substr(params.find(\""&\"") + 1);\n    string eventName = params.substr(5, params.find(\""&\"") - 5);\n    params = params.substr(params.find(\""&\"") + 1);\n    string timeString = params.substr(9, params.find(\""&\"") - 9);\n\n    cout << \""eID: \"" << eventId << \"" eName: \"" << eventName << \"" dt: \"" << timeString << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    renameEvent(uid, eventId, eventName);\n    rescheduleEvent(uid, eventId, eventTime);\n\n    stringstream bodyStream;\n    cout << \""edited event!\"" << endl;\n    bodyStream << \""Successfully edited event.\"";\n\n    body = bodyStream.str();\n  } else {\n    // 404\n    cout << \""error page\"" << endl;\n\n    string message = \""404 Page Not Found\"";\n    return getResponseHeader(\""HTTP/1.1 404 Not Found\"", &resHeaders, body.size())\n      + \""\\r\\n\"" + message;\n  }\n  \n  return getResponseHeader(\""HTTP/1.1 200 OK\"", &resHeaders, body.size()) + \""\\r\\n\"" + body;\n}""}]","{""code"": 3}","[{""source"": ""code_info(file:calenderServer.cpp, lines:244-248)"", ""result"": ""    if (usersessionIt == sessionMap.end()){\n      cout << \""Bad session ID, redirecting to login.\"" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n""}, {""source"": ""code_info(file:calenderServer.cpp, lines:244-248)"", ""result"": ""    if (usersessionIt == sessionMap.end()){\n      cout << \""Bad session ID, redirecting to login.\"" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n""}, {""source"": ""code_info(file:calenderServer.cpp, lines:240-244)"", ""result"": ""    string cookies = (*reqHeaders)[\""Cookie\""];\n    string sessionIdString = cookies.substr(cookies.find(\""=\"") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \""Bad session ID, redirecting to login.\"" << endl;\n""}]","Original code in handleGet (calenderServer.cpp:246) and handlePost (calenderServer.cpp:290) used direct sessionMap[sessionId] access, allowing invalid session IDs to return default values (e.g., empty string or 0) and bypass authentication. The patch replaces this with iterator-based access:\n- handleGet: usersessionIt is initialized via sessionMap.find(sessionId) (calenderServer.cpp:240-244), then checked against sessionMap.end() before assigning uid = usersessionIt->second.\n- handlePost: Added explicit sessionMap.find() and validity check (calenderServer.cpp:290-292). This ensures invalid sessions are rejected instead of using default values.",0.95,./github/other_context/CVE-2014-125060
2,CVE-2014-125071,CWE-346,java,A vulnerability was found in lukehutch Gribbit. It has been classified as problematic. Affected is the function messageReceived of the file src/gribbit/request/HttpRequestHandler.java. The manipulation leads to missing origin validation in websockets. The name of the patch is 620418df247aebda3dd4be1dda10fe229ea505dd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217716.,https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd,Protect against CSWSH: (Cross-Site WebSocket Hijacking),3,"[{""func_name"": ""messageReceived"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java"", ""func_code"": ""@Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\""Got unknown data chunk type: \"" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\""Unsupported HTTP method \"" + request.getMethod().name() + \"" for path \"" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\""HTTP method \"" + request.getMethod().name() + \"" not implemented in handler \""\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \""/\"", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\""/websocket\"")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n                // TODO: Also provide a means for revoking WS login.\n                wsAuthenticatedUser = User.getLoggedInUser(request);\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI + \""\\tfile://\""\n                                + staticResourceFile.getPath() + \""\\t\"" + HttpResponseStatus.OK + \""\\t\""\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \""Not Modified\"" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\""Didn't generate a response\"");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\""Didn't generate a response\"");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI\n                            + (request.getMethod() == origReqMethod ? \""\"" : \""\\t\"" + request.getMethod()) + \""\\t\"" + status\n                            + \""\\t\"" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\""favicon.ico\"") || reqURI.endsWith(\""/favicon.ico\"")))) {\n                // Log at level \""fine\"" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \""warning\"" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }"", ""target"": 0}, {""func_name"": ""toNettyCookie"", ""file_path"": ""src/gribbit/auth/Cookie.java"", ""func_code"": ""public io.netty.handler.codec.http.Cookie toNettyCookie() {\n        io.netty.handler.codec.http.Cookie nettyCookie = new DefaultCookie(name, WebUtils.escapeCookieValue(value));\n        if (path != null && !path.isEmpty()) {\n            nettyCookie.setPath(path);\n        }\n        nettyCookie.setMaxAge(maxAgeSeconds);\n        nettyCookie.setDiscard(discardAtEndOfBrowserSession);\n        nettyCookie.setHttpOnly(true);  // TODO\n        if (GribbitProperties.SSL) {\n            nettyCookie.setSecure(true);  // TODO\n        }\n        return nettyCookie;\n    }"", ""target"": 0}, {""func_name"": ""logIn"", ""file_path"": ""src/gribbit/auth/User.java"", ""func_code"": ""public void logIn(Response response) throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(id)) {\n\n            // Create new session token\n            sessionTok = new Token(TokenType.SESSION, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS);\n            csrfTok = CSRF.generateRandomCSRFToken();\n            save();\n            if (sessionTokHasExpired()) {\n                // Shouldn't happen, since we just created session tok, but just in case\n                clearSessionTok();\n                throw new UnauthorizedException(\""Couldn't create auth session\"");\n            }\n\n            // Save login cookies in result\n            response.setCookie(new Cookie(Cookie.SESSION_COOKIE_NAME, \""/\"", sessionTok.token,\n                    Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n            response.setCookie(new Cookie(Cookie.EMAIL_COOKIE_NAME, \""/\"", id, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\""User is not whitelisted for login: \"" + id);\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""messageReceived"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java"", ""func_code"": ""@Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\""Got unknown data chunk type: \"" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\""Unsupported HTTP method \"" + request.getMethod().name() + \"" for path \"" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\""HTTP method \"" + request.getMethod().name() + \"" not implemented in handler \""\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \""/\"", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            // FIXME: Make these into class annotations\n            String websocketPath = \""/websocket\"";\n            boolean isAuthenticatedWebsocket = true;\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations, rather than using hardcoded \""/websocket\""\n                    && reqURI.endsWith(websocketPath)) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)\n                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n                // http://tools.ietf.org/html/rfc6455#page-7\n                CharSequence origin = request.getOrigin();\n                URI originUri = null;\n                if (origin != null && origin.length() > 0) {\n                    try {\n                        // Try parsing origin URI\n                        originUri = new URI(origin.toString());\n                    } catch (Exception e) {\n                    }\n                }\n                // If port number is set but it is the default for the URI scheme, revert the port number\n                // back to -1 (which means unspecified), so that it matches the server port number, \n                // which is unspecified when serving http on port 80 and https on port 443\n                int originPort = originUri == null ? -1 //\n                        : originUri.getPort() == 80 && \""http\"".equals(originUri.getScheme()) ? -1 //\n                                : originUri.getPort() == 443 && \""https\"".equals(originUri.getScheme()) ? -1 //\n                                        : originUri.getPort();\n                // Scheme, host and port all must match to forbid cross-origin requests\n                if (originUri == null //\n                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //\n                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //\n                        || GribbitServer.uri.getPort() != originPort) { //\n                    // Reject scripted requests to open this websocket from a different domain\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n                // Log.info(\""Origin: \"" + origin.toString());\n\n                if (isAuthenticatedWebsocket) {\n                    // For authenticated websockets, check if the user is logged in\n                    User loggedInUser = User.getLoggedInUser(request);\n                    if (loggedInUser == null) {\n                        // Not logged in, so can't connect to this websocket\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n\n                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter \""_csrf\"";\n                    // the passed token must match the user's CSRF token. This means the websocket URL has to\n                    // be dynamically generated and inserted into the webpage that opened the websocket.\n                    // TODO: generate this URL an insert into the page somehow\n                    String csrfTok = loggedInUser.csrfTok;\n                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)\n                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {\n                        // No valid CSRF token in User object\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n                    String csrfParam = request.getQueryParam(\""_csrf\"");\n                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {\n                        // The CSRF URL query parameter is missing, or doesn't match the user's token \n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;                        \n                    }\n\n                    // Record which user was authenticated when the websocket upgrade request was made.\n                    // TODO: Also provide a means for revoking user's session while WS is still open,\n                    // e.g. poll the user table every few seconds to see if user's session token has\n                    // changed in the database? (Although this would mean that logging in on a new\n                    // device would log you out of all other sessions...)\n                    wsAuthenticatedUser = loggedInUser;\n                }\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI + \""\\tfile://\""\n                                + staticResourceFile.getPath() + \""\\t\"" + HttpResponseStatus.OK + \""\\t\""\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \""Not Modified\"" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\""Didn't generate a response\"");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\""Didn't generate a response\"");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI\n                            + (request.getMethod() == origReqMethod ? \""\"" : \""\\t\"" + request.getMethod()) + \""\\t\"" + status\n                            + \""\\t\"" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\""favicon.ico\"") || reqURI.endsWith(\""/favicon.ico\"")))) {\n                // Log at level \""fine\"" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \""warning\"" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }""}, {""func_name"": ""toNettyCookie"", ""file_path"": ""src/gribbit/auth/Cookie.java"", ""func_code"": ""public io.netty.handler.codec.http.Cookie toNettyCookie() {\n        io.netty.handler.codec.http.Cookie nettyCookie = new DefaultCookie(name, WebUtils.escapeCookieValue(value));\n        if (path != null && !path.isEmpty()) {\n            nettyCookie.setPath(path);\n        }\n        nettyCookie.setMaxAge(maxAgeSeconds);\n        nettyCookie.setDiscard(discardAtEndOfBrowserSession);\n        nettyCookie.setHttpOnly(true);  // TODO\n        if (GribbitProperties.SSL) {\n            // If SSL is enabled, force cookies to only be delivered over SSL, to prevent cookie hijacking\n            // on public wifi networks\n            nettyCookie.setSecure(true);\n        }\n        return nettyCookie;\n    }""}, {""func_name"": ""logIn"", ""file_path"": ""src/gribbit/auth/User.java"", ""func_code"": ""public void logIn(Response response) throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(id)) {\n\n            // Create new session token\n            sessionTok = new Token(TokenType.SESSION, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS);\n            \n            // Create new random CSRF token every time user logs in\n            csrfTok = CSRF.generateRandomCSRFToken();\n            \n            if (sessionTokHasExpired()) {\n                // Shouldn't happen, since we just created session tok, but just in case\n                clearSessionTok();\n                throw new UnauthorizedException(\""Couldn't create auth session\"");\n            }\n\n            // Save tokens in database\n            save();\n\n            // Save login cookies in result\n            response.setCookie(new Cookie(Cookie.SESSION_COOKIE_NAME, \""/\"", sessionTok.token,\n                    Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n            response.setCookie(new Cookie(Cookie.EMAIL_COOKIE_NAME, \""/\"", id, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\""User is not whitelisted for login: \"" + id);\n        }\n    }""}]","{""function"": 2, ""code"": 3}","[{""source"": ""func_info(file:HttpRequestHandler.java, func:messageReceived)"", ""result"": [{""code"": ""    @Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                            "", ""start_line"": 600, ""end_line"": 1033, ""full_name"": ""gribbit.request.HttpRequestHandler.messageReceived:void(io.netty.channel.ChannelHandlerContext,java.lang.Object)"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java""}]}, {""source"": ""code_info(file:HttpRequestHandler.java, lines:800-826)"", ""result"": ""                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n""}, {""source"": ""func_info(file:HttpRequestHandler.java, func:messageReceived)"", ""result"": [{""code"": ""    @Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                            "", ""start_line"": 600, ""end_line"": 1033, ""full_name"": ""gribbit.request.HttpRequestHandler.messageReceived:void(io.netty.channel.ChannelHandlerContext,java.lang.Object)"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java""}]}, {""source"": ""code_info(file:HttpRequestHandler.java, lines:827-834)"", ""result"": ""            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\""/websocket\"")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n""}, {""source"": ""code_info(file:HttpRequestHandler.java, lines:827-834)"", ""result"": ""            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\""/websocket\"")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n""}]","src/gribbit/request/HttpRequestHandler.java:827-834 (original code allowed WebSocket upgrades without origin validation). The original code checked `reqURI.endsWith(""/websocket"")` but lacked origin validation logic. The patch added origin and CSRF checks to prevent CSWSH.",0.95,./github/other_context/CVE-2014-125071
3,CVE-2016-10065,CWE-284,c_cpp,The ReadVIFFImage function in coders/viff.c in ImageMagick before 7.0.1-0 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.,https://github.com/ImageMagick/ImageMagick/commit/134463b926fa965571aa4febd61b810be5e7da05,https://github.com/ImageMagick/ImageMagick/issues/129,2,"[{""func_name"": ""ImportGrayQuantum"", ""file_path"": ""MagickCore/quantum-import.c"", ""func_code"": ""static void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}"", ""target"": 1}, {""func_name"": ""ReadVIFFImage"", ""file_path"": ""coders/viff.c"", ""func_code"": ""static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\""NotAVIFFImage\"");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\""comment\"",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\""ImageColumnOrRowSizeIsNotSupported\"");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\""DataStorageTypeIsNotSupported\"");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\""DataEncodingSchemeIsNotSupported\"");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\""MapStorageTypeIsNotSupported\"");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\""ColorspaceModelIsNotSupported\"");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\""LocationTypeIsNotSupported\"");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\""NumberOfImagesIsNotSupported\"");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\""ColormapTypeNotSupported\"");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : \n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n    else\n      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n                  \n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"", ""target"": 0}]","[{""func_name"": ""ImportGrayQuantum"", ""file_path"": ""MagickCore/quantum-import.c"", ""func_code"": ""static void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  pixel=0;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}""}, {""func_name"": ""ReadVIFFImage"", ""file_path"": ""coders/viff.c"", ""func_code"": ""static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\""NotAVIFFImage\"");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\""comment\"",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\""ImageColumnOrRowSizeIsNotSupported\"");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\""DataStorageTypeIsNotSupported\"");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\""DataEncodingSchemeIsNotSupported\"");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\""MapStorageTypeIsNotSupported\"");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\""ColorspaceModelIsNotSupported\"");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\""LocationTypeIsNotSupported\"");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\""NumberOfImagesIsNotSupported\"");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\""ColormapTypeNotSupported\"");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}""}]","{""code"": 1, ""value"": 3, ""function"": 1}","[{""source"": ""code_info(file:viff.c, lines:1-475)"", ""result"": ""/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        V   V  IIIII  FFFFF  FFFFF                           %\n%                        V   V    I    F      F                               %\n%                        V   V    I    FFF    FFF                             %\n%                         V V     I    F      F                               %\n%                          V    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write Khoros Visualization Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \""AS IS\"" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \""MagickCore/studio.h\""\n#include \""MagickCore/attribute.h\""\n#include \""MagickCore/blob.h\""\n#include \""MagickCore/blob-private.h\""\n#include \""MagickCore/cache.h\""\n#include \""MagickCore/color.h\""\n#include \""MagickCore/color-private.h\""\n#include \""MagickCore/colormap.h\""\n#include \""MagickCore/colormap-private.h\""\n#include \""MagickCore/colorspace.h\""\n#include \""MagickCore/colorspace-private.h\""\n#include \""MagickCore/exception.h\""\n#include \""MagickCore/exception-private.h\""\n#include \""MagickCore/image.h\""\n#include \""MagickCore/image-private.h\""\n#include \""MagickCore/list.h\""\n#include \""MagickCore/magick.h\""\n#include \""MagickCore/memory_.h\""\n#include \""MagickCore/monitor.h\""\n#include \""MagickCore/monitor-private.h\""\n#include \""MagickCore/pixel-accessor.h\""\n#include \""MagickCore/property.h\""\n#include \""MagickCore/quantum-private.h\""\n#include \""MagickCore/static.h\""\n#include \""MagickCore/string_.h\""\n#include \""MagickCore/module.h\""\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteVIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s V I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsVIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is VIFF.\n%\n%  The format of the IsVIFF method is:\n%\n%      MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\""\\253\\001\"",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d V I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadVIFFImage() reads a Khoros Visualization image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadVIFFImage method is:\n%\n%      Image *ReadVIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadVIFFImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\""NotAVIFFImage\"");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\""comment\"",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\""ImageColumnOrRowSizeIsNotSupported\"");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\""DataStorageTypeIsNotSupported\"");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\""DataEncodingSchemeIsNotSupported\"");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\""MapStorageTypeIsNotSupported\"");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\""ColorspaceModelIsNotSupported\"");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\""LocationTypeIsNotSupported\"");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\""NumberOfImagesIsNotSupported\"");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\""ColormapTypeNotSupported\"");\n    }\n    /*\n      Initialize image structure.\n""}, {""source"": ""value_info(file:viff.c, value:image->columns)"", ""result"": {""value_trace"": [{""full_code"": ""image->columns=viff_info.rows"", ""line"": 327, ""func_name"": ""ReadVIFFImage""}, {""full_code"": ""image->columns=viff_info.rows"", ""line"": 482, ""func_name"": ""ReadVIFFImage""}], ""struct_var"": ""image"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n    // Construct Image of specified size from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_);\n\n    // Construct Image of specified size and depth from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_);\n\n    // Construct Image of specified size, depth, and format from\n    // in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_,\n      const std::string &magick_);\n\n    // Construct Image of specified size, and format from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const std::string &magick_);\n\n    // Construct a blank image canvas of specified size and color\n    Image(const Geometry &size_,const Color &color_);\n\n    // Copy constructor\n    Image(const Image &image_);\n\n    // Copy constructor to copy part of the image\n   ...\n\nclass Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""value_info(file:viff.c, value:image->rows)"", ""result"": {""value_trace"": [{""full_code"": ""image->rows=viff_info.columns"", ""line"": 328, ""func_name"": ""ReadVIFFImage""}, {""full_code"": ""image->rows=viff_info.columns"", ""line"": 483, ""func_name"": ""ReadVIFFImage""}], ""struct_var"": ""image"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n    // Construct Image of specified size from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_);\n\n    // Construct Image of specified size and depth from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_);\n\n    // Construct Image of specified size, depth, and format from\n    // in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_,\n      const std::string &magick_);\n\n    // Construct Image of specified size, and format from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const std::string &magick_);\n\n    // Construct a blank image canvas of specified size and color\n    Image(const Geometry &size_,const Color &color_);\n\n    // Copy constructor\n    Image(const Image &image_);\n\n    // Copy constructor to copy part of the image\n   ...\n\nclass Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""value_info(file:viff.c, value:number_pixels)"", ""result"": {""value_trace"": [{""full_code"": ""number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows"", ""line"": 334, ""func_name"": ""ReadVIFFImage""}, {""full_code"": ""number_pixels=(MagickSizeType) image->columns*image->rows"", ""line"": 683, ""func_name"": ""ReadVIFFImage""}, {""full_code"": ""number_pixels=(MagickSizeType) image->columns*image->rows"", ""line"": 998, ""func_name"": ""WriteVIFFImage""}, {""full_code"": ""number_pixels=(MagickSizeType) image->columns*image->rows"", ""line"": 1089, ""func_name"": ""WriteVIFFImage""}], ""struct_var"": ""number_pixels"", ""struct_type"": ""MagickSizeType"", ""struct_definition"": ""typedef unsigned long long MagickSizeType;\n\ntypedef size_t MagickSizeType;""}}, {""source"": ""func_info(func:CheckMemoryOverflow)"", ""result"": [{""code"": ""static MagickBooleanType CheckMemoryOverflow(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}"", ""start_line"": 236, ""end_line"": 249, ""full_name"": ""CheckMemoryOverflow"", ""file_path"": ""MagickCore/memory.c""}]}]","coders/viff.c:500-517: Unchecked multiplication of (image->columns+7UL)>>3UL * image->rows (for VFF_TYP_BIT) and number_pixels * viff_info.number_data_bands (for other types) could overflow, leading to incorrect memory allocation via AcquireQuantumMemory. image->columns and image->rows are set from viff_info.rows and viff_info.columns (coders/viff.c:327-328), which are read from the input file (coders/viff.c:298-315). The overflow allows crafted inputs to allocate insufficient memory, causing a crash or undefined behavior when accessed.",0.95,./github/other_context/CVE-2016-10065
4,CVE-2016-4979,CWE-284,c_cpp,"The Apache HTTP Server 2.4.18 through 2.4.20, when mod_http2 and mod_ssl are enabled, does not properly recognize the ""SSLVerifyClient require"" directive for HTTP/2 request authorization, which allows remote attackers to bypass intended access restrictions by leveraging the ability to send multiple requests over a single connection and aborting a renegotiation.",https://github.com/apache/httpd/commit/2d0e4eff04ea963128a41faaef21f987272e05a2,modssl: reset client-verify state when renegotiation is aborted\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1750779 13f79535-47bb-0310-9956-ffa450edef68,1,"[{""func_name"": ""ssl_hook_Access"", ""file_path"": ""modules/ssl/ssl_engine_kernel.c"", ""func_code"": ""int ssl_hook_Access(request_rec *r)\n{\n    SSLDirConfigRec *dc         = myDirConfig(r);\n    SSLSrvConfigRec *sc         = mySrvConfig(r->server);\n    SSLConnRec *sslconn         = myConnConfig(r->connection);\n    SSL *ssl                    = sslconn ? sslconn->ssl : NULL;\n    server_rec *handshakeserver = sslconn ? sslconn->server : NULL;\n    SSLSrvConfigRec *hssc       = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n    SSL_CTX *ctx = NULL;\n    apr_array_header_t *requires;\n    ssl_require_t *ssl_requires;\n    int ok, i;\n    BOOL renegotiate = FALSE, renegotiate_quick = FALSE;\n    X509 *cert;\n    X509 *peercert;\n    X509_STORE *cert_store = NULL;\n    X509_STORE_CTX *cert_store_ctx;\n    STACK_OF(SSL_CIPHER) *cipher_list_old = NULL, *cipher_list = NULL;\n    const SSL_CIPHER *cipher = NULL;\n    int depth, verify_old, verify, n, is_slave = 0;\n    const char *ncipher_suite;\n\n    /* On a slave connection, we do not expect to have an SSLConnRec, but\n     * our master connection might have one. */\n    if (!(sslconn && ssl) && r->connection->master) {\n        sslconn         = myConnConfig(r->connection->master);\n        ssl             = sslconn ? sslconn->ssl : NULL;\n        handshakeserver = sslconn ? sslconn->server : NULL;\n        hssc            = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n        is_slave        = 1;\n    }\n    \n    if (ssl) {\n        /*\n         * We should have handshaken here (on handshakeserver),\n         * otherwise we are being redirected (ErrorDocument) from\n         * a renegotiation failure below. The access is still \n         * forbidden in the latter case, let ap_die() handle\n         * this recursive (same) error.\n         */\n        if (!SSL_is_init_finished(ssl)) {\n            return HTTP_FORBIDDEN;\n        }\n        ctx = SSL_get_SSL_CTX(ssl);\n    }\n\n    /*\n     * Support for SSLRequireSSL directive\n     */\n    if (dc->bSSLRequired && !ssl) {\n        if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !is_slave) {\n            /* This vhost was configured for optional SSL, just tell the\n             * client that we need to upgrade.\n             */\n            apr_table_setn(r->err_headers_out, \""Upgrade\"", \""TLS/1.0, HTTP/1.1\"");\n            apr_table_setn(r->err_headers_out, \""Connection\"", \""Upgrade\"");\n\n            return HTTP_UPGRADE_REQUIRED;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02219)\n                      \""access to %s failed, reason: %s\"",\n                      r->filename, \""SSL connection required\"");\n\n        /* remember forbidden access for strict require option */\n        apr_table_setn(r->notes, \""ssl-access-forbidden\"", \""1\"");\n\n        return HTTP_FORBIDDEN;\n    }\n\n    /*\n     * Check to see whether SSL is in use; if it's not, then no\n     * further access control checks are relevant.  (the test for\n     * sc->enabled is probably strictly unnecessary)\n     */\n    if (sc->enabled == SSL_ENABLED_FALSE || !ssl) {\n        return DECLINED;\n    }\n\n#ifdef HAVE_SRP\n    /*\n     * Support for per-directory reconfigured SSL connection parameters\n     *\n     * We do not force any renegotiation if the user is already authenticated\n     * via SRP.\n     *\n     */\n    if (SSL_get_srp_username(ssl)) {\n        return DECLINED;\n    }\n#endif\n\n    /*\n     * Support for per-directory reconfigured SSL connection parameters.\n     *\n     * This is implemented by forcing an SSL renegotiation with the\n     * reconfigured parameter suite. But Apache's internal API processing\n     * makes our life very hard here, because when internal sub-requests occur\n     * we nevertheless should avoid multiple unnecessary SSL handshakes (they\n     * require extra network I/O and especially time to perform).\n     *\n     * But the optimization for filtering out the unnecessary handshakes isn't\n     * obvious and trivial.  Especially because while Apache is in its\n     * sub-request processing the client could force additional handshakes,\n     * too. And these take place perhaps without our notice. So the only\n     * possibility is to explicitly _ask_ OpenSSL whether the renegotiation\n     * has to be performed or not. It has to performed when some parameters\n     * which were previously known (by us) are not those we've now\n     * reconfigured (as known by OpenSSL) or (in optimized way) at least when\n     * the reconfigured parameter suite is stronger (more restrictions) than\n     * the currently active one.\n     */\n\n    /*\n     * Override of SSLCipherSuite\n     *\n     * We provide two options here:\n     *\n     * o The paranoid and default approach where we force a renegotiation when\n     *   the cipher suite changed in _any_ way (which is straight-forward but\n     *   often forces renegotiations too often and is perhaps not what the\n     *   user actually wanted).\n     *\n     * o The optimized and still secure way where we force a renegotiation\n     *   only if the currently active cipher is no longer contained in the\n     *   reconfigured/new cipher suite. Any other changes are not important\n     *   because it's the servers choice to select a cipher from the ones the\n     *   client supports. So as long as the current cipher is still in the new\n     *   cipher suite we're happy. Because we can assume we would have\n     *   selected it again even when other (better) ciphers exists now in the\n     *   new cipher suite. This approach is fine because the user explicitly\n     *   has to enable this via ``SSLOptions +OptRenegotiate''. So we do no\n     *   implicit optimizations.\n     */     \n    ncipher_suite = (dc->szCipherSuite? \n                     dc->szCipherSuite : (r->server != handshakeserver)?\n                     sc->server->auth.cipher_suite : NULL);\n    \n    if (ncipher_suite && (!sslconn->cipher_suite \n                          || strcmp(ncipher_suite, sslconn->cipher_suite))) {\n        /* remember old state */\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            cipher = SSL_get_current_cipher(ssl);\n        }\n        else {\n            cipher_list_old = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n            if (cipher_list_old) {\n                cipher_list_old = sk_SSL_CIPHER_dup(cipher_list_old);\n            }\n        }\n\n        /* configure new state */\n        if (is_slave) {\n            /* TODO: this categorically fails changed cipher suite settings\n             * on slave connections. We could do better by\n             * - create a new SSL* from our SSL_CTX and set cipher suite there,\n             *   and retrieve ciphers, free afterwards\n             * Modifying the SSL on a slave connection is no good.\n             */\n            apr_table_setn(r->notes, \""ssl-renegotiate-forbidden\"", \""cipher-suite\"");\n            return HTTP_FORBIDDEN;\n        }\n\n        if (!SSL_set_cipher_list(ssl, ncipher_suite)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02253)\n                          \""Unable to reconfigure (per-directory) \""\n                          \""permitted SSL ciphers\"");\n            ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n            if (cipher_list_old) {\n                sk_SSL_CIPHER_free(cipher_list_old);\n            }\n\n            return HTTP_FORBIDDEN;\n        }\n\n        /* determine whether a renegotiation has to be forced */\n        cipher_list = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            /* optimized way */\n            if ((!cipher && cipher_list) ||\n                (cipher && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher && cipher_list &&\n                     (sk_SSL_CIPHER_find(cipher_list, cipher) < 0))\n            {\n                renegotiate = TRUE;\n            }\n        }\n        else {\n            /* paranoid way */\n            if ((!cipher_list_old && cipher_list) ||\n                (cipher_list_old && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher_list_old && cipher_list) {\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list_old, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list_old));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n            }\n        }\n\n        /* cleanup */\n        if (cipher_list_old) {\n            sk_SSL_CIPHER_free(cipher_list_old);\n        }\n\n        if (renegotiate) {\n            if (is_slave) {\n                /* The request causes renegotiation on a slave connection.\n                 * This is not allowed since we might have concurrent requests\n                 * on this connection.\n                 */\n                apr_table_setn(r->notes, \""ssl-renegotiate-forbidden\"", \""cipher-suite\"");\n                return HTTP_FORBIDDEN;\n            }\n            \n#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE\n            if (sc->cipher_server_pref == TRUE) {\n                SSL_set_options(ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n            }\n#endif\n            /* tracing */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02220)\n                         \""Reconfigured cipher suite will force renegotiation\"");\n        }\n    }\n\n    /*\n     * override of SSLVerifyClient\n     *\n     * We force a renegotiation if the reconfigured/new verify type is\n     * stronger than the currently active verify type.\n     *\n     * The order is: none << optional_no_ca << optional << require\n     *\n     * Additionally the following optimization is possible here: When the\n     * currently active verify type is \""none\"" but a client certificate is\n     * already known/present, it's enough to manually force a client\n     * verification but at least skip the I/O-intensive renegotiation\n     * handshake.\n     */\n    if ((dc->nVerifyClient != SSL_CVERIFY_UNSET) ||\n        (sc->server->auth.verify_mode != SSL_CVERIFY_UNSET)) {\n\n        /* remember old state */\n        verify_old = SSL_get_verify_mode(ssl);\n        /* configure new state */\n        verify = SSL_VERIFY_NONE;\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE)) {\n            verify |= SSL_VERIFY_PEER_STRICT;\n        }\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_OPTIONAL) ||\n            (dc->nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))\n        {\n            verify |= SSL_VERIFY_PEER;\n        }\n\n        /* TODO: this seems premature since we do not know if there\n         *       are any changes required.\n         */\n        SSL_set_verify(ssl, verify, ssl_callback_SSLVerify);\n        SSL_set_verify_result(ssl, X509_V_OK);\n\n        /* determine whether we've to force a renegotiation */\n        if (!renegotiate && verify != verify_old) {\n            if (((verify_old == SSL_VERIFY_NONE) &&\n                 (verify     != SSL_VERIFY_NONE)) ||\n\n                (!(verify_old & SSL_VERIFY_PEER) &&\n                  (verify     & SSL_VERIFY_PEER)) ||\n\n                (!(verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) &&\n                  (verify     & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))\n            {\n                renegotiate = TRUE;\n                if (is_slave) {\n                    /* The request causes renegotiation on a slave connection.\n                     * This is not allowed since we might have concurrent requests\n                     * on this connection.\n                     */\n                    apr_table_setn(r->notes, \""ssl-renegotiate-forbidden\"", \""verify-client\"");\n                    return HTTP_FORBIDDEN;\n                }\n                /* optimization */\n\n                if ((dc->nOptions & SSL_OPT_OPTRENEGOTIATE) &&\n                    (verify_old == SSL_VERIFY_NONE) &&\n                    ((peercert = SSL_get_peer_certificate(ssl)) != NULL))\n                {\n                    renegotiate_quick = TRUE;\n                    X509_free(peercert);\n                }\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02255)\n                              \""Changed client verification type will force \""\n                              \""%srenegotiation\"",\n                              renegotiate_quick ? \""quick \"" : \""\"");\n            }\n            else if (verify != SSL_VERIFY_NONE) {\n                /*\n                 * override of SSLVerifyDepth\n                 *\n                 * The depth checks are handled by us manually inside the\n                 * verify callback function and not by OpenSSL internally\n                 * (and our function is aware of both the per-server and\n                 * per-directory contexts). So we cannot ask OpenSSL about\n                 * the currently verify depth. Instead we remember it in our\n                 * SSLConnRec attached to the SSL* of OpenSSL.  We've to force\n                 * the renegotiation if the reconfigured/new verify depth is\n                 * less than the currently active/remembered verify depth\n                 * (because this means more restriction on the certificate\n                 * chain).\n                 */\n                n = (sslconn->verify_depth != UNSET)\n                    ? sslconn->verify_depth\n                    : hssc->server->auth.verify_depth;\n                /* determine the new depth */\n                sslconn->verify_depth = (dc->nVerifyDepth != UNSET)\n                                        ? dc->nVerifyDepth\n                                        : sc->server->auth.verify_depth;\n                if (sslconn->verify_depth < n) {\n                    renegotiate = TRUE;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02254)\n                                  \""Reduced client verification depth will \""\n                                  \""force renegotiation\"");\n                }\n            }\n        }\n        /* If we're handling a request for a vhost other than the default one,\n         * then we need to make sure that client authentication is properly\n         * enforced. For clients supplying an SNI extension, the peer\n         * certificate verification has happened in the handshake already\n         * (and r->server == handshakeserver). For non-SNI requests,\n         * an additional check is needed here. If client authentication\n         * is configured as mandatory, then we can only proceed if the\n         * CA list doesn't have to be changed (OpenSSL doesn't provide\n         * an option to change the list for an existing session).\n         */\n        if ((r->server != handshakeserver)\n            && renegotiate\n            && ((verify & SSL_VERIFY_PEER) ||\n                (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) {\n#define MODSSL_CFG_CA_NE(f, sc1, sc2) \\\n            (sc1->server->auth.f && \\\n             (!sc2->server->auth.f || \\\n              strNE(sc1->server->auth.f, sc2->server->auth.f)))\n\n            if (MODSSL_CFG_CA_NE(ca_cert_file, sc, hssc) ||\n                MODSSL_CFG_CA_NE(ca_cert_path, sc, hssc)) {\n                if (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) {\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02256)\n                         \""Non-default virtual host with SSLVerify set to \""\n                         \""'require' and VirtualHost-specific CA certificate \""\n                         \""list is only available to clients with TLS server \""\n                         \""name indication (SNI) support\"");\n                    SSL_set_verify(ssl, verify_old, NULL);\n                    return HTTP_FORBIDDEN;\n                } else\n                    /* let it pass, possibly with an \""incorrect\"" peer cert,\n                     * so make sure the SSL_CLIENT_VERIFY environment variable\n                     * will indicate partial success only, later on.\n                     */\n                    sslconn->verify_info = \""GENEROUS\"";\n            }\n        }\n    }\n\n    /* If a renegotiation is now required for this location, and the\n     * request includes a message body (and the client has not\n     * requested a \""100 Continue\"" response), then the client will be\n     * streaming the request body over the wire already.  In that\n     * case, it is not possible to stop and perform a new SSL\n     * handshake immediately; once the SSL library moves to the\n     * \""accept\"" state, it will reject the SSL packets which the client\n     * is sending for the request body.\n     *\n     * To allow authentication to complete in this auth hook, the\n     * solution used here is to fill a (bounded) buffer with the\n     * request body, and then to reinject that request body later.\n     */\n    if (renegotiate && !renegotiate_quick\n        && (apr_table_get(r->headers_in, \""transfer-encoding\"")\n            || (apr_table_get(r->headers_in, \""content-length\"")\n                && strcmp(apr_table_get(r->headers_in, \""content-length\""), \""0\"")))\n        && !r->expecting_100) {\n        int rv;\n        apr_size_t rsize;\n\n        rsize = dc->nRenegBufferSize == UNSET ? DEFAULT_RENEG_BUFFER_SIZE :\n                                                dc->nRenegBufferSize;\n        if (rsize > 0) {\n            /* Fill the I/O buffer with the request body if possible. */\n            rv = ssl_io_buffer_fill(r, rsize);\n        }\n        else {\n            /* If the reneg buffer size is set to zero, just fail. */\n            rv = HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n\n        if (rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02257)\n                          \""could not buffer message body to allow \""\n                          \""SSL renegotiation to proceed\"");\n            return rv;\n        }\n    }\n\n    /*\n     * now do the renegotiation if anything was actually reconfigured\n     */\n    if (renegotiate) {\n        /*\n         * Now we force the SSL renegotiation by sending the Hello Request\n         * message to the client. Here we have to do a workaround: Actually\n         * OpenSSL returns immediately after sending the Hello Request (the\n         * intent AFAIK is because the SSL/TLS protocol says it's not a must\n         * that the client replies to a Hello Request). But because we insist\n         * on a reply (anything else is an error for us) we have to go to the\n         * ACCEPT state manually. Using SSL_set_accept_state() doesn't work\n         * here because it resets too much of the connection.  So we set the\n         * state explicitly and continue the handshake manually.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02221)\n                      \""Requesting connection re-negotiation\"");\n\n        if (renegotiate_quick) {\n            STACK_OF(X509) *cert_stack;\n\n            /* perform just a manual re-verification of the peer */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02258)\n                         \""Performing quick renegotiation: \""\n                         \""just re-verifying the peer\"");\n\n            cert_stack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);\n\n            cert = SSL_get_peer_certificate(ssl);\n\n            if (!cert_stack && cert) {\n                /* client cert is in the session cache, but there is\n                 * no chain, since ssl3_get_client_certificate()\n                 * sk_X509_shift-ed the peer cert out of the chain.\n                 * we put it back here for the purpose of quick_renegotiation.\n                 */\n                cert_stack = sk_X509_new_null();\n                sk_X509_push(cert_stack, cert);\n            }\n\n            if (!cert_stack || (sk_X509_num(cert_stack) == 0)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02222)\n                              \""Cannot find peer certificate chain\"");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!(cert_store ||\n                  (cert_store = SSL_CTX_get_cert_store(ctx))))\n            {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02223)\n                              \""Cannot find certificate storage\"");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!cert) {\n                cert = sk_X509_value(cert_stack, 0);\n            }\n\n            cert_store_ctx = X509_STORE_CTX_new();\n            X509_STORE_CTX_init(cert_store_ctx, cert_store, cert, cert_stack);\n            depth = SSL_get_verify_depth(ssl);\n\n            if (depth >= 0) {\n                X509_STORE_CTX_set_depth(cert_store_ctx, depth);\n            }\n\n            X509_STORE_CTX_set_ex_data(cert_store_ctx,\n                                       SSL_get_ex_data_X509_STORE_CTX_idx(),\n                                       (char *)ssl);\n\n            if (!X509_verify_cert(cert_store_ctx)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02224)\n                              \""Re-negotiation verification step failed\"");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n            }\n\n            SSL_set_verify_result(ssl, X509_STORE_CTX_get_error(cert_store_ctx));\n            X509_STORE_CTX_cleanup(cert_store_ctx);\n            X509_STORE_CTX_free(cert_store_ctx);\n\n            if (cert_stack != SSL_get_peer_cert_chain(ssl)) {\n                /* we created this ourselves, so free it */\n                sk_X509_pop_free(cert_stack, X509_free);\n            }\n        }\n        else {\n            char peekbuf[1];\n            const char *reneg_support;\n            request_rec *id = r->main ? r->main : r;\n\n            /* Additional mitigation for CVE-2009-3555: At this point,\n             * before renegotiating, an (entire) request has been read\n             * from the connection.  An attacker may have sent further\n             * data to \""prefix\"" any subsequent request by the victim's\n             * client after the renegotiation; this data may already\n             * have been read and buffered.  Forcing a connection\n             * closure after the response ensures such data will be\n             * discarded.  Legimately pipelined HTTP requests will be\n             * retried anyway with this approach. */\n            if (has_buffered_data(r)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02259)\n                              \""insecure SSL re-negotiation required, but \""\n                              \""a pipelined request is present; keepalive \""\n                              \""disabled\"");\n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n\n#if defined(SSL_get_secure_renegotiation_support)\n            reneg_support = SSL_get_secure_renegotiation_support(ssl) ?\n                            \""client does\"" : \""client does not\"";\n#else\n            reneg_support = \""server does not\"";\n#endif\n            /* Perform a full renegotiation. */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02260)\n                          \""Performing full renegotiation: complete handshake \""\n                          \""protocol (%s support secure renegotiation)\"",\n                          reneg_support);\n\n            SSL_set_session_id_context(ssl,\n                                       (unsigned char *)&id,\n                                       sizeof(id));\n\n            /* Toggle the renegotiation state to allow the new\n             * handshake to proceed. */\n            sslconn->reneg_state = RENEG_ALLOW;\n\n            SSL_renegotiate(ssl);\n            SSL_do_handshake(ssl);\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02225)\n                              \""Re-negotiation request failed\"");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02226)\n                          \""Awaiting re-negotiation handshake\"");\n\n            /* XXX: Should replace setting state with SSL_renegotiate(ssl);\n             * However, this causes failures in perl-framework currently,\n             * perhaps pre-test if we have already negotiated?\n             */\n            /* Need to trigger renegotiation handshake by reading.\n             * Peeking 0 bytes actually works.\n             * See: http://marc.info/?t=145493359200002&r=1&w=2\n             */\n            SSL_peek(ssl, peekbuf, 0);\n\n            sslconn->reneg_state = RENEG_REJECT;\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02261)\n                              \""Re-negotiation handshake failed\"");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            /* Full renegotiation successfull, we now have handshaken with\n             * this server's parameters.\n             */\n            sslconn->server = r->server;\n        }\n\n        /*\n         * Remember the peer certificate's DN\n         */\n        if ((cert = SSL_get_peer_certificate(ssl))) {\n            if (sslconn->client_cert) {\n                X509_free(sslconn->client_cert);\n            }\n            sslconn->client_cert = cert;\n            sslconn->client_dn = NULL;\n        }\n\n        /*\n         * Finally check for acceptable renegotiation results\n         */\n        if ((dc->nVerifyClient != SSL_CVERIFY_NONE) ||\n            (sc->server->auth.verify_mode != SSL_CVERIFY_NONE)) {\n            BOOL do_verify = ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n                              (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE));\n\n            if (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02262)\n                              \""Re-negotiation handshake failed: \""\n                              \""Client verification failed\"");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (do_verify) {\n                if ((peercert = SSL_get_peer_certificate(ssl)) == NULL) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02263)\n                                  \""Re-negotiation handshake failed: \""\n                                  \""Client certificate missing\"");\n\n                    return HTTP_FORBIDDEN;\n                }\n\n                X509_free(peercert);\n            }\n        }\n\n        /*\n         * Also check that SSLCipherSuite has been enforced as expected.\n         */\n        if (cipher_list) {\n            cipher = SSL_get_current_cipher(ssl);\n            if (sk_SSL_CIPHER_find(cipher_list, cipher) < 0) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02264)\n                             \""SSL cipher suite not renegotiated: \""\n                             \""access to %s denied using cipher %s\"",\n                              r->filename,\n                              SSL_CIPHER_get_name(cipher));\n                return HTTP_FORBIDDEN;\n            }\n        }\n        /* remember any new cipher suite used in renegotiation */\n        if (ncipher_suite) {\n            sslconn->cipher_suite = ncipher_suite;\n        }\n    }\n\n    /* If we're trying to have the user name set from a client\n     * certificate then we need to set it here. This should be safe as\n     * the user name probably isn't important from an auth checking point\n     * of view as the certificate supplied acts in that capacity.\n     * However, if FakeAuth is being used then this isn't the case so\n     * we need to postpone setting the username until later.\n     */\n    if ((dc->nOptions & SSL_OPT_FAKEBASICAUTH) == 0 && dc->szUserName) {\n        char *val = ssl_var_lookup(r->pool, r->server, r->connection,\n                                   r, (char *)dc->szUserName);\n        if (val && val[0])\n            r->user = val;\n        else\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02227)\n                          \""Failed to set r->user to '%s'\"", dc->szUserName);\n    }\n\n    /*\n     * Check SSLRequire boolean expressions\n     */\n    requires = dc->aRequirement;\n    ssl_requires = (ssl_require_t *)requires->elts;\n\n    for (i = 0; i < requires->nelts; i++) {\n        ssl_require_t *req = &ssl_requires[i];\n        const char *errstring;\n        ok = ap_expr_exec(r, req->mpExpr, &errstring);\n\n        if (ok < 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02265)\n                          \""access to %s failed, reason: Failed to execute \""\n                          \""SSL requirement expression: %s\"",\n                          r->filename, errstring);\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \""ssl-access-forbidden\"", \""1\"");\n\n            return HTTP_FORBIDDEN;\n        }\n\n        if (ok != 1) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02266)\n                          \""Access to %s denied for %s \""\n                          \""(requirement expression not fulfilled)\"",\n                          r->filename, r->useragent_ip);\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02228)\n                          \""Failed expression: %s\"", req->cpExpr);\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02229)\n                          \""access to %s failed, reason: %s\"",\n                          r->filename,\n                          \""SSL requirement expression not fulfilled\"");\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \""ssl-access-forbidden\"", \""1\"");\n\n            return HTTP_FORBIDDEN;\n        }\n    }\n\n    /*\n     * Else access is granted from our point of view (except vendor\n     * handlers override). But we have to return DECLINED here instead\n     * of OK, because mod_auth and other modules still might want to\n     * deny access.\n     */\n\n    return DECLINED;\n}"", ""target"": 0}]","[{""func_name"": ""ssl_hook_Access"", ""file_path"": ""modules/ssl/ssl_engine_kernel.c"", ""func_code"": ""int ssl_hook_Access(request_rec *r)\n{\n    SSLDirConfigRec *dc         = myDirConfig(r);\n    SSLSrvConfigRec *sc         = mySrvConfig(r->server);\n    SSLConnRec *sslconn         = myConnConfig(r->connection);\n    SSL *ssl                    = sslconn ? sslconn->ssl : NULL;\n    server_rec *handshakeserver = sslconn ? sslconn->server : NULL;\n    SSLSrvConfigRec *hssc       = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n    SSL_CTX *ctx = NULL;\n    apr_array_header_t *requires;\n    ssl_require_t *ssl_requires;\n    int ok, i;\n    BOOL renegotiate = FALSE, renegotiate_quick = FALSE;\n    X509 *cert;\n    X509 *peercert;\n    X509_STORE *cert_store = NULL;\n    X509_STORE_CTX *cert_store_ctx;\n    STACK_OF(SSL_CIPHER) *cipher_list_old = NULL, *cipher_list = NULL;\n    const SSL_CIPHER *cipher = NULL;\n    int depth, verify_old, verify, n, is_slave = 0;\n    const char *ncipher_suite;\n\n    /* On a slave connection, we do not expect to have an SSLConnRec, but\n     * our master connection might have one. */\n    if (!(sslconn && ssl) && r->connection->master) {\n        sslconn         = myConnConfig(r->connection->master);\n        ssl             = sslconn ? sslconn->ssl : NULL;\n        handshakeserver = sslconn ? sslconn->server : NULL;\n        hssc            = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n        is_slave        = 1;\n    }\n    \n    if (ssl) {\n        /*\n         * We should have handshaken here (on handshakeserver),\n         * otherwise we are being redirected (ErrorDocument) from\n         * a renegotiation failure below. The access is still \n         * forbidden in the latter case, let ap_die() handle\n         * this recursive (same) error.\n         */\n        if (!SSL_is_init_finished(ssl)) {\n            return HTTP_FORBIDDEN;\n        }\n        ctx = SSL_get_SSL_CTX(ssl);\n    }\n\n    /*\n     * Support for SSLRequireSSL directive\n     */\n    if (dc->bSSLRequired && !ssl) {\n        if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !is_slave) {\n            /* This vhost was configured for optional SSL, just tell the\n             * client that we need to upgrade.\n             */\n            apr_table_setn(r->err_headers_out, \""Upgrade\"", \""TLS/1.0, HTTP/1.1\"");\n            apr_table_setn(r->err_headers_out, \""Connection\"", \""Upgrade\"");\n\n            return HTTP_UPGRADE_REQUIRED;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02219)\n                      \""access to %s failed, reason: %s\"",\n                      r->filename, \""SSL connection required\"");\n\n        /* remember forbidden access for strict require option */\n        apr_table_setn(r->notes, \""ssl-access-forbidden\"", \""1\"");\n\n        return HTTP_FORBIDDEN;\n    }\n\n    /*\n     * Check to see whether SSL is in use; if it's not, then no\n     * further access control checks are relevant.  (the test for\n     * sc->enabled is probably strictly unnecessary)\n     */\n    if (sc->enabled == SSL_ENABLED_FALSE || !ssl) {\n        return DECLINED;\n    }\n\n#ifdef HAVE_SRP\n    /*\n     * Support for per-directory reconfigured SSL connection parameters\n     *\n     * We do not force any renegotiation if the user is already authenticated\n     * via SRP.\n     *\n     */\n    if (SSL_get_srp_username(ssl)) {\n        return DECLINED;\n    }\n#endif\n\n    /*\n     * Support for per-directory reconfigured SSL connection parameters.\n     *\n     * This is implemented by forcing an SSL renegotiation with the\n     * reconfigured parameter suite. But Apache's internal API processing\n     * makes our life very hard here, because when internal sub-requests occur\n     * we nevertheless should avoid multiple unnecessary SSL handshakes (they\n     * require extra network I/O and especially time to perform).\n     *\n     * But the optimization for filtering out the unnecessary handshakes isn't\n     * obvious and trivial.  Especially because while Apache is in its\n     * sub-request processing the client could force additional handshakes,\n     * too. And these take place perhaps without our notice. So the only\n     * possibility is to explicitly _ask_ OpenSSL whether the renegotiation\n     * has to be performed or not. It has to performed when some parameters\n     * which were previously known (by us) are not those we've now\n     * reconfigured (as known by OpenSSL) or (in optimized way) at least when\n     * the reconfigured parameter suite is stronger (more restrictions) than\n     * the currently active one.\n     */\n\n    /*\n     * Override of SSLCipherSuite\n     *\n     * We provide two options here:\n     *\n     * o The paranoid and default approach where we force a renegotiation when\n     *   the cipher suite changed in _any_ way (which is straight-forward but\n     *   often forces renegotiations too often and is perhaps not what the\n     *   user actually wanted).\n     *\n     * o The optimized and still secure way where we force a renegotiation\n     *   only if the currently active cipher is no longer contained in the\n     *   reconfigured/new cipher suite. Any other changes are not important\n     *   because it's the servers choice to select a cipher from the ones the\n     *   client supports. So as long as the current cipher is still in the new\n     *   cipher suite we're happy. Because we can assume we would have\n     *   selected it again even when other (better) ciphers exists now in the\n     *   new cipher suite. This approach is fine because the user explicitly\n     *   has to enable this via ``SSLOptions +OptRenegotiate''. So we do no\n     *   implicit optimizations.\n     */     \n    ncipher_suite = (dc->szCipherSuite? \n                     dc->szCipherSuite : (r->server != handshakeserver)?\n                     sc->server->auth.cipher_suite : NULL);\n    \n    if (ncipher_suite && (!sslconn->cipher_suite \n                          || strcmp(ncipher_suite, sslconn->cipher_suite))) {\n        /* remember old state */\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            cipher = SSL_get_current_cipher(ssl);\n        }\n        else {\n            cipher_list_old = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n            if (cipher_list_old) {\n                cipher_list_old = sk_SSL_CIPHER_dup(cipher_list_old);\n            }\n        }\n\n        /* configure new state */\n        if (is_slave) {\n            /* TODO: this categorically fails changed cipher suite settings\n             * on slave connections. We could do better by\n             * - create a new SSL* from our SSL_CTX and set cipher suite there,\n             *   and retrieve ciphers, free afterwards\n             * Modifying the SSL on a slave connection is no good.\n             */\n            apr_table_setn(r->notes, \""ssl-renegotiate-forbidden\"", \""cipher-suite\"");\n            return HTTP_FORBIDDEN;\n        }\n\n        if (!SSL_set_cipher_list(ssl, ncipher_suite)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02253)\n                          \""Unable to reconfigure (per-directory) \""\n                          \""permitted SSL ciphers\"");\n            ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n            if (cipher_list_old) {\n                sk_SSL_CIPHER_free(cipher_list_old);\n            }\n\n            return HTTP_FORBIDDEN;\n        }\n\n        /* determine whether a renegotiation has to be forced */\n        cipher_list = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            /* optimized way */\n            if ((!cipher && cipher_list) ||\n                (cipher && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher && cipher_list &&\n                     (sk_SSL_CIPHER_find(cipher_list, cipher) < 0))\n            {\n                renegotiate = TRUE;\n            }\n        }\n        else {\n            /* paranoid way */\n            if ((!cipher_list_old && cipher_list) ||\n                (cipher_list_old && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher_list_old && cipher_list) {\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list_old, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list_old));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n            }\n        }\n\n        /* cleanup */\n        if (cipher_list_old) {\n            sk_SSL_CIPHER_free(cipher_list_old);\n        }\n\n        if (renegotiate) {\n            if (is_slave) {\n                /* The request causes renegotiation on a slave connection.\n                 * This is not allowed since we might have concurrent requests\n                 * on this connection.\n                 */\n                apr_table_setn(r->notes, \""ssl-renegotiate-forbidden\"", \""cipher-suite\"");\n                return HTTP_FORBIDDEN;\n            }\n            \n#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE\n            if (sc->cipher_server_pref == TRUE) {\n                SSL_set_options(ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n            }\n#endif\n            /* tracing */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02220)\n                         \""Reconfigured cipher suite will force renegotiation\"");\n        }\n    }\n\n    /*\n     * override of SSLVerifyClient\n     *\n     * We force a renegotiation if the reconfigured/new verify type is\n     * stronger than the currently active verify type.\n     *\n     * The order is: none << optional_no_ca << optional << require\n     *\n     * Additionally the following optimization is possible here: When the\n     * currently active verify type is \""none\"" but a client certificate is\n     * already known/present, it's enough to manually force a client\n     * verification but at least skip the I/O-intensive renegotiation\n     * handshake.\n     */\n    if ((dc->nVerifyClient != SSL_CVERIFY_UNSET) ||\n        (sc->server->auth.verify_mode != SSL_CVERIFY_UNSET)) {\n\n        /* remember old state */\n        verify_old = SSL_get_verify_mode(ssl);\n        /* configure new state */\n        verify = SSL_VERIFY_NONE;\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE)) {\n            verify |= SSL_VERIFY_PEER_STRICT;\n        }\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_OPTIONAL) ||\n            (dc->nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))\n        {\n            verify |= SSL_VERIFY_PEER;\n        }\n\n        /* TODO: this seems premature since we do not know if there\n         *       are any changes required.\n         */\n        SSL_set_verify(ssl, verify, ssl_callback_SSLVerify);\n        SSL_set_verify_result(ssl, X509_V_OK);\n\n        /* determine whether we've to force a renegotiation */\n        if (!renegotiate && verify != verify_old) {\n            if (((verify_old == SSL_VERIFY_NONE) &&\n                 (verify     != SSL_VERIFY_NONE)) ||\n\n                (!(verify_old & SSL_VERIFY_PEER) &&\n                  (verify     & SSL_VERIFY_PEER)) ||\n\n                (!(verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) &&\n                  (verify     & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))\n            {\n                renegotiate = TRUE;\n                if (is_slave) {\n                    /* The request causes renegotiation on a slave connection.\n                     * This is not allowed since we might have concurrent requests\n                     * on this connection.\n                     */\n                    apr_table_setn(r->notes, \""ssl-renegotiate-forbidden\"", \""verify-client\"");\n                    SSL_set_verify(ssl, verify_old, ssl_callback_SSLVerify);\n                    return HTTP_FORBIDDEN;\n                }\n                /* optimization */\n\n                if ((dc->nOptions & SSL_OPT_OPTRENEGOTIATE) &&\n                    (verify_old == SSL_VERIFY_NONE) &&\n                    ((peercert = SSL_get_peer_certificate(ssl)) != NULL))\n                {\n                    renegotiate_quick = TRUE;\n                    X509_free(peercert);\n                }\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02255)\n                              \""Changed client verification type will force \""\n                              \""%srenegotiation\"",\n                              renegotiate_quick ? \""quick \"" : \""\"");\n            }\n            else if (verify != SSL_VERIFY_NONE) {\n                /*\n                 * override of SSLVerifyDepth\n                 *\n                 * The depth checks are handled by us manually inside the\n                 * verify callback function and not by OpenSSL internally\n                 * (and our function is aware of both the per-server and\n                 * per-directory contexts). So we cannot ask OpenSSL about\n                 * the currently verify depth. Instead we remember it in our\n                 * SSLConnRec attached to the SSL* of OpenSSL.  We've to force\n                 * the renegotiation if the reconfigured/new verify depth is\n                 * less than the currently active/remembered verify depth\n                 * (because this means more restriction on the certificate\n                 * chain).\n                 */\n                n = (sslconn->verify_depth != UNSET)\n                    ? sslconn->verify_depth\n                    : hssc->server->auth.verify_depth;\n                /* determine the new depth */\n                sslconn->verify_depth = (dc->nVerifyDepth != UNSET)\n                                        ? dc->nVerifyDepth\n                                        : sc->server->auth.verify_depth;\n                if (sslconn->verify_depth < n) {\n                    renegotiate = TRUE;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02254)\n                                  \""Reduced client verification depth will \""\n                                  \""force renegotiation\"");\n                }\n            }\n        }\n        /* If we're handling a request for a vhost other than the default one,\n         * then we need to make sure that client authentication is properly\n         * enforced. For clients supplying an SNI extension, the peer\n         * certificate verification has happened in the handshake already\n         * (and r->server == handshakeserver). For non-SNI requests,\n         * an additional check is needed here. If client authentication\n         * is configured as mandatory, then we can only proceed if the\n         * CA list doesn't have to be changed (OpenSSL doesn't provide\n         * an option to change the list for an existing session).\n         */\n        if ((r->server != handshakeserver)\n            && renegotiate\n            && ((verify & SSL_VERIFY_PEER) ||\n                (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) {\n#define MODSSL_CFG_CA_NE(f, sc1, sc2) \\\n            (sc1->server->auth.f && \\\n             (!sc2->server->auth.f || \\\n              strNE(sc1->server->auth.f, sc2->server->auth.f)))\n\n            if (MODSSL_CFG_CA_NE(ca_cert_file, sc, hssc) ||\n                MODSSL_CFG_CA_NE(ca_cert_path, sc, hssc)) {\n                if (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) {\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02256)\n                         \""Non-default virtual host with SSLVerify set to \""\n                         \""'require' and VirtualHost-specific CA certificate \""\n                         \""list is only available to clients with TLS server \""\n                         \""name indication (SNI) support\"");\n                    SSL_set_verify(ssl, verify_old, NULL);\n                    return HTTP_FORBIDDEN;\n                } else\n                    /* let it pass, possibly with an \""incorrect\"" peer cert,\n                     * so make sure the SSL_CLIENT_VERIFY environment variable\n                     * will indicate partial success only, later on.\n                     */\n                    sslconn->verify_info = \""GENEROUS\"";\n            }\n        }\n    }\n\n    /* If a renegotiation is now required for this location, and the\n     * request includes a message body (and the client has not\n     * requested a \""100 Continue\"" response), then the client will be\n     * streaming the request body over the wire already.  In that\n     * case, it is not possible to stop and perform a new SSL\n     * handshake immediately; once the SSL library moves to the\n     * \""accept\"" state, it will reject the SSL packets which the client\n     * is sending for the request body.\n     *\n     * To allow authentication to complete in this auth hook, the\n     * solution used here is to fill a (bounded) buffer with the\n     * request body, and then to reinject that request body later.\n     */\n    if (renegotiate && !renegotiate_quick\n        && (apr_table_get(r->headers_in, \""transfer-encoding\"")\n            || (apr_table_get(r->headers_in, \""content-length\"")\n                && strcmp(apr_table_get(r->headers_in, \""content-length\""), \""0\"")))\n        && !r->expecting_100) {\n        int rv;\n        apr_size_t rsize;\n\n        rsize = dc->nRenegBufferSize == UNSET ? DEFAULT_RENEG_BUFFER_SIZE :\n                                                dc->nRenegBufferSize;\n        if (rsize > 0) {\n            /* Fill the I/O buffer with the request body if possible. */\n            rv = ssl_io_buffer_fill(r, rsize);\n        }\n        else {\n            /* If the reneg buffer size is set to zero, just fail. */\n            rv = HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n\n        if (rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02257)\n                          \""could not buffer message body to allow \""\n                          \""SSL renegotiation to proceed\"");\n            return rv;\n        }\n    }\n\n    /*\n     * now do the renegotiation if anything was actually reconfigured\n     */\n    if (renegotiate) {\n        /*\n         * Now we force the SSL renegotiation by sending the Hello Request\n         * message to the client. Here we have to do a workaround: Actually\n         * OpenSSL returns immediately after sending the Hello Request (the\n         * intent AFAIK is because the SSL/TLS protocol says it's not a must\n         * that the client replies to a Hello Request). But because we insist\n         * on a reply (anything else is an error for us) we have to go to the\n         * ACCEPT state manually. Using SSL_set_accept_state() doesn't work\n         * here because it resets too much of the connection.  So we set the\n         * state explicitly and continue the handshake manually.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02221)\n                      \""Requesting connection re-negotiation\"");\n\n        if (renegotiate_quick) {\n            STACK_OF(X509) *cert_stack;\n\n            /* perform just a manual re-verification of the peer */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02258)\n                         \""Performing quick renegotiation: \""\n                         \""just re-verifying the peer\"");\n\n            cert_stack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);\n\n            cert = SSL_get_peer_certificate(ssl);\n\n            if (!cert_stack && cert) {\n                /* client cert is in the session cache, but there is\n                 * no chain, since ssl3_get_client_certificate()\n                 * sk_X509_shift-ed the peer cert out of the chain.\n                 * we put it back here for the purpose of quick_renegotiation.\n                 */\n                cert_stack = sk_X509_new_null();\n                sk_X509_push(cert_stack, cert);\n            }\n\n            if (!cert_stack || (sk_X509_num(cert_stack) == 0)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02222)\n                              \""Cannot find peer certificate chain\"");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!(cert_store ||\n                  (cert_store = SSL_CTX_get_cert_store(ctx))))\n            {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02223)\n                              \""Cannot find certificate storage\"");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!cert) {\n                cert = sk_X509_value(cert_stack, 0);\n            }\n\n            cert_store_ctx = X509_STORE_CTX_new();\n            X509_STORE_CTX_init(cert_store_ctx, cert_store, cert, cert_stack);\n            depth = SSL_get_verify_depth(ssl);\n\n            if (depth >= 0) {\n                X509_STORE_CTX_set_depth(cert_store_ctx, depth);\n            }\n\n            X509_STORE_CTX_set_ex_data(cert_store_ctx,\n                                       SSL_get_ex_data_X509_STORE_CTX_idx(),\n                                       (char *)ssl);\n\n            if (!X509_verify_cert(cert_store_ctx)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02224)\n                              \""Re-negotiation verification step failed\"");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n            }\n\n            SSL_set_verify_result(ssl, X509_STORE_CTX_get_error(cert_store_ctx));\n            X509_STORE_CTX_cleanup(cert_store_ctx);\n            X509_STORE_CTX_free(cert_store_ctx);\n\n            if (cert_stack != SSL_get_peer_cert_chain(ssl)) {\n                /* we created this ourselves, so free it */\n                sk_X509_pop_free(cert_stack, X509_free);\n            }\n        }\n        else {\n            char peekbuf[1];\n            const char *reneg_support;\n            request_rec *id = r->main ? r->main : r;\n\n            /* Additional mitigation for CVE-2009-3555: At this point,\n             * before renegotiating, an (entire) request has been read\n             * from the connection.  An attacker may have sent further\n             * data to \""prefix\"" any subsequent request by the victim's\n             * client after the renegotiation; this data may already\n             * have been read and buffered.  Forcing a connection\n             * closure after the response ensures such data will be\n             * discarded.  Legimately pipelined HTTP requests will be\n             * retried anyway with this approach. */\n            if (has_buffered_data(r)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02259)\n                              \""insecure SSL re-negotiation required, but \""\n                              \""a pipelined request is present; keepalive \""\n                              \""disabled\"");\n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n\n#if defined(SSL_get_secure_renegotiation_support)\n            reneg_support = SSL_get_secure_renegotiation_support(ssl) ?\n                            \""client does\"" : \""client does not\"";\n#else\n            reneg_support = \""server does not\"";\n#endif\n            /* Perform a full renegotiation. */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02260)\n                          \""Performing full renegotiation: complete handshake \""\n                          \""protocol (%s support secure renegotiation)\"",\n                          reneg_support);\n\n            SSL_set_session_id_context(ssl,\n                                       (unsigned char *)&id,\n                                       sizeof(id));\n\n            /* Toggle the renegotiation state to allow the new\n             * handshake to proceed. */\n            sslconn->reneg_state = RENEG_ALLOW;\n\n            SSL_renegotiate(ssl);\n            SSL_do_handshake(ssl);\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02225)\n                              \""Re-negotiation request failed\"");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02226)\n                          \""Awaiting re-negotiation handshake\"");\n\n            /* XXX: Should replace setting state with SSL_renegotiate(ssl);\n             * However, this causes failures in perl-framework currently,\n             * perhaps pre-test if we have already negotiated?\n             */\n            /* Need to trigger renegotiation handshake by reading.\n             * Peeking 0 bytes actually works.\n             * See: http://marc.info/?t=145493359200002&r=1&w=2\n             */\n            SSL_peek(ssl, peekbuf, 0);\n\n            sslconn->reneg_state = RENEG_REJECT;\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02261)\n                              \""Re-negotiation handshake failed\"");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            /* Full renegotiation successfull, we now have handshaken with\n             * this server's parameters.\n             */\n            sslconn->server = r->server;\n        }\n\n        /*\n         * Remember the peer certificate's DN\n         */\n        if ((cert = SSL_get_peer_certificate(ssl))) {\n            if (sslconn->client_cert) {\n                X509_free(sslconn->client_cert);\n            }\n            sslconn->client_cert = cert;\n            sslconn->client_dn = NULL;\n        }\n\n        /*\n         * Finally check for acceptable renegotiation results\n         */\n        if ((dc->nVerifyClient != SSL_CVERIFY_NONE) ||\n            (sc->server->auth.verify_mode != SSL_CVERIFY_NONE)) {\n            BOOL do_verify = ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n                              (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE));\n\n            if (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02262)\n                              \""Re-negotiation handshake failed: \""\n                              \""Client verification failed\"");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (do_verify) {\n                if ((peercert = SSL_get_peer_certificate(ssl)) == NULL) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02263)\n                                  \""Re-negotiation handshake failed: \""\n                                  \""Client certificate missing\"");\n\n                    return HTTP_FORBIDDEN;\n                }\n\n                X509_free(peercert);\n            }\n        }\n\n        /*\n         * Also check that SSLCipherSuite has been enforced as expected.\n         */\n        if (cipher_list) {\n            cipher = SSL_get_current_cipher(ssl);\n            if (sk_SSL_CIPHER_find(cipher_list, cipher) < 0) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02264)\n                             \""SSL cipher suite not renegotiated: \""\n                             \""access to %s denied using cipher %s\"",\n                              r->filename,\n                              SSL_CIPHER_get_name(cipher));\n                return HTTP_FORBIDDEN;\n            }\n        }\n        /* remember any new cipher suite used in renegotiation */\n        if (ncipher_suite) {\n            sslconn->cipher_suite = ncipher_suite;\n        }\n    }\n\n    /* If we're trying to have the user name set from a client\n     * certificate then we need to set it here. This should be safe as\n     * the user name probably isn't important from an auth checking point\n     * of view as the certificate supplied acts in that capacity.\n     * However, if FakeAuth is being used then this isn't the case so\n     * we need to postpone setting the username until later.\n     */\n    if ((dc->nOptions & SSL_OPT_FAKEBASICAUTH) == 0 && dc->szUserName) {\n        char *val = ssl_var_lookup(r->pool, r->server, r->connection,\n                                   r, (char *)dc->szUserName);\n        if (val && val[0])\n            r->user = val;\n        else\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02227)\n                          \""Failed to set r->user to '%s'\"", dc->szUserName);\n    }\n\n    /*\n     * Check SSLRequire boolean expressions\n     */\n    requires = dc->aRequirement;\n    ssl_requires = (ssl_require_t *)requires->elts;\n\n    for (i = 0; i < requires->nelts; i++) {\n        ssl_require_t *req = &ssl_requires[i];\n        const char *errstring;\n        ok = ap_expr_exec(r, req->mpExpr, &errstring);\n\n        if (ok < 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02265)\n                          \""access to %s failed, reason: Failed to execute \""\n                          \""SSL requirement expression: %s\"",\n                          r->filename, errstring);\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \""ssl-access-forbidden\"", \""1\"");\n\n            return HTTP_FORBIDDEN;\n        }\n\n        if (ok != 1) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02266)\n                          \""Access to %s denied for %s \""\n                          \""(requirement expression not fulfilled)\"",\n                          r->filename, r->useragent_ip);\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02228)\n                          \""Failed expression: %s\"", req->cpExpr);\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02229)\n                          \""access to %s failed, reason: %s\"",\n                          r->filename,\n                          \""SSL requirement expression not fulfilled\"");\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \""ssl-access-forbidden\"", \""1\"");\n\n            return HTTP_FORBIDDEN;\n        }\n    }\n\n    /*\n     * Else access is granted from our point of view (except vendor\n     * handlers override). But we have to return DECLINED here instead\n     * of OK, because mod_auth and other modules still might want to\n     * deny access.\n     */\n\n    return DECLINED;\n}""}]","{""value"": 1, ""function"": 1, ""code"": 1}","[{""source"": ""value_info(file:ssl_engine_kernel.c, value:verify_old)"", ""result"": {""value_trace"": [{""full_code"": ""verify_old = SSL_get_verify_mode(ssl)"", ""line"": 689, ""func_name"": ""ssl_hook_Access""}], ""struct_var"": ""verify_old"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""func_info(file:ssl_engine_kernel.c, func:ssl_callback_SSLVerify)"", ""result"": [{""code"": ""int ssl_callback_SSLVerify(int ok, X509_STORE_CTX *ctx)\n{\n    /* Get Apache context back through OpenSSL context */\n    SSL *ssl = X509_STORE_CTX_get_ex_data(ctx,\n                                          SSL_get_ex_data_X509_STORE_CTX_idx());\n    conn_rec *conn      = (conn_rec *)SSL_get_app_data(ssl);\n    request_rec *r      = (request_rec *)modssl_get_app_data2(ssl);\n    server_rec *s       = r ? r->server : mySrvFromConn(conn);\n\n    SSLSrvConfigRec *sc = mySrvConfig(s);\n    SSLConnRec *sslconn = myConnConfig(conn);\n    SSLDirConfigRec *dc = r ? myDirConfig(r) : sslconn->dc;\n    modssl_ctx_t *mctx  = myCtxConfig(sslconn, sc);\n    int crl_check_mode  = mctx->crl_check_mask & ~SSL_CRLCHECK_FLAGS;\n\n    /* Get verify ingredients */\n    int errnum   = X509_STORE_CTX_get_error(ctx);\n    int errdepth = X509_STORE_CTX_get_error_depth(ctx);\n    int depth, verify;\n\n\n    /*\n     * Log verification information\n     */\n    ssl_log_cxerror(SSLLOG_MARK, APLOG_DEBUG, 0, conn,\n                   ..."", ""start_line"": 1561, ""end_line"": 1726, ""full_name"": ""ssl_callback_SSLVerify"", ""file_path"": ""modules/ssl/ssl_engine_kernel.c""}]}, {""source"": ""code_info(file:ssl_engine_kernel.c, lines:700-750)"", ""result"": ""            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))\n        {\n            verify |= SSL_VERIFY_PEER;\n        }\n\n        /* TODO: this seems premature since we do not know if there\n         *       are any changes required.\n         */\n        SSL_set_verify(ssl, verify, ssl_callback_SSLVerify);\n        SSL_set_verify_result(ssl, X509_V_OK);\n\n        /* determine whether we've to force a renegotiation */\n        if (!renegotiate && verify != verify_old) {\n            if (((verify_old == SSL_VERIFY_NONE) &&\n                 (verify     != SSL_VERIFY_NONE)) ||\n\n                (!(verify_old & SSL_VERIFY_PEER) &&\n                  (verify     & SSL_VERIFY_PEER)) ||\n\n                (!(verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) &&\n                  (verify     & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))\n            {\n                renegotiate = TRUE;\n                if (is_slave) {\n                    /* The request causes renegotiation on a slave connection.\n                     * This is not allowed since we might have concurrent requests\n                     * on this connection.\n                     */\n                    apr_table_setn(r->notes, \""ssl-renegotiate-forbidden\"", \""verify-client\"");\n                    return HTTP_FORBIDDEN;\n                }\n                /* optimization */\n\n                if ((dc->nOptions & SSL_OPT_OPTRENEGOTIATE) &&\n                    (verify_old == SSL_VERIFY_NONE) &&\n                    ((peercert = SSL_get_peer_certificate(ssl)) != NULL))\n                {\n                    renegotiate_quick = TRUE;\n                    X509_free(peercert);\n                }\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02255)\n                              \""Changed client verification type will force \""\n                              \""%srenegotiation\"",\n                              renegotiate_quick ? \""quick \"" : \""\"");\n            }\n            else if (verify != SSL_VERIFY_NONE) {\n                /*\n                 * override of SSLVerifyDepth\n                 *\n                 * The depth checks are handled by us manually inside the\n""}]","modules/ssl/ssl_engine_kernel.c:728-735: Original code failed to reset SSL verification state after aborting renegotiation. 'verify_old' (initialized at modules/ssl/ssl_engine_kernel.c:689 via SSL_get_verify_mode(ssl)) was not restored, allowing subsequent requests to bypass 'SSLVerifyClient require'. The patch adds SSL_set_verify(ssl, verify_old, ssl_callback_SSLVerify) to restore the state. The 'ssl_callback_SSLVerify' function (modules/ssl/ssl_engine_kernel.c:1561-1726) handles verification logic, including certificate checks and error logging.",0.95,./github/other_context/CVE-2016-4979
5,CVE-2017-5592,"CWE-20, CWE-346",c_cpp,"An incorrect implementation of ""XEP-0280: Message Carbons"" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0).",https://github.com/profanity-im/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,Add carbons from check,1,"[{""func_name"": ""_handle_carbons"", ""file_path"": ""src/xmpp/message.c"", ""func_code"": ""static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\""Unable to retrieve stanza name for Carbon\"");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \""private\"") == 0) {\n        log_info(\""Carbon received with private element.\"");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \""received\"") != 0) && (g_strcmp0(name, \""sent\"") != 0)) {\n        log_warning(\""Carbon received with unrecognised stanza name: %s\"", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""_handle_carbons"", ""file_path"": ""src/xmpp/message.c"", ""func_code"": ""static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\""Unable to retrieve stanza name for Carbon\"");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \""private\"") == 0) {\n        log_info(\""Carbon received with private element.\"");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \""received\"") != 0) && (g_strcmp0(name, \""sent\"") != 0)) {\n        log_warning(\""Carbon received with unrecognised stanza name: %s\"", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\""Invalid carbon received, from: %s\"", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}""}]","{""caller"": 2, ""code"": 2, ""value"": 2}","[{""source"": ""caller_info(file:message.c, func:_handle_carbons)"", ""result"": [{""call_line"": 764, ""call_code"": ""_handle_carbons(stanza)"", ""caller_code"": ""static void\n_handle_chat(xmpp_stanza_t *const stanza)\n{\n    // ignore if type not chat or absent\n    const char *type = xmpp_stanza_get_type(stanza);\n    if (!(g_strcmp0(type, \""chat\"") == 0 || type == NULL)) {\n        return;\n    }\n\n    // check if carbon message\n    gboolean res = _handle_carbons(stanza);\n    if (res) {\n        return;\n    }\n\n    // ignore handled namespaces\n    xmpp_stanza_t *conf = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (conf || captcha) {\n        return;\n    }\n\n    // some clients send the mucuser namespace with private messages\n    // if the namespace exists, and the stanza contains a body element, assume its a private message\n    // otherwise exit the handler\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    xmpp_stanza_t *body = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_BODY);\n    if (mucuser && body ==..."", ""caller_start"": 754, ""file_path"": ""src/xmpp/message.c""}]}, {""source"": ""code_info(file:message.c, lines:700-720)"", ""result"": ""    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n""}, {""source"": ""value_info(file:message.c, value:stanza)"", ""result"": {""value_trace"": [{""full_code"": ""stanza = stanza_create_invite(ctx, roomjid, contact, reason, password)"", ""line"": 316, ""func_name"": ""message_send_invite""}, {""full_code"": ""stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason)"", ""line"": 319, ""func_name"": ""message_send_invite""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING)"", ""line"": 331, ""func_name"": ""message_send_composing""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED)"", ""line"": 341, ""func_name"": ""message_send_paused""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE)"", ""line"": 350, ""func_name"": ""message_send_inactive""}], ""struct_var"": ""stanza"", ""struct_type"": ""xmpp_stanza_t*"", ""struct_definition"": ""xmpp_stanza_t""}}, {""source"": ""caller_info(file:message.c, func:_handle_chat)"", ""result"": [{""call_line"": 121, ""call_code"": ""_handle_chat(stanza)"", ""caller_code"": ""static int\n_message_handler(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata)\n{\n    log_debug(\""Message stanza handler fired\"");\n\n    char *text;\n    size_t text_size;\n    xmpp_stanza_to_text(stanza, &text, &text_size);\n    gboolean cont = plugins_on_message_stanza_receive(text);\n    xmpp_free(connection_get_ctx(), text);\n    if (!cont) {\n        return 1;\n    }\n\n    const char *type = xmpp_stanza_get_type(stanza);\n\n    if (g_strcmp0(type, STANZA_TYPE_ERROR) == 0) {\n        _handle_error(stanza);\n    }\n\n    if (g_strcmp0(type, STANZA_TYPE_GROUPCHAT) == 0) {\n        _handle_groupchat(stanza);\n    }\n\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, ..."", ""caller_start"": 77, ""file_path"": ""src/xmpp/message.c""}]}, {""source"": ""value_info(file:message.c, value:stanza)"", ""result"": {""value_trace"": [{""full_code"": ""stanza = stanza_create_invite(ctx, roomjid, contact, reason, password)"", ""line"": 316, ""func_name"": ""message_send_invite""}, {""full_code"": ""stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason)"", ""line"": 319, ""func_name"": ""message_send_invite""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING)"", ""line"": 331, ""func_name"": ""message_send_composing""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED)"", ""line"": 341, ""func_name"": ""message_send_paused""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE)"", ""line"": 350, ""func_name"": ""message_send_inactive""}], ""struct_var"": ""stanza"", ""struct_type"": ""xmpp_stanza_t*"", ""struct_definition"": ""xmpp_stanza_t""}}, {""source"": ""code_info(file:message.c, lines:100-140)"", ""result"": ""\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (captcha) {\n        _handle_captcha(stanza);\n    }\n\n    xmpp_stanza_t *receipts = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    if (receipts) {\n        _handle_receipt_received(stanza);\n    }\n\n    _handle_chat(stanza);\n\n    return 1;\n}\n\nvoid\nmessage_handlers_init(void)\n{\n    xmpp_conn_t * const conn = connection_get_conn();\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_handler_add(conn, _message_handler, NULL, STANZA_NAME_MESSAGE, NULL, ctx);\n}\n\nchar*\nmessage_send_chat(const char *const barejid, const char *const msg, const char *const oob_url,\n    gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n""}]","The vulnerability originates in missing validation of the 'from' JID in XMPP carbons (src/xmpp/message.c:716-720). `_handle_carbons` is called by `_handle_chat` (src/xmpp/message.c:764), which is triggered by `_message_handler` (src/xmpp/message.c:121) to process incoming XMPP stanzas. `_message_handler` is registered as an XMPP stanza handler via `xmpp_handler_add` in `message_handlers_init` (src/xmpp/message.c:140), establishing the network input path for the `stanza` parameter. The attack vector is confirmed as an external attacker can send a malicious carbon stanza over XMPP, which is processed by `_message_handler` and passed to `_handle_carbons` without proper validation.",1.0,./github/other_context/CVE-2017-5592
6,CVE-2018-20685,CWE-863,c_cpp,"In OpenSSH 7.9, scp.c in the scp client allows remote SSH servers to bypass intended access restrictions via the filename of . or an empty filename. The impact is modifying the permissions of the target directory on the client side.",https://github.com/openssh/openssh-portable/commit/6010c0303a422a9c5fa8860c061bf7105eb7f8b2,upstream: disallow empty incoming filename or ones that refer to the\n\ncurrent directory; based on report/patch from Harry Sintonen\n\nOpenBSD-Commit-ID: f27651b30eaee2df49540ab68d030865c04f6de9,1,"[{""func_name"": ""sink"", ""file_path"": ""scp.c"", ""func_code"": ""void\nsink(int argc, char **argv)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tenum {\n\t\tYES, NO, DISPLAYED\n\t} wrerr;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerrno = 0;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\""Unexpected off_t/time_t size\"");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\""ambiguous target\"");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \""\"", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\""unexpected <newline>\"");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\""lost connection\"");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \""Sink: %s\"", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \""%s\"", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\t\treturn;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\""mtime.sec not present\"");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\""mtime.sec not delimited\"");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tmtime.tv_sec = ull;\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||\n\t\t\t    mtime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\""mtime.usec not delimited\"");\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\""atime.sec not present\"");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\""atime.sec not delimited\"");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tatime.tv_sec = ull;\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||\n\t\t\t    atime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\""atime.usec not delimited\"");\n\t\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \""rcp remote:foo\\* local:bar\"".\n\t\t\t * In this case, the line \""No match.\"" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\""%s\"", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\""expected control record\"");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\""bad mode\"");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (!pflag)\n\t\t\tmode &= ~mask;\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\""mode not delimited\"");\n\n\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\""size not present\"");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\""size not delimited\"");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\""size out of range\"");\n\t\tsize = (off_t)ull;\n\n\t\tif ((strchr(cp, '/') != NULL) || (strcmp(cp, \""..\"") == 0)) {\n\t\t\trun_err(\""error: unexpected filename: %s\"", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \""%s%s%s\"", targ,\n\t\t\t    strcmp(targ, \""/\"") ? \""/\"" : \""\"", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\""received directory without -r\"");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) < 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\tif (utimes(vect[0], tv) < 0)\n\t\t\t\t\trun_err(\""%s: set times: %s\"",\n\t\t\t\t\t    vect[0], strerror(errno));\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {\nbad:\t\t\trun_err(\""%s: %s\"", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = NO;\n\n\t\tstatbytes = 0;\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n\t\tset_nonblock(remin);\n\t\tfor (count = i = 0; i < size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio6(read, remin, cp, amt,\n\t\t\t\t    scpio, &statbytes);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\""%s\"", j != EPIPE ?\n\t\t\t\t\t    strerror(errno) :\n\t\t\t\t\t    \""dropped connection\"");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (wrerr == NO) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\twrerr = YES;\n\t\t\t\t\t\twrerrno = errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n\t\tunset_nonblock(remin);\n\t\tif (count != 0 && wrerr == NO &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\tif (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&\n\t\t    ftruncate(ofd, size) != 0) {\n\t\t\trun_err(\""%s: truncate: %s\"", np, strerror(errno));\n\t\t\twrerr = DISPLAYED;\n\t\t}\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\""%s: set mode: %s\"",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\""%s: set mode: %s\"",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t\tif (setimes && wrerr == NO) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) < 0) {\n\t\t\t\trun_err(\""%s: set times: %s\"",\n\t\t\t\t    np, strerror(errno));\n\t\t\t\twrerr = DISPLAYED;\n\t\t\t}\n\t\t}\n\t\tswitch (wrerr) {\n\t\tcase YES:\n\t\t\trun_err(\""%s: %s\"", np, strerror(wrerrno));\n\t\t\tbreak;\n\t\tcase NO:\n\t\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\t\tbreak;\n\t\tcase DISPLAYED:\n\t\t\tbreak;\n\t\t}\n\t}\nscrewup:\n\trun_err(\""protocol error: %s\"", why);\n\texit(1);\n}"", ""target"": 0}]","[{""func_name"": ""sink"", ""file_path"": ""scp.c"", ""func_code"": ""void\nsink(int argc, char **argv)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tenum {\n\t\tYES, NO, DISPLAYED\n\t} wrerr;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerrno = 0;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\""Unexpected off_t/time_t size\"");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\""ambiguous target\"");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \""\"", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\""unexpected <newline>\"");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\""lost connection\"");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \""Sink: %s\"", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \""%s\"", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\t\treturn;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\""mtime.sec not present\"");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\""mtime.sec not delimited\"");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tmtime.tv_sec = ull;\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||\n\t\t\t    mtime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\""mtime.usec not delimited\"");\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\""atime.sec not present\"");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\""atime.sec not delimited\"");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tatime.tv_sec = ull;\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||\n\t\t\t    atime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\""atime.usec not delimited\"");\n\t\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \""rcp remote:foo\\* local:bar\"".\n\t\t\t * In this case, the line \""No match.\"" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\""%s\"", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\""expected control record\"");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\""bad mode\"");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (!pflag)\n\t\t\tmode &= ~mask;\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\""mode not delimited\"");\n\n\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\""size not present\"");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\""size not delimited\"");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\""size out of range\"");\n\t\tsize = (off_t)ull;\n\n\t\tif (*cp == '\\0' || strchr(cp, '/') != NULL ||\n\t\t    strcmp(cp, \"".\"") == 0 || strcmp(cp, \""..\"") == 0) {\n\t\t\trun_err(\""error: unexpected filename: %s\"", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \""%s%s%s\"", targ,\n\t\t\t    strcmp(targ, \""/\"") ? \""/\"" : \""\"", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\""received directory without -r\"");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) < 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\tif (utimes(vect[0], tv) < 0)\n\t\t\t\t\trun_err(\""%s: set times: %s\"",\n\t\t\t\t\t    vect[0], strerror(errno));\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {\nbad:\t\t\trun_err(\""%s: %s\"", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = NO;\n\n\t\tstatbytes = 0;\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n\t\tset_nonblock(remin);\n\t\tfor (count = i = 0; i < size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio6(read, remin, cp, amt,\n\t\t\t\t    scpio, &statbytes);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\""%s\"", j != EPIPE ?\n\t\t\t\t\t    strerror(errno) :\n\t\t\t\t\t    \""dropped connection\"");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (wrerr == NO) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\twrerr = YES;\n\t\t\t\t\t\twrerrno = errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n\t\tunset_nonblock(remin);\n\t\tif (count != 0 && wrerr == NO &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\tif (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&\n\t\t    ftruncate(ofd, size) != 0) {\n\t\t\trun_err(\""%s: truncate: %s\"", np, strerror(errno));\n\t\t\twrerr = DISPLAYED;\n\t\t}\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\""%s: set mode: %s\"",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\""%s: set mode: %s\"",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t\tif (setimes && wrerr == NO) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) < 0) {\n\t\t\t\trun_err(\""%s: set times: %s\"",\n\t\t\t\t    np, strerror(errno));\n\t\t\t\twrerr = DISPLAYED;\n\t\t\t}\n\t\t}\n\t\tswitch (wrerr) {\n\t\tcase YES:\n\t\t\trun_err(\""%s: %s\"", np, strerror(wrerrno));\n\t\t\tbreak;\n\t\tcase NO:\n\t\t\t(void) atomicio(vwrite, remout, \""\"", 1);\n\t\t\tbreak;\n\t\tcase DISPLAYED:\n\t\t\tbreak;\n\t\t}\n\t}\nscrewup:\n\trun_err(\""protocol error: %s\"", why);\n\texit(1);\n}""}]","{""function"": 1, ""code"": 2, ""value"": 1}","[{""source"": ""func_info(file:scp.c, func:sink)"", ""result"": [{""code"": ""void\nsink(int argc, char **argv)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tenum {\n\t\tYES, NO, DISPLAYED\n\t} wrerr;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerrno = 0;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\""Unexpected off_t/time_t size\"");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\""ambiguous target\"");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \""\"", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (..."", ""start_line"": 969, ""end_line"": 1274, ""full_name"": ""sink"", ""file_path"": ""scp.c""}]}, {""source"": ""code_info(file:scp.c, lines:1100-1120)"", ""result"": ""\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\""size not present\"");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\""size not delimited\"");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\""size out of range\"");\n\t\tsize = (off_t)ull;\n\n\t\tif ((strchr(cp, '/') != NULL) || (strcmp(cp, \""..\"") == 0)) {\n\t\t\trun_err(\""error: unexpected filename: %s\"", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n""}, {""source"": ""value_info(file:scp.c, value:cp)"", ""result"": {""value_trace"": [{""full_code"": ""cp = buf"", ""line"": 1011, ""func_name"": ""sink""}, {""full_code"": ""cp++"", ""line"": 1014, ""func_name"": ""sink""}, {""full_code"": ""cp++"", ""line"": 1019, ""func_name"": ""sink""}], ""struct_var"": ""cp"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""code_info(file:scp.c, lines:1000-1030)"", ""result"": ""\t\trun_err(\""ambiguous target\"");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \""\"", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\""unexpected <newline>\"");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\""lost connection\"");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \""Sink: %s\"", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \""%s\"", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n""}]","scp.c:1011 initializes 'cp' from 'buf', which is filled via atomicio(read, remin, ...) (scp.c:1011), directly reading remote input. scp.c:1107-1109 originally checked only for '/' or '..', allowing empty (*cp == '\0') or '.' filenames to bypass validation. This enabled malicious servers to send filenames that, when concatenated with the target directory (scp.c:1115-1117), modified client-side directory permissions. The patch added explicit checks for these cases.",0.95,./github/other_context/CVE-2018-20685
7,CVE-2019-10648,CWE-862,java,"Robocode through 1.9.3.5 allows remote attackers to cause external service interaction (DNS), as demonstrated by a query for a unique subdomain name within an attacker-controlled DNS zone, because of a .openStream call within java.net.URL.",https://github.com/robo-code/robocode/commit/836c84635e982e74f2f2771b2c8640c3a34221bd,Bug-406: DNS interaction is not blocked by Robocode's security manager + test(s) to verify the fix,8,"[{""func_name"": ""checkAccess"", ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/RobocodeSecurityManager.java"", ""func_code"": ""@Override\n\tpublic void checkAccess(Thread t) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\n\t\tThread c = Thread.currentThread();\n\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(t);\n\n\t\t// Threads belonging to other thread groups is not allowed to access threads belonging to other thread groups\n\t\t// Bug fix [3021140] Possible for robot to kill other robot threads.\n\t\t// In the following the thread group of the current thread must be in the thread group hierarchy of the\n\t\t// attacker thread; otherwise an AccessControlException must be thrown.\n\n\t\tboolean found = false;\n\t\t\n\t\tThreadGroup cg = c.getThreadGroup();\n\t\tThreadGroup tg = t.getThreadGroup();\n\n\t\twhile (tg != null) {\n\t\t\tif (tg == cg) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\ttg = tg.getParent();\n\t\t\t} catch (AccessControlException e) {\n\t\t\t\t// We expect an AccessControlException due to missing RuntimePermission modifyThreadGroup\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tString message = \""Preventing \"" + c.getName() + \"" from access to \"" + t.getName();\n\t\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\t\tif (robotProxy != null) {\n\t\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\t}\n\t\t\tthrow new AccessControlException(message);\n\t\t}\n\t}"", ""target"": 0}, {""func_name"": ""checkAccess"", ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/RobocodeSecurityManager.java"", ""func_code"": ""@Override\n\tpublic void checkAccess(ThreadGroup g) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\t\tThread c = Thread.currentThread();\n\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(g);\n\n\t\tfinal ThreadGroup cg = c.getThreadGroup();\n\n\t\tif (cg == null) {\n\t\t\t// What the heck is going on here?  JDK 1.3 is sending me a dead thread.\n\t\t\t// This crashes the entire jvm if I don't return here.\n\t\t\treturn;\n\t\t}\n\n\t\t// Bug fix #382 Unable to run robocode.bat -- Access Control Exception\n\t\tif (\""SeedGenerator Thread\"".equals(c.getName()) && \""SeedGenerator ThreadGroup\"".equals(cg.getName())) {\n\t\t\treturn; // The SeedGenerator might create a thread, which needs to be silently ignored\n\t\t}\n\t\t\n\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\tif (robotProxy == null) {\n\t\t\tthrow new AccessControlException(\""Preventing \"" + c.getName() + \"" from access to \"" + g.getName());\t\t\t\n\t\t}\n\n\t\tif (cg.activeCount() > 5) {\n\t\t\tString message = \""Robots are only allowed to create up to 5 threads!\"";\n\n\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\tthrow new AccessControlException(message);\n\t\t}\n\t}"", ""target"": 1}, {""func_name"": ""runTeardown"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestHttpAttack.java"", ""func_code"": ""@Override\n\tprotected void runTeardown() {\n\t\tAssert.assertTrue(\""HTTP connection is not allowed\"", messagedAccessDenied);\n\t}"", ""target"": 2}, {""func_name"": ""getExpectedErrors"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestHttpAttack.java"", ""func_code"": ""@Override\n\tprotected int getExpectedErrors() {\n\t\treturn hasJavaNetURLPermission ? 2 : 1; // Security error must be reported as an error. Java 8 reports two errors.\n\t}"", ""target"": 0}, {""func_name"": ""onTurnEnded"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestHttpAttack.java"", ""func_code"": ""@Override\n\tpublic void onTurnEnded(TurnEndedEvent event) {\n\t\tsuper.onTurnEnded(event);\n\n\t\tfinal String out = event.getTurnSnapshot().getRobots()[0].getOutputStreamSnapshot();\n\n\t\tif (out.contains(\""access denied (java.net.SocketPermission\"")\n\t\t\t\t|| out.contains(\""access denied (\\\""java.net.SocketPermission\\\""\"")) {\n\t\t\tmessagedAccessDenied = true;\t\n\t\t}\t\n\t}"", ""target"": 0}, {""func_name"": ""runTeardown"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestConstructorHttpAttack.java"", ""func_code"": ""@Override\n\tprotected void runTeardown() {\n\t\tAssert.assertTrue(\""Error during initialization\"", messagedInitialization);\n\t\tAssert.assertTrue(\""HTTP connection is not allowed\"", messagedAccessDenied);\n\t}"", ""target"": 0}, {""func_name"": ""getExpectedErrors"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestConstructorHttpAttack.java"", ""func_code"": ""@Override\n\tprotected int getExpectedErrors() {\n\t\treturn hasJavaNetURLPermission ? 3 : 2; // Security error must be reported as an error\n\t}"", ""target"": 2}, {""func_name"": ""onTurnEnded"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestConstructorHttpAttack.java"", ""func_code"": ""@Override\n\tpublic void onTurnEnded(TurnEndedEvent event) {\n\t\tsuper.onTurnEnded(event);\n\n\t\tfinal String out = event.getTurnSnapshot().getRobots()[0].getOutputStreamSnapshot();\n\n\t\tif (out.contains(\""An error occurred during initialization\"")) {\n\t\t\tmessagedInitialization = true;\t\n\t\t}\t\n\n\t\tif (out.contains(\""access denied (java.net.SocketPermission\"")\n\t\t\t\t|| out.contains(\""access denied (\\\""java.net.SocketPermission\\\""\"")) {\n\t\t\tmessagedAccessDenied = true;\t\n\t\t}\t\n\t}"", ""target"": 0}]","[{""func_name"": ""checkAccess"", ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/RobocodeSecurityManager.java"", ""func_code"": ""@Override\n\tpublic void checkAccess(Thread t) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\n\t\tThread c = Thread.currentThread();\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(t);\n\n\t\t// Threads belonging to other thread groups is not allowed to access threads belonging to other thread groups\n\t\t// Bug fix [3021140] Possible for robot to kill other robot threads.\n\t\t// In the following the thread group of the current thread must be in the thread group hierarchy of the\n\t\t// attacker thread; otherwise an AccessControlException must be thrown.\n\n\t\tboolean found = false;\n\t\t\n\t\tThreadGroup cg = c.getThreadGroup();\n\t\tThreadGroup tg = t.getThreadGroup();\n\n\t\twhile (tg != null) {\n\t\t\tif (tg == cg) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\ttg = tg.getParent();\n\t\t\t} catch (AccessControlException e) {\n\t\t\t\t// We expect an AccessControlException due to missing RuntimePermission modifyThreadGroup\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tString message = \""Preventing \"" + c.getName() + \"" from access to \"" + t.getName();\n\t\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\t\tif (robotProxy != null) {\n\t\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\t}\n\t\t\tthrow new SecurityException(message);\n\t\t}\n\t}""}, {""func_name"": ""checkAccess"", ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/RobocodeSecurityManager.java"", ""func_code"": ""@Override\n\tpublic void checkAccess(ThreadGroup g) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\t\tThread c = Thread.currentThread();\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(g);\n\n\t\tfinal ThreadGroup cg = c.getThreadGroup();\n\n\t\tif (cg == null) {\n\t\t\t// What the heck is going on here?  JDK 1.3 is sending me a dead thread.\n\t\t\t// This crashes the entire jvm if I don't return here.\n\t\t\treturn;\n\t\t}\n\n\t\t// Bug fix #382 Unable to run robocode.bat -- Access Control Exception\n\t\tif (\""SeedGenerator Thread\"".equals(c.getName()) && \""SeedGenerator ThreadGroup\"".equals(cg.getName())) {\n\t\t\treturn; // The SeedGenerator might create a thread, which needs to be silently ignored\n\t\t}\n\t\t\n\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\tif (robotProxy == null) {\n\t\t\tthrow new AccessControlException(\""Preventing \"" + c.getName() + \"" from access to \"" + g.getName());\t\t\t\n\t\t}\n\n\t\tif (cg.activeCount() > 5) {\n\t\t\tString message = \""Robots are only allowed to create up to 5 threads!\"";\n\n\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\tthrow new SecurityException(message);\n\t\t}\n\t}""}, {""func_name"": ""runTeardown"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestHttpAttack.java"", ""func_code"": ""@Override\n\tprotected void runTeardown() {\n\t\tAssert.assertTrue(\""Socket connection is not allowed\"", securityExceptionOccurred);\n\t}""}, {""func_name"": ""getExpectedErrors"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestHttpAttack.java"", ""func_code"": ""@Override\n\tprotected int getExpectedErrors() {\n\t\treturn 1;\n\t}""}, {""func_name"": ""onTurnEnded"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestHttpAttack.java"", ""func_code"": ""@Override\n\tpublic void onTurnEnded(TurnEndedEvent event) {\n\t\tsuper.onTurnEnded(event);\n\n\t\tfinal String out = event.getTurnSnapshot().getRobots()[0].getOutputStreamSnapshot();\n\n\t\tif (out.contains(\""java.lang.SecurityException:\"")) {\n\t\t\tsecurityExceptionOccurred = true;\t\n\t\t}\t\n\t}""}, {""func_name"": ""runTeardown"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestConstructorHttpAttack.java"", ""func_code"": ""@Override\n\tprotected void runTeardown() {\n\t\tAssert.assertTrue(\""Error during initialization\"", messagedInitialization);\n\t\tAssert.assertTrue(\""Socket connection is not allowed\"", securityExceptionOccurred);\n\t}""}, {""func_name"": ""getExpectedErrors"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestConstructorHttpAttack.java"", ""func_code"": ""@Override\n\tprotected int getExpectedErrors() {\n\t\treturn 2;\n\t}""}, {""func_name"": ""onTurnEnded"", ""file_path"": ""robocode.tests/src/test/java/net/sf/robocode/test/robots/TestConstructorHttpAttack.java"", ""func_code"": ""@Override\n\tpublic void onTurnEnded(TurnEndedEvent event) {\n\t\tsuper.onTurnEnded(event);\n\n\t\tfinal String out = event.getTurnSnapshot().getRobots()[0].getOutputStreamSnapshot();\n\n\t\tif (out.contains(\""An error occurred during initialization\"")) {\n\t\t\tmessagedInitialization = true;\t\n\t\t}\t\n\n\t\tif (out.contains(\""java.lang.SecurityException:\"")) {\n\t\t\tsecurityExceptionOccurred = true;\t\n\t\t}\t\n\t}""}]","{""function"": 1, ""code"": 3, ""caller"": 2, ""value"": 1}","[{""source"": ""func_info(func:isSafeThread)"", ""result"": [{""code"": ""\tpublic static boolean isSafeThread() {\n\t\tfinal IThreadManagerBase threadManager = ContainerBase.getComponent(IThreadManagerBase.class);\n\n\t\treturn threadManager != null && threadManager.isSafeThread();\n\t}\n"", ""start_line"": 243, ""end_line"": 247, ""full_name"": ""net.sf.robocode.security.HiddenAccess.isSafeThread:boolean()"", ""file_path"": ""robocode.api/src/main/java/net/sf/robocode/security/HiddenAccess.java""}, {""code"": ""\tboolean isSafeThread();\n"", ""start_line"": 19, ""end_line"": 19, ""full_name"": ""net.sf.robocode.security.IThreadManagerBase.isSafeThread:boolean()"", ""file_path"": ""robocode.api/src/main/java/net/sf/robocode/security/IThreadManagerBase.java""}, {""code"": ""\tboolean isSafeThread(Thread c);\n"", ""start_line"": 38, ""end_line"": 38, ""full_name"": ""net.sf.robocode.host.IThreadManager.isSafeThread:boolean(java.lang.Thread)"", ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/IThreadManager.java""}]}, {""source"": ""code_info(file:RobocodeSecurityManager.java, lines:40-60)"", ""result"": ""\t\tif (RobocodeProperties.isSecurityOn()) {\n\t\t\tSystem.setSecurityManager(this);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void checkAccess(Thread t) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\n\t\tThread c = Thread.currentThread();\n\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(t);\n\n\t\t// Threads belonging to other thread groups is not allowed to access threads belonging to other thread groups\n\t\t// Bug fix [3021140] Possible for robot to kill other robot threads.\n\t\t// In the following the thread group of the current thread must be in the thread group hierarchy of the\n\t\t// attacker thread; otherwise an AccessControlException must be thrown.\n""}, {""source"": ""caller_info(file:RobocodeSecurityManager.java, func:checkAccess)"", ""result"": [{""call_line"": 56, ""call_code"": ""super.checkAccess(t)"", ""caller_code"": ""\t@Override\n\tpublic void checkAccess(Thread t) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\n\t\tThread c = Thread.currentThread();\n\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(t);\n\n\t\t// Threads belonging to other thread groups is not allowed to access threads belonging to other thread groups\n\t\t// Bug fix [3021140] Possible for robot to kill other robot threads.\n\t\t// In the following the thread group of the current thread must be in the thread group hierarchy of the\n\t\t// attacker thread; otherwise an AccessControlException must be thrown.\n\n\t\tboolean found = false;\n\t\t\n\t\tThreadGroup cg = c.getThreadGroup();\n\t\tThreadGroup tg = t.getThreadGroup();\n\n\t\twhile (tg != null) {\n\t\t\tif (tg == cg) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\ttg = tg.getParent();\n\t\t\t} catch (AccessControlException e) {\n\t\t\t\t// We expect an AccessControlException due to missing RuntimePermission modifyThreadGroup\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tString message = \""Preventing \"" + c.getName() + \"" from access to \"" + t.getName();\n\t\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\t\tif (robotProxy != null) {\n\t\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\t}\n\t\t\tthrow new AccessControlException(message);\n\t\t}\n\t}\n"", ""caller_start"": 45, ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/RobocodeSecurityManager.java""}, {""call_line"": 101, ""call_code"": ""super.checkAccess(g)"", ""caller_code"": ""\t@Override\n\tpublic void checkAccess(ThreadGroup g) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\t\tThread c = Thread.currentThread();\n\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(g);\n\n\t\tfinal ThreadGroup cg = c.getThreadGroup();\n\n\t\tif (cg == null) {\n\t\t\t// What the heck is going on here?  JDK 1.3 is sending me a dead thread.\n\t\t\t// This crashes the entire jvm if I don't return here.\n\t\t\treturn;\n\t\t}\n\n\t\t// Bug fix #382 Unable to run robocode.bat -- Access Control Exception\n\t\tif (\""SeedGenerator Thread\"".equals(c.getName()) && \""SeedGenerator ThreadGroup\"".equals(cg.getName())) {\n\t\t\treturn; // The SeedGenerator might create a thread, which needs to be silently ignored\n\t\t}\n\t\t\n\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\tif (robotProxy == null) {\n\t\t\tthrow new AccessControlException(\""Preventing \"" + c.getName() + \"" from access to \"" + g.getName());\t\t\t\n\t\t}\n\n\t\tif (cg.activeCount() > 5) {\n\t\t\tString message = \""Robots are only allowed to create up to 5 threads!\"";\n\n\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\tthrow new AccessControlException(message);\n\t\t}\n\t}\n"", ""caller_start"": 91, ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/RobocodeSecurityManager.java""}, {""call_line"": 36, ""call_code"": ""this.checkAccess()"", ""caller_code"": ""\t@Override\n\tpublic final int available() throws IOException {\n\t\tcheckAccess();\n\t\treturn in.available();\n\t}\n"", ""caller_start"": 34, ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/SecureInputStream.java""}, {""call_line"": 46, ""call_code"": ""this.checkAccess()"", ""caller_code"": ""\t@Override\n\tpublic final void close() throws IOException {\n\t\tcheckAccess();\n\t\tin.close();\n\t}\n"", ""caller_start"": 44, ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/SecureInputStream.java""}]}, {""source"": ""code_info(file:RobocodeSecurityManager.java, lines:60-100)"", ""result"": ""\t\t// In the following the thread group of the current thread must be in the thread group hierarchy of the\n\t\t// attacker thread; otherwise an AccessControlException must be thrown.\n\n\t\tboolean found = false;\n\t\t\n\t\tThreadGroup cg = c.getThreadGroup();\n\t\tThreadGroup tg = t.getThreadGroup();\n\n\t\twhile (tg != null) {\n\t\t\tif (tg == cg) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\ttg = tg.getParent();\n\t\t\t} catch (AccessControlException e) {\n\t\t\t\t// We expect an AccessControlException due to missing RuntimePermission modifyThreadGroup\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tString message = \""Preventing \"" + c.getName() + \"" from access to \"" + t.getName();\n\t\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\t\tif (robotProxy != null) {\n\t\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\t}\n\t\t\tthrow new AccessControlException(message);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void checkAccess(ThreadGroup g) {\n\t\tif (RobocodeProperties.isSecurityOff()) {\n\t\t\treturn;\n\t\t}\n\t\tThread c = Thread.currentThread();\n\n\t\tif (isSafeThread(c)) {\n\t\t\treturn;\n\t\t}\n\t\tsuper.checkAccess(g);\n""}, {""source"": ""caller_info(file:RobocodeSecurityManager.java, func:checkPermission)"", ""result"": [{""call_line"": 41, ""call_code"": ""AccessController.checkPermission(inputPermission)"", ""caller_code"": ""\tprivate void checkAccess() {\n\t\tAccessController.checkPermission(inputPermission);\n\t}\n"", ""caller_start"": 40, ""file_path"": ""robocode.host/src/main/java/net/sf/robocode/host/security/SecureInputStream.java""}]}, {""source"": ""code_info(file:RobocodeSecurityManager.java, lines:100-150)"", ""result"": ""\t\t}\n\t\tsuper.checkAccess(g);\n\n\t\tfinal ThreadGroup cg = c.getThreadGroup();\n\n\t\tif (cg == null) {\n\t\t\t// What the heck is going on here?  JDK 1.3 is sending me a dead thread.\n\t\t\t// This crashes the entire jvm if I don't return here.\n\t\t\treturn;\n\t\t}\n\n\t\t// Bug fix #382 Unable to run robocode.bat -- Access Control Exception\n\t\tif (\""SeedGenerator Thread\"".equals(c.getName()) && \""SeedGenerator ThreadGroup\"".equals(cg.getName())) {\n\t\t\treturn; // The SeedGenerator might create a thread, which needs to be silently ignored\n\t\t}\n\t\t\n\t\tIHostedThread robotProxy = threadManager.getLoadedOrLoadingRobotProxy(c);\n\n\t\tif (robotProxy == null) {\n\t\t\tthrow new AccessControlException(\""Preventing \"" + c.getName() + \"" from access to \"" + g.getName());\t\t\t\n\t\t}\n\n\t\tif (cg.activeCount() > 5) {\n\t\t\tString message = \""Robots are only allowed to create up to 5 threads!\"";\n\n\t\t\trobotProxy.punishSecurityViolation(message);\n\t\t\tthrow new AccessControlException(message);\n\t\t}\n\t}\n\n\tprivate boolean isSafeThread(Thread c) {\n\t\treturn threadManager.isSafeThread(c);\n\t}\n}\n""}, {""source"": ""value_info(file:SecureInputStream.java, value:inputPermission)"", ""result"": {""value_trace"": [{""full_code"": ""RobocodePermission this.inputPermission = null"", ""line"": 20, ""func_name"": ""net.sf.robocode.host.security.SecureInputStream.<init>:void(java.io.InputStream)""}, {""full_code"": ""this.inputPermission = new RobocodePermission(\""System.in\"")"", ""line"": 31, ""func_name"": ""net.sf.robocode.host.security.SecureInputStream.<init>:void(java.io.InputStream)""}], ""struct_var"": ""inputPermission"", ""struct_type"": null, ""struct_definition"": null}}]","RobocodeSecurityManager.java: checkAccess() enforces thread safety (lines 50-52) but lacks URL/DNS permission checks. SecureInputStream.checkAccess() (line 36) validates 'System.in' permission (line 31) but not network operations. The security manager does not override checkConnect() or checkPermission() for java.net.URL, allowing DNS queries via openStream(). The absence of URL-specific permission enforcement logic in RobocodeSecurityManager is the root cause.",0.95,./github/other_context/CVE-2019-10648
8,CVE-2019-12589,CWE-732,c_cpp,"In Firejail before 0.9.60, seccomp filters are writable inside the jail, leading to a lack of intended seccomp restrictions for a process that is joined to the jail after a filter has been modified by an attacker.",https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134,mount runtime seccomp files read-only (#2602)\n\navoid creating locations in the file system that are both writable and\r\nexecutable (in this case for processes with euid of the user).\r\n\r\nfor the same reason also remove user owned libfiles\r\nwhen it is not needed any more,3,"[{""func_name"": ""fslib_copy_libs"", ""file_path"": ""src/firejail/fs_lib.c"", ""func_code"": ""void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\""    fslib_copy_libs %s\\n\"", full_path);\n\n\t// if library/executable does not exist or the user does not have read access to it\n\t// print a warning and exit the function.\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\""cannot find %s for private-lib, skipping...\\n\"", full_path);\n\t\treturn;\n\t}\n\n\t// create an empty RUN_LIB_FILE and allow the user to write to it\n\tunlink(RUN_LIB_FILE);\t\t\t  // in case is there\n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\""chown\"");\n\n\t// run fldd to extract the list of files\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\""    running fldd %s\\n\"", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\t// open the list of libraries and install them on by one\n\tFILE *fp = fopen(RUN_LIB_FILE, \""r\"");\n\tif (!fp)\n\t\terrExit(\""fopen\"");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n}"", ""target"": 0}, {""func_name"": ""preproc_mount_mnt_dir"", ""file_path"": ""src/firejail/preproc.c"", ""func_code"": ""void preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Mounting tmpfs on %s directory\\n\"", RUN_MNT_DIR);\n\t\tif (mount(\""tmpfs\"", RUN_MNT_DIR, \""tmpfs\"", MS_NOSUID | MS_STRICTATIME,  \""mode=755,gid=0\"") < 0)\n\t\t\terrExit(\""mounting /run/firejail/mnt\"");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\""tmpfs\"", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\""set_perms\"");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\""set_perms\"");\n#endif\n\t}\n}"", ""target"": 0}, {""func_name"": ""sandbox"", ""file_path"": ""src/firejail/sandbox.c"", ""func_code"": ""int sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\""Initializing child process\\n\"");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\""PID namespace installed\\n\"");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\""sethostname\"");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \""/\"", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \""/firejail\"", RUN_FIREJAIL_LIB_DIR, \""none\"", MS_BIND, NULL) < 0)\n\t\terrExit(\""mounting \"" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\""sandbox name:\"", cfg.name);\n\tfs_logger2int(\""sandbox pid:\"", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\""sandbox filesystem: chroot\"");\n\telse if (arg_overlay)\n\t\tfs_logger(\""sandbox filesystem: overlay\"");\n\telse\n\t\tfs_logger(\""sandbox filesystem: local\"");\n\tfs_logger(\""install mount namespace\"");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\""lo\"");\n\t\tif (arg_debug)\n\t\t\tprintf(\""Network namespace enabled, only loopback interface available\\n\"");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\""Network namespace '%s' activated\\n\"", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\""lo\"");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\""cannot configure default route\\n\"");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\""Network namespace enabled\\n\"");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\""\\n\"");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \""printif\"", \""scan\"");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \""printif\"");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\""Default gateway configuration failed\\n\"");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\""Default gateway %d.%d.%d.%d\\n\"", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns4);\n\t\t\tfmessage(\""\\n\"");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Build protocol filter: %s\\n\"", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \""protocol\"", \""build\"", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\""private=directory feature is disabled in chroot\\n\"");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\""private=directory feature is disabled in overlay\\n\"");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\""private-home= feature is disabled in chroot\\n\"");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\""private-home= feature is disabled in overlay\\n\"");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-etc feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-etc feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_dir_list(\""/etc\"", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-opt feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-opt feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_dir_list(\""/opt\"", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-srv feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-srv feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_dir_list(\""/srv\"", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-bin feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-bin feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \""%s,xauth\"", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\""asprintf\"");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-lib feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-lib feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-cache feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-cache feature is disabled in overlay\\n\"");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\""/\"") < 0)\n\t\t\terrExit(\""chdir\"");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\""chdir\"");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\""Current directory: %s\\n\"", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// set capabilities\n\tset_caps();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Install protocol filter: %s\\n\"", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Install memory write&execute filter\\n\"");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n#endif\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\""cannot create a new user namespace, going forward without it...\\n\"");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""noroot user namespace installed\\n\"");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\""cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\"");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \""Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\"");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\""NO_NEW_PRIVS set\\n\"");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\""fork\"");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\""firejail-default\"")) {\n\t\t\t\tfwarning(\""Cannot confine the application using AppArmor.\\n\""\n\t\t\t\t\t\""Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\""\n\t\t\t\t\t\""As root, run \\\""aa-enforce firejail-default\\\"" to load it.\\n\"");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\""AppArmor enabled\\n\"");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""fslib_copy_libs"", ""file_path"": ""src/firejail/fs_lib.c"", ""func_code"": ""void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\""    fslib_copy_libs %s\\n\"", full_path);\n\n\t// if library/executable does not exist or the user does not have read access to it\n\t// print a warning and exit the function.\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\""cannot find %s for private-lib, skipping...\\n\"", full_path);\n\t\treturn;\n\t}\n\n\t// create an empty RUN_LIB_FILE and allow the user to write to it\n\tunlink(RUN_LIB_FILE);\t\t\t  // in case is there\n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\""chown\"");\n\n\t// run fldd to extract the list of files\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\""    running fldd %s\\n\"", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\t// open the list of libraries and install them on by one\n\tFILE *fp = fopen(RUN_LIB_FILE, \""r\"");\n\tif (!fp)\n\t\terrExit(\""fopen\"");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}""}, {""func_name"": ""preproc_mount_mnt_dir"", ""file_path"": ""src/firejail/preproc.c"", ""func_code"": ""void preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Mounting tmpfs on %s directory\\n\"", RUN_MNT_DIR);\n\t\tif (mount(\""tmpfs\"", RUN_MNT_DIR, \""tmpfs\"", MS_NOSUID | MS_STRICTATIME,  \""mode=755,gid=0\"") < 0)\n\t\t\terrExit(\""mounting /run/firejail/mnt\"");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\""tmpfs\"", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\""set_perms\"");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\""set_perms\"");\n#endif\n\t}\n}""}, {""func_name"": ""sandbox"", ""file_path"": ""src/firejail/sandbox.c"", ""func_code"": ""int sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\""Initializing child process\\n\"");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\""PID namespace installed\\n\"");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\""sethostname\"");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \""/\"", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \""/firejail\"", RUN_FIREJAIL_LIB_DIR, \""none\"", MS_BIND, NULL) < 0)\n\t\terrExit(\""mounting \"" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\""sandbox name:\"", cfg.name);\n\tfs_logger2int(\""sandbox pid:\"", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\""sandbox filesystem: chroot\"");\n\telse if (arg_overlay)\n\t\tfs_logger(\""sandbox filesystem: overlay\"");\n\telse\n\t\tfs_logger(\""sandbox filesystem: local\"");\n\tfs_logger(\""install mount namespace\"");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\""lo\"");\n\t\tif (arg_debug)\n\t\t\tprintf(\""Network namespace enabled, only loopback interface available\\n\"");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\""Network namespace '%s' activated\\n\"", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\""lo\"");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\""Configuring %d.%d.%d.%d address on interface %s\\n\"", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\""cannot configure default route\\n\"");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\""Network namespace enabled\\n\"");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\""\\n\"");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \""printif\"", \""scan\"");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \""printif\"");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\""Default gateway configuration failed\\n\"");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\""Default gateway %d.%d.%d.%d\\n\"", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\""DNS server %s\\n\"", cfg.dns4);\n\t\t\tfmessage(\""\\n\"");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Build protocol filter: %s\\n\"", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \""protocol\"", \""build\"", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\""private=directory feature is disabled in chroot\\n\"");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\""private=directory feature is disabled in overlay\\n\"");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\""private-home= feature is disabled in chroot\\n\"");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\""private-home= feature is disabled in overlay\\n\"");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-etc feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-etc feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_dir_list(\""/etc\"", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-opt feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-opt feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_dir_list(\""/opt\"", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-srv feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-srv feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_dir_list(\""/srv\"", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-bin feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-bin feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \""%s,xauth\"", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\""asprintf\"");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-lib feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-lib feature is disabled in overlay\\n\"");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\""private-cache feature is disabled in chroot\\n\"");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\""private-cache feature is disabled in overlay\\n\"");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\""/\"") < 0)\n\t\t\terrExit(\""chdir\"");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\""chdir\"");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\""Current directory: %s\\n\"", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Install protocol filter: %s\\n\"", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Install memory write&execute filter\\n\"");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n\t// make seccomp filters read-only\n\tfs_rdonly(RUN_SECCOMP_DIR);\n#endif\n\n\t// set capabilities\n\tset_caps();\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\""cannot create a new user namespace, going forward without it...\\n\"");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""noroot user namespace installed\\n\"");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\""cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\"");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \""Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\"");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\""NO_NEW_PRIVS set\\n\"");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\""fork\"");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\""firejail-default\"")) {\n\t\t\t\tfwarning(\""Cannot confine the application using AppArmor.\\n\""\n\t\t\t\t\t\""Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\""\n\t\t\t\t\t\""As root, run \\\""aa-enforce firejail-default\\\"" to load it.\\n\"");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\""AppArmor enabled\\n\"");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}""}]","{""code"": 2, ""function"": 2}","[{""source"": ""code_info(file:fs_lib.c, lines:134-135)"", ""result"": ""\t}\n\tfclose(fp);\n}\n""}, {""source"": ""code_info(file:preproc.c, lines:87-89)"", ""result"": ""\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n""}, {""source"": ""func_info(func:fs_rdonly)"", ""result"": [{""code"": ""void fs_rdonly(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tunsigned long flags = 0;\n\t\tget_mount_flags(dir, &flags);\n\t\tif ((flags & MS_RDONLY) == MS_RDONLY)\n\t\t\treturn;\n\t\tflags |= MS_RDONLY;\n\t\tif (arg_debug)\n\t\t\tprintf(\""Mounting read-only %s\\n\"", dir);\n\t\t// mount --bind /bin /bin\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t    mount(NULL, dir, NULL, flags|MS_BIND|MS_REMOUNT, NULL) < 0)\n\t\t\terrExit(\""mount read-only\"");\n\t\tfs_logger2(\""read-only\"", dir);\n\t}\n}"", ""start_line"": 493, ""end_line"": 513, ""full_name"": ""fs_rdonly"", ""file_path"": ""src/firejail/fs.c""}]}, {""source"": ""func_info(func:create_empty_dir_as_root)"", ""result"": [{""code"": ""void create_empty_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\""Creating empty %s directory\\n\"", dir);\n\t\t/* coverity[toctou] */\n\t\t// don't fail if directory already exists. This can be the case in a race\n\t\t// condition, when two jails launch at the same time. See #1013\n\t\tif (mkdir(dir, mode) == -1 && errno != EEXIST)\n\t\t\terrExit(\""mkdir\"");\n\t\tif (set_perms(dir, 0, 0, mode))\n\t\t\terrExit(\""set_perms\"");\n\t\tASSERT_PERMS(dir, 0, 0, mode);\n\t}\n}"", ""start_line"": 1009, ""end_line"": 1026, ""full_name"": ""create_empty_dir_as_root"", ""file_path"": ""src/firejail/util.c""}]}]","The seccomp directory (RUN_SECCOMP_DIR) was previously created without restrictive permissions, allowing user processes to modify filters. The patch introduces:\n1. create_empty_dir_as_root(RUN_SECCOMP_DIR, 0755) (preproc.c:87-89) sets directory ownership to root with 0755 permissions (read/write/execute for owner, read/execute for others), preventing user write access.\n2. fs_rdonly(RUN_SECCOMP_DIR) (sandbox.c:1099-1102) remounts the directory as read-only via MS_BIND|MS_REMOUNT|MS_RDONLY, ensuring filters cannot be modified after setup.\nPrior to the patch, missing these steps allowed attackers to overwrite seccomp filters before the directory was secured.",0.95,./github/other_context/CVE-2019-12589
9,CVE-2019-13012,CWE-732,c_cpp,"The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",https://github.com/GNOME/glib/commit/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429,"keyfile settings: Use tighter permissions\n\nWhen creating directories, create them with 700 permissions,\ninstead of 777.\n\nCloses: #1658",13,"[{""func_name"": ""g_keyfile_settings_backend_keyfile_write"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *kfsb)\n{\n  gchar *contents;\n  gsize length;\n\n  contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);\n  g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,\n                           G_FILE_CREATE_REPLACE_DESTINATION,\n                           NULL, NULL, NULL);\n\n  compute_checksum (kfsb->digest, contents, length);\n  g_free (contents);\n}"", ""target"": 0}, {""func_name"": ""g_keyfile_settings_backend_constructed"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \""glib-2.0\"", \""settings\"", \""keyfile\"",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\""/\"");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \""changed\"",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \""changed\"",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}"", ""target"": 0}, {""func_name"": ""g_keyfile_settings_backend_check_one"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static gboolean\ng_keyfile_settings_backend_check_one (gpointer key,\n                                      gpointer value,\n                                      gpointer user_data)\n{\n  WriteManyData *data = user_data;\n\n  return data->failed = !path_is_valid (data->kfsb, key);\n}"", ""target"": 1}, {""func_name"": ""g_keyfile_settings_backend_new"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""GSettingsBackend *\ng_keyfile_settings_backend_new (const gchar *filename,\n                                const gchar *root_path,\n                                const gchar *root_group)\n{\n  GKeyfileSettingsBackend *kfsb;\n\n  g_return_val_if_fail (filename != NULL, NULL);\n  g_return_val_if_fail (root_path != NULL, NULL);\n  g_return_val_if_fail (g_str_has_prefix (root_path, \""/\""), NULL);\n  g_return_val_if_fail (g_str_has_suffix (root_path, \""/\""), NULL);\n  g_return_val_if_fail (strstr (root_path, \""//\"") == NULL, NULL);\n\n  kfsb = g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND, NULL);\n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->file = g_file_new_for_path (filename);\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, 0, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, 0, NULL, NULL);\n\n  kfsb->prefix_len = strlen (root_path);\n  kfsb->prefix = g_strdup (root_path);\n\n  if (root_group)\n    {\n      kfsb->root_group_len = strlen (root_group);\n      kfsb->root_group = g_strdup (root_group);\n    }\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \""changed\"",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \""changed\"",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  return G_SETTINGS_BACKEND (kfsb);\n}"", ""target"": 2}, {""func_name"": ""g_keyfile_settings_backend_class_init"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n}"", ""target"": 1}, {""func_name"": ""g_keyfile_settings_backend_get_property"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_get_property (GObject    *object,\n                                         guint       prop_id,\n                                         GValue     *value,\n                                         GParamSpec *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch (prop_id)\n    {\n    case PROP_FILENAME:\n      g_value_set_string (value, g_file_peek_path (kfsb->file));\n      break;\n\n    case PROP_ROOT_PATH:\n      g_value_set_string (value, kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      g_value_set_string (value, kfsb->root_group);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}"", ""target"": 1}, {""func_name"": ""g_keyfile_settings_backend_finalize"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_finalize (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  g_key_file_free (kfsb->keyfile);\n  g_object_unref (kfsb->permission);\n\n  g_file_monitor_cancel (kfsb->file_monitor);\n  g_object_unref (kfsb->file_monitor);\n  g_object_unref (kfsb->file);\n\n  g_file_monitor_cancel (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir);\n\n  g_free (kfsb->root_group);\n  g_free (kfsb->prefix);\n\n  G_OBJECT_CLASS (g_keyfile_settings_backend_parent_class)\n    ->finalize (object);\n}"", ""target"": 2}, {""func_name"": ""g_keyfile_settings_backend_get_writable"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static gboolean\ng_keyfile_settings_backend_get_writable (GSettingsBackend *backend,\n                                         const gchar      *name)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);\n\n  return kfsb->writable && path_is_valid (kfsb, name);\n}"", ""target"": 1}, {""func_name"": ""set_to_keyfile"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static gboolean\nset_to_keyfile (GKeyfileSettingsBackend *kfsb,\n                const gchar             *key,\n                GVariant                *value)\n{\n  gchar *group, *name;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      if (value)\n        {\n          gchar *str = g_variant_print (value, FALSE);\n          g_key_file_set_value (kfsb->keyfile, group, name, str);\n          g_variant_unref (g_variant_ref_sink (value));\n          g_free (str);\n        }\n      else\n        {\n          if (*name == '\\0')\n            {\n              gchar **groups;\n              gint i;\n\n              groups = g_key_file_get_groups (kfsb->keyfile, NULL);\n\n              for (i = 0; groups[i]; i++)\n                if (group_name_matches (groups[i], group))\n                  g_key_file_remove_group (kfsb->keyfile, groups[i], NULL);\n\n              g_strfreev (groups);\n            }\n          else\n            g_key_file_remove_key (kfsb->keyfile, group, name, NULL);\n        }\n\n      g_free (group);\n      g_free (name);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}"", ""target"": 1}, {""func_name"": ""get_from_keyfile"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static GVariant *\nget_from_keyfile (GKeyfileSettingsBackend *kfsb,\n                  const GVariantType      *type,\n                  const gchar             *key)\n{\n  GVariant *return_value = NULL;\n  gchar *group, *name;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      gchar *str;\n\n      g_assert (*name);\n\n      str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);\n\n      if (str)\n        {\n          return_value = g_variant_parse (type, str, NULL, NULL, NULL);\n          g_free (str);\n        }\n\n      g_free (group);\n      g_free (name);\n    }\n\n  return return_value;\n}"", ""target"": 1}, {""func_name"": ""g_keyfile_settings_backend_constructed"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \""glib-2.0\"", \""settings\"", \""keyfile\"",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\""/\"");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \""changed\"",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \""changed\"",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n}"", ""target"": 1}, {""func_name"": ""g_keyfile_settings_backend_class_init"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n  object_class->constructed = g_keyfile_settings_backend_constructed;\n  object_class->get_property = g_keyfile_settings_backend_get_property;\n  object_class->set_property = g_keyfile_settings_backend_set_property;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n\n  /**\n   * GKeyfileSettingsBackend:filename:\n   *\n   * The location where the settings are stored on disk.\n   *\n   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_FILENAME,\n                                   g_param_spec_string (\""filename\"",\n                                                        P_(\""Filename\""),\n                                                        P_(\""The filename\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-path:\n   *\n   * All settings read to or written from the backend must fall under the\n   * path given in @root_path (which must start and end with a slash and\n   * not contain two consecutive slashes).  @root_path may be \""/\"".\n   * \n   * Defaults to \""/\"".\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_PATH,\n                                   g_param_spec_string (\""root-path\"",\n                                                        P_(\""Root path\""),\n                                                        P_(\""The root path\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-group:\n   *\n   * If @root_group is non-%NULL then it specifies the name of the keyfile\n   * group used for keys that are written directly below the root path.\n   *\n   * Defaults to NULL.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_GROUP,\n                                   g_param_spec_string (\""root-group\"",\n                                                        P_(\""Root group\""),\n                                                        P_(\""The root group\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n}"", ""target"": 1}, {""func_name"": ""g_keyfile_settings_backend_set_property"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_set_property (GObject      *object,\n                                         guint         prop_id,\n                                         const GValue *value,\n                                         GParamSpec   *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch (prop_id)\n    {\n    case PROP_FILENAME:\n      /* Construct only. */\n      g_assert (kfsb->file == NULL);\n      kfsb->file = g_file_new_for_path (g_value_get_string (value));\n      break;\n\n    case PROP_ROOT_PATH:\n      /* Construct only. */\n      g_assert (kfsb->prefix == NULL);\n      kfsb->prefix = g_value_dup_string (value);\n      if (kfsb->prefix)\n        kfsb->prefix_len = strlen (kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      /* Construct only. */\n      g_assert (kfsb->root_group == NULL);\n      kfsb->root_group = g_value_dup_string (value);\n      if (kfsb->root_group)\n        kfsb->root_group_len = strlen (kfsb->root_group);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}"", ""target"": 1}]","[{""func_name"": ""g_keyfile_settings_backend_keyfile_write"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *kfsb)\n{\n  gchar *contents;\n  gsize length;\n\n  contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);\n  g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,\n                           G_FILE_CREATE_REPLACE_DESTINATION |\n                           G_FILE_CREATE_PRIVATE,\n                           NULL, NULL, NULL);\n\n  compute_checksum (kfsb->digest, contents, length);\n  g_free (contents);\n}""}, {""func_name"": ""g_keyfile_settings_backend_constructed"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \""glib-2.0\"", \""settings\"", \""keyfile\"",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\""/\"");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \""changed\"",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \""changed\"",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}""}, {""func_name"": ""g_keyfile_settings_backend_check_one"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static gboolean\ng_keyfile_settings_backend_check_one (gpointer key,\n                                      gpointer value,\n                                      gpointer user_data)\n{\n  WriteManyData *data = user_data;\n\n  return data->failed = g_hash_table_contains (data->kfsb->system_locks, key) ||\n                        !path_is_valid (data->kfsb, key);\n}""}, {""func_name"": ""g_keyfile_settings_backend_new"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""GSettingsBackend *\ng_keyfile_settings_backend_new (const gchar *filename,\n                                const gchar *root_path,\n                                const gchar *root_group)\n{\n  g_return_val_if_fail (filename != NULL, NULL);\n  g_return_val_if_fail (root_path != NULL, NULL);\n  g_return_val_if_fail (g_str_has_prefix (root_path, \""/\""), NULL);\n  g_return_val_if_fail (g_str_has_suffix (root_path, \""/\""), NULL);\n  g_return_val_if_fail (strstr (root_path, \""//\"") == NULL, NULL);\n\n  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,\n                                           \""filename\"", filename,\n                                           \""root-path\"", root_path,\n                                           \""root-group\"", root_group,\n                                           NULL));\n}""}, {""func_name"": ""g_keyfile_settings_backend_class_init"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n  object_class->constructed = g_keyfile_settings_backend_constructed;\n  object_class->get_property = g_keyfile_settings_backend_get_property;\n  object_class->set_property = g_keyfile_settings_backend_set_property;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n\n  /**\n   * GKeyfileSettingsBackend:filename:\n   *\n   * The location where the settings are stored on disk.\n   *\n   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_FILENAME,\n                                   g_param_spec_string (\""filename\"",\n                                                        P_(\""Filename\""),\n                                                        P_(\""The filename\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-path:\n   *\n   * All settings read to or written from the backend must fall under the\n   * path given in @root_path (which must start and end with a slash and\n   * not contain two consecutive slashes).  @root_path may be \""/\"".\n   * \n   * Defaults to \""/\"".\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_PATH,\n                                   g_param_spec_string (\""root-path\"",\n                                                        P_(\""Root path\""),\n                                                        P_(\""The root path\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-group:\n   *\n   * If @root_group is non-%NULL then it specifies the name of the keyfile\n   * group used for keys that are written directly below the root path.\n   *\n   * Defaults to NULL.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_GROUP,\n                                   g_param_spec_string (\""root-group\"",\n                                                        P_(\""Root group\""),\n                                                        P_(\""The root group\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n}""}, {""func_name"": ""g_keyfile_settings_backend_get_property"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_get_property (GObject    *object,\n                                         guint       prop_id,\n                                         GValue     *value,\n                                         GParamSpec *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch ((GKeyfileSettingsBackendProperty)prop_id)\n    {\n    case PROP_FILENAME:\n      g_value_set_string (value, g_file_peek_path (kfsb->file));\n      break;\n\n    case PROP_ROOT_PATH:\n      g_value_set_string (value, kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      g_value_set_string (value, kfsb->root_group);\n      break;\n\n    case PROP_DEFAULTS_DIR:\n      g_value_set_string (value, kfsb->defaults_dir);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}""}, {""func_name"": ""g_keyfile_settings_backend_finalize"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_finalize (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  g_key_file_free (kfsb->keyfile);\n  g_object_unref (kfsb->permission);\n  g_key_file_unref (kfsb->system_keyfile);\n  g_hash_table_unref (kfsb->system_locks);\n  g_free (kfsb->defaults_dir);\n\n  g_file_monitor_cancel (kfsb->file_monitor);\n  g_object_unref (kfsb->file_monitor);\n  g_object_unref (kfsb->file);\n\n  g_file_monitor_cancel (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir);\n\n  g_free (kfsb->root_group);\n  g_free (kfsb->prefix);\n\n  G_OBJECT_CLASS (g_keyfile_settings_backend_parent_class)\n    ->finalize (object);\n}""}, {""func_name"": ""g_keyfile_settings_backend_get_writable"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static gboolean\ng_keyfile_settings_backend_get_writable (GSettingsBackend *backend,\n                                         const gchar      *name)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);\n\n  return kfsb->writable &&\n         !g_hash_table_contains (kfsb->system_locks, name) &&\n         path_is_valid (kfsb, name);\n}""}, {""func_name"": ""set_to_keyfile"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static gboolean\nset_to_keyfile (GKeyfileSettingsBackend *kfsb,\n                const gchar             *key,\n                GVariant                *value)\n{\n  gchar *group, *name;\n\n  if (g_hash_table_contains (kfsb->system_locks, key))\n    return FALSE;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      if (value)\n        {\n          gchar *str = g_variant_print (value, FALSE);\n          g_key_file_set_value (kfsb->keyfile, group, name, str);\n          g_variant_unref (g_variant_ref_sink (value));\n          g_free (str);\n        }\n      else\n        {\n          if (*name == '\\0')\n            {\n              gchar **groups;\n              gint i;\n\n              groups = g_key_file_get_groups (kfsb->keyfile, NULL);\n\n              for (i = 0; groups[i]; i++)\n                if (group_name_matches (groups[i], group))\n                  g_key_file_remove_group (kfsb->keyfile, groups[i], NULL);\n\n              g_strfreev (groups);\n            }\n          else\n            g_key_file_remove_key (kfsb->keyfile, group, name, NULL);\n        }\n\n      g_free (group);\n      g_free (name);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}""}, {""func_name"": ""get_from_keyfile"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static GVariant *\nget_from_keyfile (GKeyfileSettingsBackend *kfsb,\n                  const GVariantType      *type,\n                  const gchar             *key)\n{\n  GVariant *return_value = NULL;\n  gchar *group, *name;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      gchar *str;\n      gchar *sysstr;\n\n      g_assert (*name);\n\n      sysstr = g_key_file_get_value (kfsb->system_keyfile, group, name, NULL);\n      str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);\n      if (sysstr &&\n          (g_hash_table_contains (kfsb->system_locks, key) ||\n           str == NULL))\n        {\n          g_free (str);\n          str = g_steal_pointer (&sysstr);\n        }\n\n      if (str)\n        {\n          return_value = g_variant_parse (type, str, NULL, NULL, NULL);\n          g_free (str);\n        }\n\n      g_free (sysstr);\n\n      g_free (group);\n      g_free (name);\n    }\n\n  return return_value;\n}""}, {""func_name"": ""g_keyfile_settings_backend_constructed"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \""glib-2.0\"", \""settings\"", \""keyfile\"",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\""/\"");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \""changed\"",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \""changed\"",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}""}, {""func_name"": ""g_keyfile_settings_backend_class_init"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n  object_class->constructed = g_keyfile_settings_backend_constructed;\n  object_class->get_property = g_keyfile_settings_backend_get_property;\n  object_class->set_property = g_keyfile_settings_backend_set_property;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n\n  /**\n   * GKeyfileSettingsBackend:filename:\n   *\n   * The location where the settings are stored on disk.\n   *\n   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_FILENAME,\n                                   g_param_spec_string (\""filename\"",\n                                                        P_(\""Filename\""),\n                                                        P_(\""The filename\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-path:\n   *\n   * All settings read to or written from the backend must fall under the\n   * path given in @root_path (which must start and end with a slash and\n   * not contain two consecutive slashes).  @root_path may be \""/\"".\n   * \n   * Defaults to \""/\"".\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_PATH,\n                                   g_param_spec_string (\""root-path\"",\n                                                        P_(\""Root path\""),\n                                                        P_(\""The root path\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-group:\n   *\n   * If @root_group is non-%NULL then it specifies the name of the keyfile\n   * group used for keys that are written directly below the root path.\n   *\n   * Defaults to NULL.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_GROUP,\n                                   g_param_spec_string (\""root-group\"",\n                                                        P_(\""Root group\""),\n                                                        P_(\""The root group\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:default-dir:\n   *\n   * The directory where the system defaults and locks are located.\n   *\n   * Defaults to `/etc/glib-2.0/settings`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_DEFAULTS_DIR,\n                                   g_param_spec_string (\""defaults-dir\"",\n                                                        P_(\""Default dir\""),\n                                                        P_(\""Defaults dir\""),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n}""}, {""func_name"": ""g_keyfile_settings_backend_set_property"", ""file_path"": ""gio/gkeyfilesettingsbackend.c"", ""func_code"": ""static void\ng_keyfile_settings_backend_set_property (GObject      *object,\n                                         guint         prop_id,\n                                         const GValue *value,\n                                         GParamSpec   *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch ((GKeyfileSettingsBackendProperty)prop_id)\n    {\n    case PROP_FILENAME:\n      /* Construct only. */\n      g_assert (kfsb->file == NULL);\n      kfsb->file = g_file_new_for_path (g_value_get_string (value));\n      break;\n\n    case PROP_ROOT_PATH:\n      /* Construct only. */\n      g_assert (kfsb->prefix == NULL);\n      kfsb->prefix = g_value_dup_string (value);\n      if (kfsb->prefix)\n        kfsb->prefix_len = strlen (kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      /* Construct only. */\n      g_assert (kfsb->root_group == NULL);\n      kfsb->root_group = g_value_dup_string (value);\n      if (kfsb->root_group)\n        kfsb->root_group_len = strlen (kfsb->root_group);\n      break;\n\n    case PROP_DEFAULTS_DIR:\n      /* Construct only. */\n      g_assert (kfsb->defaults_dir == NULL);\n      kfsb->defaults_dir = g_value_dup_string (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}""}]",{},[],Original code used g_file_make_directory_with_parents (default 0777) and g_file_replace_contents (default file permissions). Patch replaces with g_mkdir_with_parents(0700) and G_FILE_CREATE_PRIVATE flag. No external dependencies required for this analysis.,0.95,./github/other_context/CVE-2019-13012
10,CVE-2019-19270,"CWE-476, CWE-295",c_cpp,"An issue was discovered in tls_verify_crl in ProFTPD through 1.3.6b. Failure to check for the appropriate field of a CRL entry (checking twice for subject, rather than once for subject and once for issuer) prevents some valid CRLs from being taken into account, and can allow clients whose certificates have been revoked to proceed with a connection to the server.",https://github.com/proftpd/proftpd/commit/81cc5dce4fc0285629a1b08a07a109af10c208dd,"Issue #859, #861: Fix handling of CRL lookups by properly using issuer for\nlookups, and guarding against null pointers.",1,"[{""func_name"": ""tls_verify_crl"", ""file_path"": ""contrib/mod_tls.c"", ""func_code"": ""static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\""%s\"",\n    \""CRL store present, checking client certificate against configured CRLs\"");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: subject = '%s'\"", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: issuer = '%s'\"", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\""error initializing CRL store context: %s\"", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \""CA CRL: Issuer: \"");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \"", lastUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \"", nextUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\""%s\"", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\""invalid signature on CRL: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\""CRL has invalid nextUpdate field: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\""%s\"", \""CRL is expired, revoking all certificates until an \""\n          \""updated CRL is obtained\"");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\""certificate with serial number %ld (0x%lX) revoked per CRL \""\n            \""from issuer '%s'\"", serial, serial, cp ? cp : \""(ERROR)\"");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}"", ""target"": 0}]","[{""func_name"": ""tls_verify_crl"", ""file_path"": ""contrib/mod_tls.c"", ""func_code"": ""static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\""%s\"",\n    \""CRL store present, checking client certificate against configured CRLs\"");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: subject = '%s'\"", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: issuer = '%s'\"", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\""error initializing CRL store context: %s\"", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \""CA CRL: Issuer: \"");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \"", lastUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \"", nextUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\""%s\"", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\""invalid signature on CRL: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\""CRL has invalid nextUpdate field: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\""%s\"", \""CRL is expired, revoking all certificates until an \""\n          \""updated CRL is obtained\"");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, issuer);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, issuer);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n        if (revoked == NULL) {\n          continue;\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\""certificate with serial number %ld (0x%lX) revoked per CRL \""\n            \""from issuer '%s'\"", serial, serial, cp ? cp : \""(ERROR)\"");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}""}]","{""value"": 2, ""caller"": 1}","[{""source"": ""value_info(file:mod_tls.c, value:subject)"", ""result"": {""value_trace"": [{""full_code"": ""*subject = NULL"", ""line"": 9607, ""func_name"": ""tls_verify_crl""}, {""full_code"": ""subject = X509_get_subject_name(xs)"", ""line"": 9626, ""func_name"": ""tls_verify_crl""}], ""struct_var"": ""subject"", ""struct_type"": ""X509_NAME*"", ""struct_definition"": null}}, {""source"": ""value_info(file:mod_tls.c, value:issuer)"", ""result"": {""value_trace"": [{""full_code"": ""*issuer = NULL"", ""line"": 9607, ""func_name"": ""tls_verify_crl""}, {""full_code"": ""issuer = X509_get_issuer_name(xs)"", ""line"": 9630, ""func_name"": ""tls_verify_crl""}], ""struct_var"": ""issuer"", ""struct_type"": ""X509_NAME*"", ""struct_definition"": null}}, {""source"": ""caller_info(file:mod_tls.c, func:tls_verify_crl)"", ""result"": [{""call_line"": 9500, ""call_code"": ""tls_verify_crl(ok, ctx)"", ""caller_code"": ""static int tls_verify_cb(int ok, X509_STORE_CTX *ctx) {\n  config_rec *c;\n  int verify_err = 0;\n\n  /* We can configure the server to skip the peer's cert verification */\n  if (!(tls_flags & TLS_SESS_VERIFY_CLIENT_REQUIRED) &&\n      !(tls_flags & TLS_SESS_VERIFY_CLIENT_OPTIONAL)) {\n    return 1;\n  }\n\n  c = find_config(main_server->conf, CONF_PARAM, \""TLSVerifyOrder\"", FALSE);\n  if (c) {\n    register unsigned int i;\n\n    for (i = 0; i < c->argc; i++) {\n      char *mech = c->argv[i];\n\n      if (strncasecmp(mech, \""crl\"", 4) == 0) {\n        ok = tls_verify_crl(ok, ctx);\n        if (!ok) {\n          break;\n        }\n\n      } else if (strncasecmp(mech, \""ocsp\"", 5) == 0) {\n        ok = tls_verify_ocsp(ok, ctx);\n        if (!ok) {\n          break;\n        }\n      }\n    }\n\n  } else {\n    /* If no TLSVerifyOrder was specified, default to the old behavior of\n     * always checking CRLs, if configured, and not paying attention to\n     * any AIA attributes (i.e. no use of OCSP).\n     */\n    ok = tls_v..."", ""caller_start"": 9482, ""file_path"": ""contrib/mod_tls.c""}, {""call_line"": 9518, ""call_code"": ""tls_verify_crl(ok, ctx)"", ""caller_code"": ""static int tls_verify_cb(int ok, X509_STORE_CTX *ctx) {\n  config_rec *c;\n  int verify_err = 0;\n\n  /* We can configure the server to skip the peer's cert verification */\n  if (!(tls_flags & TLS_SESS_VERIFY_CLIENT_REQUIRED) &&\n      !(tls_flags & TLS_SESS_VERIFY_CLIENT_OPTIONAL)) {\n    return 1;\n  }\n\n  c = find_config(main_server->conf, CONF_PARAM, \""TLSVerifyOrder\"", FALSE);\n  if (c) {\n    register unsigned int i;\n\n    for (i = 0; i < c->argc; i++) {\n      char *mech = c->argv[i];\n\n      if (strncasecmp(mech, \""crl\"", 4) == 0) {\n        ok = tls_verify_crl(ok, ctx);\n        if (!ok) {\n          break;\n        }\n\n      } else if (strncasecmp(mech, \""ocsp\"", 5) == 0) {\n        ok = tls_verify_ocsp(ok, ctx);\n        if (!ok) {\n          break;\n        }\n      }\n    }\n\n  } else {\n    /* If no TLSVerifyOrder was specified, default to the old behavior of\n     * always checking CRLs, if configured, and not paying attention to\n     * any AIA attributes (i.e. no use of OCSP).\n     */\n    ok = tls_v..."", ""caller_start"": 9482, ""file_path"": ""contrib/mod_tls.c""}]}]","In contrib/mod_tls.c:tls_verify_crl(), the code incorrectly used 'subject = X509_get_subject_name(xs)' (line 9626) instead of 'issuer = X509_get_issuer_name(xs)' (line 9630) when calling X509_STORE_*_get1_crls (lines 9778-9779). This caused CRL lookups to filter by the certificate's subject name rather than its issuer name, ignoring valid CRLs issued by the correct CA. The patch replaces 'subject' with 'issuer' in the CRL lookup, ensuring revoked certificates are properly checked.",0.95,./github/other_context/CVE-2019-19270
11,CVE-2014-2062,CWE-287,java,"Jenkins before 1.551 and LTS before 1.532.2 does not invalidate the API token when a user is deleted, which allows remote authenticated users to retain access via the token.",https://github.com/jenkinsci/jenkins/commit/5548b5220cfd496831b5721124189ff18fbb12a3,"[FIXED SECURITY-89] When checking an API token, verify that the user actually exists.",1,"[{""func_name"": ""doFilter"", ""file_path"": ""core/src/main/java/jenkins/security/ApiTokenFilter.java"", ""func_code"": ""public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\""Authorization\"");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }"", ""target"": 0}]","[{""func_name"": ""doFilter"", ""file_path"": ""core/src/main/java/jenkins/security/ApiTokenFilter.java"", ""func_code"": ""public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\""Authorization\"");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                try {\n                    Jenkins.getInstance().getSecurityRealm().loadUserByUsername(username);\n                } catch (UserMayOrMayNotExistException x) {\n                    // OK, give them the benefit of the doubt.\n                } catch (UsernameNotFoundException x) {\n                    // Not/no longer a user; deny the API token. (But do not leak the information that this happened.)\n                    chain.doFilter(request, response);\n                    return;\n                } catch (DataAccessException x) {\n                    throw new ServletException(x);\n                }\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }""}]","{""function"": 1}","[{""source"": ""func_info(func:loadUserByUsername)"", ""result"": [{""code"": ""    @Override\n    public abstract UserDetails loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException;\n"", ""start_line"": 119, ""end_line"": 120, ""full_name"": ""hudson.security.AbstractPasswordBasedSecurityRealm.loadUserByUsername:org.acegisecurity.userdetails.UserDetails(java.lang.String)"", ""file_path"": ""core/src/main/java/hudson/security/AbstractPasswordBasedSecurityRealm.java""}, {""code"": ""    @Override\n    public Details loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {\n        User u = User.get(username,false);\n        Details p = u!=null ? u.getProperty(Details.class) : null;\n        if(p==null)\n            throw new UsernameNotFoundException(\""Password is not set: \""+username);\n        if(p.getUser()==null)\n            throw new AssertionError();\n        return p;\n    }\n"", ""start_line"": 164, ""end_line"": 173, ""full_name"": ""hudson.security.HudsonPrivateSecurityRealm.loadUserByUsername:hudson.security.HudsonPrivateSecurityRealm$Details(java.lang.String)"", ""file_path"": ""core/src/main/java/hudson/security/HudsonPrivateSecurityRealm.java""}, {""code"": ""    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {\n        return getSecurityComponents().userDetails.loadUserByUsername(username);\n    }\n"", ""start_line"": 304, ""end_line"": 306, ""full_name"": ""hudson.security.SecurityRealm.loadUserByUsername:org.acegisecurity.userdetails.UserDetails(java.lang.String)"", ""file_path"": ""core/src/main/java/hudson/security/SecurityRealm.java""}]}]","Root Cause Chain: 1. ApiTokenFilter.doFilter (core/src/main/java/jenkins/security/ApiTokenFilter.java:96-107) calls Jenkins.getInstance().getSecurityRealm().loadUserByUsername(username) to verify user existence. 2. SecurityRealm.loadUserByUsername (core/src/main/java/hudson/security/SecurityRealm.java:304-306) delegates to getSecurityComponents().userDetails.loadUserByUsername. 3. HudsonPrivateSecurityRealm.loadUserByUsername (core/src/main/java/hudson/security/HudsonPrivateSecurityRealm.java:164-173) calls User.get(username, false) to check if the user exists. 4. If the user was deleted, User.get returns null, causing a UsernameNotFoundException, which is caught in ApiTokenFilter.doFilter to deny access. Trigger: Missing user existence check allowed tokens for deleted users; patch adds verification via loadUserByUsername.",0.95,./github/other_context/CVE-2014-2062
12,CVE-2017-5207,CWE-269,c_cpp,"Firejail before 0.9.44.4, when running a bandwidth command, allows local users to gain root privileges via the --shell argument.",https://github.com/netblue30/firejail/commit/5d43fdcd215203868d440ffc42036f5f5ffc89fc,security fix,1,"[{""func_name"": ""bandwidth_pid"", ""file_path"": ""src/firejail/bandwidth.c"", ""func_code"": ""void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {\n\tEUID_ASSERT();\n\t//************************\n\t// verify sandbox\n\t//************************\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (!comm) {\n\t\tfprintf(stderr, \""Error: cannot find sandbox\\n\"");\n\t\texit(1);\n\t}\n\n\t// check for firejail sandbox\n\tif (strcmp(comm, \""firejail\"") != 0) {\n\t\tfprintf(stderr, \""Error: cannot find sandbox\\n\"");\n\t\texit(1);\n\t}\n\tfree(comm);\n\t\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \""/run/firejail/network/%d-netmap\"", pid) == -1)\n\t\terrExit(\""asprintf\"");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \""Error: the sandbox doesn't use a new network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\t//************************\n\t// join the network namespace\n\t//************************\n\tpid_t child;\n\tif (find_child(pid, &child) == -1) {\n\t\tfprintf(stderr, \""Error: cannot join the network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (join_namespace(child, \""net\"")) {\n\t\tfprintf(stderr, \""Error: cannot join the network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\t// set run file\n\tif (strcmp(command, \""set\"") == 0)\n\t\tbandwidth_set(pid, dev, down, up);\n\telse if (strcmp(command, \""clear\"") == 0)\n\t\tbandwidth_remove(pid, dev);\n\n\t//************************\n\t// build command\n\t//************************\n\tchar *devname = NULL;\n\tif (dev) {\n\t\t// read network map file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \""%s/%d-netmap\"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\t\terrExit(\""asprintf\"");\n\t\tFILE *fp = fopen(fname, \""r\"");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \""Error: cannot read network map file %s\\n\"", fname);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tchar buf[1024];\n\t\tint len = strlen(dev);\n\t\twhile (fgets(buf, 1024, fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strncmp(buf, dev, len) == 0  && buf[len] == ':') {\n\t\t\t\tdevname = strdup(buf + len + 1);\n\t\t\t\tif (!devname)\n\t\t\t\t\terrExit(\""strdup\"");\n\t\t\t\t// check device in namespace\n\t\t\t\tif (if_nametoindex(devname) == 0) {\n\t\t\t\t\tfprintf(stderr, \""Error: cannot find network device %s\\n\"", devname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(fname);\n\t\tfclose(fp);\n\t}\n\t\n\t// build fshaper.sh command\n\tchar *cmd = NULL;\n\tif (devname) {\n\t\tif (strcmp(command, \""set\"") == 0) {\n\t\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s %s %d %d\"",\n\t\t\t\tLIBDIR, command, devname, down, up) == -1)\n\t\t\t\terrExit(\""asprintf\"");\n\t\t}\n\t\telse {\n\t\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s %s\"",\n\t\t\t\tLIBDIR, command, devname) == -1)\n\t\t\t\terrExit(\""asprintf\"");\n\t\t}\n\t}\n\telse {\n\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s\"", LIBDIR, command) == -1)\n\t\t\terrExit(\""asprintf\"");\n\t}\n\tassert(cmd);\n\n\t// wipe out environment variables\n\tenviron = NULL;\n\n\t//************************\n\t// build command\n\t//************************\n\t// elevate privileges\n\tif (setreuid(0, 0))\n\t\terrExit(\""setreuid\"");\n\tif (setregid(0, 0))\n\t\terrExit(\""setregid\"");\n\n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (!cfg.shell) {\n\t\tfprintf(stderr, \""Error: no POSIX shell found, please use --shell command line option\\n\"");\n\t\texit(1);\n\t}\n\n\tchar *arg[4];\n\targ[0] = cfg.shell;\n\targ[1] = \""-c\"";\n\targ[2] = cmd;\n\targ[3] = NULL;\n\tclearenv();\n\texecvp(arg[0], arg);\n\t\n\t// it will never get here\n\terrExit(\""execvp\"");\n}"", ""target"": 0}]","[{""func_name"": ""bandwidth_pid"", ""file_path"": ""src/firejail/bandwidth.c"", ""func_code"": ""void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {\n\tEUID_ASSERT();\n\t//************************\n\t// verify sandbox\n\t//************************\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (!comm) {\n\t\tfprintf(stderr, \""Error: cannot find sandbox\\n\"");\n\t\texit(1);\n\t}\n\n\t// check for firejail sandbox\n\tif (strcmp(comm, \""firejail\"") != 0) {\n\t\tfprintf(stderr, \""Error: cannot find sandbox\\n\"");\n\t\texit(1);\n\t}\n\tfree(comm);\n\t\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \""/run/firejail/network/%d-netmap\"", pid) == -1)\n\t\terrExit(\""asprintf\"");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \""Error: the sandbox doesn't use a new network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\t//************************\n\t// join the network namespace\n\t//************************\n\tpid_t child;\n\tif (find_child(pid, &child) == -1) {\n\t\tfprintf(stderr, \""Error: cannot join the network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (join_namespace(child, \""net\"")) {\n\t\tfprintf(stderr, \""Error: cannot join the network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\t// set run file\n\tif (strcmp(command, \""set\"") == 0)\n\t\tbandwidth_set(pid, dev, down, up);\n\telse if (strcmp(command, \""clear\"") == 0)\n\t\tbandwidth_remove(pid, dev);\n\n\t//************************\n\t// build command\n\t//************************\n\tchar *devname = NULL;\n\tif (dev) {\n\t\t// read network map file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \""%s/%d-netmap\"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\t\terrExit(\""asprintf\"");\n\t\tFILE *fp = fopen(fname, \""r\"");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \""Error: cannot read network map file %s\\n\"", fname);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tchar buf[1024];\n\t\tint len = strlen(dev);\n\t\twhile (fgets(buf, 1024, fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strncmp(buf, dev, len) == 0  && buf[len] == ':') {\n\t\t\t\tdevname = strdup(buf + len + 1);\n\t\t\t\tif (!devname)\n\t\t\t\t\terrExit(\""strdup\"");\n\t\t\t\t// check device in namespace\n\t\t\t\tif (if_nametoindex(devname) == 0) {\n\t\t\t\t\tfprintf(stderr, \""Error: cannot find network device %s\\n\"", devname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(fname);\n\t\tfclose(fp);\n\t}\n\t\n\t// build fshaper.sh command\n\tchar *cmd = NULL;\n\tif (devname) {\n\t\tif (strcmp(command, \""set\"") == 0) {\n\t\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s %s %d %d\"",\n\t\t\t\tLIBDIR, command, devname, down, up) == -1)\n\t\t\t\terrExit(\""asprintf\"");\n\t\t}\n\t\telse {\n\t\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s %s\"",\n\t\t\t\tLIBDIR, command, devname) == -1)\n\t\t\t\terrExit(\""asprintf\"");\n\t\t}\n\t}\n\telse {\n\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s\"", LIBDIR, command) == -1)\n\t\t\terrExit(\""asprintf\"");\n\t}\n\tassert(cmd);\n\n\t// wipe out environment variables\n\tenviron = NULL;\n\n\t//************************\n\t// build command\n\t//************************\n\t// elevate privileges\n\tif (setreuid(0, 0))\n\t\terrExit(\""setreuid\"");\n\tif (setregid(0, 0))\n\t\terrExit(\""setregid\"");\n\n\tchar *arg[4];\n\targ[0] = \""/bin/sh\"";\n\targ[1] = \""-c\"";\n\targ[2] = cmd;\n\targ[3] = NULL;\n\tclearenv();\n\texecvp(arg[0], arg);\n\t\n\t// it will never get here\n\terrExit(\""execvp\"");\n}""}]","{""code"": 4, ""function"": 1, ""value"": 1}","[{""source"": ""code_info(file:bandwidth.c, lines:1-435)"", ""result"": ""/*\n * Copyright (C) 2014-2016 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <net/if.h>\n#include \""firejail.h\""\n\n//***********************************\n// interface bandwidth linked list\n//***********************************\ntypedef struct ifbw_t {\n\tstruct ifbw_t *next;\n\tchar *txt;\n} IFBW;\nIFBW *ifbw = NULL;\n\n\n#if 0\nstatic void ifbw_print(void) {\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tprintf(\""#%s#\\n\"", ptr->txt);\n\t\tptr = ptr->next;\n\t}\n}\n#endif\n\nstatic void ifbw_add(IFBW *ptr) {\n\tassert(ptr);\n\n\tif (ifbw != NULL)\n\t\tptr->next = ifbw;\n\tifbw = ptr;\n}\n\n\nIFBW *ifbw_find(const char *dev) {\n\tassert(dev);\n\tint len = strlen(dev);\n\tassert(len);\n\t\n\tif (ifbw == NULL)\n\t\treturn NULL;\n\t\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tif (strncmp(ptr->txt, dev, len) == 0 && ptr->txt[len] == ':')\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn NULL;\n}\n\nvoid ifbw_remove(IFBW *r) {\n\tif (ifbw == NULL)\n\t\treturn;\n\t\n\t// remove the first element\n\tif (ifbw == r) {\n\t\tifbw = ifbw->next;\n\t\treturn;\n\t}\n\t\n\t// walk the list\n\tIFBW *ptr = ifbw->next;\n\tIFBW *prev = ifbw;\n\twhile (ptr) {\n\t\tif (ptr == r) {\n\t\t\tprev->next = ptr->next;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tprev = ptr;\n\t\tptr = ptr->next;\n\t}\t\n\t\n\treturn;\n}\n\nint fibw_count(void) {\n\tint rv = 0;\n\tIFBW *ptr = ifbw;\n\n\twhile (ptr) {\n\t\trv++;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn rv;\n}\n\t\n\n//***********************************\n// run file handling\n//***********************************\nstatic void bandwidth_create_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \""%s/%d-bandwidth\"", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\""asprintf\"");\n\t\n\t// if the file already exists, do nothing\n\tstruct stat s;\n\tif (stat(fname, &s) == 0) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// create an empty file and set mod and ownership\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \""w\"");\n\tif (fp) {\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \""Error: cannot create bandwidth file\\n\"");\n\t\texit(1);\n\t}\n\t\n\tfree(fname);\n}\n\n// delete bandwidth file\nvoid bandwidth_del_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \""%s/%d-bandwidth\"", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\""asprintf\"");\n\tunlink(fname);\n\tfree(fname);\n}\n\nvoid network_del_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \""%s/%d-netmap\"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\terrExit(\""asprintf\"");\n\tunlink(fname);\n\tfree(fname);\n}\n\nvoid network_set_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \""%s/%d-netmap\"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\terrExit(\""asprintf\"");\n\t\n\t// create an empty file and set mod and ownership\n\tFILE *fp = fopen(fname, \""w\"");\n\tif (fp) {\n\t\tif (cfg.bridge0.configured)\n\t\t\tfprintf(fp, \""%s:%s\\n\"", cfg.bridge0.dev, cfg.bridge0.devsandbox);\n\t\tif (cfg.bridge1.configured)\n\t\t\tfprintf(fp, \""%s:%s\\n\"", cfg.bridge1.dev, cfg.bridge1.devsandbox);\n\t\tif (cfg.bridge2.configured)\n\t\t\tfprintf(fp, \""%s:%s\\n\"", cfg.bridge2.dev, cfg.bridge2.devsandbox);\n\t\tif (cfg.bridge3.configured)\n\t\t\tfprintf(fp, \""%s:%s\\n\"", cfg.bridge3.dev, cfg.bridge3.devsandbox);\n\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \""Error: cannot create network map file\\n\"");\n\t\texit(1);\n\t}\n\t\n\tfree(fname);\n}\n\n\nstatic void read_bandwidth_file(pid_t pid) {\n\tassert(ifbw == NULL);\n\n\tchar *fname;\n\tif (asprintf(&fname, \""%s/%d-bandwidth\"", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\""asprintf\"");\n\n\tFILE *fp = fopen(fname, \""r\"");\n\tif (fp) {\n\t\tchar buf[1024];\n\t\twhile (fgets(buf, 1024,fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (strlen(buf) == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// create a new IFBW entry\n\t\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\t\tif (!ifbw_new)\n\t\t\t\terrExit(\""malloc\"");\n\t\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\t\tifbw_new->txt = strdup(buf);\n\t\t\tif (!ifbw_new->txt)\n\t\t\t\terrExit(\""strdup\"");\n\t\t\t\n\t\t\t// add it to the linked list\n\t\t\tifbw_add(ifbw_new);\n\t\t}\t\n\t\t\n\t\tfclose(fp);\t\t\n\t}\n}\n\nstatic void write_bandwidth_file(pid_t pid) {\n\tif (ifbw == NULL)\n\t\treturn; // nothing to do\n\n\tchar *fname;\n\tif (asprintf(&fname, \""%s/%d-bandwidth\"", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\""asprintf\"");\n\n\tFILE *fp = fopen(fname, \""w\"");\n\tif (fp) {\n\t\tIFBW *ptr = ifbw;\n\t\twhile (ptr) {\n\t\t\tif (fprintf(fp, \""%s\\n\"", ptr->txt) < 0)\n\t\t\t\tgoto errout;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tgoto errout;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \""Error: cannot write bandwidth file %s\\n\"", fname);\n\texit(1);\n}\n\n//***********************************\n// add or remove interfaces\n//***********************************\n\n// remove interface from run file\nvoid bandwidth_remove(pid_t pid, const char *dev) {\n\tbandwidth_create_run_file(pid);\n\t\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\t\n\t// find the element and remove it\n\tIFBW *elem = ifbw_find(dev);\n\tif (elem) {\n\t\tifbw_remove(elem);\n\t\twrite_bandwidth_file(pid) ;\n\t}\n\t\n\t// remove the file if there are no entries in the list\n\tif (ifbw == NULL) {\n\t\t bandwidth_del_run_file(pid);\n\t}\n}\n\n// add interface to run file\nvoid bandwidth_set(pid_t pid, const char *dev, int down, int up) {\n\t// create bandwidth directory & file in case they are not in the filesystem yet\n\tbandwidth_create_run_file(pid);\n\n\t// create the new text entry\n\tchar *txt;\n\tif (asprintf(&txt, \""%s: RX %dKB/s, TX %dKB/s\"", dev, down, up) == -1)\n\t\terrExit(\""asprintf\"");\n\t\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// look for an existing entry and replace the text\n\tIFBW *ptr = ifbw_find(dev);\n\tif (ptr) {\n\t\tassert(ptr->txt);\n\t\tfree(ptr->txt);\n\t\tptr->txt = txt;\n\t}\n\t// ... or add a new entry\n\telse {\n\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\tif (!ifbw_new)\n\t\t\terrExit(\""malloc\"");\n\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\tifbw_new->txt = txt;\n\t\t\n\t\t// add it to the linked list\n\t\tifbw_add(ifbw_new);\n\t}\n\twrite_bandwidth_file(pid) ;\n}\n\n\n//***********************************\n// command execution\n//***********************************\nvoid bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {\n\tEUID_ASSERT();\n\t//************************\n\t// verify sandbox\n\t//************************\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (!comm) {\n\t\tfprintf(stderr, \""Error: cannot find sandbox\\n\"");\n\t\texit(1);\n\t}\n\n\t// check for firejail sandbox\n\tif (strcmp(comm, \""firejail\"") != 0) {\n\t\tfprintf(stderr, \""Error: cannot find sandbox\\n\"");\n\t\texit(1);\n\t}\n\tfree(comm);\n\t\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \""/run/firejail/network/%d-netmap\"", pid) == -1)\n\t\terrExit(\""asprintf\"");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \""Error: the sandbox doesn't use a new network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\t//************************\n\t// join the network namespace\n\t//************************\n\tpid_t child;\n\tif (find_child(pid, &child) == -1) {\n\t\tfprintf(stderr, \""Error: cannot join the network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (join_namespace(child, \""net\"")) {\n\t\tfprintf(stderr, \""Error: cannot join the network namespace\\n\"");\n\t\texit(1);\n\t}\n\n\t// set run file\n\tif (strcmp(command, \""set\"") == 0)\n\t\tbandwidth_set(pid, dev, down, up);\n\telse if (strcmp(command, \""clear\"") == 0)\n\t\tbandwidth_remove(pid, dev);\n\n\t//************************\n\t// build command\n\t//************************\n\tchar *devname = NULL;\n\tif (dev) {\n\t\t// read network map file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \""%s/%d-netmap\"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\t\terrExit(\""asprintf\"");\n\t\tFILE *fp = fopen(fname, \""r\"");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \""Error: cannot read network map file %s\\n\"", fname);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tchar buf[1024];\n\t\tint len = strlen(dev);\n\t\twhile (fgets(buf, 1024, fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strncmp(buf, dev, len) == 0  && buf[len] == ':') {\n\t\t\t\tdevname = strdup(buf + len + 1);\n\t\t\t\tif (!devname)\n\t\t\t\t\terrExit(\""strdup\"");\n\t\t\t\t// check device in namespace\n\t\t\t\tif (if_nametoindex(devname) == 0) {\n\t\t\t\t\tfprintf(stderr, \""Error: cannot find network device %s\\n\"", devname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(fname);\n\t\tfclose(fp);\n\t}\n\t\n\t// build fshaper.sh command\n\tchar *cmd = NULL;\n\tif (devname) {\n\t\tif (strcmp(command, \""set\"") == 0) {\n\t\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s %s %d %d\"",\n\t\t\t\tLIBDIR, command, devname, down, up) == -1)\n\t\t\t\terrExit(\""asprintf\"");\n\t\t}\n\t\telse {\n\t\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s %s\"",\n\t\t\t\tLIBDIR, command, devname) == -1)\n\t\t\t\terrExit(\""asprintf\"");\n\t\t}\n\t}\n\telse {\n\t\tif (asprintf(&cmd, \""%s/firejail/fshaper.sh --%s\"", LIBDIR, command) == -1)\n\t\t\terrExit(\""asprintf\"");\n\t}\n\tassert(cmd);\n\n\t// wipe out environment variables\n\tenviron = NULL;\n\n\t//************************\n\t// build command\n\t//************************\n\t// elevate privileges\n\tif (setreuid(0, 0))\n\t\terrExit(\""setreuid\"");\n\tif (setregid(0, 0))\n\t\terrExit(\""setregid\"");\n""}, {""source"": ""func_info(func:guess_shell)"", ""result"": [{""code"": ""char *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\""SHELL\"");\n\tif (shell) {\n\t\t// TODO: handle rogue shell variables?\n\t\tif (stat(shell, &s) == 0 && access(shell, R_OK) == 0) {\n\t\t\treturn shell;\n\t\t}\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\""/bin/bash\"", \""/bin/csh\"", \""/usr/bin/zsh\"", \""/bin/sh\"", \""/bin/ash\"", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], R_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"", ""start_line"": 756, ""end_line"": 782, ""full_name"": ""guess_shell"", ""file_path"": ""src/firejail/main.c""}]}, {""source"": ""value_info(file:config.h, value:cfg.shell)"", ""result"": {""value_trace"": [{""full_code"": ""cfg.shell = guess_shell()"", ""line"": 439, ""func_name"": ""bandwidth_pid""}, {""full_code"": ""cfg.shell = guess_shell()"", ""line"": 127, ""func_name"": ""env_defaults""}, {""full_code"": ""cfg.shell = guess_shell()"", ""line"": 619, ""func_name"": ""run_cmd_and_exit""}, {""full_code"": ""cfg.shell = guess_shell()"", ""line"": 684, ""func_name"": ""run_cmd_and_exit""}, {""full_code"": ""cfg.shell = \""/bin/csh\"""", ""line"": 2041, ""func_name"": ""main<duplicate>2""}], ""struct_var"": ""cfg"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:main.c, lines:2000-2060)"", ""result"": ""\t\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t\t}\n\t\t\telse\n\t\t\t\texit_err_feature(\""networking\"");\n\t\t}\n#endif\n\t\t//*************************************\n\t\t// command\n\t\t//*************************************\n\t\telse if (strcmp(argv[i], \""--audit\"") == 0) {\n\t\t\targ_audit_prog = LIBDIR \""/firejail/faudit\"";\n\t\t\targ_audit = 1;\n\t\t}\n\t\telse if (strncmp(argv[i], \""--audit=\"", 8) == 0) {\n\t\t\tif (strlen(argv[i] + 8) == 0) {\n\t\t\t\tfprintf(stderr, \""Error: invalid audit program\\n\"");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_audit_prog = strdup(argv[i] + 8);\n\t\t\tif (!arg_audit_prog)\n\t\t\t\terrExit(\""strdup\"");\n\n\t\t\tstruct stat s;\n\t\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\t\tfprintf(stderr, \""Error: cannot find the audit program %s\\n\"", arg_audit_prog);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_audit = 1;\n\t\t}\n\t\telse if (strcmp(argv[i], \""--appimage\"") == 0)\n\t\t\targ_appimage = 1;\n\t\telse if (strcmp(argv[i], \""--csh\"") == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\n\t\t\t\tfprintf(stderr, \""Error: --shell=none was already specified.\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \""Error: only one default user shell can be specified\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcfg.shell = \""/bin/csh\"";\n\t\t}\n\t\telse if (strcmp(argv[i], \""--zsh\"") == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \""Error: --shell=none was already specified.\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \""Error: only one default user shell can be specified\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcfg.shell = \""/bin/zsh\"";\n\t\t}\n\t\telse if (strcmp(argv[i], \""--shell=none\"") == 0) {\n\t\t\targ_shell_none = 1;\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \""Error: a shell was already specified\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(argv[i], \""--shell=\"", 8) == 0) {\n""}, {""source"": ""code_info(file:main.c, lines:2060-2080)"", ""result"": ""\t\t}\n\t\telse if (strncmp(argv[i], \""--shell=\"", 8) == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \""Error: --shell=none was already specified.\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tinvalid_filename(argv[i] + 8);\n\t\t\t\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \""Error: only one user shell can be specified\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcfg.shell = argv[i] + 8;\n\n\t\t\tif (is_dir(cfg.shell) || strstr(cfg.shell, \""..\"")) {\n\t\t\t\tfprintf(stderr, \""Error: invalid shell\\n\"");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\t\tif(cfg.chrootdir) {\n\t\t\t\tchar *shellpath;\n""}, {""source"": ""code_info(file:main.c, lines:2080-2100)"", ""result"": ""\t\t\tif(cfg.chrootdir) {\n\t\t\t\tchar *shellpath;\n\t\t\t\tif (asprintf(&shellpath, \""%s%s\"", cfg.chrootdir, cfg.shell) == -1)\n\t\t\t\t\terrExit(\""asprintf\"");\n\t\t\t\tif (access(shellpath, R_OK)) {\n\t\t\t\t\tfprintf(stderr, \""Error: cannot access shell file in chroot\\n\"");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tfree(shellpath);\n\t\t\t} else if (access(cfg.shell, R_OK)) {\n\t\t\t\tfprintf(stderr, \""Error: cannot access shell file\\n\"");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(argv[i], \""-c\"") == 0) {\n\t\t\targ_command = 1;\n\t\t\tif (i == (argc -  1)) {\n\t\t\t\tfprintf(stderr, \""Error: option -c requires an argument\\n\"");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t\n""}]","src/firejail/bandwidth.c:436-445: Dynamic use of `cfg.shell` (set via `guess_shell()` in `main.c:756-782` or user-provided `--shell` CLI argument in `main.c:2060-2080`) allowed arbitrary shell execution with root privileges in `bandwidth_pid`. The `--shell` argument directly assigns user input to `cfg.shell` after minimal validation, enabling privilege escalation when `bandwidth_pid` elevates privileges via `setreuid(0, 0)` and `setregid(0, 0)` to execute the shell.",0.95,./github/other_context/CVE-2017-5207
13,CVE-2019-18425,CWE-269,c_cpp,"An issue was discovered in Xen through 4.12.x allowing 32-bit PV guest OS users to gain guest OS privileges by installing and using descriptors. There is missing descriptor table limit checking in x86 PV emulation. When emulating certain PV guest operations, descriptor table accesses are performed by the emulating code. Such accesses should respect the guest specified limits, unless otherwise guaranteed to fail in such a case. Without this, emulation of 32-bit guest user mode calls through call gates would allow guest user mode to install and then use descriptors of their choice, as long as the guest kernel did not itself install an LDT. (Most OSes don't install any LDT by default). 32-bit PV guest user mode can elevate its privileges to that of the guest kernel. Xen versions from at least 3.2 onwards are affected. Only 32-bit PV guest user mode can leverage this vulnerability. HVM, PVH, as well as 64-bit PV guests cannot leverage this vulnerability. Arm systems are unaffected.",https://github.com/xen-project/xen/commit/93021cbe880a8013691a48d0febef8ed7d3e3ebd,"x86/PV: check GDT/LDT limits during emulation\n\nAccesses beyond the LDT limit originating from emulation would trigger\nthe ASSERT() in pv_map_ldt_shadow_page(). On production builds such\naccesses would cause an attempt to promote the touched page (offset from\nthe present LDT base address) to a segment descriptor one. If this\nhappens to succeed, guest user mode would be able to elevate its\nprivileges to that of the guest kernel. This is particularly easy when\nthere's no LDT at all, in which case the LDT base stored internally to\nXen is simply zero.\n\nAlso adjust the ASSERT() that was triggering: It was off by one to\nbegin with, and for production builds we also better use\nASSERT_UNREACHABLE() instead with suitable recovery code afterwards.\n\nThis is XSA-298.\n\nReported-by: Andrew Cooper <andrew.cooper3@citrix.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",3,"[{""func_name"": ""pv_emul_read_descriptor"", ""file_path"": ""xen/arch/x86/pv/emulate.c"", ""func_code"": ""int pv_emul_read_descriptor(unsigned int sel, const struct vcpu *v,\n                            unsigned long *base, unsigned long *limit,\n                            unsigned int *ar, bool insn_fetch)\n{\n    seg_desc_t desc;\n\n    if ( sel < 4)\n        desc.b = desc.a = 0;\n    else if ( __get_user(desc, gdt_ldt_desc_ptr(sel)) )\n        return 0;\n    if ( !insn_fetch )\n        desc.b &= ~_SEGMENT_L;\n\n    *ar = desc.b & 0x00f0ff00;\n    if ( !(desc.b & _SEGMENT_L) )\n    {\n        *base = ((desc.a >> 16) + ((desc.b & 0xff) << 16) +\n                 (desc.b & 0xff000000));\n        *limit = (desc.a & 0xffff) | (desc.b & 0x000f0000);\n        if ( desc.b & _SEGMENT_G )\n            *limit = ((*limit + 1) << 12) - 1;\n#ifndef NDEBUG\n        if ( sel > 3 )\n        {\n            unsigned int a, l;\n            unsigned char valid;\n\n            asm volatile (\n                \""larl %2,%0 ; setz %1\""\n                : \""=r\"" (a), \""=qm\"" (valid) : \""rm\"" (sel));\n            BUG_ON(valid && ((a & 0x00f0ff00) != *ar));\n            asm volatile (\n                \""lsll %2,%0 ; setz %1\""\n                : \""=r\"" (l), \""=qm\"" (valid) : \""rm\"" (sel));\n            BUG_ON(valid && (l != *limit));\n        }\n#endif\n    }\n    else\n    {\n        *base = 0UL;\n        *limit = ~0UL;\n    }\n\n    return 1;\n}"", ""target"": 0}, {""func_name"": ""pv_map_ldt_shadow_page"", ""file_path"": ""xen/arch/x86/pv/mm.c"", ""func_code"": ""bool pv_map_ldt_shadow_page(unsigned int offset)\n{\n    struct vcpu *curr = current;\n    struct domain *currd = curr->domain;\n    struct page_info *page;\n    l1_pgentry_t gl1e, *pl1e;\n    unsigned long linear = curr->arch.pv.ldt_base + offset;\n\n    BUG_ON(unlikely(in_irq()));\n\n    /*\n     * Hardware limit checking should guarantee this property.  NB. This is\n     * safe as updates to the LDT can only be made by MMUEXT_SET_LDT to the\n     * current vcpu, and vcpu_reset() will block until this vcpu has been\n     * descheduled before continuing.\n     */\n    ASSERT((offset >> 3) <= curr->arch.pv.ldt_ents);\n\n    if ( is_pv_32bit_domain(currd) )\n        linear = (uint32_t)linear;\n\n    gl1e = guest_get_eff_kern_l1e(linear);\n    if ( unlikely(!(l1e_get_flags(gl1e) & _PAGE_PRESENT)) )\n        return false;\n\n    page = get_page_from_gfn(currd, l1e_get_pfn(gl1e), NULL, P2M_ALLOC);\n    if ( unlikely(!page) )\n        return false;\n\n    if ( unlikely(!get_page_type(page, PGT_seg_desc_page)) )\n    {\n        put_page(page);\n        return false;\n    }\n\n    pl1e = &pv_ldt_ptes(curr)[offset >> PAGE_SHIFT];\n    l1e_add_flags(gl1e, _PAGE_RW);\n\n#ifdef CONFIG_PV_LDT_PAGING\n    spin_lock(&curr->arch.pv.shadow_ldt_lock);\n#endif\n\n    l1e_write(pl1e, gl1e);\n\n#ifdef CONFIG_PV_LDT_PAGING\n    curr->arch.pv.shadow_ldt_mapcnt++;\n    spin_unlock(&curr->arch.pv.shadow_ldt_lock);\n#endif\n\n    return true;\n}"", ""target"": 0}, {""func_name"": ""read_gate_descriptor"", ""file_path"": ""xen/arch/x86/pv/emul-gate-op.c"", ""func_code"": ""static int read_gate_descriptor(unsigned int gate_sel,\n                                const struct vcpu *v,\n                                unsigned int *sel,\n                                unsigned long *off,\n                                unsigned int *ar)\n{\n    seg_desc_t desc;\n    const seg_desc_t *pdesc = gdt_ldt_desc_ptr(gate_sel);\n\n    if ( (gate_sel < 4) ||\n         ((gate_sel >= FIRST_RESERVED_GDT_BYTE) && !(gate_sel & 4)) ||\n         __get_user(desc, pdesc) )\n        return 0;\n\n    *sel = (desc.a >> 16) & 0x0000fffc;\n    *off = (desc.a & 0x0000ffff) | (desc.b & 0xffff0000);\n    *ar = desc.b & 0x0000ffff;\n\n    /*\n     * check_descriptor() clears the DPL field and stores the\n     * guest requested DPL in the selector's RPL field.\n     */\n    if ( *ar & _SEGMENT_DPL )\n        return 0;\n    *ar |= (desc.a >> (16 - 13)) & _SEGMENT_DPL;\n\n    if ( !is_pv_32bit_vcpu(v) )\n    {\n        if ( (*ar & 0x1f00) != 0x0c00 ||\n             (gate_sel >= FIRST_RESERVED_GDT_BYTE - 8 && !(gate_sel & 4)) ||\n             __get_user(desc, pdesc + 1) ||\n             (desc.b & 0x1f00) )\n            return 0;\n\n        *off |= (unsigned long)desc.a << 32;\n        return 1;\n    }\n\n    switch ( *ar & 0x1f00 )\n    {\n    case 0x0400:\n        *off &= 0xffff;\n        break;\n    case 0x0c00:\n        break;\n    default:\n        return 0;\n    }\n\n    return 1;\n}"", ""target"": 0}]","[{""func_name"": ""pv_emul_read_descriptor"", ""file_path"": ""xen/arch/x86/pv/emulate.c"", ""func_code"": ""int pv_emul_read_descriptor(unsigned int sel, const struct vcpu *v,\n                            unsigned long *base, unsigned long *limit,\n                            unsigned int *ar, bool insn_fetch)\n{\n    seg_desc_t desc;\n\n    if ( sel < 4 ||\n         /*\n          * Don't apply the GDT limit here, as the selector may be a Xen\n          * provided one. __get_user() will fail (without taking further\n          * action) for ones falling in the gap between guest populated\n          * and Xen ones.\n          */\n         ((sel & 4) && (sel >> 3) >= v->arch.pv.ldt_ents) )\n        desc.b = desc.a = 0;\n    else if ( __get_user(desc, gdt_ldt_desc_ptr(sel)) )\n        return 0;\n    if ( !insn_fetch )\n        desc.b &= ~_SEGMENT_L;\n\n    *ar = desc.b & 0x00f0ff00;\n    if ( !(desc.b & _SEGMENT_L) )\n    {\n        *base = ((desc.a >> 16) + ((desc.b & 0xff) << 16) +\n                 (desc.b & 0xff000000));\n        *limit = (desc.a & 0xffff) | (desc.b & 0x000f0000);\n        if ( desc.b & _SEGMENT_G )\n            *limit = ((*limit + 1) << 12) - 1;\n#ifndef NDEBUG\n        if ( sel > 3 )\n        {\n            unsigned int a, l;\n            unsigned char valid;\n\n            asm volatile (\n                \""larl %2,%0 ; setz %1\""\n                : \""=r\"" (a), \""=qm\"" (valid) : \""rm\"" (sel));\n            BUG_ON(valid && ((a & 0x00f0ff00) != *ar));\n            asm volatile (\n                \""lsll %2,%0 ; setz %1\""\n                : \""=r\"" (l), \""=qm\"" (valid) : \""rm\"" (sel));\n            BUG_ON(valid && (l != *limit));\n        }\n#endif\n    }\n    else\n    {\n        *base = 0UL;\n        *limit = ~0UL;\n    }\n\n    return 1;\n}""}, {""func_name"": ""pv_map_ldt_shadow_page"", ""file_path"": ""xen/arch/x86/pv/mm.c"", ""func_code"": ""bool pv_map_ldt_shadow_page(unsigned int offset)\n{\n    struct vcpu *curr = current;\n    struct domain *currd = curr->domain;\n    struct page_info *page;\n    l1_pgentry_t gl1e, *pl1e;\n    unsigned long linear = curr->arch.pv.ldt_base + offset;\n\n    BUG_ON(unlikely(in_irq()));\n\n    /*\n     * Prior limit checking should guarantee this property.  NB. This is\n     * safe as updates to the LDT can only be made by MMUEXT_SET_LDT to the\n     * current vcpu, and vcpu_reset() will block until this vcpu has been\n     * descheduled before continuing.\n     */\n    if ( unlikely((offset >> 3) >= curr->arch.pv.ldt_ents) )\n    {\n        ASSERT_UNREACHABLE();\n        return false;\n    }\n\n    if ( is_pv_32bit_domain(currd) )\n        linear = (uint32_t)linear;\n\n    gl1e = guest_get_eff_kern_l1e(linear);\n    if ( unlikely(!(l1e_get_flags(gl1e) & _PAGE_PRESENT)) )\n        return false;\n\n    page = get_page_from_gfn(currd, l1e_get_pfn(gl1e), NULL, P2M_ALLOC);\n    if ( unlikely(!page) )\n        return false;\n\n    if ( unlikely(!get_page_type(page, PGT_seg_desc_page)) )\n    {\n        put_page(page);\n        return false;\n    }\n\n    pl1e = &pv_ldt_ptes(curr)[offset >> PAGE_SHIFT];\n    l1e_add_flags(gl1e, _PAGE_RW);\n\n#ifdef CONFIG_PV_LDT_PAGING\n    spin_lock(&curr->arch.pv.shadow_ldt_lock);\n#endif\n\n    l1e_write(pl1e, gl1e);\n\n#ifdef CONFIG_PV_LDT_PAGING\n    curr->arch.pv.shadow_ldt_mapcnt++;\n    spin_unlock(&curr->arch.pv.shadow_ldt_lock);\n#endif\n\n    return true;\n}""}, {""func_name"": ""read_gate_descriptor"", ""file_path"": ""xen/arch/x86/pv/emul-gate-op.c"", ""func_code"": ""static int read_gate_descriptor(unsigned int gate_sel,\n                                const struct vcpu *v,\n                                unsigned int *sel,\n                                unsigned long *off,\n                                unsigned int *ar)\n{\n    seg_desc_t desc;\n    const seg_desc_t *pdesc = gdt_ldt_desc_ptr(gate_sel);\n\n    if ( (gate_sel < 4) ||\n         /*\n          * We're interested in call gates only, which occupy a single\n          * seg_desc_t for 32-bit and a consecutive pair of them for 64-bit.\n          */\n         ((gate_sel >> 3) + !is_pv_32bit_vcpu(v) >=\n          (gate_sel & 4 ? v->arch.pv.ldt_ents\n                        : v->arch.pv.gdt_ents)) ||\n         __get_user(desc, pdesc) )\n        return 0;\n\n    *sel = (desc.a >> 16) & 0x0000fffc;\n    *off = (desc.a & 0x0000ffff) | (desc.b & 0xffff0000);\n    *ar = desc.b & 0x0000ffff;\n\n    /*\n     * check_descriptor() clears the DPL field and stores the\n     * guest requested DPL in the selector's RPL field.\n     */\n    if ( *ar & _SEGMENT_DPL )\n        return 0;\n    *ar |= (desc.a >> (16 - 13)) & _SEGMENT_DPL;\n\n    if ( !is_pv_32bit_vcpu(v) )\n    {\n        if ( (*ar & 0x1f00) != 0x0c00 ||\n             /* Limit check done above already. */\n             __get_user(desc, pdesc + 1) ||\n             (desc.b & 0x1f00) )\n            return 0;\n\n        *off |= (unsigned long)desc.a << 32;\n        return 1;\n    }\n\n    switch ( *ar & 0x1f00 )\n    {\n    case 0x0400:\n        *off &= 0xffff;\n        break;\n    case 0x0c00:\n        break;\n    default:\n        return 0;\n    }\n\n    return 1;\n}""}]","{""caller"": 2, ""value"": 1}","[{""source"": ""caller_info(file:emulate.c, func:pv_emul_read_descriptor)"", ""result"": [{""call_line"": 148, ""call_code"": ""pv_emul_read_descriptor(sel, current, &addr, &limit, &ar, 0)"", ""caller_code"": ""static int read_mem(enum x86_segment seg, unsigned long offset, void *p_data,\n                    unsigned int bytes, struct x86_emulate_ctxt *ctxt)\n{\n    const struct gate_op_ctxt *goc =\n        container_of(ctxt, struct gate_op_ctxt, ctxt);\n    unsigned int rc = bytes, sel = 0;\n    unsigned long addr = offset, limit = 0;\n\n    switch ( seg )\n    {\n    case x86_seg_cs:\n        addr += goc->cs.base;\n        limit = goc->cs.limit;\n        break;\n    case x86_seg_ds:\n        sel = read_sreg(ds);\n        break;\n    case x86_seg_es:\n        sel = read_sreg(es);\n        break;\n    case x86_seg_fs:\n        sel = read_sreg(fs);\n        break;\n    case x86_seg_gs:\n        sel = read_sreg(gs);\n        break;\n    case x86_seg_ss:\n        sel = ctxt->regs->ss;\n        break;\n    default:\n        return X86EMUL_UNHANDLEABLE;\n    }\n    if ( sel )\n    {\n        unsigned int ar;\n\n        ASSERT(!goc->insn_fetch);\n        if ( !pv_emul_read_descriptor(sel, current, &addr, &limit, &ar, 0) ||\n        ..."", ""caller_start"": 111, ""file_path"": ""xen/arch/x86/pv/emul-gate-op.c""}, {""call_line"": 208, ""call_code"": ""pv_emul_read_descriptor(regs->cs, v, &ctxt.cs.base, &ctxt.cs.limit,\n                                  &ar, 0)"", ""caller_code"": ""void pv_emulate_gate_op(struct cpu_user_regs *regs)\n{\n    struct vcpu *v = current;\n    unsigned int sel, ar, dpl, nparm, insn_len;\n    struct gate_op_ctxt ctxt = { .ctxt.regs = regs, .insn_fetch = true };\n    struct x86_emulate_state *state;\n    unsigned long off, base, limit;\n    uint16_t opnd_sel = 0;\n    int jump = -1, rc = X86EMUL_OKAY;\n\n    /* Check whether this fault is due to the use of a call gate. */\n    if ( !read_gate_descriptor(regs->error_code, v, &sel, &off, &ar) ||\n         (((ar >> 13) & 3) < (regs->cs & 3)) ||\n         ((ar & _SEGMENT_TYPE) != 0xc00) )\n    {\n        pv_inject_hw_exception(TRAP_gp_fault, regs->error_code);\n        return;\n    }\n    if ( !(ar & _SEGMENT_P) )\n    {\n        pv_inject_hw_exception(TRAP_no_segment, regs->error_code);\n        return;\n    }\n    dpl = (ar >> 13) & 3;\n    nparm = ar & 0x1f;\n\n    /*\n     * Decode instruction (and perhaps operand) to determine RPL,\n     * whether this is a jump or a call, and the call return offset.\n     */\n  ..."", ""caller_start"": 178, ""file_path"": ""xen/arch/x86/pv/emul-gate-op.c""}, {""call_line"": 280, ""call_code"": ""pv_emul_read_descriptor(sel, v, &base, &limit, &ar, 0)"", ""caller_code"": ""void pv_emulate_gate_op(struct cpu_user_regs *regs)\n{\n    struct vcpu *v = current;\n    unsigned int sel, ar, dpl, nparm, insn_len;\n    struct gate_op_ctxt ctxt = { .ctxt.regs = regs, .insn_fetch = true };\n    struct x86_emulate_state *state;\n    unsigned long off, base, limit;\n    uint16_t opnd_sel = 0;\n    int jump = -1, rc = X86EMUL_OKAY;\n\n    /* Check whether this fault is due to the use of a call gate. */\n    if ( !read_gate_descriptor(regs->error_code, v, &sel, &off, &ar) ||\n         (((ar >> 13) & 3) < (regs->cs & 3)) ||\n         ((ar & _SEGMENT_TYPE) != 0xc00) )\n    {\n        pv_inject_hw_exception(TRAP_gp_fault, regs->error_code);\n        return;\n    }\n    if ( !(ar & _SEGMENT_P) )\n    {\n        pv_inject_hw_exception(TRAP_no_segment, regs->error_code);\n        return;\n    }\n    dpl = (ar >> 13) & 3;\n    nparm = ar & 0x1f;\n\n    /*\n     * Decode instruction (and perhaps operand) to determine RPL,\n     * whether this is a jump or a call, and the call return offset.\n     */\n  ..."", ""caller_start"": 178, ""file_path"": ""xen/arch/x86/pv/emul-gate-op.c""}]}, {""source"": ""caller_info(file:emul-gate-op.c, func:read_gate_descriptor)"", ""result"": [{""call_line"": 189, ""call_code"": ""read_gate_descriptor(regs->error_code, v, &sel, &off, &ar)"", ""caller_code"": ""void pv_emulate_gate_op(struct cpu_user_regs *regs)\n{\n    struct vcpu *v = current;\n    unsigned int sel, ar, dpl, nparm, insn_len;\n    struct gate_op_ctxt ctxt = { .ctxt.regs = regs, .insn_fetch = true };\n    struct x86_emulate_state *state;\n    unsigned long off, base, limit;\n    uint16_t opnd_sel = 0;\n    int jump = -1, rc = X86EMUL_OKAY;\n\n    /* Check whether this fault is due to the use of a call gate. */\n    if ( !read_gate_descriptor(regs->error_code, v, &sel, &off, &ar) ||\n         (((ar >> 13) & 3) < (regs->cs & 3)) ||\n         ((ar & _SEGMENT_TYPE) != 0xc00) )\n    {\n        pv_inject_hw_exception(TRAP_gp_fault, regs->error_code);\n        return;\n    }\n    if ( !(ar & _SEGMENT_P) )\n    {\n        pv_inject_hw_exception(TRAP_no_segment, regs->error_code);\n        return;\n    }\n    dpl = (ar >> 13) & 3;\n    nparm = ar & 0x1f;\n\n    /*\n     * Decode instruction (and perhaps operand) to determine RPL,\n     * whether this is a jump or a call, and the call return offset.\n     */\n  ..."", ""caller_start"": 178, ""file_path"": ""xen/arch/x86/pv/emul-gate-op.c""}]}, {""source"": ""value_info(file:emulate.c, value:sel)"", ""result"": {""value_trace"": [{""full_code"": ""sel = le32_native(selection)"", ""line"": 60, ""func_name"": ""TPM_pcr_digest""}, {""full_code"": ""sel = {\n\t\t.sizeOfSelect = 3,\n\t\t.pcrSelect = (void*)&reset_sel,\n\t}"", ""line"": 188, ""func_name"": ""do_pcr_setup""}, {""full_code"": ""sel = vmr(selector)"", ""line"": 1863, ""func_name"": ""vmx_dump_sel""}, {""full_code"": ""sel = 0"", ""line"": 921, ""func_name"": ""vmx_get_segment_register""}, {""full_code"": ""sel = reg->sel"", ""line"": 1025, ""func_name"": ""vmx_set_segment_register""}], ""struct_var"": ""sel"", ""struct_type"": ""uint32_t"", ""struct_definition"": ""typedef unsigned int uint32_t;\n\ntypedef unsigned int uint32_t;\n\ntypedef u32 uint32_t;\n\ntypedef unsigned int        uint32_t;\n\ntypedef unsigned int        uint32_t;\n\ntypedef unsigned int        uint32_t;\n\ntypedef unsigned int        uint32_t;\n\ntypedef unsigned int        uint32_t;\n\ntypedef unsigned int        uint32_t;\n\ntypedef unsigned int uint32_t;\n\ntypedef         __u32           uint32_t;""}}]","The vulnerability stems from missing GDT/LDT limit checks in Xen's PV emulation. Guest OS segment registers (e.g., ds, es) are read into 'sel' in read_mem (emul-gate-op.c:111-148), which is passed to pv_emul_read_descriptor (emulate.c:32-39). Prior to the patch, selectors beyond LDT/GDT limits were not checked, allowing invalid descriptors. The patch adds checks for (sel & 4 && (sel >> 3) >= v->arch.pv.ldt_ents) in emulate.c:32-39. Similarly, 'gate_sel' from CPU error_code in pv_emulate_gate_op (emul-gate-op.c:178-189) is validated in read_gate_descriptor (emul-gate-op.c:52-58) against GDT/LDT limits. pv_map_ldt_shadow_page (mm.c:93-99) now checks (offset >> 3) >= curr->arch.pv.ldt_ents with recovery. These checks prevent out-of-bounds accesses and privilege escalation.",1.0,./github/other_context/CVE-2019-18425
14,CVE-2019-3827,CWE-863,c_cpp,An incorrect permission check in the admin backend in gvfs before version 1.39.4 was found that allows reading and modify arbitrary files by privileged users without asking for password when no authentication agent is running. This vulnerability can be exploited by malicious programs running under privileges of users belonging to the wheel group to further escalate its privileges by modifying system files without user's knowledge. Successful exploitation requires uncommon system configuration.,https://github.com/GNOME/gvfs/commit/d8d0c8c40049cfd824b2b90d0cd47914052b9811,"admin: Prevent access if any authentication agent isn't available\n\nThe backend currently allows to access and modify files without prompting\nfor password if any polkit authentication agent isn't available. This seems\nisn't usually problem, because polkit agents are integral parts of\ngraphical environments / linux distributions. The agents can't be simply\ndisabled without root permissions and are automatically respawned. However,\nthis might be a problem in some non-standard cases.\n\nThis affects only users which belong to wheel group (i.e. those who are\nalready allowed to use sudo). It doesn't allow privilege escalation for\nusers, who don't belong to that group.\n\nLet's return permission denied error also when the subject can't be\nauthorized by any polkit agent to prevent this behavior.\n\nCloses: https://gitlab.gnome.org/GNOME/gvfs/issues/355",1,"[{""func_name"": ""check_permission"", ""file_path"": ""daemon/gvfsbackendadmin.c"", ""func_code"": ""static gboolean\ncheck_permission (GVfsBackendAdmin *self,\n                  GVfsJob *job)\n{\n  GVfsJobDBus *dbus_job = G_VFS_JOB_DBUS (job);\n  GError *error = NULL;\n  GDBusMethodInvocation *invocation;\n  GDBusConnection *connection;\n  GCredentials *credentials;\n  pid_t pid;\n  uid_t uid;\n  PolkitSubject *subject;\n  PolkitAuthorizationResult *result;\n  gboolean is_authorized;\n\n  invocation = dbus_job->invocation;\n  connection = g_dbus_method_invocation_get_connection (invocation);\n  credentials = g_dbus_connection_get_peer_credentials (connection);\n\n  pid = g_credentials_get_unix_pid (credentials, &error);\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  uid = g_credentials_get_unix_user (credentials, &error);\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  /* Only one polkit dialog at a time */\n  g_mutex_lock (&self->polkit_mutex);\n\n  subject = polkit_unix_process_new_for_owner (pid, 0, uid);\n  result = polkit_authority_check_authorization_sync (self->authority,\n                                                      subject,\n                                                      \""org.gtk.vfs.file-operations\"",\n                                                      NULL, POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,\n                                                      NULL, &error);\n  g_object_unref (subject);\n\n  g_mutex_unlock (&self->polkit_mutex);\n\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  is_authorized = polkit_authorization_result_get_is_authorized (result) ||\n    polkit_authorization_result_get_is_challenge (result);\n\n  g_object_unref (result);\n\n  if (!is_authorized)\n    g_vfs_job_failed_literal (job, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                              _(\""Permission denied\""));\n\n  return is_authorized;\n}"", ""target"": 0}]","[{""func_name"": ""check_permission"", ""file_path"": ""daemon/gvfsbackendadmin.c"", ""func_code"": ""static gboolean\ncheck_permission (GVfsBackendAdmin *self,\n                  GVfsJob *job)\n{\n  GVfsJobDBus *dbus_job = G_VFS_JOB_DBUS (job);\n  GError *error = NULL;\n  GDBusMethodInvocation *invocation;\n  GDBusConnection *connection;\n  GCredentials *credentials;\n  pid_t pid;\n  uid_t uid;\n  PolkitSubject *subject;\n  PolkitAuthorizationResult *result;\n  gboolean is_authorized;\n\n  invocation = dbus_job->invocation;\n  connection = g_dbus_method_invocation_get_connection (invocation);\n  credentials = g_dbus_connection_get_peer_credentials (connection);\n\n  pid = g_credentials_get_unix_pid (credentials, &error);\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  uid = g_credentials_get_unix_user (credentials, &error);\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  /* Only one polkit dialog at a time */\n  g_mutex_lock (&self->polkit_mutex);\n\n  subject = polkit_unix_process_new_for_owner (pid, 0, uid);\n  result = polkit_authority_check_authorization_sync (self->authority,\n                                                      subject,\n                                                      \""org.gtk.vfs.file-operations\"",\n                                                      NULL, POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,\n                                                      NULL, &error);\n  g_object_unref (subject);\n\n  g_mutex_unlock (&self->polkit_mutex);\n\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  is_authorized = polkit_authorization_result_get_is_authorized (result);\n\n  g_object_unref (result);\n\n  if (!is_authorized)\n    g_vfs_job_failed_literal (job, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                              _(\""Permission denied\""));\n\n  return is_authorized;\n}""}]","{""caller"": 1, ""value"": 1, ""function"": 1}","[{""source"": ""caller_info(file:gvfsbackendadmin.c, func:check_permission)"", ""result"": [{""call_line"": 173, ""call_code"": ""check_permission (self, job)"", ""caller_code"": ""static void\ndo_query_info (GVfsBackend *backend,\n               GVfsJobQueryInfo *query_info_job,\n               const char *filename,\n               GFileQueryInfoFlags flags,\n               GFileInfo *info,\n               GFileAttributeMatcher *matcher)\n{\n  GVfsBackendAdmin *self = G_VFS_BACKEND_ADMIN (backend);\n  GVfsJob *job = G_VFS_JOB (query_info_job);\n  GError *error = NULL;\n  GFile *file;\n  GFileInfo *real_info;\n\n  if (!check_permission (self, job))\n    return;\n\n  file = g_file_new_for_path (filename);\n  real_info = g_file_query_info (file, query_info_job->attributes,\n                                 flags, job->cancellable, &error);\n  g_object_unref (file);\n\n  if (error != NULL)\n    goto out;\n\n  /* Override read/write flags, since the above call will use access()\n   * to determine permissions, which does not honor our privileged\n   * capabilities.\n   */\n  g_file_info_set_attribute_boolean (real_info,\n                                     G_FILE_ATTRIBUTE_ACCESS_CAN_READ, TRUE);\n  g_file_info_set_attribute_boolean (real_info,\n                                     G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE, TRUE);\n  g_file_info_set_attribute_boolean (real_info,\n                                     G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE, TRUE);\n  g_file_info_set_attribute_boolean (real_info,\n                                     G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME, TRUE);\n\n  g_file_info_copy_into (real_info, info);\n  g_object_unref (real_info);\n\n out:\n  complete_job (job, error);\n}\n"", ""caller_start"": 159, ""file_path"": ""daemon/gvfsbackendadmin.c""}, {""call_line"": 264, ""call_code"": ""check_permission (self, job)"", ""caller_code"": ""static void\ndo_append_to (GVfsBackend *backend,\n              GVfsJobOpenForWrite *open_write_job,\n              const char *filename,\n              GFileCreateFlags flags)\n{\n  GVfsBackendAdmin *self = G_VFS_BACKEND_ADMIN (backend);\n  GVfsJob *job = G_VFS_JOB (open_write_job);\n  GError *error = NULL;\n  GFile *file;\n  GFileOutputStream *stream;\n\n  if (!check_permission (self, job))\n    return;\n\n  file = g_file_new_for_path (filename);\n  stream = g_file_append_to (file, flags, job->cancellable, &error);\n  g_object_unref (file);\n\n  if (error != NULL)\n    goto out;\n\n  set_open_for_write_attributes (open_write_job, stream);\n  g_vfs_job_open_for_write_set_initial_offset (open_write_job,\n                                               g_seekable_tell (G_SEEKABLE (stream)));\n\n out:\n  complete_job (job, error);\n}"", ""caller_start"": 252, ""file_path"": ""daemon/gvfsbackendadmin.c""}, {""call_line"": 294, ""call_code"": ""check_permission (self, job)"", ""caller_code"": ""static void\ndo_create (GVfsBackend *backend,\n           GVfsJobOpenForWrite *open_write_job,\n           const char *filename,\n           GFileCreateFlags flags)\n{\n  GVfsBackendAdmin *self = G_VFS_BACKEND_ADMIN (backend);\n  GVfsJob *job = G_VFS_JOB (open_write_job);\n  GError *error = NULL;\n  GFile *file;\n  GFileOutputStream *stream;\n\n  if (!check_permission (self, job))\n    return;\n\n  file = g_file_new_for_path (filename);\n  stream = g_file_create (file, flags, job->cancellable, &error);\n  g_object_unref (file);\n\n  if (error != NULL)\n    goto out;\n\n  set_open_for_write_attributes (open_write_job, stream);\n\n out:\n  complete_job (job, error);\n}"", ""caller_start"": 282, ""file_path"": ""daemon/gvfsbackendadmin.c""}, {""call_line"": 324, ""call_code"": ""check_permission (self, job)"", ""caller_code"": ""static void\ndo_replace (GVfsBackend *backend,\n            GVfsJobOpenForWrite *open_write_job,\n            const char *filename,\n            const char *etag,\n            gboolean make_backup,\n            GFileCreateFlags flags)\n{\n  GVfsBackendAdmin *self = G_VFS_BACKEND_ADMIN (backend);\n  GVfsJob *job = G_VFS_JOB (open_write_job);\n  GError *error = NULL;\n  GFile *file;\n  GFileOutputStream *stream;\n\n  if (!check_permission (self, job))\n    return;\n\n  file = g_file_new_for_path (filename);\n  stream = g_file_replace (file, etag, make_backup, flags,\n                           job->cancellable, &error);\n  g_object_unref (file);\n\n  if (error != NULL)\n    goto out;\n\n  set_open_for_write_attributes (open_write_job, stream);\n\n out:\n  complete_job (job, error);\n}"", ""caller_start"": 310, ""file_path"": ""daemon/gvfsbackendadmin.c""}]}, {""source"": ""value_info(file:gvfsbackendadmin.c, value:result)"", ""result"": {""value_trace"": [{""full_code"": ""result = polkit_authority_check_authorization_sync (self->authority,\n                                                      subject,\n                                                      \""org.gtk.vfs.file-operations\"",\n                                                      NULL, POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,\n                                                      NULL, &error)"", ""line"": 117, ""func_name"": ""check_permission""}], ""struct_var"": ""result"", ""struct_type"": ""PolkitAuthorizationResult*"", ""struct_definition"": null}}, {""source"": ""func_info(file:gvfsbackendadmin.c, func:check_permission)"", ""result"": [{""code"": ""static gboolean\ncheck_permission (GVfsBackendAdmin *self,\n                  GVfsJob *job)\n{\n  GVfsJobDBus *dbus_job = G_VFS_JOB_DBUS (job);\n  GError *error = NULL;\n  GDBusMethodInvocation *invocation;\n  GDBusConnection *connection;\n  GCredentials *credentials;\n  pid_t pid;\n  uid_t uid;\n  PolkitSubject *subject;\n  PolkitAuthorizationResult *result;\n  gboolean is_authorized;\n\n  invocation = dbus_job->invocation;\n  connection = g_dbus_method_invocation_get_connection (invocation);\n  credentials = g_dbus_connection_get_peer_credentials (connection);\n\n  pid = g_credentials_get_unix_pid (credentials, &error);\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  uid = g_credentials_get_unix_user (credentials, &error);\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  /* Only one polkit dialog at a time */\n  g_mutex_lock (&self->polkit_mutex);\n\n  subject = polkit_unix_process_new_for_owner (pid, 0, uid);\n  result = polkit_authority_check_authorization_sync (self->authority,\n                                                      subject,\n                                                      \""org.gtk.vfs.file-operations\"",\n                                                      NULL, POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,\n                                                      NULL, &error);\n  g_object_unref (subject);\n\n  g_mutex_unlock (&self->polkit_mutex);\n\n  if (error != NULL)\n    {\n      g_vfs_job_failed_from_error (job, error);\n      g_error_free (error);\n      return FALSE;\n    }\n\n  is_authorized = polkit_authorization_result_get_is_authorized (result) ||\n    polkit_authorization_result_get_is_challenge (result);\n\n  g_object_unref (result);\n\n  if (!is_authorized)\n    g_vfs_job_failed_literal (job, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                              _(\""Permission denied\""));\n\n  return is_authorized;\n}\n"", ""start_line"": 78, ""end_line"": 143, ""full_name"": ""check_permission"", ""file_path"": ""daemon/gvfsbackendadmin.c""}]}]","daemon/gvfsbackendadmin.c:131-133: Original logic allowed access if `is_authorized` OR `is_challenge` was true. When no Polkit agent is available, `is_challenge` could incorrectly permit access for users in the wheel group. The patch removes the `is_challenge` condition, requiring explicit `is_authorized`. This affects callers like `do_append_to` (line 264) and `do_create` (line 294), which perform file operations after permission checks.",0.95,./github/other_context/CVE-2019-3827
15,CVE-2020-11008,CWE-522,c_cpp,"Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. This bug is similar to CVE-2020-5260(GHSA-qm7j-c969-7j4q). The fix for that bug still left the door open for an exploit where _some_ credential is leaked (but the attacker cannot control which one). Git uses external ""credential helper"" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that are considered illegal as of the recently published Git versions can cause Git to send a ""blank"" pattern to helpers, missing hostname and protocol fields. Many helpers will interpret this as matching _any_ URL, and will return some unspecified stored password, leaking the password to an attacker's server. The vulnerability can be triggered by feeding a malicious URL to `git clone`. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The root of the problem is in Git itself, which should not be feeding blank input to helpers. However, the ability to exploit the vulnerability in practice depends on which helpers are in use. Credential helpers which are known to trigger the vulnerability: - Git's ""store"" helper - Git's ""cache"" helper - the ""osxkeychain"" helper that ships in Git's ""contrib"" directory Credential helpers which are known to be safe even with vulnerable versions of Git: - Git Credential Manager for Windows Any helper not in this list should be assumed to trigger the vulnerability.",https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282,"credential: treat URL without scheme as invalid\n\nlibcurl permits making requests without a URL scheme specified.  In\nthis case, it guesses the URL from the hostname, so I can run\n\n	git ls-remote http::ftp.example.com/path/to/repo\n\nand it would make an FTP request.\n\nAny user intentionally using such a URL is likely to have made a typo.\nUnfortunately, credential_from_url is not able to determine the host and\nprotocol in order to determine appropriate credentials to send, and\nuntil ""credential: refuse to operate when missing host or protocol"",\nthis resulted in another host's credentials being leaked to the named\nhost.\n\nTeach credential_from_url_gently to consider such a URL to be invalid\nso that fsck can detect and block gitmodules files with such URLs,\nallowing server operators to avoid serving them to downstream users\nrunning older versions of Git.\n\nThis also means that when such URLs are passed on the command line, Git\nwill print a clearer error so affected users can switch to the simpler\nURL that explicitly specifies the host and protocol they intend.\n\nOne subtlety: .gitmodules files can contain relative URLs, representing\na URL relative to the URL they were cloned from.  The relative URL\nresolver used for .gitmodules can follow "".."" components out of the path\npart and past the host part of a URL, meaning that such a relative URL\ncan be used to traverse from a https://foo.example.com/innocent\nsuperproject to a https::attacker.example.com/exploit submodule.\nFortunately a leading ':' in the first path component after a series of\nleading './' and '../' components is unlikely to show up in other\ncontexts, so we can catch this by detecting that pattern.\n\nReported-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>",2,"[{""func_name"": ""credential_from_url_gently"", ""file_path"": ""credential.c"", ""func_code"": ""int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \""://\"");\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \""username\"", c->username) < 0 ||\n\t    check_url_component(url, quiet, \""password\"", c->password) < 0 ||\n\t    check_url_component(url, quiet, \""protocol\"", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \""host\"", c->host) < 0 ||\n\t    check_url_component(url, quiet, \""path\"", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""check_submodule_url"", ""file_path"": ""fsck.c"", ""func_code"": ""static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""credential_from_url_gently"", ""file_path"": ""credential.c"", ""func_code"": ""int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \""://\"");\n\tif (!proto_end) {\n\t\tif (!quiet)\n\t\t\twarning(_(\""url has no scheme: %s\""), url);\n\t\treturn -1;\n\t}\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \""username\"", c->username) < 0 ||\n\t    check_url_component(url, quiet, \""password\"", c->password) < 0 ||\n\t    check_url_component(url, quiet, \""protocol\"", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \""host\"", c->host) < 0 ||\n\t    check_url_component(url, quiet, \""path\"", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}""}, {""func_name"": ""check_submodule_url"", ""file_path"": ""fsck.c"", ""func_code"": ""static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * URLs which escape their root via \""../\"" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t */\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}""}]","{""caller"": 2, ""function"": 2}","[{""source"": ""caller_info(file:credential.c, func:credential_from_url_gently)"", ""result"": [{""call_line"": 408, ""call_code"": ""credential_from_url_gently(c, url, 0)"", ""caller_code"": ""void credential_from_url(struct credential *c, const char *url)\n{\n\tif (credential_from_url_gently(c, url, 0) < 0)\n\t\tdie(_(\""credential url cannot be parsed: %s\""), url);\n}"", ""caller_start"": 406, ""file_path"": ""credential.c""}, {""call_line"": 1034, ""call_code"": ""credential_from_url_gently(&c, curl_url, 1)"", ""caller_code"": ""static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"", ""caller_start"": 1013, ""file_path"": ""fsck.c""}]}, {""source"": ""caller_info(file:fsck.c, func:check_submodule_url)"", ""result"": [{""call_line"": 1066, ""call_code"": ""check_submodule_url(value)"", ""caller_code"": ""static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \""submodule\"", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \""disallowed submodule name: %s\"",\n\t\t\t\t    name);\n\tif (!strcmp(key, \""url\"") && value &&\n\t    check_submodule_url(value) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \""disallowed submodule url: %s\"",\n\t\t\t\t    value);\n\tif (!strcmp(key, \""path\"") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \""disallowed submodule path: %s\"",\n\t\t\t\t    value);\n\tif (!strcmp(key, \""update\"") && value &&\n\t    parse_submodule_update_type(value) == SM_UPDATE_COMMAND)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_UPDATE,\n\t\t\t\t    \""disallowed submodule update setting: %s\"",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}\n"", ""caller_start"": 1048, ""file_path"": ""fsck.c""}]}, {""source"": ""func_info(func:credential_from_url_gently)"", ""result"": [{""code"": ""int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \""://\"");\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \""username\"", c->username) < 0 ||\n\t    check_url_component(url, quiet, \""password\"", c->password) < 0 ||\n\t    check_url_component(url, quiet, \""protocol\"", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \""host\"", c->host) < 0 ||\n\t    check_url_component(url, quiet, \""path\"", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n"", ""start_line"": 346, ""end_line"": 404, ""full_name"": ""credential_from_url_gently"", ""file_path"": ""credential.c""}]}, {""source"": ""func_info(func:check_submodule_url)"", ""result"": [{""code"": ""static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"", ""start_line"": 1013, ""end_line"": 1040, ""full_name"": ""check_submodule_url"", ""file_path"": ""fsck.c""}]}]","1. Malformed URL (no scheme) is passed to Git (e.g., submodule URL in .gitmodules).\n2. `credential_from_url_gently` (credential.c:358-363) detects missing scheme and returns -1.\n3. Caller `credential_from_url` (credential.c:406-408) sees return <0 and calls `die()`, aborting the operation.\n4. For relative URLs in .gitmodules, `check_submodule_url` (fsck.c:1013-1040) uses `credential_from_url_gently` and returns -1 on error.\n5. `fsck_gitmodules_fn` (fsck.c:1066) checks return value; if <0, reports an error during fsck, blocking the malicious URL.",0.95,./github/other_context/CVE-2020-11008
16,CVE-2020-10059,CWE-295,c_cpp,"The UpdateHub module disables DTLS peer checking, which allows for a man in the middle attack. This is mitigated by firmware images requiring valid signatures. However, there is no benefit to using DTLS without the peer checking. See NCC-ZEP-018 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",https://github.com/zephyrproject-rtos/zephyr/commit/e79336c896ff4fe51217d9ffd82b22fca8459919,"updatehub: Require peer verification with DTLS\n\nDTLS without peer verification offers no security whatsoever (and is\narguably worse than not using DTLS in the first place).\n\nChange the verification option to require this peer verification.  To\nuse this, it may be necessary to install and use a root certificate.\n\nSigned-off-by: David Brown <david.brown@linaro.org>",1,"[{""func_name"": ""start_coap_client"", ""file_path"": ""lib/updatehub/updatehub.c"", ""func_code"": ""static bool start_coap_client(void)\n{\n\tstruct addrinfo *addr;\n\tstruct addrinfo hints;\n\tint resolve_attempts = 10;\n\tint ret = -1;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4)) {\n\t\thints.ai_family = AF_INET;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_NONE;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \""5684\"";\n#else\n\tint protocol = IPPROTO_UDP;\n\tchar port[] = \""5683\"";\n#endif\n\n\twhile (resolve_attempts--) {\n\t\tret = getaddrinfo(UPDATEHUB_SERVER, port, &hints, &addr);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (ret < 0) {\n\t\tLOG_ERR(\""Could not resolve dns\"");\n\t\treturn false;\n\t}\n\n\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n\tif (ctx.sock < 0) {\n\t\tLOG_ERR(\""Failed to create UDP socket\"");\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_SEC_TAG_LIST,\n\t\t       sec_list, sizeof(sec_list)) < 0) {\n\t\tLOG_ERR(\""Failed to set TLS_TAG option\"");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_PEER_VERIFY, &verify, sizeof(int)) < 0) {\n\t\tLOG_ERR(\""Failed to set TLS_PEER_VERIFY option\"");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(ctx.sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\t\tLOG_ERR(\""Cannot connect to UDP remote\"");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}"", ""target"": 0}]","[{""func_name"": ""start_coap_client"", ""file_path"": ""lib/updatehub/updatehub.c"", ""func_code"": ""static bool start_coap_client(void)\n{\n\tstruct addrinfo *addr;\n\tstruct addrinfo hints;\n\tint resolve_attempts = 10;\n\tint ret = -1;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4)) {\n\t\thints.ai_family = AF_INET;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_REQUIRED;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \""5684\"";\n#else\n\tint protocol = IPPROTO_UDP;\n\tchar port[] = \""5683\"";\n#endif\n\n\twhile (resolve_attempts--) {\n\t\tret = getaddrinfo(UPDATEHUB_SERVER, port, &hints, &addr);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (ret < 0) {\n\t\tLOG_ERR(\""Could not resolve dns\"");\n\t\treturn false;\n\t}\n\n\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n\tif (ctx.sock < 0) {\n\t\tLOG_ERR(\""Failed to create UDP socket\"");\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_SEC_TAG_LIST,\n\t\t       sec_list, sizeof(sec_list)) < 0) {\n\t\tLOG_ERR(\""Failed to set TLS_TAG option\"");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_PEER_VERIFY, &verify, sizeof(int)) < 0) {\n\t\tLOG_ERR(\""Failed to set TLS_PEER_VERIFY option\"");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(ctx.sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\t\tLOG_ERR(\""Cannot connect to UDP remote\"");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}""}]","{""code"": 2, ""value"": 1}","[{""source"": ""code_info(file:updatehub.c, lines:145-185)"", ""result"": ""\t}\n\treturn false;\n}\n\nstatic bool start_coap_client(void)\n{\n\tstruct addrinfo *addr;\n\tstruct addrinfo hints;\n\tint resolve_attempts = 10;\n\tint ret = -1;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4)) {\n\t\thints.ai_family = AF_INET;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_NONE;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \""5684\"";\n#else\n\tint protocol = IPPROTO_UDP;\n\tchar port[] = \""5683\"";\n#endif\n\n\twhile (resolve_attempts--) {\n\t\tret = getaddrinfo(UPDATEHUB_SERVER, port, &hints, &addr);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (ret < 0) {\n\t\tLOG_ERR(\""Could not resolve dns\"");\n\t\treturn false;\n\t}\n\n\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n""}, {""source"": ""value_info(file:updatehub.c, value:TLS_PEER_VERIFY_REQUIRED)"", ""result"": {""value_trace"": [{""full_code"": ""TLS_PEER_VERIFY_REQUIRED"", ""line"": 307, ""func_name"": null}, {""full_code"": ""TLS_PEER_VERIFY_REQUIRED"", ""line"": 183, ""func_name"": null}], ""struct_var"": ""TLS_PEER_VERIFY_REQUIRED"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""code_info(file:updatehub.c, lines:186-200)"", ""result"": ""\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n\tif (ctx.sock < 0) {\n\t\tLOG_ERR(\""Failed to create UDP socket\"");\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_SEC_TAG_LIST,\n\t\t       sec_list, sizeof(sec_list)) < 0) {\n\t\tLOG_ERR(\""Failed to set TLS_TAG option\"");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_PEER_VERIFY, &verify, sizeof(int)) < 0) {\n\t\tLOG_ERR(\""Failed to set TLS_PEER_VERIFY option\"");\n\t\treturn false;\n""}]","The vulnerability was caused by `int verify = TLS_PEER_VERIFY_NONE;` in `lib/updatehub/updatehub.c` line 163 (before patch), disabling DTLS peer verification. The `verify` variable is passed to `setsockopt(..., TLS_PEER_VERIFY, &verify, ...)` in lines 189193, configuring the DTLS socket to skip peer validation. The patch changes `TLS_PEER_VERIFY_NONE` to `TLS_PEER_VERIFY_REQUIRED`, enforcing certificate checks during the handshake. The `sec_list` (line 164) provides trusted CA certificates via `setsockopt(..., TLS_SEC_TAG_LIST, sec_list, ...)` in lines 186189, enabling validation when peer verification is required.",1.0,./github/other_context/CVE-2020-10059
17,CVE-2020-13645,CWE-295,c_cpp,"In GNOME glib-networking through 2.64.2, the implementation of GTlsClientConnection skips hostname verification of the server's TLS certificate if the application fails to specify the expected server identity. This is in contrast to its intended documented behavior, to fail the certificate verification. Applications that fail to provide the server identity, including Balsa before 2.5.11 and 2.6.x before 2.6.1, accept a TLS certificate if the certificate is valid for any host.",https://github.com/GNOME/glib-networking/commit/dbc8d69f58b07f6ed091aa123e5d40a53573a5fc,"Return bad identity error if identity is unset\n\nWhen the server-identity property of GTlsClientConnection is unset, the\ndocumentation sasy we need to fail the certificate verification with\nG_TLS_CERTIFICATE_BAD_IDENTITY. This is important because otherwise,\nit's easy for applications to fail to specify server identity.\n\nUnfortunately, we did not correctly implement the intended, documented\nbehavior. When server identity is missing, we check the validity of the\nTLS certificate, but do not check if it corresponds to the expected\nserver (since we have no expected server). Then we assume the identity\nis good, instead of returning bad identity, as documented. This means,\nfor example, that evil.com can present a valid certificate issued to\nevil.com, and we would happily accept it for paypal.com.\n\nFixes #135",1,"[{""func_name"": ""verify_peer_certificate"", ""file_path"": ""tls/base/gtlsconnection-base.c"", ""func_code"": ""static GTlsCertificateFlags\nverify_peer_certificate (GTlsConnectionBase *tls,\n                         GTlsCertificate    *peer_certificate)\n{\n  GSocketConnectable *peer_identity;\n  GTlsDatabase *database;\n  GTlsCertificateFlags errors;\n  gboolean is_client;\n\n  is_client = G_IS_TLS_CLIENT_CONNECTION (tls);\n\n  if (!is_client)\n    peer_identity = NULL;\n  else if (!g_tls_connection_base_is_dtls (tls))\n    peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));\n  else\n    peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));\n\n  errors = 0;\n\n  database = g_tls_connection_get_database (G_TLS_CONNECTION (tls));\n  if (!database)\n    {\n      errors |= G_TLS_CERTIFICATE_UNKNOWN_CA;\n      errors |= g_tls_certificate_verify (peer_certificate, peer_identity, NULL);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      errors |= g_tls_database_verify_chain (database, peer_certificate,\n                                             is_client ?\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER :\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT,\n                                             peer_identity,\n                                             g_tls_connection_get_interaction (G_TLS_CONNECTION (tls)),\n                                             G_TLS_DATABASE_VERIFY_NONE,\n                                             NULL, &error);\n      if (error)\n        {\n          g_tls_log_debug (tls, \""failure verifying certificate chain: %s\"", error->message);\n          g_assert (errors != 0);\n          g_clear_error (&error);\n        }\n    }\n\n  return errors;\n}"", ""target"": 0}]","[{""func_name"": ""verify_peer_certificate"", ""file_path"": ""tls/base/gtlsconnection-base.c"", ""func_code"": ""static GTlsCertificateFlags\nverify_peer_certificate (GTlsConnectionBase *tls,\n                         GTlsCertificate    *peer_certificate)\n{\n  GSocketConnectable *peer_identity = NULL;\n  GTlsDatabase *database;\n  GTlsCertificateFlags errors = 0;\n  gboolean is_client;\n\n  is_client = G_IS_TLS_CLIENT_CONNECTION (tls);\n\n  if (is_client)\n    {\n      if (!g_tls_connection_base_is_dtls (tls))\n        peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));\n      else\n        peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));\n\n      if (!peer_identity)\n        errors |= G_TLS_CERTIFICATE_BAD_IDENTITY;\n    }\n\n  database = g_tls_connection_get_database (G_TLS_CONNECTION (tls));\n  if (!database)\n    {\n      errors |= G_TLS_CERTIFICATE_UNKNOWN_CA;\n      errors |= g_tls_certificate_verify (peer_certificate, peer_identity, NULL);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      errors |= g_tls_database_verify_chain (database, peer_certificate,\n                                             is_client ?\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER :\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT,\n                                             peer_identity,\n                                             g_tls_connection_get_interaction (G_TLS_CONNECTION (tls)),\n                                             G_TLS_DATABASE_VERIFY_NONE,\n                                             NULL, &error);\n      if (error)\n        {\n          g_tls_log_debug (tls, \""failure verifying certificate chain: %s\"", error->message);\n          g_assert (errors != 0);\n          g_clear_error (&error);\n        }\n    }\n\n  return errors;\n}""}]","{""function"": 2, ""code"": 4}","[{""source"": ""func_info(file:gtlsconnection-base.c, func:verify_peer_certificate)"", ""result"": [{""code"": ""static GTlsCertificateFlags\nverify_peer_certificate (GTlsConnectionBase *tls,\n                         GTlsCertificate    *peer_certificate)\n{\n  GSocketConnectable *peer_identity;\n  GTlsDatabase *database;\n  GTlsCertificateFlags errors;\n  gboolean is_client;\n\n  is_client = G_IS_TLS_CLIENT_CONNECTION (tls);\n\n  if (!is_client)\n    peer_identity = NULL;\n  else if (!g_tls_connection_base_is_dtls (tls))\n    peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));\n  else\n    peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));\n\n  errors = 0;\n\n  database = g_tls_connection_get_database (G_TLS_CONNECTION (tls));\n  if (!database)\n    {\n      errors |= G_TLS_CERTIFICATE_UNKNOWN_CA;\n      errors |= g_tls_certificate_verify (peer_certificate, peer_identity, NULL);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      errors |= g_tls_database_verify_chain (database, peer_certificate,\n                                             is_client ?\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER :\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT,\n                                             peer_identity,\n                                             g_tls_connection_get_interaction (G_TLS_CONNECTION (tls)),\n                                             G_TLS_DATABASE_VERIFY_NONE,\n                                             NULL, &error);\n      if (error)\n        {\n          g_tls_log_debug (tls, \""failure verifying certificate chain: %s\"", error->message);\n          g_assert (errors != 0);\n          g_clear_error (&error);\n        }\n    }\n\n  return errors;\n}\n"", ""start_line"": 1232, ""end_line"": 1279, ""full_name"": ""verify_peer_certificate"", ""file_path"": ""tls/base/gtlsconnection-base.c""}]}, {""source"": ""code_info(file:gtlsconnection-base.c, lines:1250-1270)"", ""result"": ""  errors = 0;\n\n  database = g_tls_connection_get_database (G_TLS_CONNECTION (tls));\n  if (!database)\n    {\n      errors |= G_TLS_CERTIFICATE_UNKNOWN_CA;\n      errors |= g_tls_certificate_verify (peer_certificate, peer_identity, NULL);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      errors |= g_tls_database_verify_chain (database, peer_certificate,\n                                             is_client ?\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER :\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT,\n                                             peer_identity,\n                                             g_tls_connection_get_interaction (G_TLS_CONNECTION (tls)),\n                                             G_TLS_DATABASE_VERIFY_NONE,\n                                             NULL, &error);\n      if (error)\n        {\n""}, {""source"": ""code_info(file:gtlsconnection-base.c, lines:1280-1300)"", ""result"": ""\nstatic void\nupdate_peer_certificate_and_compute_errors (GTlsConnectionBase *tls)\n{\n  GTlsConnectionBasePrivate *priv = g_tls_connection_base_get_instance_private (tls);\n  GTlsCertificate *peer_certificate = NULL;\n  GTlsCertificateFlags peer_certificate_errors = 0;\n\n  /* This function must be called from the handshake context thread\n   * (probably the main thread, NOT the handshake thread) because\n   * it emits notifies that are application-visible.\n   *\n   * verify_certificate_mutex should be locked.\n   */\n  g_assert (priv->handshake_context);\n  g_assert (g_main_context_is_owner (priv->handshake_context));\n\n  peer_certificate = G_TLS_CONNECTION_BASE_GET_CLASS (tls)->retrieve_peer_certificate (tls);\n  if (peer_certificate)\n    peer_certificate_errors = verify_peer_certificate (tls, peer_certificate);\n\n  g_clear_object (&priv->peer_certificate);\n""}, {""source"": ""code_info(file:gtlsconnection-base.c, lines:1300-1320)"", ""result"": ""\n  g_clear_object (&priv->peer_certificate);\n  priv->peer_certificate = g_steal_pointer (&peer_certificate);\n  g_clear_object (&peer_certificate);\n\n  priv->peer_certificate_errors = peer_certificate_errors;\n\n  g_object_notify (G_OBJECT (tls), \""peer-certificate\"");\n  g_object_notify (G_OBJECT (tls), \""peer-certificate-errors\"");\n}\n\nstatic gboolean\naccept_or_reject_peer_certificate (gpointer user_data)\n{\n  GTlsConnectionBase *tls = user_data;\n  GTlsConnectionBasePrivate *priv = g_tls_connection_base_get_instance_private (tls);\n  gboolean accepted = FALSE;\n\n  g_assert (g_main_context_is_owner (priv->handshake_context));\n\n  g_mutex_lock (&priv->verify_certificate_mutex);\n\n""}, {""source"": ""func_info(file:gtlsconnection-base.c, func:accept_or_reject_peer_certificate)"", ""result"": [{""code"": ""static gboolean\naccept_or_reject_peer_certificate (gpointer user_data)\n{\n  GTlsConnectionBase *tls = user_data;\n  GTlsConnectionBasePrivate *priv = g_tls_connection_base_get_instance_private (tls);\n  gboolean accepted = FALSE;\n\n  g_assert (g_main_context_is_owner (priv->handshake_context));\n\n  g_mutex_lock (&priv->verify_certificate_mutex);\n\n  update_peer_certificate_and_compute_errors (tls);\n\n  if (priv->peer_certificate)\n    {\n      if (G_IS_TLS_CLIENT_CONNECTION (tls))\n        {\n          GTlsCertificateFlags validation_flags;\n\n          if (!g_tls_connection_base_is_dtls (tls))\n            validation_flags =\n              g_tls_client_connection_get_validation_flags (G_TLS_CLIENT_CONNECTION (tls));\n          else\n            validation_flags =\n              g_dtls_client_connection_get_validation_flags (G_DTLS_CLIENT_CONNECTION (tls));\n\n          if ((priv->peer_certificate_errors & validation_flags) == 0)\n            accepted = TRUE;\n        }\n\n      if (!accepted)\n        {\n          gboolean sync_handshake_in_progress;\n\n          g_mutex_lock (&priv->op_mutex);\n          sync_handshake_in_progress = priv->sync_handshake_in_progress;\n          g_mutex_unlock (&priv->op_mutex);\n\n          if (sync_handshake_in_progress)\n            g_main_context_pop_thread_default (priv->handshake_context);\n\n          accepted = g_tls_connection_emit_accept_certificate (G_TLS_CONNECTION (tls),\n                                                               priv->peer_certificate,\n                                                               priv->peer_certificate_errors);\n\n          if (sync_handshake_in_progress)\n            g_main_context_push_thread_default (priv->handshake_context);\n        }\n    }\n  else if (G_IS_TLS_SERVER_CONNECTION (tls))\n    {\n      GTlsAuthenticationMode mode = 0;\n\n      g_object_get (tls,\n                    \""authentication-mode\"", &mode,\n                    NULL);\n\n      if (mode != G_TLS_AUTHENTICATION_REQUIRED)\n        accepted = TRUE;\n    }\n\n  priv->peer_certificate_accepted = accepted;\n\n  /* This has to be the very last statement before signaling the\n   * condition variable because otherwise the code could spuriously\n   * wakeup and continue before we are done here.\n   */\n  priv->peer_certificate_examined = TRUE;\n\n  g_cond_signal (&priv->verify_certificate_condition);\n  g_mutex_unlock (&priv->verify_certificate_mutex);\n\n  return G_SOURCE_REMOVE;\n}\n"", ""start_line"": 1311, ""end_line"": 1384, ""full_name"": ""accept_or_reject_peer_certificate"", ""file_path"": ""tls/base/gtlsconnection-base.c""}]}, {""source"": ""code_info(file:gtlsconnection-base.c, lines:1320-1340)"", ""result"": ""  g_mutex_lock (&priv->verify_certificate_mutex);\n\n  update_peer_certificate_and_compute_errors (tls);\n\n  if (priv->peer_certificate)\n    {\n      if (G_IS_TLS_CLIENT_CONNECTION (tls))\n        {\n          GTlsCertificateFlags validation_flags;\n\n          if (!g_tls_connection_base_is_dtls (tls))\n            validation_flags =\n              g_tls_client_connection_get_validation_flags (G_TLS_CLIENT_CONNECTION (tls));\n          else\n            validation_flags =\n              g_dtls_client_connection_get_validation_flags (G_DTLS_CLIENT_CONNECTION (tls));\n\n          if ((priv->peer_certificate_errors & validation_flags) == 0)\n            accepted = TRUE;\n        }\n\n      if (!accepted)\n""}]","Original code (tls/base/gtlsconnection-base.c:1234-1245) did not check for NULL peer_identity in client connections. The patch (tls/base/gtlsconnection-base.c:1238-1241) adds a NULL check and sets G_TLS_CERTIFICATE_BAD_IDENTITY when unset. The final validation logic in 'accept_or_reject_peer_certificate' (tls/base/gtlsconnection-base.c:1311-1384) checks if (peer_certificate_errors & validation_flags) == 0. If not, the certificate is rejected unless the application explicitly allows it via the 'accept_certificate' signal. This ensures the error flag triggers rejection by default, fixing the vulnerability.",1.0,./github/other_context/CVE-2020-13645
18,CVE-2021-21335,CWE-287,c_cpp,"In the SPNEGO HTTP Authentication Module for nginx (spnego-http-auth-nginx-module) before version 1.1.1 basic Authentication can be bypassed using a malformed username. This affects users of spnego-http-auth-nginx-module that have enabled basic authentication. This is fixed in version 1.1.1 of spnego-http-auth-nginx-module. As a workaround, one may disable basic authentication.",https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570,"Check basic auth result against != NGX_OK rather than == NGX_DECLINED\n\nThis corrects the error handling case when ngx_http_auth_spnego_basic is called with a bad configuration or bad username. These cases return NGX_ERROR, which allowed basic auth to proceed.\r\n\r\nThanks to Prakapovich Pavel aka Flyguy.by for pointing this out.",1,"[{""func_name"": ""ngx_http_auth_spnego_handler"", ""file_path"": ""ngx_http_auth_spnego_module.c"", ""func_code"": ""static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\""SSO auth handling IN: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\""Found token and head, returning %d\"", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\""User header set\"");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\""Begin auth\"");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\""Detect basic auth\"");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\""Basic auth credentials supplied by client\"");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\""Basic auth failed\"");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\""Error setting headers\"");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\""User not authorized\"");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\""Basic auth succeeded\"");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\""Detect SPNEGO token\"");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\""Client sent a reasonable Negotiate header\"");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\""Error setting headers\"");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\""User not authorized\"");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\""GSSAPI auth succeeded\"");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\""Error setting headers\"");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\""SSO auth handling OUT: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}"", ""target"": 0}]","[{""func_name"": ""ngx_http_auth_spnego_handler"", ""file_path"": ""ngx_http_auth_spnego_module.c"", ""func_code"": ""static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\""SSO auth handling IN: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\""Found token and head, returning %d\"", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\""User header set\"");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\""Begin auth\"");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\""Detect basic auth\"");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\""Basic auth credentials supplied by client\"");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\""Basic auth failed\"");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\""Error setting headers\"");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\""User not authorized\"");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\""Basic auth succeeded\"");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\""Detect SPNEGO token\"");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\""Client sent a reasonable Negotiate header\"");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\""Error setting headers\"");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\""User not authorized\"");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\""GSSAPI auth succeeded\"");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\""Error setting headers\"");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\""SSO auth handling OUT: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:ngx_http_auth_spnego_module.c, func:ngx_http_auth_spnego_basic)"", ""result"": [{""code"": ""    ngx_int_t\nngx_http_auth_spnego_basic(\n        ngx_http_request_t * r,\n        ngx_http_auth_spnego_ctx_t * ctx,\n        ngx_http_auth_spnego_loc_conf_t * alcf)\n{\n    ngx_str_t host_name;\n    ngx_str_t service;\n    ngx_str_t user;\n    user.data = NULL;\n    ngx_str_t new_user;\n    ngx_int_t ret = NGX_DECLINED;\n\n    krb5_context kcontext = NULL;\n    krb5_error_code code;\n    krb5_principal client = NULL;\n    krb5_principal server = NULL;\n    krb5_creds creds;\n    krb5_get_init_creds_opt *gic_options = NULL;\n    int kret = 0;\n    char *name = NULL;\n    char *p = NULL;\n\n    code = krb5_init_context(&kcontext);\n    if (code) {\n        spnego_debug0(\""Kerberos error: Cannot initialize kerberos context\"");\n        return NGX_ERROR;\n    }\n\n    host_name = r->headers_in.host->value;\n    service.len = alcf->srvcname.len + alcf->realm.len + 3;\n\n    if (ngx_strchr(alcf->srvcname.data, '/')) {\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \""%V@%V%Z\"",\n                &alcf->srvcname, &alcf->realm);\n    } else {\n        service.len += host_name.len;\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \""%V/%V@%V%Z\"",\n                &alcf->srvcname, &host_name, &alcf->realm);\n    }\n\n    kret = krb5_parse_name(kcontext, (const char *) service.data, &server);\n\n    if (kret) {\n        spnego_log_error(\""Kerberos error:  Unable to parse service name\"");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    code = krb5_unparse_name(kcontext, server, &name);\n    if (code) {\n        spnego_log_error(\""Kerberos error: Cannot unparse servicename\"");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    free(name);\n    name = NULL;\n\n    p = ngx_strchr(r->headers_in.user.data, '@');\n    user.len = r->headers_in.user.len + 1;\n    if (NULL == p) {\n        if (alcf->force_realm && alcf->realm.len && alcf->realm.data ) {\n            user.len += alcf->realm.len + 1; /* +1 for @ */\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\""Not enough memory\"");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \""%V@%V%Z\"", &r->headers_in.user,\n                    &alcf->realm);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\""Not enough memory\"");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \""%V%Z\"", &r->headers_in.user);\n        }\n    } else {\n        if (alcf->realm.len && alcf->realm.data && ngx_strncmp(p + 1,\n                    alcf->realm.data, alcf->realm.len) == 0) {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\""Not enough memory\"");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \""%V%Z\"",\n                    &r->headers_in.user);\n            if (alcf->fqun == 0) {\n                /*\n                 * Specified realm is identical to configured realm.\n                 * Truncate $remote_user to strip @REALM.\n                 */\n                r->headers_in.user.len -= alcf->realm.len + 1;\n            }\n        } else if (alcf->force_realm) {\n            *p = '\\0';\n            user.len = ngx_strlen(r->headers_in.user.data) + 1;\n            if (alcf->realm.len && alcf->realm.data)\n                user.len += alcf->realm.len + 1;\n            user.data = ngx_pcalloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\""Not enough memory\"");\n                spnego_error(NGX_ERROR);\n            }\n            if (alcf->realm.len && alcf->realm.data)\n                ngx_snprintf(user.data, user.len, \""%s@%V%Z\"",\n                        r->headers_in.user.data, &alcf->realm);\n            else\n                ngx_snprintf(user.data, user.len, \""%s%Z\"",\n                        r->headers_in.user.data);\n            /*\n             * Rewrite $remote_user with the forced realm.\n             * If the forced realm is shorter than the\n             * specified realm, we can reuse the original\n             * buffer.\n             */\n            if (r->headers_in.user.len >= user.len - 1)\n                r->headers_in.user.len = user.len - 1;\n            else {\n                new_user.len = user.len - 1;\n                new_user.data = ngx_palloc(r->pool, new_user.len);\n                if (NULL == new_user.data) {\n                    spnego_log_error(\""Not enough memory\"");\n                    spnego_error(NGX_ERROR);\n                }\n                ngx_pfree(r->pool, r->headers_in.user.data);\n                r->headers_in.user.data = new_user.data;\n                r->headers_in.user.len = new_user.len;\n            }\n            ngx_memcpy(r->headers_in.user.data, user.data,\n                    r->headers_in.user.len);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\""Not enough memory\"");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \""%V%Z\"", &r->headers_in.user);\n        }\n    }\n\n    spnego_debug1(\""Attempting authentication with principal %s\"",\n            (const char *)user.data);\n\n    code = krb5_parse_name(kcontext, (const char *) user.data, &client);\n    if (code) {\n        spnego_log_error(\""Kerberos error: Unable to parse username\"");\n        spnego_debug1(\""username is %s.\"", (const char *) user.data);\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    code = krb5_unparse_name(kcontext, client, &name);\n    if (code) {\n        spnego_log_error(\""Kerberos error: Cannot unparse username\"");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    krb5_get_init_creds_opt_alloc(kcontext, &gic_options);\n\n    code = krb5_get_init_creds_password(kcontext, &creds, client,\n                (char *) r->headers_in.passwd.data,\n                NULL, NULL, 0, NULL, gic_options);\n\n    krb5_free_cred_contents(kcontext, &creds);\n\n    if (code) {\n        spnego_log_error(\""Kerberos error: Credentials failed\"");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_DECLINED);\n    }\n\n    /* Try to add the system realm to $remote_user if needed. */\n    if (alcf->fqun && !ngx_strchr(r->headers_in.user.data, '@')) {\n#ifdef krb5_princ_realm\n        /*\n         * MIT does not have krb5_principal_get_realm() but its\n         * krb5_princ_realm() is a macro that effectively points\n         * to a char *.\n         */\n        const char *realm = krb5_princ_realm(kcontext, client)->data;\n#else\n        const char *realm = krb5_principal_get_realm(kcontext, client);\n#endif\n        if (realm) {\n            new_user.len = r->headers_in.user.len + 1 + ngx_strlen(realm);\n            new_user.data = ngx_palloc(r->pool, new_user.len);\n            if (NULL == new_user.data) {\n                spnego_log_error(\""Not enough memory\"");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(new_user.data, new_user.len, \""%V@%s\"",\n                    &r->headers_in.user, realm);\n            ngx_pfree(r->pool, r->headers_in.user.data);\n            r->headers_in.user.data = new_user.data;\n            r->headers_in.user.len = new_user.len;\n        }\n    }\n\n    spnego_debug1(\""Setting $remote_user to %V\"", &r->headers_in.user);\n    if (ngx_http_auth_spnego_set_bogus_authorization(r) != NGX_OK)\n        spnego_log_error(\""Failed to set $remote_user\"");\n\n    spnego_debug0(\""ngx_http_auth_spnego_basic: returning NGX_OK\"");\n\n    ret = NGX_OK;\n\nend:\n    if (name)\n        free(name);\n    if (client)\n        krb5_free_principal(kcontext, client);\n    if (server)\n        krb5_free_principal(kcontext, server);\n    if (service.data)\n        ngx_pfree(r->pool, service.data);\n    if (user.data)\n        ngx_pfree(r->pool, user.data);\n\n    krb5_get_init_creds_opt_free(kcontext, gic_options);\n\n    krb5_free_context(kcontext);\n\n    return ret;\n}\n"", ""start_line"": 494, ""end_line"": 733, ""full_name"": ""ngx_http_auth_spnego_basic"", ""file_path"": ""ngx_http_auth_spnego_module.c""}]}]","In ngx_http_auth_spnego_handler (ngx_http_auth_spnego_module.c:1044), the return value of ngx_http_auth_spnego_basic was incorrectly checked against NGX_DECLINED. This allowed NGX_ERROR returns (e.g., from malformed usernames) to be treated as successful. The function ngx_http_auth_spnego_basic (ngx_http_auth_spnego_module.c:494-733) returns NGX_ERROR for errors like invalid Kerberos credentials or memory allocation failures. The original condition (== NGX_DECLINED) failed to catch these errors, which the patch (NGX_OK != ...) now addresses.",0.95,./github/other_context/CVE-2021-21335
19,CVE-2021-21429,CWE-552,java,"OpenAPI Generator allows generation of API client libraries, server stubs, documentation and configuration automatically given an OpenAPI Spec. Using `File.createTempFile` in JDK will result in creating and using insecure temporary files that can leave application and system data vulnerable to attacks. OpenAPI Generator maven plug-in creates insecure temporary files during the process. The issue has been patched with `Files.createTempFile` and released in the v5.1.0 stable version.",https://github.com/OpenAPITools/openapi-generator/commit/34002dc1d4b1f9e1c741cab32f9249b361ead6df,use Files.createTempFile in maven plugin to avoid security issues,2,"[{""func_name"": ""execute"", ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java"", ""func_code"": ""@Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }"", ""target"": 1}, {""func_name"": ""calculateInputSpecHash"", ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java"", ""func_code"": ""private String calculateInputSpecHash(File inputSpecFile) throws IOException {\n\n        URL inputSpecRemoteUrl = inputSpecRemoteUrl();\n\n        File inputSpecTempFile = inputSpecFile;\n\n        if (inputSpecRemoteUrl != null) {\n            inputSpecTempFile = File.createTempFile(\""openapi-spec\"", \"".tmp\"");\n\n            URLConnection conn = inputSpecRemoteUrl.openConnection();\n            if (isNotEmpty(auth)) {\n                List<AuthorizationValue> authList = AuthParser.parse(auth);\n                for (AuthorizationValue a : authList) {\n                    conn.setRequestProperty(a.getKeyName(), a.getValue());\n                }\n            }\n            try (ReadableByteChannel readableByteChannel = Channels.newChannel(conn.getInputStream())) {\n                FileChannel fileChannel;\n                try (FileOutputStream fileOutputStream = new FileOutputStream(inputSpecTempFile)) {\n                    fileChannel = fileOutputStream.getChannel();\n                    fileChannel.transferFrom(readableByteChannel, 0, Long.MAX_VALUE);\n                }\n            }\n        }\n\n        ByteSource inputSpecByteSource =\n                inputSpecTempFile.exists()\n                        ? Files.asByteSource(inputSpecTempFile)\n                        : CharSource.wrap(ClasspathHelper.loadFileFromClasspath(inputSpecTempFile.toString().replaceAll(\""\\\\\\\\\"",\""/\"")))\n                        .asByteSource(StandardCharsets.UTF_8);\n\n        return inputSpecByteSource.hash(Hashing.sha256()).toString();\n    }"", ""target"": 0}]","[{""func_name"": ""execute"", ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java"", ""func_code"": ""@Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                if (!parent.mkdirs()) {\n                    throw new RuntimeException(\""Failed to create the folder \"" + parent.getAbsolutePath() +\n                                               \"" to store the checksum of the input spec.\"");\n                }\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }""}, {""func_name"": ""calculateInputSpecHash"", ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java"", ""func_code"": ""private String calculateInputSpecHash(File inputSpecFile) throws IOException {\n\n        URL inputSpecRemoteUrl = inputSpecRemoteUrl();\n\n        File inputSpecTempFile = inputSpecFile;\n\n        if (inputSpecRemoteUrl != null) {\n            inputSpecTempFile = java.nio.file.Files.createTempFile(\""openapi-spec\"", \"".tmp\"").toFile();\n\n            URLConnection conn = inputSpecRemoteUrl.openConnection();\n            if (isNotEmpty(auth)) {\n                List<AuthorizationValue> authList = AuthParser.parse(auth);\n                for (AuthorizationValue a : authList) {\n                    conn.setRequestProperty(a.getKeyName(), a.getValue());\n                }\n            }\n            try (ReadableByteChannel readableByteChannel = Channels.newChannel(conn.getInputStream())) {\n                FileChannel fileChannel;\n                try (FileOutputStream fileOutputStream = new FileOutputStream(inputSpecTempFile)) {\n                    fileChannel = fileOutputStream.getChannel();\n                    fileChannel.transferFrom(readableByteChannel, 0, Long.MAX_VALUE);\n                }\n            }\n        }\n\n        ByteSource inputSpecByteSource =\n                inputSpecTempFile.exists()\n                        ? Files.asByteSource(inputSpecTempFile)\n                        : CharSource.wrap(ClasspathHelper.loadFileFromClasspath(inputSpecTempFile.toString().replaceAll(\""\\\\\\\\\"",\""/\"")))\n                        .asByteSource(StandardCharsets.UTF_8);\n\n        return inputSpecByteSource.hash(Hashing.sha256()).toString();\n    }""}]","{""caller"": 4, ""code"": 1, ""function"": 3}","[{""source"": ""caller_info(file:CodeGenMojo.java, func:calculateInputSpecHash)"", ""result"": [{""call_line"": 462, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}, {""call_line"": 757, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}]}, {""source"": ""code_info(file:CodeGenMojo.java, lines:795-805)"", ""result"": ""            URLConnection conn = inputSpecRemoteUrl.openConnection();\n            if (isNotEmpty(auth)) {\n                List<AuthorizationValue> authList = AuthParser.parse(auth);\n                for (AuthorizationValue a : authList) {\n                    conn.setRequestProperty(a.getKeyName(), a.getValue());\n                }\n            }\n            try (ReadableByteChannel readableByteChannel = Channels.newChannel(conn.getInputStream())) {\n                FileChannel fileChannel;\n                try (FileOutputStream fileOutputStream = new FileOutputStream(inputSpecTempFile)) {\n                    fileChannel = fileOutputStream.getChannel();\n                    fileChannel.transferFrom(readableByteChannel, 0, Long.MAX_VALUE);\n""}, {""source"": ""func_info(file:CodeGenMojo.java, line:791)"", ""result"": [{""code"": ""    private String calculateInputSpecHash(File inputSpecFile) throws IOException {\n\n        URL inputSpecRemoteUrl = inputSpecRemoteUrl();\n\n        File inputSpecTempFile = inputSpecFile;\n\n        if (inputSpecRemoteUrl != null) {\n            inputSpecTempFile = java.nio.file.Files.createTempFile(\""openapi-spec\"", \"".tmp\"").toFile();\n\n            URLConnection conn = inputSpecRemoteUrl.openConnection();\n            if (isNotEmpty(auth)) {\n                List<AuthorizationValue> authList = AuthParser.parse(auth);\n                for (AuthorizationValue a : authList) {\n                    conn.setRequestProperty(a.getKeyName(), a.getValue());\n                }\n            }\n            try (ReadableByteChannel readableByteChannel = Channels.newChannel(conn.getInputStream())) {\n                FileChannel fileChannel;\n                try (FileOutputStream fileOutputStream = new FileOutputStream(inputSpecTempFile)) {\n                    fileChannel = fileOutputStream.getChannel();\n                    fileChannel.transferFrom(readableByteChannel, 0, Long.MAX_VALUE);\n                }\n            }\n        }\n\n        ByteSource inputSpecByteSource =\n                inputSpecTempFile.exists()\n                        ? Files.asByteSource(inputSpecTempFile)\n                        : CharSource.wrap(ClasspathHelper.loadFileFromClasspath(inputSpecTempFile.toString().replaceAll(\""\\\\\\\\\"",\""/\"")))\n                        .asByteSource(StandardCharsets.UTF_8);\n\n        return inputSpecByteSource.hash(Hashing.sha256()).toString();\n    }\n"", ""start_line"": 786, ""end_line"": 818, ""full_name"": ""org.openapitools.codegen.plugin.CodeGenMojo.calculateInputSpecHash:java.lang.String(java.io.File)"", ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}]}, {""source"": ""caller_info(file:CodeGenMojo.java, func:calculateInputSpecHash)"", ""result"": [{""call_line"": 462, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}, {""call_line"": 757, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}]}, {""source"": ""func_info(file:CodeGenMojo.java, line:791)"", ""result"": [{""code"": ""    private String calculateInputSpecHash(File inputSpecFile) throws IOException {\n\n        URL inputSpecRemoteUrl = inputSpecRemoteUrl();\n\n        File inputSpecTempFile = inputSpecFile;\n\n        if (inputSpecRemoteUrl != null) {\n            inputSpecTempFile = java.nio.file.Files.createTempFile(\""openapi-spec\"", \"".tmp\"").toFile();\n\n            URLConnection conn = inputSpecRemoteUrl.openConnection();\n            if (isNotEmpty(auth)) {\n                List<AuthorizationValue> authList = AuthParser.parse(auth);\n                for (AuthorizationValue a : authList) {\n                    conn.setRequestProperty(a.getKeyName(), a.getValue());\n                }\n            }\n            try (ReadableByteChannel readableByteChannel = Channels.newChannel(conn.getInputStream())) {\n                FileChannel fileChannel;\n                try (FileOutputStream fileOutputStream = new FileOutputStream(inputSpecTempFile)) {\n                    fileChannel = fileOutputStream.getChannel();\n                    fileChannel.transferFrom(readableByteChannel, 0, Long.MAX_VALUE);\n                }\n            }\n        }\n\n        ByteSource inputSpecByteSource =\n                inputSpecTempFile.exists()\n                        ? Files.asByteSource(inputSpecTempFile)\n                        : CharSource.wrap(ClasspathHelper.loadFileFromClasspath(inputSpecTempFile.toString().replaceAll(\""\\\\\\\\\"",\""/\"")))\n                        .asByteSource(StandardCharsets.UTF_8);\n\n        return inputSpecByteSource.hash(Hashing.sha256()).toString();\n    }\n"", ""start_line"": 786, ""end_line"": 818, ""full_name"": ""org.openapitools.codegen.plugin.CodeGenMojo.calculateInputSpecHash:java.lang.String(java.io.File)"", ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}]}, {""source"": ""caller_info(file:CodeGenMojo.java, func:calculateInputSpecHash)"", ""result"": [{""call_line"": 462, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}, {""call_line"": 757, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}]}, {""source"": ""func_info(file:CodeGenMojo.java, line:791)"", ""result"": [{""code"": ""    private String calculateInputSpecHash(File inputSpecFile) throws IOException {\n\n        URL inputSpecRemoteUrl = inputSpecRemoteUrl();\n\n        File inputSpecTempFile = inputSpecFile;\n\n        if (inputSpecRemoteUrl != null) {\n            inputSpecTempFile = java.nio.file.Files.createTempFile(\""openapi-spec\"", \"".tmp\"").toFile();\n\n            URLConnection conn = inputSpecRemoteUrl.openConnection();\n            if (isNotEmpty(auth)) {\n                List<AuthorizationValue> authList = AuthParser.parse(auth);\n                for (AuthorizationValue a : authList) {\n                    conn.setRequestProperty(a.getKeyName(), a.getValue());\n                }\n            }\n            try (ReadableByteChannel readableByteChannel = Channels.newChannel(conn.getInputStream())) {\n                FileChannel fileChannel;\n                try (FileOutputStream fileOutputStream = new FileOutputStream(inputSpecTempFile)) {\n                    fileChannel = fileOutputStream.getChannel();\n                    fileChannel.transferFrom(readableByteChannel, 0, Long.MAX_VALUE);\n                }\n            }\n        }\n\n        ByteSource inputSpecByteSource =\n                inputSpecTempFile.exists()\n                        ? Files.asByteSource(inputSpecTempFile)\n                        : CharSource.wrap(ClasspathHelper.loadFileFromClasspath(inputSpecTempFile.toString().replaceAll(\""\\\\\\\\\"",\""/\"")))\n                        .asByteSource(StandardCharsets.UTF_8);\n\n        return inputSpecByteSource.hash(Hashing.sha256()).toString();\n    }\n"", ""start_line"": 786, ""end_line"": 818, ""full_name"": ""org.openapitools.codegen.plugin.CodeGenMojo.calculateInputSpecHash:java.lang.String(java.io.File)"", ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}]}, {""source"": ""caller_info(file:CodeGenMojo.java, func:calculateInputSpecHash)"", ""result"": [{""call_line"": 462, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}, {""call_line"": 757, ""call_code"": ""this.calculateInputSpecHash(inputSpecFile)"", ""caller_code"": ""    @Override\n    public void execute() throws MojoExecutionException {\n        File inputSpecFile = new File(inputSpec);\n        addCompileSourceRootIfConfigured();\n\n        try {\n            if (Boolean.TRUE.equals(skip)) {\n                getLog().info(\""Code generation is skipped.\"");\n                return;\n            }\n\n            if (buildContext != null && inputSpec != null ) {\n                if (buildContext.isIncremental() &&\n                        inputSpecFile.exists() &&\n                        !buildContext.hasDelta(inputSpecFile)) {\n                    getLog().info(\n                            \""Code generation is skipped in delta-build because source-json was not modified.\"");\n                    return;\n                }\n            }\n\n            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {\n                File storedInputSpecHashFile = getHashFile(inputSpecFile);\n                if (storedInputSpecHashFile.exists()) {\n                    String inputSpecHash = null;\n                    try {\n                        inputSpecHash = calculateInputSpecHash(inputSpecFile);\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                    @SuppressWarnings(\""UnstableApiUsage\"")\n                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();\n                    if (storedInputSpecHash.equals(inputSpecHash)) {\n                        getLog().info(\n                                \""Code generation is skipped because input was unchanged\"");\n                        return;\n                    }\n                }\n            }\n\n            // attempt to read from config file\n            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);\n\n            // if a config file wasn't specified or we were unable to read it\n            if (configurator == null) {\n                configurator = new CodegenConfigurator();\n            }\n\n            configurator.setVerbose(verbose);\n\n            if (skipOverwrite != null) {\n                configurator.setSkipOverwrite(skipOverwrite);\n            }\n\n            if (removeOperationIdPrefix != null) {\n                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);\n            }\n\n            if (skipOperationExample != null) {\n                configurator.setSkipOperationExample(skipOperationExample);\n            }\n\n            if (isNotEmpty(inputSpec)) {\n                configurator.setInputSpec(inputSpec);\n            }\n\n            if (isNotEmpty(gitHost)) {\n                configurator.setGitHost(gitHost);\n            }\n\n            if (isNotEmpty(gitUserId)) {\n                configurator.setGitUserId(gitUserId);\n            }\n\n            if (isNotEmpty(gitRepoId)) {\n                configurator.setGitRepoId(gitRepoId);\n            }\n\n            if (isNotEmpty(ignoreFileOverride)) {\n                configurator.setIgnoreFileOverride(ignoreFileOverride);\n            }\n\n            if (isNotEmpty(httpUserAgent)) {\n                configurator.setHttpUserAgent(httpUserAgent);\n            }\n\n            if (skipValidateSpec != null) {\n                configurator.setValidateSpec(!skipValidateSpec);\n            }\n\n            if (strictSpec != null) {\n                configurator.setStrictSpecBehavior(strictSpec);\n            }\n\n            if (logToStderr != null) {\n                configurator.setLogToStderr(logToStderr);\n            }\n\n            if (enablePostProcessFile != null) {\n                configurator.setEnablePostProcessFile(enablePostProcessFile);\n            }\n\n            if (generateAliasAsModel  != null) {\n                configurator.setGenerateAliasAsModel(generateAliasAsModel);\n            }\n\n            if (isNotEmpty(generatorName)) {\n                configurator.setGeneratorName(generatorName);\n            } else {\n                LOGGER.error(\""A generator name (generatorName) is required.\"");\n                throw new MojoExecutionException(\""The generator requires 'generatorName'. Refer to documentation for a list of options.\"");\n            }\n\n            configurator.setOutputDir(output.getAbsolutePath());\n\n            if (isNotEmpty(auth)) {\n                configurator.setAuth(auth);\n            }\n\n            if (isNotEmpty(apiPackage)) {\n                configurator.setApiPackage(apiPackage);\n            }\n\n            if (isNotEmpty(modelPackage)) {\n                configurator.setModelPackage(modelPackage);\n            }\n\n            if (isNotEmpty(invokerPackage)) {\n                configurator.setInvokerPackage(invokerPackage);\n            }\n\n            if (isNotEmpty(packageName)) {\n                configurator.setPackageName(packageName);\n            }\n\n            if (isNotEmpty(groupId)) {\n                configurator.setGroupId(groupId);\n            }\n\n            if (isNotEmpty(artifactId)) {\n                configurator.setArtifactId(artifactId);\n            }\n\n            if (isNotEmpty(artifactVersion)) {\n                configurator.setArtifactVersion(artifactVersion);\n            }\n\n            if (isNotEmpty(library)) {\n                configurator.setLibrary(library);\n            }\n\n            if (isNotEmpty(modelNamePrefix)) {\n                configurator.setModelNamePrefix(modelNamePrefix);\n            }\n\n            if (isNotEmpty(modelNameSuffix)) {\n                configurator.setModelNameSuffix(modelNameSuffix);\n            }\n\n            if (null != templateDirectory) {\n                configurator.setTemplateDir(templateDirectory.getAbsolutePath());\n            }\n\n            if (StringUtils.isNotEmpty(templateResourcePath)) {\n                if (null != templateDirectory) {\n                    LOGGER.warn(\""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory.\"");\n                }\n                configurator.setTemplateDir(templateResourcePath);\n            }\n\n            if (null != engine) {\n                configurator.setTemplatingEngineName(engine);\n            }\n\n            // Set generation options\n            if (null != generateApis && generateApis) {\n                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.APIS);\n            }\n\n            if (null != generateModels && generateModels) {\n                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.MODELS);\n            }\n\n            if (null != generateSupportingFiles && generateSupportingFiles) {\n                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);\n            } else {\n                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);\n            }\n\n            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());\n            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());\n            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());\n\n            if (configOptions != null) {\n                // Retained for backwards-compataibility with configOptions -> instantiation-types\n                if (instantiationTypes == null && configOptions.containsKey(\""instantiation-types\"")) {\n                    applyInstantiationTypesKvp(configOptions.get(\""instantiation-types\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compatibility with configOptions -> import-mappings\n                if (importMappings == null && configOptions.containsKey(\""import-mappings\"")) {\n                    applyImportMappingsKvp(configOptions.get(\""import-mappings\"").toString(),\n                            configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> type-mappings\n                if (typeMappings == null && configOptions.containsKey(\""type-mappings\"")) {\n                    applyTypeMappingsKvp(configOptions.get(\""type-mappings\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> language-specific-primitives\n                if (languageSpecificPrimitives == null && configOptions.containsKey(\""language-specific-primitives\"")) {\n                    applyLanguageSpecificPrimitivesCsv(configOptions\n                            .get(\""language-specific-primitives\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> additional-properties\n                if (additionalProperties == null && configOptions.containsKey(\""additional-properties\"")) {\n                    applyAdditionalPropertiesKvp(configOptions.get(\""additional-properties\"").toString(),\n                            configurator);\n                }\n\n                if (serverVariableOverrides == null && configOptions.containsKey(\""server-variables\"")) {\n                    applyServerVariablesKvp(configOptions.get(\""server-variables\"").toString(), configurator);\n                }\n\n                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings\n                if (reservedWordsMappings == null && configOptions.containsKey(\""reserved-words-mappings\"")) {\n                    applyReservedWordsMappingsKvp(configOptions.get(\""reserved-words-mappings\"")\n                            .toString(), configurator);\n                }\n            }\n\n            // Apply Instantiation Types\n            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(\""instantiation-types\""))) {\n                applyInstantiationTypesKvpList(instantiationTypes, configurator);\n            }\n\n            // Apply Import Mappings\n            if (importMappings != null && (configOptions == null || !configOptions.containsKey(\""import-mappings\""))) {\n                applyImportMappingsKvpList(importMappings, configurator);\n            }\n\n            // Apply Type Mappings\n            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(\""type-mappings\""))) {\n                applyTypeMappingsKvpList(typeMappings, configurator);\n            }\n\n            // Apply Language Specific Primitives\n            if (languageSpecificPrimitives != null\n                    && (configOptions == null || !configOptions.containsKey(\""language-specific-primitives\""))) {\n                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);\n            }\n\n            // Apply Additional Properties\n            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(\""additional-properties\""))) {\n                applyAdditionalPropertiesKvpList(additionalProperties, configurator);\n            }\n\n            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(\""server-variables\""))) {\n                applyServerVariablesKvpList(serverVariableOverrides, configurator);\n            }\n\n            // Apply Reserved Words Mappings\n            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(\""reserved-words-mappings\""))) {\n                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);\n            }\n\n            if (globalProperties == null) {\n                globalProperties = new HashMap<>();\n            }\n\n            if (environmentVariables != null && environmentVariables.size() > 0) {\n                globalProperties.putAll(environmentVariables);\n                getLog().warn(\""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead.\"");\n            }\n\n            for (String key : globalProperties.keySet()) {\n                String value = globalProperties.get(key);\n                if (value != null) {\n                    configurator.addGlobalProperty(key, value);\n                }\n            }\n\n            final ClientOptInput input = configurator.toClientOptInput();\n            final CodegenConfig config = input.getConfig();\n\n            if (configOptions != null) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    if (configOptions.containsKey(langCliOption.getOpt())) {\n                        input.getConfig().additionalProperties()\n                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));\n                    }\n                }\n            }\n\n            if (configHelp) {\n                for (CliOption langCliOption : config.cliOptions()) {\n                    System.out.println(\""\\t\"" + langCliOption.getOpt());\n                    System.out.println(\""\\t    \""\n                            + langCliOption.getOptionHelp().replaceAll(\""\\n\"", \""\\n\\t    \""));\n                    System.out.println();\n                }\n                return;\n            }\n            adjustAdditionalProperties(config);\n            new DefaultGenerator().opts(input).generate();\n\n            if (buildContext != null) {\n                buildContext.refresh(new File(getCompileSourceRoot()));\n            }\n\n            // Store a checksum of the input spec\n            File storedInputSpecHashFile = getHashFile(inputSpecFile);\n            String inputSpecHash = calculateInputSpecHash(inputSpecFile);\n\n            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {\n                File parent = new File(storedInputSpecHashFile.getParent());\n                parent.mkdirs();\n            }\n            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);\n\n        } catch (Exception e) {\n            // Maven logs exceptions thrown by plugins only if invoked with -e\n            // I find it annoying to jump through hoops to get basic diagnostic information,\n            // so let's log it in any case:\n            if (buildContext != null) {\n                buildContext.addMessage(inputSpecFile, 0, 0, \""unexpected error in Open-API generation\"", BuildContext.SEVERITY_WARNING, e);\n            }\n            getLog().error(e);\n            throw new MojoExecutionException(\n                    \""Code generation failed. See above for the full exception.\"");\n        }\n    }\n"", ""caller_start"": 436, ""file_path"": ""modules/openapi-generator-maven-plugin/src/main/java/org/openapitools/codegen/plugin/CodeGenMojo.java""}]}]","The root cause is the use of `File.createTempFile` (line 791) in `calculateInputSpecHash` to create temporary files during remote spec downloads. This method lacks secure file-creation guarantees (e.g., atomic creation, restricted permissions) compared to `Files.createTempFile`. The insecure temp file is written via `FileOutputStream` (line 804), but no deletion logic exists in the function or its callers. The trigger occurs when `inputSpecRemoteUrl` is non-null, leading to temp file creation during remote spec downloads.",0.95,./github/other_context/CVE-2021-21429
20,CVE-2021-39365,CWE-295,c_cpp,"In GNOME grilo though 0.3.13, grl-net-wc.c does not enable TLS certificate verification on the SoupSessionAsync objects it creates, leaving users vulnerable to network MITM attacks. NOTE: this is similar to CVE-2016-20011.",https://github.com/GNOME/grilo/commit/cd2472e506dafb1bb8ae510e34ad4797f63e263e,"net: Fix TLS cert validation not being done for any network call\n\nThe default SoupSessionAsync behaviour does not perform any TLS certificate\nvalidation, unless the ssl-use-system-ca-file property is set to true.\n\nSee https://blogs.gnome.org/mcatanzaro/2021/05/25/reminder-soupsessionsync-and-soupsessionasync-default-to-no-tls-certificate-verification/\n\nThis mitigates CVE-2016-20011.\n\nCloses: #146",1,"[{""func_name"": ""grl_net_wc_init"", ""file_path"": ""libs/net/grl-net-wc.c"", ""func_code"": ""static void\ngrl_net_wc_init (GrlNetWc *wc)\n{\n  GRL_LOG_DOMAIN_INIT (wc_log_domain, \""wc\"");\n\n  wc->priv = grl_net_wc_get_instance_private (wc);\n\n  wc->priv->session = soup_session_async_new ();\n  wc->priv->pending = g_queue_new ();\n\n  set_thread_context (wc);\n  init_mock_requester (wc);\n  init_requester (wc);\n}"", ""target"": 0}]","[{""func_name"": ""grl_net_wc_init"", ""file_path"": ""libs/net/grl-net-wc.c"", ""func_code"": ""static void\ngrl_net_wc_init (GrlNetWc *wc)\n{\n  GRL_LOG_DOMAIN_INIT (wc_log_domain, \""wc\"");\n\n  wc->priv = grl_net_wc_get_instance_private (wc);\n\n  wc->priv->session = soup_session_async_new ();\n  g_object_set (G_OBJECT (wc->priv->session), \""ssl-use-system-ca-file\"", TRUE, NULL);\n  wc->priv->pending = g_queue_new ();\n\n  set_thread_context (wc);\n  init_mock_requester (wc);\n  init_requester (wc);\n}""}]",{},[],"In grl_net_wc_init(), the SoupSessionAsync object was created without enabling TLS certificate validation via 'ssl-use-system-ca-file'. This left network calls unsecured (grl-net-wc.c:315). The patch explicitly sets this property to TRUE, ensuring validation.",0.95,./github/other_context/CVE-2021-39365
21,CVE-2021-39359,CWE-295,c_cpp,"In GNOME libgda through 6.0.0, gda-web-provider.c does not enable TLS certificate verification on the SoupSessionSync objects it creates, leaving users vulnerable to network MITM attacks. NOTE: this is similar to CVE-2016-20011.",https://github.com/GNOME/libgda/commit/bebdffb4de586fb43fd07ac549121f4b22f6812d,"Fix CVE-2021-39359 by forcing TLS certificate validation\n\nThis was done by adding ""ssl-use-system-ca-file"", TRUE to the options\nfor each soup_session_new_with_options() call that was made.\n\nTested on Linux From Scratch 11.0 and Debian 11.\n\nFixes #249",1,"[{""func_name"": ""gda_web_provider_open_connection"", ""file_path"": ""providers/web/gda-web-provider.c"", ""func_code"": ""static gboolean\ngda_web_provider_open_connection (GdaServerProvider *provider, GdaConnection *cnc,\n\t\t\t\t  GdaQuarkList *params, GdaQuarkList *auth)\n{\n\tg_return_val_if_fail (GDA_IS_WEB_PROVIDER (provider), FALSE);\n\tg_return_val_if_fail (GDA_IS_CONNECTION (cnc), FALSE);\n\n\t/* Check for connection parameters */\n\tconst gchar *db_name, *host, *path, *port, *serversecret, *pass = NULL, *use_ssl;\n\n\tif (auth)\n\t\tpass = gda_quark_list_find (auth, \""PASSWORD\"");\n\tif (!pass) {\n\t\tgda_connection_add_event_string (cnc, _(\""The connection string must contain the %s value\""), \""PASSWORD\"");\n                return FALSE;\n\t}\n\thost = gda_quark_list_find (params, \""HOST\"");\n\tif (!host) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\""The connection string must contain the %s value\""), \""HOST\"");\n\t\treturn FALSE;\n\t}\n\tserversecret = gda_quark_list_find (params, \""SECRET\"");\n\tif (!serversecret) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\""The connection string must contain the %s value\""), \""SECRET\"");\n\t\treturn FALSE;\n\t}\n\tpath = gda_quark_list_find (params, \""PATH\"");\n\tport = gda_quark_list_find (params, \""PORT\"");\n\tdb_name = gda_quark_list_find (params, \""DB_NAME\"");\n\tif (!db_name) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\""The connection string must contain the %s value\""), \""DB_NAME\"");\n\t\treturn FALSE;\n\t}\n\tuse_ssl = gda_quark_list_find (params, \""USE_SSL\"");\n\tif (use_ssl && (*use_ssl != 'T') && (*use_ssl != 't'))\n\t\tuse_ssl = NULL;\n\t\n\t/* open Libsoup session */\n\tWebConnectionData *cdata;\n\tGString *server_url;\n\n\tcdata = g_new0 (WebConnectionData, 1);\n\tg_rec_mutex_init (& (cdata->mutex));\n\tcdata->server_id = NULL;\n\tcdata->forced_closing = FALSE;\n\tcdata->worker_session = soup_session_new ();\n\tcdata->front_session = soup_session_new_with_options (\""max-conns-per-host\"", 1, NULL);\n\tif (use_ssl) {\n\t\tserver_url = g_string_new (\""https://\"");\n\t\tg_print (\""USING SSL\\n\"");\n\t}\n\telse\n\t\tserver_url = g_string_new (\""http://\"");\n\tg_string_append (server_url, host);\n\tif (port)\n\t\tg_string_append_printf (server_url, \"":%s\"", port);\n\tif (path)\n\t\tg_string_append_printf (server_url, \""/%s\"", path);\n\tcdata->front_url = g_strdup_printf (\""%s/gda-front.php\"", server_url->str);\n\tcdata->worker_url = g_strdup_printf (\""%s/gda-worker.php\"", server_url->str);\n\tcdata->server_base_url = g_string_free (server_url, FALSE);\n\tif (serversecret)\n\t\tcdata->key = g_strdup (serversecret);\n\tgda_connection_internal_set_provider_data (cnc, (GdaServerProviderConnectionData*) cdata, (GDestroyNotify) _gda_web_free_cnc_data);\n\n\t/*\n\t * perform setup\n\t */\n\tif (! do_server_setup (cnc, cdata))\n\t\treturn FALSE;\n\n\t/*\n\t * send HELLO\n\t */\n\txmlDocPtr doc;\n\tgchar status;\n#define HELLO_MSG \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\"" standalone=\\\""no\\\""?>\\n\"" \\\n\t\t\""<request>\\n\""\t\t\t\t\t\t\\\n\t\t\""  <cmd>HELLO</cmd>\\n\""\t\t\t\t\t\\\n\t\t\""</request>\""\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_HELLO, HELLO_MSG, NULL, &status);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * send CONNECT\n\t */\n\tgchar *tmp, *token;\n#define CONNECT_MSG \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\"" standalone=\\\""no\\\""?>\"" \\\n\t\t\""<request>\\n\""\t\t\t\t\t\t\\\n\t\t\""  <token>%s</token>\\n\""\t\t\t\t\t\\\n\t\t\""  <cmd>CONNECT</cmd>\\n\""\t\t\t\t\\\n\t\t\""</request>\""\n\tif (cdata->key)\n\t\tg_free (cdata->key);\n\tcdata->key = g_strdup_printf (\""%s/AND/%s\"", db_name, pass);\n\t\n\ttoken = _gda_web_compute_token (cdata);\n\ttmp = g_strdup_printf (CONNECT_MSG, token);\n\tg_free (token);\n\n\tcdata->server_secret = g_strdup (serversecret);\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_CONNECT, tmp, serversecret, &status);\n\tg_free (tmp);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * change key: cdata->key = MD5(cdata->key)\n\t */\n\tgchar *md5str;\n\tmd5str = g_compute_checksum_for_data (G_CHECKSUM_MD5, (const guchar*) cdata->key, strlen (cdata->key));\n\tg_free (cdata->key);\n\tcdata->key = md5str;\n\n\treturn TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""gda_web_provider_open_connection"", ""file_path"": ""providers/web/gda-web-provider.c"", ""func_code"": ""static gboolean\ngda_web_provider_open_connection (GdaServerProvider *provider, GdaConnection *cnc,\n\t\t\t\t  GdaQuarkList *params, GdaQuarkList *auth)\n{\n\tg_return_val_if_fail (GDA_IS_WEB_PROVIDER (provider), FALSE);\n\tg_return_val_if_fail (GDA_IS_CONNECTION (cnc), FALSE);\n\n\t/* Check for connection parameters */\n\tconst gchar *db_name, *host, *path, *port, *serversecret, *pass = NULL, *use_ssl;\n\n\tif (auth)\n\t\tpass = gda_quark_list_find (auth, \""PASSWORD\"");\n\tif (!pass) {\n\t\tgda_connection_add_event_string (cnc, _(\""The connection string must contain the %s value\""), \""PASSWORD\"");\n                return FALSE;\n\t}\n\thost = gda_quark_list_find (params, \""HOST\"");\n\tif (!host) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\""The connection string must contain the %s value\""), \""HOST\"");\n\t\treturn FALSE;\n\t}\n\tserversecret = gda_quark_list_find (params, \""SECRET\"");\n\tif (!serversecret) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\""The connection string must contain the %s value\""), \""SECRET\"");\n\t\treturn FALSE;\n\t}\n\tpath = gda_quark_list_find (params, \""PATH\"");\n\tport = gda_quark_list_find (params, \""PORT\"");\n\tdb_name = gda_quark_list_find (params, \""DB_NAME\"");\n\tif (!db_name) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\""The connection string must contain the %s value\""), \""DB_NAME\"");\n\t\treturn FALSE;\n\t}\n\tuse_ssl = gda_quark_list_find (params, \""USE_SSL\"");\n\tif (use_ssl && (*use_ssl != 'T') && (*use_ssl != 't'))\n\t\tuse_ssl = NULL;\n\t\n\t/* open Libsoup session */\n\tWebConnectionData *cdata;\n\tGString *server_url;\n\n\tcdata = g_new0 (WebConnectionData, 1);\n\tg_rec_mutex_init (& (cdata->mutex));\n\tcdata->server_id = NULL;\n\tcdata->forced_closing = FALSE;\n\tcdata->worker_session = soup_session_new_with_options (\""ssl-use-system-ca-file\"", TRUE, NULL);\n\tcdata->front_session = soup_session_new_with_options (\""max-conns-per-host\"", 1, \""ssl-use-system-ca-file\"", TRUE, NULL);\n\tif (use_ssl) {\n\t\tserver_url = g_string_new (\""https://\"");\n\t\tg_print (\""USING SSL\\n\"");\n\t}\n\telse\n\t\tserver_url = g_string_new (\""http://\"");\n\tg_string_append (server_url, host);\n\tif (port)\n\t\tg_string_append_printf (server_url, \"":%s\"", port);\n\tif (path)\n\t\tg_string_append_printf (server_url, \""/%s\"", path);\n\tcdata->front_url = g_strdup_printf (\""%s/gda-front.php\"", server_url->str);\n\tcdata->worker_url = g_strdup_printf (\""%s/gda-worker.php\"", server_url->str);\n\tcdata->server_base_url = g_string_free (server_url, FALSE);\n\tif (serversecret)\n\t\tcdata->key = g_strdup (serversecret);\n\tgda_connection_internal_set_provider_data (cnc, (GdaServerProviderConnectionData*) cdata, (GDestroyNotify) _gda_web_free_cnc_data);\n\n\t/*\n\t * perform setup\n\t */\n\tif (! do_server_setup (cnc, cdata))\n\t\treturn FALSE;\n\n\t/*\n\t * send HELLO\n\t */\n\txmlDocPtr doc;\n\tgchar status;\n#define HELLO_MSG \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\"" standalone=\\\""no\\\""?>\\n\"" \\\n\t\t\""<request>\\n\""\t\t\t\t\t\t\\\n\t\t\""  <cmd>HELLO</cmd>\\n\""\t\t\t\t\t\\\n\t\t\""</request>\""\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_HELLO, HELLO_MSG, NULL, &status);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * send CONNECT\n\t */\n\tgchar *tmp, *token;\n#define CONNECT_MSG \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\"" standalone=\\\""no\\\""?>\"" \\\n\t\t\""<request>\\n\""\t\t\t\t\t\t\\\n\t\t\""  <token>%s</token>\\n\""\t\t\t\t\t\\\n\t\t\""  <cmd>CONNECT</cmd>\\n\""\t\t\t\t\\\n\t\t\""</request>\""\n\tif (cdata->key)\n\t\tg_free (cdata->key);\n\tcdata->key = g_strdup_printf (\""%s/AND/%s\"", db_name, pass);\n\t\n\ttoken = _gda_web_compute_token (cdata);\n\ttmp = g_strdup_printf (CONNECT_MSG, token);\n\tg_free (token);\n\n\tcdata->server_secret = g_strdup (serversecret);\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_CONNECT, tmp, serversecret, &status);\n\tg_free (tmp);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * change key: cdata->key = MD5(cdata->key)\n\t */\n\tgchar *md5str;\n\tmd5str = g_compute_checksum_for_data (G_CHECKSUM_MD5, (const guchar*) cdata->key, strlen (cdata->key));\n\tg_free (cdata->key);\n\tcdata->key = md5str;\n\n\treturn TRUE;\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:gda-web-provider.c, value:use_ssl)"", ""result"": {""value_trace"": [{""full_code"": ""use_ssl = gda_quark_list_find (params, \""USE_SSL\"")"", ""line"": 346, ""func_name"": ""gda_web_provider_open_connection""}, {""full_code"": ""use_ssl = NULL"", ""line"": 348, ""func_name"": ""gda_web_provider_open_connection""}], ""struct_var"": ""use_ssl"", ""struct_type"": ""gchar*"", ""struct_definition"": ""gchar""}}]","providers/web/gda-web-provider.c:356-357: Original code created SoupSession objects without SSL validation options. The 'use_ssl' variable (set at 346-348) determines if SSL is used, but no certificate validation was enforced. Patch adds 'ssl-use-system-ca-file', TRUE to both worker_session and front_session. GAP: 'gda_quark_list_find' logic is not traced, but 'use_ssl' is initialized to NULL and set based on 'USE_SSL' in parameters.",0.95,./github/other_context/CVE-2021-39359
22,CVE-2022-0336,CWE-276,c_cpp,"The Samba AD DC includes checks when adding service principals names (SPNs) to an account to ensure that SPNs do not alias with those already in the database. Some of these checks are able to be bypassed if an account modification re-adds an SPN that was previously present on that account, such as one added when a computer is joined to a domain. An attacker who has the ability to write to an account can exploit this to perform a denial-of-service attack by adding an SPN that matches an existing service. Additionally, an attacker who can intercept traffic can impersonate existing services, resulting in a loss of confidentiality and integrity.",https://github.com/samba-team/samba/commit/1a5dc817c0c9379bbaab14c676681b42b0039a3c,"CVE-2022-0336: s4/dsdb/samldb: Don't return early when an SPN is re-added to an object\n\nIf an added SPN already exists on an object, we still want to check the\nrest of the element values for conflicts.\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=14950\n\nSigned-off-by: Joseph Sutton <josephsutton@catalyst.net.nz>\nReviewed-by: Douglas Bagnall <douglas.bagnall@catalyst.net.nz>",1,"[{""func_name"": ""samldb_spn_uniqueness_check"", ""file_path"": ""source4/dsdb/samdb/ldb_modules/samldb.c"", ""func_code"": ""static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \""samldb: spn[%s] invalid with %u components\"",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\""SPN %s re-added to the same object\\n\"", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\""SPN %s failed direct uniqueness check\\n\"", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t/* we have no sPNMappings, hence no aliases */\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\""SPN %s failed alias uniqueness check\\n\"", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\""SPN %s seems to be unique\\n\"", spn);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}"", ""target"": 0}]","[{""func_name"": ""samldb_spn_uniqueness_check"", ""file_path"": ""source4/dsdb/samdb/ldb_modules/samldb.c"", ""func_code"": ""static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \""samldb: spn[%s] invalid with %u components\"",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\""SPN %s re-added to the same object\\n\"", spn);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\""SPN %s failed direct uniqueness check\\n\"", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t/* we have no sPNMappings, hence no aliases */\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\""SPN %s failed alias uniqueness check\\n\"", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\""SPN %s seems to be unique\\n\"", spn);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}""}]","{""caller"": 1, ""code"": 3}","[{""source"": ""caller_info(file:samldb.c, func:samldb_spn_uniqueness_check)"", ""result"": [{""call_line"": 4852, ""call_code"": ""samldb_spn_uniqueness_check(ac, el)"", ""caller_code"": ""static int samldb_add(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tstruct ldb_message_element *el;\n\tint ret;\n\tchar *referral = NULL;\n\n\tldb = ldb_module_get_ctx(module);\n\tldb_debug(ldb, LDB_DEBUG_TRACE, \""samldb_add\\n\"");\n\n\t/* do not manipulate our control entries */\n\tif (ldb_dn_is_special(req->op.add.message->dn)) {\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\treferral = refer_if_rodc(ldb, req, req->op.add.message->dn);\n\tif (referral != NULL) {\n\t\tret = ldb_module_send_referral(req, referral);\n\t\treturn ret;\n\t}\n\n\tel = ldb_msg_find_element(req->op.add.message, \""userParameters\"");\n\tif (el != NULL && ldb_req_is_untrusted(req)) {\n\t\tconst char *reason = \""samldb_add: \""\n\t\t\t\""setting userParameters is not supported over LDAP, \""\n\t\t\t\""see https://bugzilla.samba.org/show_bug.cgi?id=8077\"";\n\t\tldb_debug(ldb, LDB_DEBUG_WARNING, \""%s\"", reason);\n\t\treturn ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);\n\t}\n\n\tac = samldb_ctx_init(module, req);\n\t..."", ""caller_start"": 4787, ""file_path"": ""source4/dsdb/samdb/ldb_modules/samldb.c""}, {""call_line"": 5229, ""call_code"": ""samldb_spn_uniqueness_check(ac, el)"", ""caller_code"": ""static int samldb_modify(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tstruct ldb_message_element *el, *el2;\n\tstruct ldb_control *is_undelete;\n\tbool modified = false;\n\tint ret;\n\n\tif (ldb_dn_is_special(req->op.mod.message->dn)) {\n\t\t/* do not manipulate our control entries */\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\tldb = ldb_module_get_ctx(module);\n\n\t/*\n\t * we are going to need some special handling if in Undelete call.\n\t * Since tombstone_reanimate module will restore certain attributes,\n\t * we need to relax checks for: sAMAccountType, primaryGroupID\n\t */\n\tis_undelete = ldb_request_get_control(req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID);\n\n\t/* make sure that \""objectSid\"" is not specified */\n\tel = ldb_msg_find_element(req->op.mod.message, \""objectSid\"");\n\tif (el != NULL) {\n\t\tif (ldb_request_get_control(req, LDB_CONTROL_PROVISION_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \""samldb: objectSid must not be specified!\"");\n\t\t\tretu..."", ""caller_start"": 4974, ""file_path"": ""source4/dsdb/samdb/ldb_modules/samldb.c""}]}, {""source"": ""code_info(file:samldb.c, lines:4000-4020)"", ""result"": ""\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\""SPN %s re-added to the same object\\n\"", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\""SPN %s failed direct uniqueness check\\n\"", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n""}, {""source"": ""code_info(file:samldb.c, lines:4830-4870)"", ""result"": ""\t}\n\n\tret = samldb_check_sensitive_attributes(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(ac);\n\t\treturn ret;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \""fSMORoleOwner\"");\n\tif (el != NULL) {\n\t\tret = samldb_fsmo_role_owner_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \""servicePrincipalName\"");\n\tif ((el != NULL)) {\n\t\t/*\n\t\t * We need to check whether the SPN collides with an existing\n\t\t * one (anywhere) including via aliases.\n\t\t */\n\t\tret = samldb_spn_uniqueness_check(ac, el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \""objectclass\"", \""user\"") != NULL) {\n\t\tac->type = SAMLDB_TYPE_USER;\n\n\t\tret = samldb_prim_group_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = samldb_objectclass_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n""}, {""source"": ""code_info(file:samldb.c, lines:5200-5250)"", ""result"": ""\t}\n\n\tel = ldb_msg_find_element(ac->msg, \""dNSHostName\"");\n\tel2 = ldb_msg_find_element(ac->msg, \""sAMAccountName\"");\n\tif ((el != NULL) || (el2 != NULL)) {\n\t\tmodified = true;\n\t\t/*\n\t\t * samldb_service_principal_names_change() might add SPN\n\t\t * changes to the request, so this must come before the SPN\n\t\t * uniqueness check below.\n\t\t *\n\t\t * Note we ALSO have to do the SPN uniqueness check inside\n\t\t * samldb_service_principal_names_change(), because it does a\n\t\t * subrequest to do requested SPN modifications *before* its\n\t\t * automatic ones are added.\n\t\t */\n\t\tret = samldb_service_principal_names_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \""servicePrincipalName\"");\n\tif ((el != NULL)) {\n\t\t/*\n\t\t * We need to check whether the SPN collides with an existing\n\t\t * one (anywhere) including via aliases.\n\t\t */\n\t\tmodified = true;\n\t\tret = samldb_spn_uniqueness_check(ac, el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \""fSMORoleOwner\"");\n\tif (el != NULL) {\n\t\tret = samldb_fsmo_role_owner_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (modified) {\n\t\tstruct ldb_request *child_req;\n\n\t\t/* Now perform the real modifications as a child request */\n\t\tret = ldb_build_mod_req(&child_req, ldb, ac,\n\t\t\t\t\tac->msg,\n\t\t\t\t\treq->controls,\n\t\t\t\t\treq, dsdb_next_callback,\n\t\t\t\t\treq);\n""}]","The vulnerability arises from an early return (LDB_SUCCESS) in samldb_spn_uniqueness_check when an SPN is re-added (source4/dsdb/samdb/ldb_modules/samldb.c:4007-4009), bypassing further uniqueness checks. The function is invoked during LDAP add/modify operations via samldb_add (line 4852) and samldb_modify (line 5229). SPN values are extracted into 'el' via ldb_msg_find_element in these functions (lines 4830-4870 and 5200-5250), which retrieves the 'servicePrincipalName' attribute from the LDAP message. The patch replaces the early return with 'continue' to ensure all SPNs are checked, closing the bypass.",1.0,./github/other_context/CVE-2022-0336
23,CVE-2022-25299,CWE-552,c_cpp,This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.,https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945,Protect against the directory traversal in mg_upload(),2,"[{""func_name"": ""mg_http_upload"", ""file_path"": ""src/http.c"", ""func_code"": ""int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \""\"", name[200] = \""\"", path[256];\n  mg_http_get_var(&hm->query, \""offset\"", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \""name\"", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \""\"", \""%s\"", \""name required\"");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \""%s%c%s\"", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\""%p %d bytes @ %d [%s]\"", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \""wb\"" : \""ab\"")) == NULL) {\n      mg_http_reply(c, 400, \""\"", \""fopen(%s): %d\"", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \""\"", \""\"");\n      return (int) hm->body.len;\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""mg_http_upload"", ""file_path"": ""mongoose.c"", ""func_code"": ""int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \""\"", name[200] = \""\"", path[256];\n  mg_http_get_var(&hm->query, \""offset\"", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \""name\"", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \""\"", \""%s\"", \""name required\"");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \""%s%c%s\"", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\""%p %d bytes @ %d [%s]\"", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \""wb\"" : \""ab\"")) == NULL) {\n      mg_http_reply(c, 400, \""\"", \""fopen(%s): %d\"", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \""\"", \""\"");\n      return (int) hm->body.len;\n    }\n  }\n}"", ""target"": 0}]","[{""func_name"": ""mg_http_upload"", ""file_path"": ""src/http.c"", ""func_code"": ""int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \""\"", name[200] = \""\"", path[256];\n  mg_http_get_var(&hm->query, \""offset\"", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \""name\"", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \""\"", \""%s\"", \""name required\"");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \""%s%c%s\"", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\""%d bytes @ %ld [%s]\"", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \""wb\"" : \""ab\"")) == NULL) {\n      mg_http_reply(c, 400, \""\"", \""fopen(%s): %d\"", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \""\"", \""\"");\n      return (int) hm->body.len;\n    }\n  }\n}""}, {""func_name"": ""mg_http_upload"", ""file_path"": ""mongoose.c"", ""func_code"": ""int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \""\"", name[200] = \""\"", path[256];\n  mg_http_get_var(&hm->query, \""offset\"", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \""name\"", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \""\"", \""%s\"", \""name required\"");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \""%s%c%s\"", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\""%d bytes @ %ld [%s]\"", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \""wb\"" : \""ab\"")) == NULL) {\n      mg_http_reply(c, 400, \""\"", \""fopen(%s): %d\"", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \""\"", \""\"");\n      return (int) hm->body.len;\n    }\n  }\n}""}]","{""value"": 2, ""function"": 8, ""code"": 3}","[{""source"": ""value_info(file:http.c, value:name)"", ""result"": {""value_trace"": [{""full_code"": ""part->name = part->filename = part->body = mg_str_n(0, 0)"", ""line"": 30, ""func_name"": ""mg_http_next_multipart<duplicate>2""}, {""full_code"": ""part->name = mg_http_get_header_var(v, mg_str_n(\""name\"", 4))"", ""line"": 47, ""func_name"": ""mg_http_next_multipart<duplicate>2""}, {""full_code"": ""part->filename = mg_http_get_header_var(v, mg_str_n(\""filename\"", 8))"", ""line"": 48, ""func_name"": ""mg_http_next_multipart<duplicate>2""}], ""struct_var"": ""name"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:mongoose.c, value:name)"", ""result"": {""value_trace"": [{""full_code"": ""part->name = part->filename = part->body = mg_str_n(0, 0)"", ""line"": 794, ""func_name"": ""mg_http_next_multipart<duplicate>1""}, {""full_code"": ""part->name = mg_http_get_header_var(v, mg_str_n(\""name\"", 4))"", ""line"": 811, ""func_name"": ""mg_http_next_multipart<duplicate>1""}, {""full_code"": ""part->filename = mg_http_get_header_var(v, mg_str_n(\""filename\"", 8))"", ""line"": 812, ""func_name"": ""mg_http_next_multipart<duplicate>1""}], ""struct_var"": ""name"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:remove_double_dots)"", ""result"": [{""code"": ""static void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}"", ""start_line"": 1439, ""end_line"": 1457, ""full_name"": ""remove_double_dots"", ""file_path"": ""examples/esp32/main/mongoose.c""}, {""code"": ""static void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}"", ""start_line"": 1439, ""end_line"": 1457, ""full_name"": ""remove_double_dots<duplicate>0"", ""file_path"": ""examples/esp8266/src/main/mongoose.c""}, {""code"": ""static void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}"", ""start_line"": 1439, ""end_line"": 1457, ""full_name"": ""remove_double_dots<duplicate>1"", ""file_path"": ""mongoose.c""}]}, {""source"": ""func_info(file:http.c, func:mg_http_get_header_var)"", ""result"": [{""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 823, ""end_line"": 838, ""full_name"": ""mg_http_get_header_var<duplicate>2"", ""file_path"": ""src/http.c""}]}, {""source"": ""func_info(file:mongoose.c, func:mg_http_get_header_var)"", ""result"": [{""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 1587, ""end_line"": 1602, ""full_name"": ""mg_http_get_header_var<duplicate>1"", ""file_path"": ""mongoose.c""}]}, {""source"": ""code_info(file:mongoose.c, lines:1439-1457)"", ""result"": ""static void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\n""}, {""source"": ""func_info(file:http.c, func:mg_http_get_header_var)"", ""result"": [{""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 823, ""end_line"": 838, ""full_name"": ""mg_http_get_header_var<duplicate>2"", ""file_path"": ""src/http.c""}]}, {""source"": ""func_info(file:mongoose.c, func:mg_http_get_header_var)"", ""result"": [{""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 1587, ""end_line"": 1602, ""full_name"": ""mg_http_get_header_var<duplicate>1"", ""file_path"": ""mongoose.c""}]}, {""source"": ""code_info(file:mongoose.c, lines:1439-1457)"", ""result"": ""static void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\n""}, {""source"": ""code_info(file:mongoose.c, lines:1439-1457)"", ""result"": ""static void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\n""}, {""source"": ""func_info(func:mg_http_get_header_var)"", ""result"": [{""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 1587, ""end_line"": 1602, ""full_name"": ""mg_http_get_header_var"", ""file_path"": ""examples/esp32/main/mongoose.c""}, {""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 1587, ""end_line"": 1602, ""full_name"": ""mg_http_get_header_var<duplicate>0"", ""file_path"": ""examples/esp8266/src/main/mongoose.c""}, {""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 1587, ""end_line"": 1602, ""full_name"": ""mg_http_get_header_var<duplicate>1"", ""file_path"": ""mongoose.c""}]}, {""source"": ""func_info(file:http.c, func:mg_http_get_header_var)"", ""result"": [{""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 823, ""end_line"": 838, ""full_name"": ""mg_http_get_header_var<duplicate>2"", ""file_path"": ""src/http.c""}]}, {""source"": ""func_info(file:mongoose.c, func:mg_http_get_header_var)"", ""result"": [{""code"": ""struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\""' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\""' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\""[%.*s] [%.*s] [%.*s]\"", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}"", ""start_line"": 1587, ""end_line"": 1602, ""full_name"": ""mg_http_get_header_var<duplicate>1"", ""file_path"": ""mongoose.c""}]}]","1. 'name' is derived from HTTP multipart 'filename' header via mg_http_get_header_var (src/http.c:823, mongoose.c:1587) without sanitization.\n2. 'name' is concatenated into the path via snprintf (src/http.c:1154, mongoose.c:1154) as '%s%c%s'.\n3. remove_double_dots (mongoose.c:1439-1457) is applied post-concatenation but skips leading '..' sequences and encoded traversal patterns.\n4. Unsanitized 'name' with traversal sequences (e.g., '../') bypasses remove_double_dots' basic sanitization, enabling arbitrary file writes.",0.95,./github/other_context/CVE-2022-25299
24,CVE-2022-25640,CWE-295,c_cpp,"In wolfSSL before 5.2.0, a TLS 1.3 server cannot properly enforce a requirement for mutual authentication. A client can simply omit the certificate_verify message from the handshake, and never present a certificate.",https://github.com/wolfSSL/wolfssl/commit/3cdb1c639da94a9dc8c75590d0ec475e7f27c226,Improve the client certificate checking logic. Make sure calling `wolfSSL_CTX_mutual_auth` is also checked.,3,"[{""func_name"": ""DoTls13Finished"", ""file_path"": ""src/tls13.c"", ""func_code"": ""int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\""DoTls13Finished\"");\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \""Finished\"");\n    if (ssl->toInfoOn) AddLateName(\""Finished\"", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\""Verify finished error on hashes\"");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\""DoTls13Finished\"", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""DoCertFatalAlert"", ""file_path"": ""src/internal.c"", ""func_code"": ""static void DoCertFatalAlert(WOLFSSL* ssl, int ret)\n{\n    int alertWhy;\n    if (ssl == NULL || ret == 0) {\n        return;\n    }\n    WOLFSSL_ERROR(ret);\n\n    /* Determine alert reason */\n    alertWhy = bad_certificate;\n    if (ret == ASN_AFTER_DATE_E || ret == ASN_BEFORE_DATE_E) {\n        alertWhy = certificate_expired;\n    } else if (ret == ASN_NO_SIGNER_E) {\n        alertWhy = unknown_ca;\n    }\n#if (defined(OPENSSL_ALL) || defined(WOLFSSL_APACHE_HTTPD))\n    else if (ret == CRL_CERT_REVOKED) {\n        alertWhy = certificate_revoked;\n    }\n#endif\n    else if (ret == NO_PEER_CERT) {\n#ifdef WOLFSSL_TLS13\n        if (ssl->options.tls1_3) {\n            alertWhy = certificate_required;\n        }\n        else\n#endif\n        {\n            alertWhy = handshake_failure;\n        }\n    }\n\n    /* send fatal alert and mark connection closed */\n    SendAlert(ssl, alert_fatal, alertWhy); /* try to send */\n    ssl->options.isClosed = 1;\n}"", ""target"": 0}, {""func_name"": ""DoTls13Finished"", ""file_path"": ""src/tls13.c"", ""func_code"": ""int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\""DoTls13Finished\"");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n            ret = NO_PEER_CERT;\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \""Finished\"");\n    if (ssl->toInfoOn) AddLateName(\""Finished\"", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\""Verify finished error on hashes\"");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\""DoTls13Finished\"", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""DoTls13Finished"", ""file_path"": ""src/tls13.c"", ""func_code"": ""int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\""DoTls13Finished\"");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n            ret = NO_PEER_CERT;\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \""Finished\"");\n    if (ssl->toInfoOn) AddLateName(\""Finished\"", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\""Verify finished error on hashes\"");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\""DoTls13Finished\"", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}""}, {""func_name"": ""DoCertFatalAlert"", ""file_path"": ""src/internal.c"", ""func_code"": ""void DoCertFatalAlert(WOLFSSL* ssl, int ret)\n{\n    int alertWhy;\n    if (ssl == NULL || ret == 0) {\n        return;\n    }\n    WOLFSSL_ERROR(ret);\n\n    /* Determine alert reason */\n    alertWhy = bad_certificate;\n    if (ret == ASN_AFTER_DATE_E || ret == ASN_BEFORE_DATE_E) {\n        alertWhy = certificate_expired;\n    } else if (ret == ASN_NO_SIGNER_E) {\n        alertWhy = unknown_ca;\n    }\n#if (defined(OPENSSL_ALL) || defined(WOLFSSL_APACHE_HTTPD))\n    else if (ret == CRL_CERT_REVOKED) {\n        alertWhy = certificate_revoked;\n    }\n#endif\n    else if (ret == NO_PEER_CERT) {\n#ifdef WOLFSSL_TLS13\n        if (ssl->options.tls1_3) {\n            alertWhy = certificate_required;\n        }\n        else\n#endif\n        {\n            alertWhy = handshake_failure;\n        }\n    }\n\n    /* send fatal alert and mark connection closed */\n    SendAlert(ssl, alert_fatal, alertWhy); /* try to send */\n    ssl->options.isClosed = 1;\n}""}, {""func_name"": ""DoTls13Finished"", ""file_path"": ""src/tls13.c"", ""func_code"": ""int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\""DoTls13Finished\"");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.resuming &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerCert || !ssl->options.havePeerVerify) {\n            ret = NO_PEER_CERT; /* NO_PEER_VERIFY */\n            WOLFSSL_MSG(\""TLS v1.3 client did not present peer cert\"");\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \""Finished\"");\n    if (ssl->toInfoOn) AddLateName(\""Finished\"", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\""Verify finished error on hashes\"");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\""DoTls13Finished\"", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}""}]","{""value"": 3, ""function"": 1, ""code"": 1}","[{""source"": ""value_info(file:ssl.h, value:ssl->options.mutualAuth)"", ""result"": {""value_trace"": [{""full_code"": ""ssl->options.mutualAuth = ctx->mutualAuth"", ""line"": 6420, ""func_name"": ""InitSSL""}, {""full_code"": ""ssl->options.mutualAuth = (word16)req"", ""line"": 1112, ""func_name"": ""wolfSSL_mutual_auth""}], ""struct_var"": ""ssl"", ""struct_type"": ""Options"", ""struct_definition"": ""typedef struct Options {\n#ifndef NO_PSK\n    wc_psk_client_callback client_psk_cb;\n    wc_psk_server_callback server_psk_cb;\n#ifdef OPENSSL_EXTRA\n    wc_psk_use_session_cb_func session_psk_cb;\n#endif\n#ifdef WOLFSSL_TLS13\n    wc_psk_client_cs_callback    client_psk_cs_cb;     /* client callback */\n    wc_psk_client_tls13_callback client_psk_tls13_cb;  /* client callback */\n    wc_psk_server_tls13_callback server_psk_tls13_cb;  /* server callback */\n#endif\n    void*             psk_ctx;\n#endif /* NO_PSK */\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)\n    unsigned long     mask; /* store SSL_OP_ flags */\n    word16            minProto:1; /* sets min to min available */\n    word16            maxProto:1; /* sets max to max available */\n#endif\n#if defined(HAVE_SESSION_TICKET) && defined(WOLFSSL_TLS13)\n    unsigned int      maxTicketTls13;  /* maximum number of tickets to send */\n    unsigned int      ticketsSent;     /* keep track of the total sent *...\n\ntypedef struct Options {\n#ifndef NO_PSK\n    wc_psk_client_callback client_psk_cb;\n    wc_psk_server_callback server_psk_cb;\n#ifdef OPENSSL_EXTRA\n    wc_psk_use_session_cb_func session_psk_cb;\n#endif\n#ifdef WOLFSSL_TLS13\n    wc_psk_client_cs_callback    client_psk_cs_cb;     /* client callback */\n    wc_psk_client_tls13_callback client_psk_tls13_cb;  /* client callback */\n    wc_psk_server_tls13_callback server_psk_tls13_cb;  /* server callback */\n#endif\n    void*             psk_ctx;\n#endif /* NO_PSK */\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)\n    unsigned long     mask; /* store SSL_OP_ flags */\n    word16            minProto:1; /* sets min to min available */\n    word16            maxProto:1; /* sets max to max available */\n#endif\n#if defined(HAVE_SESSION_TICKET) && defined(WOLFSSL_TLS13)\n    unsigned int      maxTicketTls13;  /* maximum number of tickets to send */\n    unsigned int      ticketsSent;     /* keep track of the total sent *...""}}, {""source"": ""value_info(file:ssl.h, value:ssl->options.havePeerVerify)"", ""result"": {""value_trace"": [{""full_code"": ""ssl->options.havePeerVerify = 1"", ""line"": 30351, ""func_name"": ""DoCertificateVerify""}], ""struct_var"": ""ssl"", ""struct_type"": ""Options"", ""struct_definition"": ""typedef struct Options {\n#ifndef NO_PSK\n    wc_psk_client_callback client_psk_cb;\n    wc_psk_server_callback server_psk_cb;\n#ifdef OPENSSL_EXTRA\n    wc_psk_use_session_cb_func session_psk_cb;\n#endif\n#ifdef WOLFSSL_TLS13\n    wc_psk_client_cs_callback    client_psk_cs_cb;     /* client callback */\n    wc_psk_client_tls13_callback client_psk_tls13_cb;  /* client callback */\n    wc_psk_server_tls13_callback server_psk_tls13_cb;  /* server callback */\n#endif\n    void*             psk_ctx;\n#endif /* NO_PSK */\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)\n    unsigned long     mask; /* store SSL_OP_ flags */\n    word16            minProto:1; /* sets min to min available */\n    word16            maxProto:1; /* sets max to max available */\n#endif\n#if defined(HAVE_SESSION_TICKET) && defined(WOLFSSL_TLS13)\n    unsigned int      maxTicketTls13;  /* maximum number of tickets to send */\n    unsigned int      ticketsSent;     /* keep track of the total sent *...\n\ntypedef struct Options {\n#ifndef NO_PSK\n    wc_psk_client_callback client_psk_cb;\n    wc_psk_server_callback server_psk_cb;\n#ifdef OPENSSL_EXTRA\n    wc_psk_use_session_cb_func session_psk_cb;\n#endif\n#ifdef WOLFSSL_TLS13\n    wc_psk_client_cs_callback    client_psk_cs_cb;     /* client callback */\n    wc_psk_client_tls13_callback client_psk_tls13_cb;  /* client callback */\n    wc_psk_server_tls13_callback server_psk_tls13_cb;  /* server callback */\n#endif\n    void*             psk_ctx;\n#endif /* NO_PSK */\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)\n    unsigned long     mask; /* store SSL_OP_ flags */\n    word16            minProto:1; /* sets min to min available */\n    word16            maxProto:1; /* sets max to max available */\n#endif\n#if defined(HAVE_SESSION_TICKET) && defined(WOLFSSL_TLS13)\n    unsigned int      maxTicketTls13;  /* maximum number of tickets to send */\n    unsigned int      ticketsSent;     /* keep track of the total sent *...""}}, {""source"": ""func_info(file:ssl.c, func:wolfSSL_CTX_mutual_auth)"", ""result"": [{""code"": ""int wolfSSL_CTX_mutual_auth(WOLFSSL_CTX* ctx, int req)\n{\n    if (ctx == NULL)\n        return BAD_FUNC_ARG;\n    if (ctx->method->side == WOLFSSL_CLIENT_END)\n        return SIDE_ERROR;\n\n    ctx->mutualAuth = (byte)req;\n\n    return 0;\n}"", ""start_line"": 1085, ""end_line"": 1095, ""full_name"": ""wolfSSL_CTX_mutual_auth"", ""file_path"": ""src/ssl.c""}]}, {""source"": ""code_info(file:tls13.c, lines:6850-6900)"", ""result"": ""    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}\n#endif /* !NO_RSA || HAVE_ECC */\n#endif /* !NO_CERTS */\n\n/* Parse and handle a TLS v1.3 Finished message.\n *\n * ssl       The SSL/TLS object.\n * input     The message buffer.\n * inOutIdx  On entry, the index into the message buffer of Finished.\n *           On exit, the index of byte after the Finished message and padding.\n * size      Length of message data.\n * totalSz   Length of remaining data in the message buffer.\n * sniff     Indicates whether we are sniffing packets.\n * returns 0 on success and otherwise failure.\n */\nint DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\""DoTls13Finished\"");\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n""}, {""source"": ""value_info(file:ssl.h, value:ssl->options.havePeerCert)"", ""result"": {""value_trace"": [{""full_code"": ""ssl->options.havePeerCert = 1"", ""line"": 12763, ""func_name"": ""ProcessPeerCerts""}], ""struct_var"": ""ssl"", ""struct_type"": ""Options"", ""struct_definition"": ""typedef struct Options {\n#ifndef NO_PSK\n    wc_psk_client_callback client_psk_cb;\n    wc_psk_server_callback server_psk_cb;\n#ifdef OPENSSL_EXTRA\n    wc_psk_use_session_cb_func session_psk_cb;\n#endif\n#ifdef WOLFSSL_TLS13\n    wc_psk_client_cs_callback    client_psk_cs_cb;     /* client callback */\n    wc_psk_client_tls13_callback client_psk_tls13_cb;  /* client callback */\n    wc_psk_server_tls13_callback server_psk_tls13_cb;  /* server callback */\n#endif\n    void*             psk_ctx;\n#endif /* NO_PSK */\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)\n    unsigned long     mask; /* store SSL_OP_ flags */\n    word16            minProto:1; /* sets min to min available */\n    word16            maxProto:1; /* sets max to max available */\n#endif\n#if defined(HAVE_SESSION_TICKET) && defined(WOLFSSL_TLS13)\n    unsigned int      maxTicketTls13;  /* maximum number of tickets to send */\n    unsigned int      ticketsSent;     /* keep track of the total sent *...\n\ntypedef struct Options {\n#ifndef NO_PSK\n    wc_psk_client_callback client_psk_cb;\n    wc_psk_server_callback server_psk_cb;\n#ifdef OPENSSL_EXTRA\n    wc_psk_use_session_cb_func session_psk_cb;\n#endif\n#ifdef WOLFSSL_TLS13\n    wc_psk_client_cs_callback    client_psk_cs_cb;     /* client callback */\n    wc_psk_client_tls13_callback client_psk_tls13_cb;  /* client callback */\n    wc_psk_server_tls13_callback server_psk_tls13_cb;  /* server callback */\n#endif\n    void*             psk_ctx;\n#endif /* NO_PSK */\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)\n    unsigned long     mask; /* store SSL_OP_ flags */\n    word16            minProto:1; /* sets min to min available */\n    word16            maxProto:1; /* sets max to max available */\n#endif\n#if defined(HAVE_SESSION_TICKET) && defined(WOLFSSL_TLS13)\n    unsigned int      maxTicketTls13;  /* maximum number of tickets to send */\n    unsigned int      ticketsSent;     /* keep track of the total sent *...""}}]","1. **Mutual Auth Configuration**: `wolfSSL_CTX_mutual_auth` (src/ssl.c:1085) sets `ctx->mutualAuth`, which is copied to `ssl->options.mutualAuth` during `InitSSL`. 2. **Certificate Processing**: During TLS 1.3 handshake, if the client sends a certificate, `ProcessPeerCerts` (ssl.h:12763) sets `ssl->options.havePeerCert = 1`. 3. **Verification Check**: `DoCertificateVerify` (ssl.h:30351) sets `ssl->options.havePeerVerify = 1` after processing the client's CertificateVerify message. 4. **Enforcement Gap (Pre-Patch)**: Prior to the patch, `DoTls13Finished` (src/tls13.c) did not check `havePeerCert`/`havePeerVerify`, allowing clients to omit certificate/CertificateVerify messages. 5. **Patch Fix**: The patch adds checks for `havePeerCert` and `havePeerVerify` in `DoTls13Finished`, triggering `NO_PEER_CERT` if missing.",0.95,./github/other_context/CVE-2022-25640
25,CVE-2022-3287,CWE-552,c_cpp,"When creating an OPERATOR user account on the BMC, the redfish plugin saved the auto-generated password to /etc/fwupd/redfish.conf without proper restriction, allowing any user on the system to read the same configuration file.",https://github.com/fwupd/fwupd/commit/ea676855f2119e36d433fbd2ed604039f53b2091,"Never save the Redfish passwords to a file readable by users\n\nWhen the redfish plugin automatically creates an OPERATOR user account on the\nBMC we save the autogenerated password to /etc/fwupd/redfish.conf, ensuring it\nis chmod'ed to 0660 before writing the file with g_key_file_save_to_file().\n\nUnder the covers, g_key_file_save_to_file() calls g_file_set_contents() with\nthe keyfile string data.\nI was under the impression that G_FILE_CREATE_REPLACE_DESTINATION was being\nused to copy permissions, but alas not.\n\nGLib instead calls g_file_set_contents_full() with the mode hardcoded to 0666,\nwhich undoes the previous chmod().\n\nUse g_file_set_contents_full() with the correct mode for newer GLib versions,\nand provide a fallback with the same semantics for older versions.",1,"[{""func_name"": ""fu_plugin_set_secure_config_value"", ""file_path"": ""libfwupdplugin/fu-plugin.c"", ""func_code"": ""gboolean\nfu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \""%s is missing\"", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \""failed to set permissions on %s\"",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}"", ""target"": 0}]","[{""func_name"": ""fu_plugin_set_secure_config_value"", ""file_path"": ""libfwupdplugin/fu-plugin.c"", ""func_code"": ""gboolean\nfu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tg_autofree gchar *data = NULL;\n\tg_autoptr(GKeyFile) keyfile = g_key_file_new();\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \""%s is missing\"", conf_path);\n\t\treturn FALSE;\n\t}\n\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))\n\t\treturn FALSE;\n\tg_key_file_set_string(keyfile, fu_plugin_get_name(self), key, value);\n\tdata = g_key_file_to_data(keyfile, NULL, error);\n\tif (data == NULL)\n\t\treturn FALSE;\n\treturn g_file_set_contents_full(conf_path,\n\t\t\t\t\tdata,\n\t\t\t\t\t-1,\n\t\t\t\t\tG_FILE_SET_CONTENTS_CONSISTENT,\n\t\t\t\t\t0660,\n\t\t\t\t\terror);\n}""}]",{},[],"libfwupdplugin/fu-plugin.c:2449-2459: The original code used g_key_file_save_to_file(), which internally used g_file_set_contents() with a hardcoded 0666 mode. This undid the prior g_chmod(0660) call, leaving the file world-readable. The patch explicitly uses g_file_set_contents_full() with 0660 mode to enforce correct permissions.",0.95,./github/other_context/CVE-2022-3287
26,CVE-2023-37471,CWE-287,java,"Open Access Management (OpenAM) is an access management solution that includes Authentication, SSO, Authorization, Federation, Entitlements and Web Services Security. OpenAM up to version 14.7.2 does not properly validate the signature of SAML responses received as part of the SAMLv1.x Single Sign-On process. Attackers can use this fact to impersonate any OpenAM user, including the administrator, by sending a specially crafted SAML response to the SAMLPOSTProfileServlet servlet. This problem has been patched in  OpenAM 14.7.3-SNAPSHOT and later. User unable to upgrade should comment servlet `SAMLPOSTProfileServlet` from their pom file. See the linked GHSA for details.",https://github.com/OpenIdentityPlatform/OpenAM/commit/7c18543d126e8a567b83bb4535631825aaa9d742,"GHSL-2023-143, GHSL-2023-144, deny unsigned SAML response (#624)",2,"[{""func_name"": ""verifyResponse"", ""file_path"": ""openam-federation/openam-federation-library/src/main/java/com/sun/identity/saml/common/SAMLUtils.java"", ""func_code"": ""public static boolean verifyResponse(Response response,\n    String requestUrl, HttpServletRequest request) {\n        if (!response.isSignatureValid()) {\n            debug.message(\""verifyResponse: Response's signature is invalid.\"");\n            return false;\n        }\n\n        // check Recipient == this server's POST profile URL(requestURL)\n        String recipient = response.getRecipient();\n        if ((recipient == null) || (recipient.length() == 0) ||\n        ((!equalURL(recipient, requestUrl)) &&\n        (!equalURL(recipient,getLBURL(requestUrl, request))))) {\n            debug.error(\""verifyResponse : Incorrect Recipient.\"");\n            return false;\n        }\n        \n        // check status of the Response\n        if (!response.getStatus().getStatusCode().getValue().endsWith(\n        SAMLConstants.STATUS_CODE_SUCCESS_NO_PREFIX)) {\n            debug.error(\""verifyResponse : Incorrect StatusCode value.\"");\n            return false;\n        }\n        \n        return true;\n    }"", ""target"": 0}, {""func_name"": ""processResponse"", ""file_path"": ""openam-federation/openam-federation-library/src/main/java/com/sun/identity/saml/common/SAMLUtils.java"", ""func_code"": ""public static Map processResponse(Response samlResponse, String target) \n        throws SAMLException {\n        List assertions = null;    \n        SAMLServiceManager.SOAPEntry partnerdest = null;\n        Subject assertionSubject = null;\n        if (samlResponse.isSigned()) {\n            // verify the signature\n            boolean isSignedandValid = verifySignature(samlResponse);\n            if (!isSignedandValid) {\n                throw new SAMLException(bundle.getString(\""invalidResponse\""));\n            }\n        }\n        // check Assertion and get back a Map of relevant data including,\n        // Subject, SOAPEntry for the partner and the List of Assertions.\n        Map ssMap = verifyAssertionAndGetSSMap(samlResponse);\n        if (debug.messageEnabled()) {\n            debug.message(\""processResponse: ssMap = \"" + ssMap);\n        }\n        \n        if (ssMap == null) {\n            throw new SAMLException(bundle.getString(\""invalidAssertion\""));\n        }\n        assertionSubject = (com.sun.identity.saml.assertion.Subject)\n            ssMap.get(SAMLConstants.SUBJECT);\n        if (assertionSubject == null) {\n            throw new SAMLException(bundle.getString(\""nullSubject\""));\n        }\n        \n        partnerdest = (SAMLServiceManager.SOAPEntry)ssMap\n            .get(SAMLConstants.SOURCE_SITE_SOAP_ENTRY);\n        if (partnerdest == null) {\n            throw new SAMLException(bundle.getString(\""failedAccountMapping\""));\n        }\n        \n        assertions = (List)ssMap.get(SAMLConstants.POST_ASSERTION);\n        Map sessMap = null;\n        try { \n            sessMap = getAttributeMap(partnerdest, assertions,\n                assertionSubject, target); \n        } catch (Exception se) {\n            debug.error(\""SAMLUtils.processResponse :\"" , se);\n            throw new SAMLException(\n                bundle.getString(\""failProcessResponse\""));\n        }\n        return sessMap;\n    }"", ""target"": 0}]","[{""func_name"": ""verifyResponse"", ""file_path"": ""openam-federation/openam-federation-library/src/main/java/com/sun/identity/saml/common/SAMLUtils.java"", ""func_code"": ""public static boolean verifyResponse(Response response,\n    String requestUrl, HttpServletRequest request) {\n        if(!response.isSigned()) {\n            debug.message(\""verifyResponse: Response is not signed\"");\n            return false;\n        }\n        if (!response.isSignatureValid()) {\n            debug.message(\""verifyResponse: Response's signature is invalid.\"");\n            return false;\n        }\n\n        // check Recipient == this server's POST profile URL(requestURL)\n        String recipient = response.getRecipient();\n        if ((recipient == null) || (recipient.length() == 0) ||\n        ((!equalURL(recipient, requestUrl)) &&\n        (!equalURL(recipient,getLBURL(requestUrl, request))))) {\n            debug.error(\""verifyResponse : Incorrect Recipient.\"");\n            return false;\n        }\n        \n        // check status of the Response\n        if (!response.getStatus().getStatusCode().getValue().endsWith(\n        SAMLConstants.STATUS_CODE_SUCCESS_NO_PREFIX)) {\n            debug.error(\""verifyResponse : Incorrect StatusCode value.\"");\n            return false;\n        }\n        \n        return true;\n    }""}, {""func_name"": ""processResponse"", ""file_path"": ""openam-federation/openam-federation-library/src/main/java/com/sun/identity/saml/common/SAMLUtils.java"", ""func_code"": ""public static Map processResponse(Response samlResponse, String target) \n        throws SAMLException {\n        List assertions = null;    \n        SAMLServiceManager.SOAPEntry partnerdest = null;\n        Subject assertionSubject = null;\n\n        // verify the signature\n        boolean isSignedandValid = verifySignature(samlResponse);\n        if (!isSignedandValid) {\n            throw new SAMLException(bundle.getString(\""invalidResponse\""));\n        }\n\n        // check Assertion and get back a Map of relevant data including,\n        // Subject, SOAPEntry for the partner and the List of Assertions.\n        Map ssMap = verifyAssertionAndGetSSMap(samlResponse);\n        if (debug.messageEnabled()) {\n            debug.message(\""processResponse: ssMap = \"" + ssMap);\n        }\n        \n        if (ssMap == null) {\n            throw new SAMLException(bundle.getString(\""invalidAssertion\""));\n        }\n        assertionSubject = (com.sun.identity.saml.assertion.Subject)\n            ssMap.get(SAMLConstants.SUBJECT);\n        if (assertionSubject == null) {\n            throw new SAMLException(bundle.getString(\""nullSubject\""));\n        }\n        \n        partnerdest = (SAMLServiceManager.SOAPEntry)ssMap\n            .get(SAMLConstants.SOURCE_SITE_SOAP_ENTRY);\n        if (partnerdest == null) {\n            throw new SAMLException(bundle.getString(\""failedAccountMapping\""));\n        }\n        \n        assertions = (List)ssMap.get(SAMLConstants.POST_ASSERTION);\n        Map sessMap = null;\n        try { \n            sessMap = getAttributeMap(partnerdest, assertions,\n                assertionSubject, target); \n        } catch (Exception se) {\n            debug.error(\""SAMLUtils.processResponse :\"" , se);\n            throw new SAMLException(\n                bundle.getString(\""failProcessResponse\""));\n        }\n        return sessMap;\n    }""}]",{},[],"OpenAM did not enforce SAML response signing. The first patch (SAMLUtils.java:953-957) adds a check for response.isSigned(), rejecting unsigned responses. The second patch (SAMLUtils.java:72-82) ensures signature validation is always performed, closing gaps in prior conditional checks.",0.95,./github/other_context/CVE-2023-37471
27,CVE-2023-38494,CWE-862,java,"MeterSphere is an open-source continuous testing platform. Prior to version 2.10.4 LTS, some interfaces of the Cloud version of MeterSphere do not have configuration permissions, and are sensitively leaked by attackers. Version 2.10.4 LTS contains a patch for this issue.",https://github.com/metersphere/metersphere/commit/a23f75d93b666901fd148d834df9384f6f24cf28,fix: ,3,"[{""func_name"": ""getCurrentWorkspaceMember"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/controller/BaseUserController.java"", ""func_code"": ""@GetMapping(\""/ws/current/member/list\"")\n    public List<User> getCurrentWorkspaceMember() {\n        QueryMemberRequest request = new QueryMemberRequest();\n        request.setWorkspaceId(SessionUtils.getCurrentWorkspaceId());\n        return baseUserService.getMemberList(request);\n    }"", ""target"": 0}, {""func_name"": ""getProjectMembers"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/controller/BaseUserController.java"", ""func_code"": ""@GetMapping(\""/project/member/{projectId}\"")\n    public List<User> getProjectMembers(@PathVariable String projectId) {\n        QueryMemberRequest request = new QueryMemberRequest();\n        request.setProjectId(projectId);\n        return baseUserService.getProjectMemberList(request);\n    }"", ""target"": 0}, {""func_name"": ""getProjectMemberListAll"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/controller/BaseUserController.java"", ""func_code"": ""@GetMapping(\""/project/member/list\"")\n    public List<User> getProjectMemberListAll() {\n        QueryMemberRequest request = new QueryMemberRequest();\n        request.setProjectId(SessionUtils.getCurrentProjectId());\n        return baseUserService.getProjectMemberList(request);\n    }"", ""target"": 0}]","[{""func_name"": ""getCurrentWorkspaceMember"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/controller/BaseUserController.java"", ""func_code"": ""@GetMapping(\""/ws/current/member/list\"")\n    public List<User> getCurrentWorkspaceMember() {\n        SessionUser user = SessionUtils.getUser();\n        Optional<UserGroup> any = user.getUserGroups().stream()\n                .filter(ug -> (ug.getSourceId().equals(SessionUtils.getCurrentWorkspaceId()) || ug.getGroupId().equals(UserGroupConstants.SUPER_GROUP)))\n                .findAny();\n        if (any.isEmpty()) {\n            return new ArrayList<>();\n        }\n        QueryMemberRequest request = new QueryMemberRequest();\n        request.setWorkspaceId(SessionUtils.getCurrentWorkspaceId());\n        return baseUserService.getMemberList(request);\n    }""}, {""func_name"": ""getProjectMembers"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/controller/BaseUserController.java"", ""func_code"": ""@GetMapping(\""/project/member/{projectId}\"")\n    public List<User> getProjectMembers(@PathVariable String projectId) {\n        SessionUser user = SessionUtils.getUser();\n        Optional<UserGroup> any = user.getUserGroups().stream()\n                .filter(ug -> (ug.getSourceId().equals(projectId) || ug.getGroupId().equals(UserGroupConstants.SUPER_GROUP)))\n                .findAny();\n        if (any.isEmpty()) {\n            return new ArrayList<>();\n        }\n        QueryMemberRequest request = new QueryMemberRequest();\n        request.setProjectId(projectId);\n        return baseUserService.getProjectMemberList(request);\n    }""}, {""func_name"": ""getProjectMemberListAll"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/controller/BaseUserController.java"", ""func_code"": ""@GetMapping(\""/project/member/list\"")\n    public List<User> getProjectMemberListAll() {\n        SessionUser user = SessionUtils.getUser();\n        Optional<UserGroup> any = user.getUserGroups().stream()\n                .filter(ug -> (ug.getSourceId().equals(SessionUtils.getCurrentProjectId()) || ug.getGroupId().equals(UserGroupConstants.SUPER_GROUP)))\n                .findAny();\n        if (any.isEmpty()) {\n            return new ArrayList<>();\n        }\n        QueryMemberRequest request = new QueryMemberRequest();\n        request.setProjectId(SessionUtils.getCurrentProjectId());\n        return baseUserService.getProjectMemberList(request);\n    }""}]","{""function"": 2, ""value"": 1}","[{""source"": ""func_info(file:BaseUserController.java, func:getCurrentWorkspaceMember)"", ""result"": [{""code"": ""    @GetMapping(\""/ws/current/member/list\"")\n    public List<User> getCurrentWorkspaceMember() {\n        QueryMemberRequest request = new QueryMemberRequest();\n        request.setWorkspaceId(SessionUtils.getCurrentWorkspaceId());\n        return baseUserService.getMemberList(request);\n    }\n"", ""start_line"": 27, ""end_line"": 32, ""full_name"": ""io.metersphere.controller.BaseUserController.getCurrentWorkspaceMember:java.util.List()"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/controller/BaseUserController.java""}]}, {""source"": ""func_info(func:getUser)"", ""result"": [{""code"": ""    private User getUser(ResultDTO dto, ApiDefinitionExecResult result) {\n        User user = null;\n        if (MapUtils.isNotEmpty(dto.getExtendedParameters())) {\n            if (dto.getExtendedParameters().containsKey(CommonConstants.USER_ID)\n                    && dto.getExtendedParameters().containsKey(CommonConstants.USER_NAME)) {\n                user = new User() {{\n                    this.setId(dto.getExtendedParameters().get(CommonConstants.USER_ID).toString());\n                    this.setName(dto.getExtendedParameters().get(CommonConstants.USER_NAME).toString());\n                }};\n                result.setUserId(user.getId());\n            } else if (dto.getExtendedParameters().containsKey(CommonConstants.USER_ID)) {\n                result.setUserId(dto.getExtendedParameters().get(CommonConstants.USER_ID).toString());\n            }\n        }\n        return user;\n    }\n"", ""start_line"": 146, ""end_line"": 161, ""full_name"": ""io.metersphere.service.definition.ApiDefinitionExecResultService.getUser:io.metersphere.base.domain.User(io.metersphere.dto.ResultDTO,io.metersphere.base.domain.ApiDefinitionExecResult)"", ""file_path"": ""api-test/backend/src/main/java/io/metersphere/service/definition/ApiDefinitionExecResultService.java""}, {""code"": ""    public String getUser(String id) {\n        User user = userMapper.selectByPrimaryKey(id);\n        if (user != null) {\n            return user.getName();\n        }\n        return null;\n    }\n"", ""start_line"": 184, ""end_line"": 190, ""full_name"": ""io.metersphere.service.scenario.ApiScenarioService.getUser:java.lang.String(java.lang.String)"", ""file_path"": ""api-test/backend/src/main/java/io/metersphere/service/scenario/ApiScenarioService.java""}, {""code"": ""    public static SessionUser getUser() {\n        try {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            SessionUser user = (SessionUser) session.getAttribute(ATTR_USER);\n            assert user != null;\n            return user;\n        } catch (Exception e) {\n            LogUtil.warn(\""\u540e\u53f0\u83b7\u53d6\u5728\u7ebf\u7528\u6237\u5931\u8d25: \"" + e.getMessage());\n            return null;\n        }\n    }\n"", ""start_line"": 33, ""end_line"": 44, ""full_name"": ""io.metersphere.commons.utils.SessionUtils.getUser:io.metersphere.commons.user.SessionUser()"", ""file_path"": ""framework/sdk-parent/sdk/src/main/java/io/metersphere/commons/utils/SessionUtils.java""}]}, {""source"": ""value_info(file:UserGroupConstants.java, value:SUPER_GROUP)"", ""result"": {""value_trace"": [{""full_code"": ""String UserGroupConstants.SUPER_GROUP = \""super_group\"""", ""line"": 7, ""func_name"": ""io.metersphere.commons.constants.UserGroupConstants.<clinit>:void()""}], ""struct_var"": ""SUPER_GROUP"", ""struct_type"": null, ""struct_definition"": null}}]","In the original code (BaseUserController.java:27-32, BaseUserController.java:58-63, BaseUserController.java:70-75), functions like getCurrentWorkspaceMember(), getProjectMemberListAll(), and getProjectMembers() retrieved member data based solely on session-derived IDs (e.g., SessionUtils.getCurrentWorkspaceId()) without validating if the requesting user had permissions via user groups. The SUPER_GROUP (UserGroupConstants.java:7) was not enforced. The patch introduced checks to verify if the user belongs to the target workspace/project group or is in the SUPER_GROUP (e.g., BaseUserController.java:28+).",0.95,./github/other_context/CVE-2023-38494
28,CVE-2013-2016,CWE-269,c_cpp,"A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.",https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,virtio: properly validate address before accessing config\n\nThere are several several issues in the current checking:\n\n- The check was based on the minus of unsigned values which can overflow\n- It was done after .{set|get}_config() which can lead crash when config_len\n  is zero since vdev->config is NULL\n\nFix this by:\n\n- Validate the address in virtio_pci_config_{read|write}() before\n  .{set|get}_config\n- Use addition instead minus to do the validation\n\nCc: Michael S. Tsirkin <mst@redhat.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nAcked-by: Michael S. Tsirkin <mst@redhat.com>\nAcked-by: Petr Matousek <pmatouse@redhat.com>\nMessage-id: 1367905369-10765-1-git-send-email-jasowang@redhat.com\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>,6,"[{""func_name"": ""virtio_config_readb"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n\n    k->get_config(vdev, vdev->config);\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n\n    val = ldub_p(vdev->config + addr);\n    return val;\n}"", ""target"": 0}, {""func_name"": ""virtio_config_writew"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stw_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}"", ""target"": 0}, {""func_name"": ""virtio_config_readl"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    k->get_config(vdev, vdev->config);\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}"", ""target"": 0}, {""func_name"": ""virtio_config_writeb"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}"", ""target"": 0}, {""func_name"": ""virtio_config_readw"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n\n    k->get_config(vdev, vdev->config);\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n\n    val = lduw_p(vdev->config + addr);\n    return val;\n}"", ""target"": 0}, {""func_name"": ""virtio_config_writel"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stl_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}"", ""target"": 0}]","[{""func_name"": ""virtio_config_readb"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldub_p(vdev->config + addr);\n    return val;\n}""}, {""func_name"": ""virtio_config_writew"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stw_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}""}, {""func_name"": ""virtio_config_readl"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}""}, {""func_name"": ""virtio_config_writeb"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}""}, {""func_name"": ""virtio_config_readw"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = lduw_p(vdev->config + addr);\n    return val;\n}""}, {""func_name"": ""virtio_config_writel"", ""file_path"": ""hw/virtio/virtio.c"", ""func_code"": ""void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stl_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}""}]","{""value"": 2, ""code"": 1}","[{""source"": ""value_info(file:virtio.c, value:vdev->config)"", ""result"": {""value_trace"": [{""full_code"": ""vdev->config = g_malloc0(config_size)"", ""line"": 961, ""func_name"": ""virtio_init""}, {""full_code"": ""vdev->config = NULL"", ""line"": 963, ""func_name"": ""virtio_init""}], ""struct_var"": ""vdev"", ""struct_type"": ""VirtIODevice*"", ""struct_definition"": ""struct VirtIODevice\n{\n    DeviceState parent_obj;\n    const char *name;\n    uint8_t status;\n    uint8_t isr;\n    uint16_t queue_sel;\n    uint32_t guest_features;\n    size_t config_len;\n    void *config;\n    uint16_t config_vector;\n    int nvectors;\n    VirtQueue *vq;\n    uint16_t device_id;\n    bool vm_running;\n    VMChangeStateEntry *vmstate;\n    char *bus_name;\n}\n\ntypedef struct VirtIODevice\n\ntypedef struct VirtIODevice VirtIODevice;""}}, {""source"": ""value_info(file:virtio.c, value:vdev->config_len)"", ""result"": {""value_trace"": [{""full_code"": ""vdev->config_len = qemu_get_be32(f)"", ""line"": 871, ""func_name"": ""virtio_load""}, {""full_code"": ""vdev->config_len = config_size"", ""line"": 959, ""func_name"": ""virtio_init""}], ""struct_var"": ""vdev"", ""struct_type"": ""VirtIODevice*"", ""struct_definition"": ""struct VirtIODevice\n{\n    DeviceState parent_obj;\n    const char *name;\n    uint8_t status;\n    uint8_t isr;\n    uint16_t queue_sel;\n    uint32_t guest_features;\n    size_t config_len;\n    void *config;\n    uint16_t config_vector;\n    int nvectors;\n    VirtQueue *vq;\n    uint16_t device_id;\n    bool vm_running;\n    VMChangeStateEntry *vmstate;\n    char *bus_name;\n}\n\ntypedef struct VirtIODevice\n\ntypedef struct VirtIODevice VirtIODevice;""}}, {""source"": ""code_info(file:virtio.c, lines:960-965)"", ""result"": ""    if (vdev->config_len) {\n        vdev->config = g_malloc0(config_size);\n    } else {\n        vdev->config = NULL;\n    }\n    vdev->vmstate = qemu_add_vm_change_state_handler(virtio_vmstate_change,\n                                                     vdev);\n""}]","Original code used subtraction-based bounds checking (e.g., hw/virtio/virtio.c:571: `addr > (vdev->config_len - sizeof(val))`) which underflowed when `addr` exceeded `vdev->config_len`, allowing out-of-bounds access. Validation occurred after `.get_config()` (e.g., hw/virtio/virtio.c:569-573), risking NULL dereference if `config_len=0` (since `vdev->config` is initialized to NULL in `virtio_init` at hw/virtio/virtio.c:963). The patch replaces this with addition-based checks (`addr + sizeof(val) > vdev->config_len`) and moves validation before `.get_config()`.",0.95,./github/other_context/CVE-2013-2016
29,CVE-2016-10130,CWE-284,c_cpp,The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable.,https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211,http: check certificate validity before clobbering the error variable,1,"[{""func_name"": ""http_connect"", ""file_path"": ""src/transports/http.c"", ""func_code"": ""static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \""git_stream\"");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \""user cancelled certificate check\"");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""http_connect"", ""file_path"": ""src/transports/http.c"", ""func_code"": ""static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \""git_stream\"");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid = (error == GIT_OK);\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \""user cancelled certificate check\"");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}""}]","{""value"": 2, ""function"": 1}","[{""source"": ""value_info(file:http.c, value:GIT_ECERTIFICATE)"", ""result"": {""value_trace"": [{""full_code"": ""GIT_ECERTIFICATE    = -17"", ""line"": 45, ""func_name"": ""git_error_code:<clinit>""}], ""struct_var"": ""GIT_ECERTIFICATE"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:http.c, value:GIT_OK)"", ""result"": {""value_trace"": [{""full_code"": ""GIT_OK         =  0"", ""line"": 22, ""func_name"": ""git_error_code:<clinit>""}], ""struct_var"": ""GIT_OK"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(func:git_stream_certificate)"", ""result"": [{""code"": ""GIT_INLINE(int) git_stream_certificate(git_cert **out, git_stream *st)\n{\n\tif (!st->encrypted) {\n\t\tgiterr_set(GITERR_INVALID, \""an unencrypted stream does not have a certificate\"");\n\t\treturn -1;\n\t}\n\n\treturn st->certificate(out, st);\n}"", ""start_line"": 23, ""end_line"": 31, ""full_name"": ""git_stream_certificate"", ""file_path"": ""src/stream.h""}]}]","src/transports/http.c:603-612: In the original code, 'error' was overwritten by 'git_stream_certificate()' (src/stream.h:23-31) before 'is_valid' was determined. This allowed the original error state (e.g., GIT_OK or GIT_ECERTIFICATE) to be lost. The patch initializes 'is_valid = (error == GIT_OK)' before calling 'git_stream_certificate()', preserving the original error state. 'git_stream_certificate()' returns GIT_ECERTIFICATE (-17) for unencrypted streams, which was previously used to determine validity but could overwrite 'error' before tracking.",0.95,./github/other_context/CVE-2016-10130
30,CVE-2017-11747,CWE-269,c_cpp,"main.c in Tinyproxy 1.8.4 and earlier creates a /run/tinyproxy/tinyproxy.pid file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for tinyproxy.pid modification before a root script executes a ""kill `cat /run/tinyproxy/tinyproxy.pid`"" command.",https://github.com/tinyproxy/tinyproxy/commit/fe4d29888306e62f3bbf964b3fdb8126ddbe8f6e,Fix CVE-2017-11747: Create PID file before dropping privileges.\n\nResolves #106\n\nSigned-off-by: Michael Adam <obnox@samba.org>,1,"[{""func_name"": ""main"", ""file_path"": ""src/main.c"", ""func_code"": ""int\nmain (int argc, char **argv)\n{\n        /* Only allow u+rw bits. This may be required for some versions\n         * of glibc so that mkstemp() doesn't make us vulnerable.\n         */\n        umask (0177);\n\n        log_message (LOG_INFO, \""Initializing \"" PACKAGE \"" ...\"");\n\n        if (config_compile_regex()) {\n                exit (EX_SOFTWARE);\n        }\n\n        initialize_config_defaults (&config_defaults);\n        process_cmdline (argc, argv, &config_defaults);\n\n        if (reload_config_file (config_defaults.config_file,\n                                &config,\n                                &config_defaults)) {\n                exit (EX_SOFTWARE);\n        }\n\n        init_stats ();\n\n        /* If ANONYMOUS is turned on, make sure that Content-Length is\n         * in the list of allowed headers, since it is required in a\n         * HTTP/1.0 request. Also add the Content-Type header since it\n         * goes hand in hand with Content-Length. */\n        if (is_anonymous_enabled ()) {\n                anonymous_insert (\""Content-Length\"");\n                anonymous_insert (\""Content-Type\"");\n        }\n\n        if (config.godaemon == TRUE)\n                makedaemon ();\n\n        if (set_signal_handler (SIGPIPE, SIG_IGN) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGPIPE\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n#ifdef FILTER_ENABLE\n        if (config.filter)\n                filter_init ();\n#endif /* FILTER_ENABLE */\n\n        /* Start listening on the selected port. */\n        if (child_listening_sockets(config.listen_addrs, config.port) < 0) {\n                fprintf (stderr, \""%s: Could not create listening sockets.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        /* Switch to a different user if we're running as root */\n        if (geteuid () == 0)\n                change_user (argv[0]);\n        else\n                log_message (LOG_WARNING,\n                             \""Not running as root, so not changing UID/GID.\"");\n\n        /* Create log file after we drop privileges */\n        if (setup_logging ()) {\n                exit (EX_SOFTWARE);\n        }\n\n        /* Create pid file after we drop privileges */\n        if (config.pidpath) {\n                if (pidfile_create (config.pidpath) < 0) {\n                        fprintf (stderr, \""%s: Could not create PID file.\\n\"",\n                                 argv[0]);\n                        exit (EX_OSERR);\n                }\n        }\n\n        if (child_pool_create () < 0) {\n                fprintf (stderr,\n                         \""%s: Could not create the pool of children.\\n\"",\n                         argv[0]);\n                exit (EX_SOFTWARE);\n        }\n\n        /* These signals are only for the parent process. */\n        log_message (LOG_INFO, \""Setting the various signals.\"");\n\n        if (set_signal_handler (SIGCHLD, takesig) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGCHLD\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        if (set_signal_handler (SIGTERM, takesig) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGTERM\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        if (set_signal_handler (SIGHUP, takesig) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGHUP\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        /* Start the main loop */\n        log_message (LOG_INFO, \""Starting main loop. Accepting connections.\"");\n\n        child_main_loop ();\n\n        log_message (LOG_INFO, \""Shutting down.\"");\n\n        child_kill_children (SIGTERM);\n        child_close_sock ();\n\n        /* Remove the PID file */\n        if (unlink (config.pidpath) < 0) {\n                log_message (LOG_WARNING,\n                             \""Could not remove PID file \\\""%s\\\"": %s.\"",\n                             config.pidpath, strerror (errno));\n        }\n\n#ifdef FILTER_ENABLE\n        if (config.filter)\n                filter_destroy ();\n#endif /* FILTER_ENABLE */\n\n        shutdown_logging ();\n\n        return EXIT_SUCCESS;\n}"", ""target"": 0}]","[{""func_name"": ""main"", ""file_path"": ""src/main.c"", ""func_code"": ""int\nmain (int argc, char **argv)\n{\n        /* Only allow u+rw bits. This may be required for some versions\n         * of glibc so that mkstemp() doesn't make us vulnerable.\n         */\n        umask (0177);\n\n        log_message (LOG_INFO, \""Initializing \"" PACKAGE \"" ...\"");\n\n        if (config_compile_regex()) {\n                exit (EX_SOFTWARE);\n        }\n\n        initialize_config_defaults (&config_defaults);\n        process_cmdline (argc, argv, &config_defaults);\n\n        if (reload_config_file (config_defaults.config_file,\n                                &config,\n                                &config_defaults)) {\n                exit (EX_SOFTWARE);\n        }\n\n        init_stats ();\n\n        /* If ANONYMOUS is turned on, make sure that Content-Length is\n         * in the list of allowed headers, since it is required in a\n         * HTTP/1.0 request. Also add the Content-Type header since it\n         * goes hand in hand with Content-Length. */\n        if (is_anonymous_enabled ()) {\n                anonymous_insert (\""Content-Length\"");\n                anonymous_insert (\""Content-Type\"");\n        }\n\n        if (config.godaemon == TRUE)\n                makedaemon ();\n\n        if (set_signal_handler (SIGPIPE, SIG_IGN) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGPIPE\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n#ifdef FILTER_ENABLE\n        if (config.filter)\n                filter_init ();\n#endif /* FILTER_ENABLE */\n\n        /* Start listening on the selected port. */\n        if (child_listening_sockets(config.listen_addrs, config.port) < 0) {\n                fprintf (stderr, \""%s: Could not create listening sockets.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        /* Create pid file before we drop privileges */\n        if (config.pidpath) {\n                if (pidfile_create (config.pidpath) < 0) {\n                        fprintf (stderr, \""%s: Could not create PID file.\\n\"",\n                                 argv[0]);\n                        exit (EX_OSERR);\n                }\n        }\n\n        /* Switch to a different user if we're running as root */\n        if (geteuid () == 0)\n                change_user (argv[0]);\n        else\n                log_message (LOG_WARNING,\n                             \""Not running as root, so not changing UID/GID.\"");\n\n        /* Create log file after we drop privileges */\n        if (setup_logging ()) {\n                exit (EX_SOFTWARE);\n        }\n\n        if (child_pool_create () < 0) {\n                fprintf (stderr,\n                         \""%s: Could not create the pool of children.\\n\"",\n                         argv[0]);\n                exit (EX_SOFTWARE);\n        }\n\n        /* These signals are only for the parent process. */\n        log_message (LOG_INFO, \""Setting the various signals.\"");\n\n        if (set_signal_handler (SIGCHLD, takesig) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGCHLD\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        if (set_signal_handler (SIGTERM, takesig) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGTERM\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        if (set_signal_handler (SIGHUP, takesig) == SIG_ERR) {\n                fprintf (stderr, \""%s: Could not set the \\\""SIGHUP\\\"" signal.\\n\"",\n                         argv[0]);\n                exit (EX_OSERR);\n        }\n\n        /* Start the main loop */\n        log_message (LOG_INFO, \""Starting main loop. Accepting connections.\"");\n\n        child_main_loop ();\n\n        log_message (LOG_INFO, \""Shutting down.\"");\n\n        child_kill_children (SIGTERM);\n        child_close_sock ();\n\n        /* Remove the PID file */\n        if (unlink (config.pidpath) < 0) {\n                log_message (LOG_WARNING,\n                             \""Could not remove PID file \\\""%s\\\"": %s.\"",\n                             config.pidpath, strerror (errno));\n        }\n\n#ifdef FILTER_ENABLE\n        if (config.filter)\n                filter_destroy ();\n#endif /* FILTER_ENABLE */\n\n        shutdown_logging ();\n\n        return EXIT_SUCCESS;\n}""}]","{""function"": 3}","[{""source"": ""func_info(func:pidfile_create)"", ""result"": [{""code"": ""int\npidfile_create (const char *filename)\n{\n        int fildes;\n        FILE *fd;\n\n        /*\n         * Create a new file\n         */\n        if ((fildes = create_file_safely (filename, TRUE)) < 0)\n                return fildes;\n\n        /*\n         * Open a stdio file over the low-level one.\n         */\n        if ((fd = fdopen (fildes, \""w\"")) == NULL) {\n                fprintf (stderr,\n                         \""%s: Could not write PID file %s: %s.\"",\n                         PACKAGE, filename, strerror (errno));\n                close (fildes);\n                unlink (filename);\n                return -EIO;\n        }\n\n        fprintf (fd, \""%d\\n\"", getpid ());\n        fclose (fd);\n        return 0;\n}"", ""start_line"": 188, ""end_line"": 215, ""full_name"": ""pidfile_create"", ""file_path"": ""src/utils.c""}]}, {""source"": ""func_info(file:main.c, func:change_user)"", ""result"": [{""code"": ""static void\nchange_user (const char *program)\n{\n        if (config.group && strlen (config.group) > 0) {\n                int gid = get_id (config.group);\n\n                if (gid < 0) {\n                        struct group *thisgroup = getgrnam (config.group);\n\n                        if (!thisgroup) {\n                                fprintf (stderr,\n                                         \""%s: Unable to find group \\\""%s\\\"".\\n\"",\n                                         program, config.group);\n                                exit (EX_NOUSER);\n                        }\n\n                        gid = thisgroup->gr_gid;\n                }\n\n                if (setgid (gid) < 0) {\n                        fprintf (stderr,\n                                 \""%s: Unable to change to group \\\""%s\\\"".\\n\"",\n                                 program, config.group);\n                        exit (EX_NOPERM);\n                }\n\n#ifdef HAVE_SETGROUPS\n                /* Drop all supplementary groups, otherwise these are inherited from the calling process */\n                if (setgroups (0, NULL) < 0) {\n                        fprintf (stderr,\n                                 \""%s: Unable to drop supplementary groups.\\n\"",\n                                 program);\n                        exit (EX_NOPERM);\n                }\n#endif\n\n                log_message (LOG_INFO, \""Now running as group \\\""%s\\\"".\"",\n                             config.group);\n        }\n\n        if (config.user && strlen (config.user) > 0) {\n                int uid = get_id (config.user);\n\n                if (uid < 0) {\n                        struct passwd *thisuser = getpwnam (config.user);\n\n                        if (!thisuser) {\n                                fprintf (stderr,\n                                         \""%s: Unable to find user \\\""%s\\\"".\\n\"",\n                                         program, config.user);\n                                exit (EX_NOUSER);\n                        }\n\n                        uid = thisuser->pw_uid;\n                }\n\n                if (setuid (uid) < 0) {\n                        fprintf (stderr,\n                                 \""%s: Unable to change to user \\\""%s\\\"".\\n\"",\n                                 program, config.user);\n                        exit (EX_NOPERM);\n                }\n\n                log_message (LOG_INFO, \""Now running as user \\\""%s\\\"".\"",\n                             config.user);\n        }\n}\n"", ""start_line"": 273, ""end_line"": 339, ""full_name"": ""change_user"", ""file_path"": ""src/main.c""}]}, {""source"": ""func_info(file:utils.c, func:create_file_safely)"", ""result"": [{""code"": ""int create_file_safely (const char *filename, unsigned int truncate_file)\n{\n        struct stat lstatinfo;\n        int fildes;\n\n        /*\n         * lstat() the file. If it doesn't exist, create it with O_EXCL.\n         * If it does exist, open it for writing and perform the fstat()\n         * check.\n         */\n        if (lstat (filename, &lstatinfo) < 0) {\n                /*\n                 * If lstat() failed for any reason other than \""file not\n                 * existing\"", exit.\n                 */\n                if (errno != ENOENT) {\n                        fprintf (stderr,\n                                 \""%s: Error checking file %s: %s\\n\"",\n                                 PACKAGE, filename, strerror (errno));\n                        return -EACCES;\n                }\n\n                /*\n                 * The file doesn't exist, so create it with O_EXCL to make\n                 * sure an attacker can't slip in a file between the lstat()\n                 * and open()\n                 */\n                if ((fildes =\n                     open (filename, O_RDWR | O_CREAT | O_EXCL, 0600)) < 0) {\n                        fprintf (stderr, \""%s: Could not create file %s: %s\\n\"",\n                                 PACKAGE, filename, strerror (errno));\n                        return fildes;\n                }\n        } else {\n                struct stat fstatinfo;\n                int flags;\n\n                flags = O_RDWR;\n                if (!truncate_file)\n                        flags |= O_APPEND;\n\n                /*\n                 * Open an existing file.\n                 */\n                if ((fildes = open (filename, flags)) < 0) {\n                        fprintf (stderr,\n                                 \""%s: Could not open file %s: %s\\n\"",\n                                 PACKAGE, filename, strerror (errno));\n                        return fildes;\n                }\n\n                /*\n                 * fstat() the opened file and check that the file mode bits,\n                 * inode, and device match.\n                 */\n                if (fstat (fildes, &fstatinfo) < 0\n                    || lstatinfo.st_mode != fstatinfo.st_mode\n                    || lstatinfo.st_ino != fstatinfo.st_ino\n                    || lstatinfo.st_dev != fstatinfo.st_dev) {\n                        fprintf (stderr,\n                                 \""%s: The file %s has been changed before it could be opened\\n\"",\n                                 PACKAGE, filename);\n                        close (fildes);\n                        return -EIO;\n                }\n\n                /*\n                 * If the above check was passed, we know that the lstat()\n                 * and fstat() were done on the same file. Now we check that\n                 * there's only one link, and that it's a normal file (this\n                 * isn't strictly necessary because the fstat() vs lstat()\n                 * st_mode check would also find this)\n                 */\n                if (fstatinfo.st_nlink > 1 || !S_ISREG (lstatinfo.st_mode)) {\n                        fprintf (stderr,\n                                 \""%s: The file %s has too many links, \""\n                                 \""or is not a regular file: %s\\n\"",\n                                 PACKAGE, filename, strerror (errno));\n                        close (fildes);\n                        return -EMLINK;\n                }\n\n                /*\n                 * Just return the file descriptor if we _don't_ want the file\n                 * truncated.\n                 */\n                if (!truncate_file)\n                        return fildes;\n\n                /*\n                 * On systems which don't support ftruncate() the best we can\n                 * do is to close the file and reopen it in create mode, which\n                 * unfortunately leads to a race condition, however \""systems\n                 * which don't support ftruncate()\"" is pretty much SCO only,\n                 * and if you're using that you deserve what you get.\n                 * (\""Little sympathy has been extended\"")\n                 */\n#ifdef HAVE_FTRUNCATE\n                if (ftruncate (fildes, 0) != 0) {\n                        log_message (LOG_WARNING,\n                                     \""Unable to truncate file '%s'\"", filename);\n                }\n#else\n                close (fildes);\n                if ((fildes =\n                     open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600)) < 0) {\n                        fprintf (stderr, \""%s: Could not open file %s: %s.\"",\n                                 PACKAGE, filename, strerror (errno));\n                        return fildes;\n                }\n#endif /* HAVE_FTRUNCATE */\n        }\n\n        return fildes;\n}\n"", ""start_line"": 64, ""end_line"": 178, ""full_name"": ""create_file_safely"", ""file_path"": ""src/utils.c""}]}]","Original logic in src/main.c:447-456 created the PID file after dropping privileges via `change_user` (src/main.c:449). This allowed a non-root user to overwrite `/run/tinyproxy/tinyproxy.pid` before a root script executed `kill `cat /run/tinyproxy/tinyproxy.pid``. The patch moves `pidfile_create` to src/main.c:437-446, before privilege drop. `pidfile_create` (src/utils.c:188-215) uses `create_file_safely` (src/utils.c:64-178), which creates the file with O_EXCL and 0600 permissions, ensuring it is owned by root and immutable by non-root users after creation.",0.95,./github/other_context/CVE-2017-11747
31,CVE-2017-6519,CWE-346,c_cpp,"avahi-daemon in Avahi through 0.6.32 and 0.7 inadvertently responds to IPv6 unicast queries with source addresses that are not on-link, which allows remote attackers to cause a denial of service (traffic amplification) and may cause information leakage by obtaining potentially sensitive  information from the responding device via port-5353 UDP packets.  NOTE: this may overlap CVE-2015-2809.",https://github.com/avahi/avahi/commit/e111def44a7df4624a4aa3f85fe98054bffb6b4f,"Drop legacy unicast queries from address not on local link\n\nWhen handling legacy unicast queries, ensure that the source IP is\ninside a subnet on the local link, otherwise drop the packet.\n\nFixes #145\nFixes #203\nCVE-2017-6519\nCVE-2018-100084",1,"[{""func_name"": ""dispatch_packet"", ""file_path"": ""avahi-core/server.c"", ""func_code"": ""static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_debug(\""Received packet from invalid interface.\"");\n        return;\n    }\n\n    if (port <= 0) {\n        /* This fixes RHBZ #475394 */\n        avahi_log_debug(\""Received packet from invalid source port %u.\"", (unsigned) port);\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_debug(\""Received invalid packet.\"");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n\n        /* For queries EDNS0 might allow ARCOUNT != 0. We ignore the\n         * AR section completely here, so far. Until the day we add\n         * EDNS0 support. */\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_debug(\""Invalid legacy unicast query packet.\"");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_debug(\""Received response from host %s with invalid source port %u on interface '%s.%i'\"", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_debug(\""Received response from host %s with invalid TTL %u on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\""Received non-local response from host %s on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_debug(\""Invalid response packet from host %s.\"", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}"", ""target"": 0}]","[{""func_name"": ""dispatch_packet"", ""file_path"": ""avahi-core/server.c"", ""func_code"": ""static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_debug(\""Received packet from invalid interface.\"");\n        return;\n    }\n\n    if (port <= 0) {\n        /* This fixes RHBZ #475394 */\n        avahi_log_debug(\""Received packet from invalid source port %u.\"", (unsigned) port);\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_debug(\""Received invalid packet.\"");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        /* For queries EDNS0 might allow ARCOUNT != 0. We ignore the\n         * AR section completely here, so far. Until the day we add\n         * EDNS0 support. */\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_debug(\""Invalid legacy unicast query packet.\"");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\""Received non-local unicast query from host %s on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_debug(\""Received response from host %s with invalid source port %u on interface '%s.%i'\"", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_debug(\""Received response from host %s with invalid TTL %u on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\""Received non-local response from host %s on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_debug(\""Invalid response packet from host %s.\"", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}""}]","{""function"": 2}","[{""source"": ""func_info(func:is_mdns_mcast_address)"", ""result"": [{""code"": ""static int is_mdns_mcast_address(const AvahiAddress *a) {\n    AvahiAddress b;\n    assert(a);\n\n    avahi_address_parse(a->proto == AVAHI_PROTO_INET ? AVAHI_IPV4_MCAST_GROUP : AVAHI_IPV6_MCAST_GROUP, a->proto, &b);\n    return avahi_address_cmp(a, &b) == 0;\n}"", ""start_line"": 871, ""end_line"": 877, ""full_name"": ""is_mdns_mcast_address"", ""file_path"": ""avahi-core/server.c""}]}, {""source"": ""func_info(func:avahi_interface_address_on_link)"", ""result"": [{""code"": ""int avahi_interface_address_on_link(AvahiInterface *i, const AvahiAddress *a) {\n    AvahiInterfaceAddress *ia;\n\n    assert(i);\n    assert(a);\n\n    if (a->proto != i->protocol)\n        return 0;\n\n    for (ia = i->addresses; ia; ia = ia->address_next) {\n\n        if (a->proto == AVAHI_PROTO_INET) {\n            uint32_t m;\n\n            m = ~(((uint32_t) -1) >> ia->prefix_len);\n\n            if ((ntohl(a->data.ipv4.address) & m) == (ntohl(ia->address.data.ipv4.address) & m))\n                return 1;\n        } else {\n            unsigned j;\n            unsigned char pl;\n            assert(a->proto == AVAHI_PROTO_INET6);\n\n            pl = ia->prefix_len;\n\n            for (j = 0; j < 16; j++) {\n                uint8_t m;\n\n                if (pl == 0)\n                    return 1;\n\n                if (pl >= 8) {\n                    m = 0xFF;\n                    pl -= 8;\n                } else {\n                    m = ~(0xFF >> pl);\n                    pl = 0;\n                }\n\n                if ((a->data.ipv6.address[j] & m) != (ia->address.data.ipv6.address[j] & m))\n                    break;\n            }\n        }\n    }\n\n    return 0;\n}\n"", ""start_line"": 777, ""end_line"": 823, ""full_name"": ""avahi_interface_address_on_link"", ""file_path"": ""avahi-core/iface.c""}]}]","Legacy unicast queries were processed without verifying the source IP's on-link status in `server.c:dispatch_packet()` (CVE-2017-6519/CVE-2018-100084). The patch adds checks at `server.c:947-953` to drop packets where `dst_address` is not a multicast address (`is_mdns_mcast_address()` in `server.c:871-877`) and `src_address` is not on the local interface's subnet (`avahi_interface_address_on_link()` in `iface.c:777-823`). The vulnerability arose because packets with remote source IPs were processed, enabling traffic amplification and information leakage.",0.95,./github/other_context/CVE-2017-6519
32,CVE-2018-15468,CWE-863,c_cpp,"An issue was discovered in Xen through 4.11.x. The DEBUGCTL MSR contains several debugging features, some of which virtualise cleanly, but some do not. In particular, Branch Trace Store is not virtualised by the processor, and software has to be careful to configure it suitably not to lock up the core. As a result, it must only be available to fully trusted guests. Unfortunately, in the case that vPMU is disabled, all value checking was skipped, allowing the guest to choose any MSR_DEBUGCTL setting it likes. A malicious or buggy guest administrator (on Intel x86 HVM or PVH) can lock up the entire host, causing a Denial of Service.",https://github.com/xen-project/xen/commit/2a8a8e99feb950504559196521bc9fd63ed3a962,"x86/vtx: Fix the checking for unknown/invalid MSR_DEBUGCTL bits\n\nThe VPMU_MODE_OFF early-exit in vpmu_do_wrmsr() introduced by c/s\n11fe998e56 bypasses all reserved bit checking in the general case.  As a\nresult, a guest can enable BTS when it shouldn't be permitted to, and\nlock up the entire host.\n\nWith vPMU active (not a security supported configuration, but useful for\ndebugging), the reserved bit checking in broken, caused by the original\nBTS changeset 1a8aa75ed.\n\nFrom a correctness standpoint, it is not possible to have two different\npieces of code responsible for different parts of value checking, if\nthere isn't an accumulation of bits which have been checked.  A\npractical upshot of this is that a guest can set any value it\nwishes (usually resulting in a vmentry failure for bad guest state).\n\nTherefore, fix this by implementing all the reserved bit checking in the\nmain MSR_DEBUGCTL block, and removing all handling of DEBUGCTL from the\nvPMU MSR logic.\n\nThis is XSA-269.\n\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",2,"[{""func_name"": ""core2_vpmu_do_wrmsr"", ""file_path"": ""xen/arch/x86/cpu/vpmu_intel.c"", ""func_code"": ""static int core2_vpmu_do_wrmsr(unsigned int msr, uint64_t msr_content,\n                               uint64_t supported)\n{\n    int i, tmp;\n    int type = -1, index = -1;\n    struct vcpu *v = current;\n    struct vpmu_struct *vpmu = vcpu_vpmu(v);\n    struct xen_pmu_intel_ctxt *core2_vpmu_cxt;\n    uint64_t *enabled_cntrs;\n\n    if ( !core2_vpmu_msr_common_check(msr, &type, &index) )\n    {\n        /* Special handling for BTS */\n        if ( msr == MSR_IA32_DEBUGCTLMSR )\n        {\n            supported |= IA32_DEBUGCTLMSR_TR | IA32_DEBUGCTLMSR_BTS |\n                         IA32_DEBUGCTLMSR_BTINT;\n\n            if ( cpu_has(&current_cpu_data, X86_FEATURE_DSCPL) )\n                supported |= IA32_DEBUGCTLMSR_BTS_OFF_OS |\n                             IA32_DEBUGCTLMSR_BTS_OFF_USR;\n            if ( !(msr_content & ~supported) &&\n                 vpmu_is_set(vpmu, VPMU_CPU_HAS_BTS) )\n                return 0;\n            if ( (msr_content & supported) &&\n                 !vpmu_is_set(vpmu, VPMU_CPU_HAS_BTS) )\n                printk(XENLOG_G_WARNING\n                       \""%pv: Debug Store unsupported on this CPU\\n\"",\n                       current);\n        }\n        return -EINVAL;\n    }\n\n    ASSERT(!supported);\n\n    if ( (type == MSR_TYPE_COUNTER) && (msr_content & fixed_counters_mask) )\n        /* Writing unsupported bits to a fixed counter */\n        return -EINVAL;\n\n    core2_vpmu_cxt = vpmu->context;\n    enabled_cntrs = vpmu->priv_context;\n    switch ( msr )\n    {\n    case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( msr_content & global_ovf_ctrl_mask )\n            return -EINVAL;\n        core2_vpmu_cxt->global_status &= ~msr_content;\n        wrmsrl(MSR_CORE_PERF_GLOBAL_OVF_CTRL, msr_content);\n        return 0;\n    case MSR_CORE_PERF_GLOBAL_STATUS:\n        gdprintk(XENLOG_INFO, \""Can not write readonly MSR: \""\n                 \""MSR_PERF_GLOBAL_STATUS(0x38E)!\\n\"");\n        return -EINVAL;\n    case MSR_IA32_PEBS_ENABLE:\n        if ( vpmu_features & (XENPMU_FEATURE_IPC_ONLY |\n                              XENPMU_FEATURE_ARCH_ONLY) )\n            return -EINVAL;\n        if ( msr_content )\n            /* PEBS is reported as unavailable in MSR_IA32_MISC_ENABLE */\n            return -EINVAL;\n        return 0;\n    case MSR_IA32_DS_AREA:\n        if ( !(vpmu_features & XENPMU_FEATURE_INTEL_BTS) )\n            return -EINVAL;\n        if ( vpmu_is_set(vpmu, VPMU_CPU_HAS_DS) )\n        {\n            if ( !(is_hvm_vcpu(v) ? is_canonical_address(msr_content)\n                                  : __addr_ok(msr_content)) )\n            {\n                gdprintk(XENLOG_WARNING,\n                         \""Illegal address for IA32_DS_AREA: %#\"" PRIx64 \""x\\n\"",\n                         msr_content);\n                return -EINVAL;\n            }\n            core2_vpmu_cxt->ds_area = msr_content;\n            break;\n        }\n        gdprintk(XENLOG_WARNING, \""Guest setting of DTS is ignored.\\n\"");\n        return 0;\n    case MSR_CORE_PERF_GLOBAL_CTRL:\n        if ( msr_content & global_ctrl_mask )\n            return -EINVAL;\n        core2_vpmu_cxt->global_ctrl = msr_content;\n        break;\n    case MSR_CORE_PERF_FIXED_CTR_CTRL:\n        if ( msr_content & fixed_ctrl_mask )\n            return -EINVAL;\n\n        if ( is_hvm_vcpu(v) )\n            vmx_read_guest_msr(v, MSR_CORE_PERF_GLOBAL_CTRL,\n                               &core2_vpmu_cxt->global_ctrl);\n        else\n            rdmsrl(MSR_CORE_PERF_GLOBAL_CTRL, core2_vpmu_cxt->global_ctrl);\n        *enabled_cntrs &= ~(((1ULL << fixed_pmc_cnt) - 1) << 32);\n        if ( msr_content != 0 )\n        {\n            u64 val = msr_content;\n            for ( i = 0; i < fixed_pmc_cnt; i++ )\n            {\n                if ( val & 3 )\n                    *enabled_cntrs |= (1ULL << 32) << i;\n                val >>= FIXED_CTR_CTRL_BITS;\n            }\n        }\n\n        core2_vpmu_cxt->fixed_ctrl = msr_content;\n        break;\n    default:\n        tmp = msr - MSR_P6_EVNTSEL(0);\n        if ( tmp >= 0 && tmp < arch_pmc_cnt )\n        {\n            bool_t blocked = 0;\n            uint64_t umaskevent = msr_content & MSR_IA32_CMT_EVTSEL_UE_MASK;\n            struct xen_pmu_cntr_pair *xen_pmu_cntr_pair =\n                vpmu_reg_pointer(core2_vpmu_cxt, arch_counters);\n\n            if ( msr_content & ARCH_CTRL_MASK )\n                return -EINVAL;\n\n            /* PMC filters */\n            if ( vpmu_features & (XENPMU_FEATURE_IPC_ONLY |\n                                  XENPMU_FEATURE_ARCH_ONLY) )\n            {\n                blocked = 1;\n                switch ( umaskevent )\n                {\n                /*\n                 * See the Pre-Defined Architectural Performance Events table\n                 * from the Intel 64 and IA-32 Architectures Software\n                 * Developer's Manual, Volume 3B, System Programming Guide,\n                 * Part 2.\n                 */\n                case 0x003c:\t/* UnHalted Core Cycles */\n                case 0x013c:\t/* UnHalted Reference Cycles */\n                case 0x00c0:\t/* Instructions Retired */\n                    blocked = 0;\n                    break;\n                }\n            }\n\n            if ( vpmu_features & XENPMU_FEATURE_ARCH_ONLY )\n            {\n                /* Additional counters beyond IPC only; blocked already set. */\n                switch ( umaskevent )\n                {\n                case 0x4f2e:\t/* Last Level Cache References */\n                case 0x412e:\t/* Last Level Cache Misses */\n                case 0x00c4:\t/* Branch Instructions Retired */\n                case 0x00c5:\t/* All Branch Mispredict Retired */\n                    blocked = 0;\n                    break;\n               }\n            }\n\n            if ( blocked )\n                return -EINVAL;\n\n            if ( is_hvm_vcpu(v) )\n                vmx_read_guest_msr(v, MSR_CORE_PERF_GLOBAL_CTRL,\n                                   &core2_vpmu_cxt->global_ctrl);\n            else\n                rdmsrl(MSR_CORE_PERF_GLOBAL_CTRL, core2_vpmu_cxt->global_ctrl);\n\n            if ( msr_content & ARCH_CNTR_ENABLED )\n                *enabled_cntrs |= 1ULL << tmp;\n            else\n                *enabled_cntrs &= ~(1ULL << tmp);\n\n            xen_pmu_cntr_pair[tmp].control = msr_content;\n        }\n    }\n\n    if ( type != MSR_TYPE_GLOBAL )\n        wrmsrl(msr, msr_content);\n    else\n    {\n        if ( is_hvm_vcpu(v) )\n            vmx_write_guest_msr(v, MSR_CORE_PERF_GLOBAL_CTRL, msr_content);\n        else\n            wrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, msr_content);\n    }\n\n    if ( (core2_vpmu_cxt->global_ctrl & *enabled_cntrs) ||\n         (core2_vpmu_cxt->ds_area != 0) )\n        vpmu_set(vpmu, VPMU_RUNNING);\n    else\n        vpmu_reset(vpmu, VPMU_RUNNING);\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""vmx_msr_write_intercept"", ""file_path"": ""xen/arch/x86/hvm/vmx/vmx.c"", ""func_code"": ""static int vmx_msr_write_intercept(unsigned int msr, uint64_t msr_content)\n{\n    struct vcpu *v = current;\n\n    HVM_DBG_LOG(DBG_LEVEL_MSR, \""ecx=%#x, msr_value=%#\""PRIx64, msr, msr_content);\n\n    switch ( msr )\n    {\n    case MSR_IA32_SYSENTER_CS:\n        __vmwrite(GUEST_SYSENTER_CS, msr_content);\n        break;\n    case MSR_IA32_SYSENTER_ESP:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        __vmwrite(GUEST_SYSENTER_ESP, msr_content);\n        break;\n    case MSR_IA32_SYSENTER_EIP:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        __vmwrite(GUEST_SYSENTER_EIP, msr_content);\n        break;\n\n    case MSR_FS_BASE:\n    case MSR_GS_BASE:\n    case MSR_SHADOW_GS_BASE:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n\n        if ( msr == MSR_FS_BASE )\n            __vmwrite(GUEST_FS_BASE, msr_content);\n        else if ( msr == MSR_GS_BASE )\n            __vmwrite(GUEST_GS_BASE, msr_content);\n        else\n            wrgsshadow(msr_content);\n\n        break;\n\n    case MSR_STAR:\n        v->arch.hvm_vmx.star = msr_content;\n        wrmsrl(MSR_STAR, msr_content);\n        break;\n\n    case MSR_LSTAR:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        v->arch.hvm_vmx.lstar = msr_content;\n        wrmsrl(MSR_LSTAR, msr_content);\n        break;\n\n    case MSR_CSTAR:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        v->arch.hvm_vmx.cstar = msr_content;\n        break;\n\n    case MSR_SYSCALL_MASK:\n        v->arch.hvm_vmx.sfmask = msr_content;\n        wrmsrl(MSR_SYSCALL_MASK, msr_content);\n        break;\n\n    case MSR_IA32_DEBUGCTLMSR: {\n        uint64_t supported = IA32_DEBUGCTLMSR_LBR | IA32_DEBUGCTLMSR_BTF;\n\n        if ( boot_cpu_has(X86_FEATURE_RTM) )\n            supported |= IA32_DEBUGCTLMSR_RTM;\n        if ( msr_content & ~supported )\n        {\n            /* Perhaps some other bits are supported in vpmu. */\n            if ( vpmu_do_wrmsr(msr, msr_content, supported) )\n                break;\n        }\n\n        /*\n         * When a guest first enables LBR, arrange to save and restore the LBR\n         * MSRs and allow the guest direct access.\n         *\n         * MSR_DEBUGCTL and LBR has existed almost as long as MSRs have\n         * existed, and there is no architectural way to hide the feature, or\n         * fail the attempt to enable LBR.\n         *\n         * Unknown host LBR MSRs or hitting -ENOSPC with the guest load/save\n         * list are definitely hypervisor bugs, whereas -ENOMEM for allocating\n         * the load/save list is simply unlucky (and shouldn't occur with\n         * sensible management by the toolstack).\n         *\n         * Either way, there is nothing we can do right now to recover, and\n         * the guest won't execute correctly either.  Simply crash the domain\n         * to make the failure obvious.\n         */\n        if ( !(v->arch.hvm_vmx.lbr_flags & LBR_MSRS_INSERTED) &&\n             (msr_content & IA32_DEBUGCTLMSR_LBR) )\n        {\n            const struct lbr_info *lbr = last_branch_msr_get();\n\n            if ( unlikely(!lbr) )\n            {\n                gprintk(XENLOG_ERR, \""Unknown Host LBR MSRs\\n\"");\n                domain_crash(v->domain);\n                return X86EMUL_OKAY;\n            }\n\n            for ( ; lbr->count; lbr++ )\n            {\n                unsigned int i;\n\n                for ( i = 0; i < lbr->count; i++ )\n                {\n                    int rc = vmx_add_guest_msr(v, lbr->base + i, 0);\n\n                    if ( unlikely(rc) )\n                    {\n                        gprintk(XENLOG_ERR,\n                                \""Guest load/save list error %d\\n\"", rc);\n                        domain_crash(v->domain);\n                        return X86EMUL_OKAY;\n                    }\n\n                    vmx_clear_msr_intercept(v, lbr->base + i, VMX_MSR_RW);\n                }\n            }\n\n            v->arch.hvm_vmx.lbr_flags |= LBR_MSRS_INSERTED;\n            if ( lbr_tsx_fixup_needed )\n                v->arch.hvm_vmx.lbr_flags |= LBR_FIXUP_TSX;\n            if ( bdw_erratum_bdf14_fixup_needed )\n                v->arch.hvm_vmx.lbr_flags |= LBR_FIXUP_BDF14;\n        }\n\n        __vmwrite(GUEST_IA32_DEBUGCTL, msr_content);\n        break;\n    }\n    case MSR_IA32_FEATURE_CONTROL:\n    case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n        /* None of these MSRs are writeable. */\n        goto gp_fault;\n\n    case MSR_P6_PERFCTR(0)...MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0)...MSR_P6_EVNTSEL(7):\n    case MSR_CORE_PERF_FIXED_CTR0...MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL...MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n    case MSR_IA32_PEBS_ENABLE:\n    case MSR_IA32_DS_AREA:\n         if ( vpmu_do_wrmsr(msr, msr_content, 0) )\n            goto gp_fault;\n        break;\n\n    default:\n        if ( passive_domain_do_wrmsr(msr, msr_content) )\n            return X86EMUL_OKAY;\n\n        if ( wrmsr_viridian_regs(msr, msr_content) ) \n            break;\n\n        if ( vmx_write_guest_msr(v, msr, msr_content) == 0 ||\n             is_last_branch_msr(msr) )\n            break;\n\n        switch ( wrmsr_hypervisor_regs(msr, msr_content) )\n        {\n        case -ERESTART:\n            return X86EMUL_RETRY;\n        case 0:\n            /*\n             * Match up with the RDMSR side for now; ultimately this\n             * entire case block should go away.\n             */\n            if ( rdmsr_safe(msr, msr_content) == 0 )\n                break;\n            goto gp_fault;\n        case 1:\n            break;\n        default:\n            goto gp_fault;\n        }\n        break;\n    }\n\n    return X86EMUL_OKAY;\n\ngp_fault:\n    return X86EMUL_EXCEPTION;\n}"", ""target"": 0}]","[{""func_name"": ""core2_vpmu_do_wrmsr"", ""file_path"": ""xen/arch/x86/cpu/vpmu_intel.c"", ""func_code"": ""static int core2_vpmu_do_wrmsr(unsigned int msr, uint64_t msr_content,\n                               uint64_t supported)\n{\n    int i, tmp;\n    int type = -1, index = -1;\n    struct vcpu *v = current;\n    struct vpmu_struct *vpmu = vcpu_vpmu(v);\n    struct xen_pmu_intel_ctxt *core2_vpmu_cxt;\n    uint64_t *enabled_cntrs;\n\n    if ( !core2_vpmu_msr_common_check(msr, &type, &index) )\n        return -EINVAL;\n\n    ASSERT(!supported);\n\n    if ( (type == MSR_TYPE_COUNTER) && (msr_content & fixed_counters_mask) )\n        /* Writing unsupported bits to a fixed counter */\n        return -EINVAL;\n\n    core2_vpmu_cxt = vpmu->context;\n    enabled_cntrs = vpmu->priv_context;\n    switch ( msr )\n    {\n    case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( msr_content & global_ovf_ctrl_mask )\n            return -EINVAL;\n        core2_vpmu_cxt->global_status &= ~msr_content;\n        wrmsrl(MSR_CORE_PERF_GLOBAL_OVF_CTRL, msr_content);\n        return 0;\n    case MSR_CORE_PERF_GLOBAL_STATUS:\n        gdprintk(XENLOG_INFO, \""Can not write readonly MSR: \""\n                 \""MSR_PERF_GLOBAL_STATUS(0x38E)!\\n\"");\n        return -EINVAL;\n    case MSR_IA32_PEBS_ENABLE:\n        if ( vpmu_features & (XENPMU_FEATURE_IPC_ONLY |\n                              XENPMU_FEATURE_ARCH_ONLY) )\n            return -EINVAL;\n        if ( msr_content )\n            /* PEBS is reported as unavailable in MSR_IA32_MISC_ENABLE */\n            return -EINVAL;\n        return 0;\n    case MSR_IA32_DS_AREA:\n        if ( !(vpmu_features & XENPMU_FEATURE_INTEL_BTS) )\n            return -EINVAL;\n        if ( vpmu_is_set(vpmu, VPMU_CPU_HAS_DS) )\n        {\n            if ( !(is_hvm_vcpu(v) ? is_canonical_address(msr_content)\n                                  : __addr_ok(msr_content)) )\n            {\n                gdprintk(XENLOG_WARNING,\n                         \""Illegal address for IA32_DS_AREA: %#\"" PRIx64 \""x\\n\"",\n                         msr_content);\n                return -EINVAL;\n            }\n            core2_vpmu_cxt->ds_area = msr_content;\n            break;\n        }\n        gdprintk(XENLOG_WARNING, \""Guest setting of DTS is ignored.\\n\"");\n        return 0;\n    case MSR_CORE_PERF_GLOBAL_CTRL:\n        if ( msr_content & global_ctrl_mask )\n            return -EINVAL;\n        core2_vpmu_cxt->global_ctrl = msr_content;\n        break;\n    case MSR_CORE_PERF_FIXED_CTR_CTRL:\n        if ( msr_content & fixed_ctrl_mask )\n            return -EINVAL;\n\n        if ( is_hvm_vcpu(v) )\n            vmx_read_guest_msr(v, MSR_CORE_PERF_GLOBAL_CTRL,\n                               &core2_vpmu_cxt->global_ctrl);\n        else\n            rdmsrl(MSR_CORE_PERF_GLOBAL_CTRL, core2_vpmu_cxt->global_ctrl);\n        *enabled_cntrs &= ~(((1ULL << fixed_pmc_cnt) - 1) << 32);\n        if ( msr_content != 0 )\n        {\n            u64 val = msr_content;\n            for ( i = 0; i < fixed_pmc_cnt; i++ )\n            {\n                if ( val & 3 )\n                    *enabled_cntrs |= (1ULL << 32) << i;\n                val >>= FIXED_CTR_CTRL_BITS;\n            }\n        }\n\n        core2_vpmu_cxt->fixed_ctrl = msr_content;\n        break;\n    default:\n        tmp = msr - MSR_P6_EVNTSEL(0);\n        if ( tmp >= 0 && tmp < arch_pmc_cnt )\n        {\n            bool_t blocked = 0;\n            uint64_t umaskevent = msr_content & MSR_IA32_CMT_EVTSEL_UE_MASK;\n            struct xen_pmu_cntr_pair *xen_pmu_cntr_pair =\n                vpmu_reg_pointer(core2_vpmu_cxt, arch_counters);\n\n            if ( msr_content & ARCH_CTRL_MASK )\n                return -EINVAL;\n\n            /* PMC filters */\n            if ( vpmu_features & (XENPMU_FEATURE_IPC_ONLY |\n                                  XENPMU_FEATURE_ARCH_ONLY) )\n            {\n                blocked = 1;\n                switch ( umaskevent )\n                {\n                /*\n                 * See the Pre-Defined Architectural Performance Events table\n                 * from the Intel 64 and IA-32 Architectures Software\n                 * Developer's Manual, Volume 3B, System Programming Guide,\n                 * Part 2.\n                 */\n                case 0x003c:\t/* UnHalted Core Cycles */\n                case 0x013c:\t/* UnHalted Reference Cycles */\n                case 0x00c0:\t/* Instructions Retired */\n                    blocked = 0;\n                    break;\n                }\n            }\n\n            if ( vpmu_features & XENPMU_FEATURE_ARCH_ONLY )\n            {\n                /* Additional counters beyond IPC only; blocked already set. */\n                switch ( umaskevent )\n                {\n                case 0x4f2e:\t/* Last Level Cache References */\n                case 0x412e:\t/* Last Level Cache Misses */\n                case 0x00c4:\t/* Branch Instructions Retired */\n                case 0x00c5:\t/* All Branch Mispredict Retired */\n                    blocked = 0;\n                    break;\n               }\n            }\n\n            if ( blocked )\n                return -EINVAL;\n\n            if ( is_hvm_vcpu(v) )\n                vmx_read_guest_msr(v, MSR_CORE_PERF_GLOBAL_CTRL,\n                                   &core2_vpmu_cxt->global_ctrl);\n            else\n                rdmsrl(MSR_CORE_PERF_GLOBAL_CTRL, core2_vpmu_cxt->global_ctrl);\n\n            if ( msr_content & ARCH_CNTR_ENABLED )\n                *enabled_cntrs |= 1ULL << tmp;\n            else\n                *enabled_cntrs &= ~(1ULL << tmp);\n\n            xen_pmu_cntr_pair[tmp].control = msr_content;\n        }\n    }\n\n    if ( type != MSR_TYPE_GLOBAL )\n        wrmsrl(msr, msr_content);\n    else\n    {\n        if ( is_hvm_vcpu(v) )\n            vmx_write_guest_msr(v, MSR_CORE_PERF_GLOBAL_CTRL, msr_content);\n        else\n            wrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, msr_content);\n    }\n\n    if ( (core2_vpmu_cxt->global_ctrl & *enabled_cntrs) ||\n         (core2_vpmu_cxt->ds_area != 0) )\n        vpmu_set(vpmu, VPMU_RUNNING);\n    else\n        vpmu_reset(vpmu, VPMU_RUNNING);\n\n    return 0;\n}""}, {""func_name"": ""vmx_msr_write_intercept"", ""file_path"": ""xen/arch/x86/hvm/vmx/vmx.c"", ""func_code"": ""static int vmx_msr_write_intercept(unsigned int msr, uint64_t msr_content)\n{\n    struct vcpu *v = current;\n    const struct cpuid_policy *cp = v->domain->arch.cpuid;\n\n    HVM_DBG_LOG(DBG_LEVEL_MSR, \""ecx=%#x, msr_value=%#\""PRIx64, msr, msr_content);\n\n    switch ( msr )\n    {\n        uint64_t rsvd;\n\n    case MSR_IA32_SYSENTER_CS:\n        __vmwrite(GUEST_SYSENTER_CS, msr_content);\n        break;\n    case MSR_IA32_SYSENTER_ESP:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        __vmwrite(GUEST_SYSENTER_ESP, msr_content);\n        break;\n    case MSR_IA32_SYSENTER_EIP:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        __vmwrite(GUEST_SYSENTER_EIP, msr_content);\n        break;\n\n    case MSR_FS_BASE:\n    case MSR_GS_BASE:\n    case MSR_SHADOW_GS_BASE:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n\n        if ( msr == MSR_FS_BASE )\n            __vmwrite(GUEST_FS_BASE, msr_content);\n        else if ( msr == MSR_GS_BASE )\n            __vmwrite(GUEST_GS_BASE, msr_content);\n        else\n            wrgsshadow(msr_content);\n\n        break;\n\n    case MSR_STAR:\n        v->arch.hvm_vmx.star = msr_content;\n        wrmsrl(MSR_STAR, msr_content);\n        break;\n\n    case MSR_LSTAR:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        v->arch.hvm_vmx.lstar = msr_content;\n        wrmsrl(MSR_LSTAR, msr_content);\n        break;\n\n    case MSR_CSTAR:\n        if ( !is_canonical_address(msr_content) )\n            goto gp_fault;\n        v->arch.hvm_vmx.cstar = msr_content;\n        break;\n\n    case MSR_SYSCALL_MASK:\n        v->arch.hvm_vmx.sfmask = msr_content;\n        wrmsrl(MSR_SYSCALL_MASK, msr_content);\n        break;\n\n    case MSR_IA32_DEBUGCTLMSR:\n        rsvd = ~(IA32_DEBUGCTLMSR_LBR | IA32_DEBUGCTLMSR_BTF);\n\n        /* TODO: Wire vPMU settings properly through the CPUID policy */\n        if ( vpmu_is_set(vcpu_vpmu(v), VPMU_CPU_HAS_BTS) )\n        {\n            rsvd &= ~(IA32_DEBUGCTLMSR_TR | IA32_DEBUGCTLMSR_BTS |\n                      IA32_DEBUGCTLMSR_BTINT);\n\n            if ( cpu_has(&current_cpu_data, X86_FEATURE_DSCPL) )\n                rsvd &= ~(IA32_DEBUGCTLMSR_BTS_OFF_OS |\n                          IA32_DEBUGCTLMSR_BTS_OFF_USR);\n        }\n\n        if ( cp->feat.rtm )\n            rsvd &= ~IA32_DEBUGCTLMSR_RTM;\n\n        if ( msr_content & rsvd )\n            goto gp_fault;\n\n        /*\n         * When a guest first enables LBR, arrange to save and restore the LBR\n         * MSRs and allow the guest direct access.\n         *\n         * MSR_DEBUGCTL and LBR has existed almost as long as MSRs have\n         * existed, and there is no architectural way to hide the feature, or\n         * fail the attempt to enable LBR.\n         *\n         * Unknown host LBR MSRs or hitting -ENOSPC with the guest load/save\n         * list are definitely hypervisor bugs, whereas -ENOMEM for allocating\n         * the load/save list is simply unlucky (and shouldn't occur with\n         * sensible management by the toolstack).\n         *\n         * Either way, there is nothing we can do right now to recover, and\n         * the guest won't execute correctly either.  Simply crash the domain\n         * to make the failure obvious.\n         */\n        if ( !(v->arch.hvm_vmx.lbr_flags & LBR_MSRS_INSERTED) &&\n             (msr_content & IA32_DEBUGCTLMSR_LBR) )\n        {\n            const struct lbr_info *lbr = last_branch_msr_get();\n\n            if ( unlikely(!lbr) )\n            {\n                gprintk(XENLOG_ERR, \""Unknown Host LBR MSRs\\n\"");\n                domain_crash(v->domain);\n                return X86EMUL_OKAY;\n            }\n\n            for ( ; lbr->count; lbr++ )\n            {\n                unsigned int i;\n\n                for ( i = 0; i < lbr->count; i++ )\n                {\n                    int rc = vmx_add_guest_msr(v, lbr->base + i, 0);\n\n                    if ( unlikely(rc) )\n                    {\n                        gprintk(XENLOG_ERR,\n                                \""Guest load/save list error %d\\n\"", rc);\n                        domain_crash(v->domain);\n                        return X86EMUL_OKAY;\n                    }\n\n                    vmx_clear_msr_intercept(v, lbr->base + i, VMX_MSR_RW);\n                }\n            }\n\n            v->arch.hvm_vmx.lbr_flags |= LBR_MSRS_INSERTED;\n            if ( lbr_tsx_fixup_needed )\n                v->arch.hvm_vmx.lbr_flags |= LBR_FIXUP_TSX;\n            if ( bdw_erratum_bdf14_fixup_needed )\n                v->arch.hvm_vmx.lbr_flags |= LBR_FIXUP_BDF14;\n        }\n\n        __vmwrite(GUEST_IA32_DEBUGCTL, msr_content);\n        break;\n\n    case MSR_IA32_FEATURE_CONTROL:\n    case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n        /* None of these MSRs are writeable. */\n        goto gp_fault;\n\n    case MSR_P6_PERFCTR(0)...MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0)...MSR_P6_EVNTSEL(7):\n    case MSR_CORE_PERF_FIXED_CTR0...MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL...MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n    case MSR_IA32_PEBS_ENABLE:\n    case MSR_IA32_DS_AREA:\n         if ( vpmu_do_wrmsr(msr, msr_content, 0) )\n            goto gp_fault;\n        break;\n\n    default:\n        if ( passive_domain_do_wrmsr(msr, msr_content) )\n            return X86EMUL_OKAY;\n\n        if ( wrmsr_viridian_regs(msr, msr_content) ) \n            break;\n\n        if ( vmx_write_guest_msr(v, msr, msr_content) == 0 ||\n             is_last_branch_msr(msr) )\n            break;\n\n        switch ( wrmsr_hypervisor_regs(msr, msr_content) )\n        {\n        case -ERESTART:\n            return X86EMUL_RETRY;\n        case 0:\n            /*\n             * Match up with the RDMSR side for now; ultimately this\n             * entire case block should go away.\n             */\n            if ( rdmsr_safe(msr, msr_content) == 0 )\n                break;\n            goto gp_fault;\n        case 1:\n            break;\n        default:\n            goto gp_fault;\n        }\n        break;\n    }\n\n    return X86EMUL_OKAY;\n\ngp_fault:\n    return X86EMUL_EXCEPTION;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(func:vpmu_do_wrmsr)"", ""result"": [{""code"": ""static inline int vpmu_do_wrmsr(unsigned int msr, uint64_t msr_content,\n                                uint64_t supported)\n{\n    return vpmu_do_msr(msr, &msr_content, supported, 1);\n}"", ""start_line"": 116, ""end_line"": 120, ""full_name"": ""vpmu_do_wrmsr"", ""file_path"": ""xen/include/asm-x86/vpmu.h""}]}, {""source"": ""code_info(file:vpmu.c, lines:11-211)"", ""result"": "" * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; If not, see <http://www.gnu.org/licenses/>.\n *\n * Author: Haitao Shan <haitao.shan@intel.com>\n */\n#include <xen/sched.h>\n#include <xen/xenoprof.h>\n#include <xen/event.h>\n#include <xen/guest_access.h>\n#include <xen/cpu.h>\n#include <asm/regs.h>\n#include <asm/types.h>\n#include <asm/msr.h>\n#include <asm/nmi.h>\n#include <asm/p2m.h>\n#include <asm/vpmu.h>\n#include <asm/hvm/support.h>\n#include <asm/hvm/vmx/vmx.h>\n#include <asm/hvm/vmx/vmcs.h>\n#include <asm/hvm/svm/svm.h>\n#include <asm/hvm/svm/vmcb.h>\n#include <asm/apic.h>\n#include <public/pmu.h>\n#include <xsm/xsm.h>\n\n#include <compat/pmu.h>\nCHECK_pmu_cntr_pair;\nCHECK_pmu_data;\nCHECK_pmu_params;\n\n/*\n * \""vpmu\"" :     vpmu generally enabled (all counters)\n * \""vpmu=off\""  : vpmu generally disabled\n * \""vpmu=bts\""  : vpmu enabled and Intel BTS feature switched on.\n * \""vpmu=ipc\""  : vpmu enabled for IPC counters only (most restrictive)\n * \""vpmu=arch\"" : vpmu enabled for predef arch counters only (restrictive)\n * flag combinations are allowed, eg, \""vpmu=ipc,bts\"".\n */\nstatic unsigned int __read_mostly opt_vpmu_enabled;\nunsigned int __read_mostly vpmu_mode = XENPMU_MODE_OFF;\nunsigned int __read_mostly vpmu_features = 0;\nstatic int parse_vpmu_params(const char *s);\ncustom_param(\""vpmu\"", parse_vpmu_params);\n\nstatic DEFINE_SPINLOCK(vpmu_lock);\nstatic unsigned vpmu_count;\n\nstatic DEFINE_PER_CPU(struct vcpu *, last_vcpu);\n\nstatic int parse_vpmu_param(const char *s, unsigned int len)\n{\n    if ( !*s || !len )\n        return 0;\n    if ( !strncmp(s, \""bts\"", len) )\n        vpmu_features |= XENPMU_FEATURE_INTEL_BTS;\n    else if ( !strncmp(s, \""ipc\"", len) )\n        vpmu_features |= XENPMU_FEATURE_IPC_ONLY;\n    else if ( !strncmp(s, \""arch\"", len) )\n        vpmu_features |= XENPMU_FEATURE_ARCH_ONLY;\n    else\n        return 1;\n    return 0;\n}\n\nstatic int __init parse_vpmu_params(const char *s)\n{\n    const char *sep, *p = s;\n\n    switch ( parse_bool(s, NULL) )\n    {\n    case 0:\n        break;\n    default:\n        for ( ; ; )\n        {\n            sep = strchr(p, ',');\n            if ( sep == NULL )\n                sep = strchr(p, 0);\n            if ( parse_vpmu_param(p, sep - p) )\n                goto error;\n            if ( !*sep )\n                /* reached end of flags */\n                break;\n            p = sep + 1;\n        }\n        /* fall through */\n    case 1:\n        /* Default VPMU mode */\n        vpmu_mode = XENPMU_MODE_SELF;\n        opt_vpmu_enabled = 1;\n        break;\n    }\n    return 0;\n\n error:\n    printk(\""VPMU: unknown flags: %s - vpmu disabled!\\n\"", s);\n    return -EINVAL;\n}\n\nvoid vpmu_lvtpc_update(uint32_t val)\n{\n    struct vpmu_struct *vpmu;\n    struct vcpu *curr = current;\n\n    if ( likely(vpmu_mode == XENPMU_MODE_OFF) )\n        return;\n\n    vpmu = vcpu_vpmu(curr);\n\n    vpmu->hw_lapic_lvtpc = PMU_APIC_VECTOR | (val & APIC_LVT_MASKED);\n\n    /* Postpone APIC updates for PV(H) guests if PMU interrupt is pending */\n    if ( has_vlapic(curr->domain) || !vpmu->xenpmu_data ||\n         !vpmu_is_set(vpmu, VPMU_CACHED) )\n        apic_write(APIC_LVTPC, vpmu->hw_lapic_lvtpc);\n}\n\nint vpmu_do_msr(unsigned int msr, uint64_t *msr_content,\n                uint64_t supported, bool_t is_write)\n{\n    struct vcpu *curr = current;\n    struct vpmu_struct *vpmu;\n    const struct arch_vpmu_ops *ops;\n    int ret = 0;\n\n    /*\n     * Hide the PMU MSRs if vpmu is not configured, or the hardware domain is\n     * profiling the whole system.\n     */\n    if ( likely(vpmu_mode == XENPMU_MODE_OFF) ||\n         ((vpmu_mode & XENPMU_MODE_ALL) &&\n          !is_hardware_domain(curr->domain)) )\n         goto nop;\n\n    vpmu = vcpu_vpmu(curr);\n    ops = vpmu->arch_vpmu_ops;\n    if ( !ops )\n        goto nop;\n\n    if ( is_write && ops->do_wrmsr )\n        ret = ops->do_wrmsr(msr, *msr_content, supported);\n    else if ( !is_write && ops->do_rdmsr )\n        ret = ops->do_rdmsr(msr, msr_content);\n    else\n        goto nop;\n\n    /*\n     * We may have received a PMU interrupt while handling MSR access\n     * and since do_wr/rdmsr may load VPMU context we should save\n     * (and unload) it again.\n     */\n    if ( !has_vlapic(curr->domain) && vpmu->xenpmu_data &&\n        vpmu_is_set(vpmu, VPMU_CACHED) )\n    {\n        vpmu_set(vpmu, VPMU_CONTEXT_SAVE);\n        ops->arch_vpmu_save(curr, 0);\n        vpmu_reset(vpmu, VPMU_CONTEXT_SAVE | VPMU_CONTEXT_LOADED);\n    }\n\n    return ret;\n\n nop:\n    if ( !is_write && (msr != MSR_IA32_MISC_ENABLE) )\n        *msr_content = 0;\n\n    return 0;\n}\n\nstatic inline struct vcpu *choose_hwdom_vcpu(void)\n{\n    unsigned idx;\n\n    if ( hardware_domain->max_vcpus == 0 )\n        return NULL;\n\n    idx = smp_processor_id() % hardware_domain->max_vcpus;\n\n    return hardware_domain->vcpu[idx];\n}\n\nvoid vpmu_do_interrupt(struct cpu_user_regs *regs)\n{\n    struct vcpu *sampled = current, *sampling;\n    struct vpmu_struct *vpmu;\n    struct vlapic *vlapic;\n    u32 vlapic_lvtpc;\n\n    /*\n     * dom0 will handle interrupt for special domains (e.g. idle domain) or,\n     * in XENPMU_MODE_ALL, for everyone.\n     */\n    if ( (vpmu_mode & XENPMU_MODE_ALL) ||\n         (sampled->domain->domain_id >= DOMID_FIRST_RESERVED) )\n    {\n        sampling = choose_hwdom_vcpu();\n        if ( !sampling )\n            return;\n""}]","The root cause is the early-exit in vpmu_do_msr() (xen/arch/x86/cpu/vpmu.c:11-211) when vpmu_mode == XENPMU_MODE_OFF. This skips reserved bit validation for MSR_DEBUGCTL. When vPMU is disabled, calls to vpmu_do_wrmsr() (xen/include/asm-x86/vpmu.h:116-120) return early, bypassing checks. The VMX interception code (xen/arch/x86/hvm/vmx/vmx.c:3142-3223) now enforces reserved bits directly, closing the gap.",0.95,./github/other_context/CVE-2018-15468
33,CVE-2019-12450,"CWE-362, CWE-276",c_cpp,"file_copy_fallback in gio/gfile.c in GNOME GLib 2.15.0 through 2.61.1 does not properly restrict file permissions while a copy operation is in progress. Instead, default permissions are used.",https://github.com/GNOME/glib/commit/d8f8f4d637ce43f8699ba94c9b7648beda0ca174,gfile: Limit access to files when copying\n\nfile_copy_fallback creates new files with default permissions and\nset the correct permissions after the operation is finished. This\nmight cause that the files can be accessible by more users during\nthe operation than expected. Use G_FILE_CREATE_PRIVATE for the new\nfiles to limit access to those files.,1,"[{""func_name"": ""file_copy_fallback"", ""file_path"": ""gio/gfile.c"", ""func_code"": ""static gboolean\nfile_copy_fallback (GFile                  *source,\n                    GFile                  *destination,\n                    GFileCopyFlags          flags,\n                    GCancellable           *cancellable,\n                    GFileProgressCallback   progress_callback,\n                    gpointer                progress_callback_data,\n                    GError                **error)\n{\n  gboolean ret = FALSE;\n  GFileInputStream *file_in = NULL;\n  GInputStream *in = NULL;\n  GOutputStream *out = NULL;\n  GFileInfo *info = NULL;\n  const char *target;\n  char *attrs_to_read;\n  gboolean do_set_attributes = FALSE;\n\n  /* need to know the file type */\n  info = g_file_query_info (source,\n                            G_FILE_ATTRIBUTE_STANDARD_TYPE \"",\"" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            cancellable,\n                            error);\n  if (!info)\n    goto out;\n\n  /* Maybe copy the symlink? */\n  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&\n      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n      target = g_file_info_get_symlink_target (info);\n      if (target)\n        {\n          if (!copy_symlink (destination, flags, cancellable, target, error))\n            goto out;\n\n          ret = TRUE;\n          goto out;\n        }\n        /* ... else fall back on a regular file copy */\n    }\n  /* Handle \""special\"" files (pipes, device nodes, ...)? */\n  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)\n    {\n      /* FIXME: could try to recreate device nodes and others? */\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Can\u2019t copy special file\""));\n      goto out;\n    }\n\n  /* Everything else should just fall back on a regular copy. */\n\n  file_in = open_source_for_copy (source, destination, flags, cancellable, error);\n  if (!file_in)\n    goto out;\n  in = G_INPUT_STREAM (file_in);\n\n  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,\n                                      cancellable, error))\n    goto out;\n\n  if (attrs_to_read != NULL)\n    {\n      GError *tmp_error = NULL;\n\n      /* Ok, ditch the previous lightweight info (on Unix we just\n       * called lstat()); at this point we gather all the information\n       * we need about the source from the opened file descriptor.\n       */\n      g_object_unref (info);\n\n      info = g_file_input_stream_query_info (file_in, attrs_to_read,\n                                             cancellable, &tmp_error);\n      if (!info)\n        {\n          /* Not all gvfs backends implement query_info_on_read(), we\n           * can just fall back to the pathname again.\n           * https://bugzilla.gnome.org/706254\n           */\n          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&tmp_error);\n              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n            }\n          else\n            {\n              g_free (attrs_to_read);\n              g_propagate_error (error, tmp_error);\n              goto out;\n            }\n        }\n      g_free (attrs_to_read);\n      if (!info)\n        goto out;\n\n      do_set_attributes = TRUE;\n    }\n\n  /* In the local file path, we pass down the source info which\n   * includes things like unix::mode, to ensure that the target file\n   * is not created with different permissions from the source file.\n   *\n   * If a future API like g_file_replace_with_info() is added, switch\n   * this code to use that.\n   */\n  if (G_IS_LOCAL_FILE (destination))\n    {\n      if (flags & G_FILE_COPY_OVERWRITE)\n        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                   FALSE, NULL,\n                                                                   flags & G_FILE_COPY_BACKUP,\n                                                                   G_FILE_CREATE_REPLACE_DESTINATION,\n                                                                   info,\n                                                                   cancellable, error);\n      else\n        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                  FALSE, 0, info,\n                                                                  cancellable, error);\n    }\n  else if (flags & G_FILE_COPY_OVERWRITE)\n    {\n      out = (GOutputStream *)g_file_replace (destination,\n                                             NULL,\n                                             flags & G_FILE_COPY_BACKUP,\n                                             G_FILE_CREATE_REPLACE_DESTINATION,\n                                             cancellable, error);\n    }\n  else\n    {\n      out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);\n    }\n\n  if (!out)\n    goto out;\n\n#ifdef __linux__\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *reflink_err = NULL;\n\n      if (!btrfs_reflink_with_progress (in, out, info, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &reflink_err))\n        {\n          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&reflink_err);\n            }\n          else\n            {\n              g_propagate_error (error, reflink_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n#endif\n\n#ifdef HAVE_SPLICE\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *splice_err = NULL;\n\n      if (!splice_stream_with_progress (in, out, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &splice_err))\n        {\n          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&splice_err);\n            }\n          else\n            {\n              g_propagate_error (error, splice_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n#endif\n\n  /* A plain read/write loop */\n  if (!copy_stream_with_progress (in, out, source, cancellable,\n                                  progress_callback, progress_callback_data,\n                                  error))\n    goto out;\n\n  ret = TRUE;\n out:\n  if (in)\n    {\n      /* Don't care about errors in source here */\n      (void) g_input_stream_close (in, cancellable, NULL);\n      g_object_unref (in);\n    }\n\n  if (out)\n    {\n      /* But write errors on close are bad! */\n      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))\n        ret = FALSE;\n      g_object_unref (out);\n    }\n\n  /* Ignore errors here. Failure to copy metadata is not a hard error */\n  /* TODO: set these attributes /before/ we do the rename() on Unix */\n  if (ret && do_set_attributes)\n    {\n      g_file_set_attributes_from_info (destination,\n                                       info,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       cancellable,\n                                       NULL);\n    }\n\n  g_clear_object (&info);\n\n  return ret;\n}"", ""target"": 0}]","[{""func_name"": ""file_copy_fallback"", ""file_path"": ""gio/gfile.c"", ""func_code"": ""static gboolean\nfile_copy_fallback (GFile                  *source,\n                    GFile                  *destination,\n                    GFileCopyFlags          flags,\n                    GCancellable           *cancellable,\n                    GFileProgressCallback   progress_callback,\n                    gpointer                progress_callback_data,\n                    GError                **error)\n{\n  gboolean ret = FALSE;\n  GFileInputStream *file_in = NULL;\n  GInputStream *in = NULL;\n  GOutputStream *out = NULL;\n  GFileInfo *info = NULL;\n  const char *target;\n  char *attrs_to_read;\n  gboolean do_set_attributes = FALSE;\n\n  /* need to know the file type */\n  info = g_file_query_info (source,\n                            G_FILE_ATTRIBUTE_STANDARD_TYPE \"",\"" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            cancellable,\n                            error);\n  if (!info)\n    goto out;\n\n  /* Maybe copy the symlink? */\n  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&\n      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n      target = g_file_info_get_symlink_target (info);\n      if (target)\n        {\n          if (!copy_symlink (destination, flags, cancellable, target, error))\n            goto out;\n\n          ret = TRUE;\n          goto out;\n        }\n        /* ... else fall back on a regular file copy */\n    }\n  /* Handle \""special\"" files (pipes, device nodes, ...)? */\n  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)\n    {\n      /* FIXME: could try to recreate device nodes and others? */\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Can\u2019t copy special file\""));\n      goto out;\n    }\n\n  /* Everything else should just fall back on a regular copy. */\n\n  file_in = open_source_for_copy (source, destination, flags, cancellable, error);\n  if (!file_in)\n    goto out;\n  in = G_INPUT_STREAM (file_in);\n\n  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,\n                                      cancellable, error))\n    goto out;\n\n  if (attrs_to_read != NULL)\n    {\n      GError *tmp_error = NULL;\n\n      /* Ok, ditch the previous lightweight info (on Unix we just\n       * called lstat()); at this point we gather all the information\n       * we need about the source from the opened file descriptor.\n       */\n      g_object_unref (info);\n\n      info = g_file_input_stream_query_info (file_in, attrs_to_read,\n                                             cancellable, &tmp_error);\n      if (!info)\n        {\n          /* Not all gvfs backends implement query_info_on_read(), we\n           * can just fall back to the pathname again.\n           * https://bugzilla.gnome.org/706254\n           */\n          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&tmp_error);\n              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n            }\n          else\n            {\n              g_free (attrs_to_read);\n              g_propagate_error (error, tmp_error);\n              goto out;\n            }\n        }\n      g_free (attrs_to_read);\n      if (!info)\n        goto out;\n\n      do_set_attributes = TRUE;\n    }\n\n  /* In the local file path, we pass down the source info which\n   * includes things like unix::mode, to ensure that the target file\n   * is not created with different permissions from the source file.\n   *\n   * If a future API like g_file_replace_with_info() is added, switch\n   * this code to use that.\n   */\n  if (G_IS_LOCAL_FILE (destination))\n    {\n      if (flags & G_FILE_COPY_OVERWRITE)\n        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                   FALSE, NULL,\n                                                                   flags & G_FILE_COPY_BACKUP,\n                                                                   G_FILE_CREATE_REPLACE_DESTINATION |\n                                                                   G_FILE_CREATE_PRIVATE, info,\n                                                                   cancellable, error);\n      else\n        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,\n                                                                  cancellable, error);\n    }\n  else if (flags & G_FILE_COPY_OVERWRITE)\n    {\n      out = (GOutputStream *)g_file_replace (destination,\n                                             NULL,\n                                             flags & G_FILE_COPY_BACKUP,\n                                             G_FILE_CREATE_REPLACE_DESTINATION |\n                                             G_FILE_CREATE_PRIVATE,\n                                             cancellable, error);\n    }\n  else\n    {\n      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);\n    }\n\n  if (!out)\n    goto out;\n\n#ifdef __linux__\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *reflink_err = NULL;\n\n      if (!btrfs_reflink_with_progress (in, out, info, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &reflink_err))\n        {\n          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&reflink_err);\n            }\n          else\n            {\n              g_propagate_error (error, reflink_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n#endif\n\n#ifdef HAVE_SPLICE\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *splice_err = NULL;\n\n      if (!splice_stream_with_progress (in, out, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &splice_err))\n        {\n          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&splice_err);\n            }\n          else\n            {\n              g_propagate_error (error, splice_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n#endif\n\n  /* A plain read/write loop */\n  if (!copy_stream_with_progress (in, out, source, cancellable,\n                                  progress_callback, progress_callback_data,\n                                  error))\n    goto out;\n\n  ret = TRUE;\n out:\n  if (in)\n    {\n      /* Don't care about errors in source here */\n      (void) g_input_stream_close (in, cancellable, NULL);\n      g_object_unref (in);\n    }\n\n  if (out)\n    {\n      /* But write errors on close are bad! */\n      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))\n        ret = FALSE;\n      g_object_unref (out);\n    }\n\n  /* Ignore errors here. Failure to copy metadata is not a hard error */\n  /* TODO: set these attributes /before/ we do the rename() on Unix */\n  if (ret && do_set_attributes)\n    {\n      g_file_set_attributes_from_info (destination,\n                                       info,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       cancellable,\n                                       NULL);\n    }\n\n  g_clear_object (&info);\n\n  return ret;\n}""}]","{""function"": 4, ""value"": 1}","[{""source"": ""func_info(file:glocalfileoutputstream.c, func:_g_local_file_output_stream_create)"", ""result"": [{""code"": ""GFileOutputStream *\n_g_local_file_output_stream_create  (const char        *filename,\n\t\t\t\t     gboolean          readable,\n\t\t\t\t     GFileCreateFlags   flags,\n                                     GFileInfo         *reference_info,\n\t\t\t\t     GCancellable      *cancellable,\n\t\t\t\t     GError           **error)\n{\n  int mode;\n  int open_flags;\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\n  mode = mode_from_flags_or_info (flags, reference_info);\n\n  open_flags = O_CREAT | O_EXCL | O_BINARY;\n  if (readable)\n    open_flags |= O_RDWR;\n  else\n    open_flags |= O_WRONLY;\n\n  return output_stream_open (filename, open_flags, mode, cancellable, error);\n}"", ""start_line"": 712, ""end_line"": 735, ""full_name"": ""_g_local_file_output_stream_create"", ""file_path"": ""gio/glocalfileoutputstream.c""}]}, {""source"": ""func_info(file:gfile.c, func:g_file_replace)"", ""result"": [{""code"": ""GFileOutputStream *\ng_file_replace (GFile             *file,\n                const char        *etag,\n                gboolean           make_backup,\n                GFileCreateFlags   flags,\n                GCancellable      *cancellable,\n                GError           **error)\n{\n  GFileIface *iface;\n\n  g_return_val_if_fail (G_IS_FILE (file), NULL);\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\n  iface = G_FILE_GET_IFACE (file);\n\n  if (iface->replace == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR,\n                           G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Operation not supported\""));\n      return NULL;\n    }\n\n  /* Handle empty tag string as NULL in consistent way. */\n  if (etag && *etag == 0)\n    etag = NULL;\n\n  return (* iface->replace) (file, etag, make_backup, flags, cancellable, error);\n}"", ""start_line"": 1866, ""end_line"": 1896, ""full_name"": ""g_file_replace"", ""file_path"": ""gio/gfile.c""}]}, {""source"": ""func_info(file:gfile.c, func:g_file_create)"", ""result"": [{""code"": ""GFileOutputStream *\ng_file_create (GFile             *file,\n               GFileCreateFlags   flags,\n               GCancellable      *cancellable,\n               GError           **error)\n{\n  GFileIface *iface;\n\n  g_return_val_if_fail (G_IS_FILE (file), NULL);\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\n  iface = G_FILE_GET_IFACE (file);\n\n  if (iface->create == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR,\n                           G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Operation not supported\""));\n      return NULL;\n    }\n\n  return (* iface->create) (file, flags, cancellable, error);\n}"", ""start_line"": 1784, ""end_line"": 1808, ""full_name"": ""g_file_create"", ""file_path"": ""gio/gfile.c""}]}, {""source"": ""value_info(file:gfileenums.h, value:G_FILE_CREATE_PRIVATE)"", ""result"": {""value_trace"": [{""full_code"": ""G_FILE_CREATE_PRIVATE = (1 << 0)"", ""line"": 208, ""func_name"": ""GFileCreateFlags:<clinit>""}], ""struct_var"": ""G_FILE_CREATE_PRIVATE"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(file:glocalfileoutputstream.c, func:mode_from_flags_or_info)"", ""result"": [{""code"": ""static gint\nmode_from_flags_or_info (GFileCreateFlags   flags,\n                         GFileInfo         *reference_info)\n{\n  if (flags & G_FILE_CREATE_PRIVATE)\n    return 0600;\n  else if (reference_info && g_file_info_has_attribute (reference_info, \""unix::mode\""))\n    return g_file_info_get_attribute_uint32 (reference_info, \""unix::mode\"") & (~S_IFMT);\n  else\n    return 0666;\n}"", ""start_line"": 700, ""end_line"": 710, ""full_name"": ""mode_from_flags_or_info"", ""file_path"": ""gio/glocalfileoutputstream.c""}]}]","gio/gfile.c:3285-3295: Files were created with default permissions (0666) during copy operations. The patch adds G_FILE_CREATE_PRIVATE to g_file_create, g_file_replace, and _g_local_file_output_stream_create. This flag is processed in gio/glocalfileoutputstream.c:700-710 (mode_from_flags_or_info), which sets mode=0600 for private files. Previously, mode_from_flags_or_info defaulted to 0666, allowing temporary over-privilege before final permissions were applied.",0.95,./github/other_context/CVE-2019-12450
34,CVE-2019-15900,"CWE-863, CWE-252, CWE-908, CWE-754",c_cpp,"An issue was discovered in slicer69 doas before 6.2 on certain platforms other than OpenBSD. On platforms without strtonum(3), sscanf was used without checking for error cases. Instead, the uninitialized variable errstr was checked and in some cases returned success even if sscanf failed. The result was that, instead of reporting that the supplied username or group name did not exist, it would execute the command as root.",https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531,Added optimization to Makefile (can be set/overruled using OPT).\nAdded flag to display all warnings during compiling.\nAdded status checks when parsing user/group IDs for Linux.\nMake sure Linux drops original user's groups when running as another user.,2,"[{""func_name"": ""parsegid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \""%d\"", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""parseuid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \""%d\"", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"", ""target"": 1}]","[{""func_name"": ""parsegid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \""%d\"", gid);\n        if (status != 1)\n            return -1;\n\t#endif\n\treturn 0;\n}""}, {""func_name"": ""parseuid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \""%d\"", uid);\n        if (status != 1)\n           return -1;\n\t#endif\n\treturn 0;\n}""}]","{""caller"": 3}","[{""source"": ""caller_info(file:doas.c, func:parsegid)"", ""result"": [{""call_line"": 144, ""call_code"": ""parsegid(r->ident + 1, &rgid)"", ""caller_code"": ""static int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"", ""caller_start"": 136, ""file_path"": ""doas.c""}]}, {""source"": ""caller_info(file:doas.c, func:match)"", ""result"": [{""call_line"": 184, ""call_code"": ""match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i])"", ""caller_code"": ""static int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}"", ""caller_start"": 176, ""file_path"": ""doas.c""}]}, {""source"": ""caller_info(file:doas.c, func:permit)"", ""result"": [{""call_line"": 241, ""call_code"": ""permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)"", ""caller_code"": ""static void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\""doas: Unable to set UID\\n\"");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\""permit%s\\n\"", (rule->options & NOPASS) ? \"" nopass\"" : \""\"");\n\t\texit(0);\n\t} else {\n\t\tprintf(\""deny\\n\"");\n\t\texit(1);\n\t}\n}"", ""caller_start"": 220, ""file_path"": ""doas.c""}, {""call_line"": 416, ""call_code"": ""permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)"", ""caller_code"": ""int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\""doas\"");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \""a:C:nsu:\"")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \""a:C:Lnsu:\"")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\""/dev/tty\"", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \""unknown user\"");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \""getpwuid failed\"");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \""pw_name too long\"");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \""can't get groups\"");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\""SHELL\"");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \""not installed setuid\"");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \"" \"", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \""failed command for %s: %s\"", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \""Authorization required\"");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \""%s: %s\"", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\""%s: %s\"", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \""dup\"");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \""dup\"");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \""dup2\"");\n/* #endif */\n\n\t\tpam_err = pam_start(\""doas\"", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\""pam_start\"");\n\t\t\tsyslog(LOG_ERR, \""pam_start failed: %s\"",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \""pam_start failed\"");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\""pam_chauthtok\"");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \""failed auth for %s\"", myname);\n                                errx(EXIT_FAILURE, \""second authentication failed\"");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\""pam_acct_mgmt\"");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \""failed auth for %s\"", myname);\n                        errx(EXIT_FAILURE, \""authentication failed\"");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\""pam_authenticate\"");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \""dup2\"");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \""dup2\"");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\""stdio rpath getpw exec id\"", NULL) == -1)\n\t\terr(1, \""pledge\"");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \""no passwd entry for target\"");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \""failed to set user context for target\"");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \""setresgid\"");\n\t#else\n\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \""setregid\"");\n\t#endif\n\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n\t\terr(1, \""initgroups\"");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, \""setresuid\"");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, \""setreuid\"");\n\t#endif\n#endif\n        /*\n\tif (pledge(\""stdio rpath exec\"", NULL) == -1)\n\t\terr(1, \""pledge\"");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \""(failed)\"";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\""stdio exec\"", NULL) == -1)\n\t\terr(1, \""pledge\"");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \""%s ran command %s as %s from %s\"",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\""PATH\"", safepath, 1) == -1)\n\t\t\terr(1, \""failed to set PATH '%s'\"", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \""%s: command not found\"", cmd);\n\terr(1, \""%s\"", cmd);\n}\n"", ""caller_start"": 299, ""file_path"": ""doas.c""}]}]",doas.c:128-133: sscanf() used without return value check in parsegid() for non-OpenBSD/NetBSD platforms. Vulnerable logic allowed invalid GID inputs to be accepted as valid. Patch adds status = sscanf(...) and 'if (status != 1)' check. Caller match() at doas.c:144 uses parsegid() return value to validate group membership. permit() at doas.c:176 aggregates match() results. main() at doas.c:416 calls permit() and executes command as root if permitted.,0.95,./github/other_context/CVE-2019-15900
35,CVE-2019-25058,CWE-863,c_cpp,"An issue was discovered in USBGuard before 1.1.0. On systems with the usbguard-dbus daemon running, an unprivileged user could make USBGuard allow all USB devices to be connected in the future.",https://github.com/USBGuard/usbguard/commit/df5f01c6ed0c20d269f7239901d21883cc871bbb,dbus: Add missing checks for authorization using Polkit,3,"[{""func_name"": ""DBusBridge::handleRootMethodCall"", ""file_path"": ""src/DBus/DBusBridge.cpp"", ""func_code"": ""void DBusBridge::handleRootMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \""getParameter\"") {\n      const char* name_cstr = nullptr;\n      g_variant_get(parameters, \""(&s)\"", &name_cstr);\n      std::string name(name_cstr);\n      auto value = getParameter(name);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(s)\"", value.c_str()));\n      return;\n    }\n\n    if (method_name == \""setParameter\"") {\n      const char* name_cstr = nullptr;\n      const char* value_cstr = nullptr;\n      g_variant_get(parameters, \""(&s&s)\"", &name_cstr, &value_cstr);\n      const std::string name(name_cstr);\n      const std::string value(value_cstr);\n      auto previous_value = setParameter(name, value);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(s)\"", previous_value.c_str()));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \""Unknown method interface\"");\n    return;\n  }"", ""target"": 0}, {""func_name"": ""DBusBridge::handleDevicesMethodCall"", ""file_path"": ""src/DBus/DBusBridge.cpp"", ""func_code"": ""void DBusBridge::handleDevicesMethodCall(const std::string& method_name, GVariant* parameters,\n    GDBusMethodInvocation* invocation)\n  {\n    USBGUARD_LOG(Debug) << \""dbus devices method call: \"" << method_name;\n\n    if (method_name == \""listDevices\"") {\n      const char* query_cstr = nullptr;\n      g_variant_get(parameters, \""(&s)\"", &query_cstr);\n      std::string query(query_cstr);\n      auto devices = listDevices(query);\n\n      if (devices.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto device_rule : devices) {\n            g_variant_builder_add(gvbuilder, \""(us)\"",\n              device_rule.getRuleID(),\n              device_rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \""applyDevicePolicy\"") {\n      uint32_t device_id = 0;\n      uint32_t target_integer = 0;\n      gboolean permanent = false;\n      g_variant_get(parameters, \""(uub)\"", &device_id, &target_integer, &permanent);\n      USBGUARD_LOG(Debug) << \""DBus: applyDevicePolicy: Parsed device_id: \"" << device_id << \"" target_integer: \"" << target_integer <<\n        \"" and permanent: \"" << permanent;\n      const Rule::Target target = Rule::targetFromInteger(target_integer);\n      const uint32_t rule_id = applyDevicePolicy(device_id, target, permanent);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(u)\"", rule_id));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \""Unknown method \"");\n  }"", ""target"": 0}, {""func_name"": ""DBusBridge::handlePolicyMethodCall"", ""file_path"": ""src/DBus/DBusBridge.cpp"", ""func_code"": ""void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \""listRules\"") {\n      const char* label_cstr = nullptr;\n      g_variant_get(parameters, \""(&s)\"", &label_cstr);\n      std::string label(label_cstr);\n      auto rules = listRules(label);\n\n      if (rules.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto rule : rules) {\n            g_variant_builder_add(gvbuilder, \""(us)\"",\n              rule.getRuleID(),\n              rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \""appendRule\"") {\n      const char* rule_spec_cstr = nullptr;\n      uint32_t parent_id = 0;\n      gboolean temporary = false;\n      g_variant_get(parameters, \""(&sub)\"", &rule_spec_cstr, &parent_id, &temporary);\n      std::string rule_spec(rule_spec_cstr);\n      const uint32_t rule_id = appendRule(rule_spec, parent_id, !temporary);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(u)\"", rule_id));\n      return;\n    }\n\n    if (method_name == \""removeRule\"") {\n      uint32_t rule_id = 0;\n      g_variant_get(parameters, \""(u)\"", &rule_id);\n      removeRule(rule_id);\n      g_dbus_method_invocation_return_value(invocation, nullptr);\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \""Unknown method interface\"");\n    return;\n  }"", ""target"": 0}]","[{""func_name"": ""DBusBridge::handleRootMethodCall"", ""file_path"": ""src/DBus/DBusBridge.cpp"", ""func_code"": ""void DBusBridge::handleRootMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \""getParameter\"") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* name_cstr = nullptr;\n      g_variant_get(parameters, \""(&s)\"", &name_cstr);\n      std::string name(name_cstr);\n      auto value = getParameter(name);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(s)\"", value.c_str()));\n      return;\n    }\n\n    if (method_name == \""setParameter\"") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* name_cstr = nullptr;\n      const char* value_cstr = nullptr;\n      g_variant_get(parameters, \""(&s&s)\"", &name_cstr, &value_cstr);\n      const std::string name(name_cstr);\n      const std::string value(value_cstr);\n      auto previous_value = setParameter(name, value);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(s)\"", previous_value.c_str()));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \""Unknown method interface\"");\n    return;\n  }""}, {""func_name"": ""DBusBridge::handleDevicesMethodCall"", ""file_path"": ""src/DBus/DBusBridge.cpp"", ""func_code"": ""void DBusBridge::handleDevicesMethodCall(const std::string& method_name, GVariant* parameters,\n    GDBusMethodInvocation* invocation)\n  {\n    USBGUARD_LOG(Debug) << \""dbus devices method call: \"" << method_name;\n\n    if (method_name == \""listDevices\"") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* query_cstr = nullptr;\n      g_variant_get(parameters, \""(&s)\"", &query_cstr);\n      std::string query(query_cstr);\n      auto devices = listDevices(query);\n\n      if (devices.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto device_rule : devices) {\n            g_variant_builder_add(gvbuilder, \""(us)\"",\n              device_rule.getRuleID(),\n              device_rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \""applyDevicePolicy\"") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      uint32_t device_id = 0;\n      uint32_t target_integer = 0;\n      gboolean permanent = false;\n      g_variant_get(parameters, \""(uub)\"", &device_id, &target_integer, &permanent);\n      USBGUARD_LOG(Debug) << \""DBus: applyDevicePolicy: Parsed device_id: \"" << device_id << \"" target_integer: \"" << target_integer <<\n        \"" and permanent: \"" << permanent;\n      const Rule::Target target = Rule::targetFromInteger(target_integer);\n      const uint32_t rule_id = applyDevicePolicy(device_id, target, permanent);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(u)\"", rule_id));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \""Unknown method \"");\n  }""}, {""func_name"": ""DBusBridge::handlePolicyMethodCall"", ""file_path"": ""src/DBus/DBusBridge.cpp"", ""func_code"": ""void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \""listRules\"") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* label_cstr = nullptr;\n      g_variant_get(parameters, \""(&s)\"", &label_cstr);\n      std::string label(label_cstr);\n      auto rules = listRules(label);\n\n      if (rules.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto rule : rules) {\n            g_variant_builder_add(gvbuilder, \""(us)\"",\n              rule.getRuleID(),\n              rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(a(us))\"", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \""appendRule\"") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* rule_spec_cstr = nullptr;\n      uint32_t parent_id = 0;\n      gboolean temporary = false;\n      g_variant_get(parameters, \""(&sub)\"", &rule_spec_cstr, &parent_id, &temporary);\n      std::string rule_spec(rule_spec_cstr);\n      const uint32_t rule_id = appendRule(rule_spec, parent_id, !temporary);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\""(u)\"", rule_id));\n      return;\n    }\n\n    if (method_name == \""removeRule\"") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      uint32_t rule_id = 0;\n      g_variant_get(parameters, \""(u)\"", &rule_id);\n      removeRule(rule_id);\n      g_dbus_method_invocation_return_value(invocation, nullptr);\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \""Unknown method interface\"");\n    return;\n  }""}]","{""function"": 5}","[{""source"": ""func_info(func:getParameter)"", ""result"": [{""code"": ""std::string Daemon::getParameter(const std::string& name)\n  {\n    if (name == \""InsertedDevicePolicy\"") {\n      return devicePolicyMethodToString(_inserted_device_policy_method);\n    }\n    else if (name"", ""start_line"": 720, ""end_line"": 731, ""full_name"": ""usbguard.Daemon.getParameter:string(std.string&)"", ""file_path"": ""src/Daemon/Daemon.cpp""}, {""code"": ""std::string IPCClientPrivate::getParameter(const std::string& name)\n  {\n    IPC::getParameter message_out;\n    message_out.mutable_request()->set_name(name);\n    auto message_in = qbIPCSendRecvMessage"", ""start_line"": 381, ""end_line"": 387, ""full_name"": ""usbguard.IPCClientPrivate.getParameter:string(std.string&)"", ""file_path"": ""src/Library/IPCClientPrivate.cpp""}, {""code"": ""std::string IPCClient::getParameter(const std::string& name)\n  {\n    return d_pointer->getParameter(name);\n  }"", ""start_line"": 60, ""end_line"": 63, ""full_name"": ""usbguard.IPCClient.getParameter:string(std.string&)"", ""file_path"": ""src/Library/public/usbguard/IPCClient.cpp""}]}, {""source"": ""func_info(func:setParameter)"", ""result"": [{""code"": ""std::string Daemon::setParameter(const std::string& name, const std::string& value)\n  {\n    if (name == \""InsertedDevicePolicy\"") {\n      const auto previous_value = devicePolicyMethodToString(_inserted"", ""start_line"": 697, ""end_line"": 718, ""full_name"": ""usbguard.Daemon.setParameter:string(std.string&,std.string&)"", ""file_path"": ""src/Daemon/Daemon.cpp""}, {""code"": ""std::string IPCClientPrivate::setParameter(const std::string& name, const std::string& value)\n  {\n    IPC::setParameter message_out;\n    message_out.mutable_request()->set_name(name);\n    message_out."", ""start_line"": 372, ""end_line"": 379, ""full_name"": ""usbguard.IPCClientPrivate.setParameter:string(std.string&,std.string&)"", ""file_path"": ""src/Library/IPCClientPrivate.cpp""}, {""code"": ""std::string IPCClient::setParameter(const std::string& name, const std::string& value)\n  {\n    return d_pointer->setParameter(name, value);\n  }"", ""start_line"": 55, ""end_line"": 58, ""full_name"": ""usbguard.IPCClient.setParameter:string(std.string&,std.string&)"", ""file_path"": ""src/Library/public/usbguard/IPCClient.cpp""}]}, {""source"": ""func_info(func:applyDevicePolicy)"", ""result"": [{""code"": ""uint32_t Daemon::applyDevicePolicy(uint32_t id, Rule::Target target, bool permanent)\n  {\n    USBGUARD_LOG(Trace) << \""entry:\""\n      << \"" id=\"" << id\n      << \"" target=\"" << Rule::targetToString(target)\n "", ""start_line"": 778, ""end_line"": 799, ""full_name"": ""usbguard.Daemon.applyDevicePolicy:uint32_t(uint32_t,usbguard.Rule.Target,bool)"", ""file_path"": ""src/Daemon/Daemon.cpp""}, {""code"": ""std::shared_ptr<Device> DeviceManagerBase::applyDevicePolicy(uint32_t id, Rule::Target target)\n  {\n    USBGUARD_LOG(Trace) << \""id=\"" << id << \"" target=\"" << Rule::targetToString(target);\n    std::shared"", ""start_line"": 65, ""end_line"": 73, ""full_name"": ""usbguard.DeviceManagerBase.applyDevicePolicy:shared_ptr(uint32_t,usbguard.Rule.Target)"", ""file_path"": ""src/Library/DeviceManagerBase.cpp""}, {""code"": ""uint32_t IPCClientPrivate::applyDevicePolicy(uint32_t id, Rule::Target target, bool permanent)\n  {\n    IPC::applyDevicePolicy message_out;\n    message_out.mutable_request()->set_id(id);\n    message_ou"", ""start_line"": 422, ""end_line"": 430, ""full_name"": ""usbguard.IPCClientPrivate.applyDevicePolicy:uint32_t(uint32_t,usbguard.Rule.Target,bool)"", ""file_path"": ""src/Library/IPCClientPrivate.cpp""}]}, {""source"": ""func_info(func:appendRule)"", ""result"": [{""code"": ""uint32_t Daemon::appendRule(const std::string& rule_spec,\n    uint32_t parent_id, bool permanent)\n  {\n    USBGUARD_LOG(Trace) << \""entry:\""\n      << \"" rule_spec=\"" << rule_spec\n      << \"" parent_id=\"" << "", ""start_line"": 733, ""end_line"": 749, ""full_name"": ""usbguard.Daemon.appendRule:uint32_t(std.string&,uint32_t,bool)"", ""file_path"": ""src/Daemon/Daemon.cpp""}, {""code"": ""uint32_t IPCClientPrivate::appendRule(const std::string& rule_spec, uint32_t parent_id, bool permanent)\n  {\n    IPC::appendRule message_out;\n    message_out.mutable_request()->set_rule(rule_spec);\n   "", ""start_line"": 389, ""end_line"": 397, ""full_name"": ""usbguard.IPCClientPrivate.appendRule:uint32_t(std.string&,uint32_t,bool)"", ""file_path"": ""src/Library/IPCClientPrivate.cpp""}, {""code"": ""uint32_t IPCClient::appendRule(const std::string& rule_spec, uint32_t parent_id, bool permanent)\n  {\n    return d_pointer->appendRule(rule_spec, parent_id, permanent);\n  }"", ""start_line"": 65, ""end_line"": 68, ""full_name"": ""usbguard.IPCClient.appendRule:uint32_t(std.string&,uint32_t,bool)"", ""file_path"": ""src/Library/public/usbguard/IPCClient.cpp""}]}, {""source"": ""func_info(func:removeRule)"", ""result"": [{""code"": ""void Daemon::removeRule(uint32_t id)\n  {\n    USBGUARD_LOG(Trace) << \""id=\"" << id;\n    _policy.removeRule(id);\n\n    if (_config.hasSettingValue(\""RuleFile\"")) {\n      _policy.save();\n    }\n  }"", ""start_line"": 751, ""end_line"": 759, ""full_name"": ""usbguard.Daemon.removeRule:void(uint32_t)"", ""file_path"": ""src/Daemon/Daemon.cpp""}, {""code"": ""void IPCClientPrivate::removeRule(uint32_t id)\n  {\n    IPC::removeRule message_out;\n    message_out.mutable_request()->set_id(id);\n    auto message_in = qbIPCSendRecvMessage(message_out);\n  }"", ""start_line"": 399, ""end_line"": 404, ""full_name"": ""usbguard.IPCClientPrivate.removeRule:void(uint32_t)"", ""file_path"": ""src/Library/IPCClientPrivate.cpp""}, {""code"": ""void IPCClient::removeRule(uint32_t id)\n  {\n    d_pointer->removeRule(id);\n  }"", ""start_line"": 70, ""end_line"": 73, ""full_name"": ""usbguard.IPCClient.removeRule:void(uint32_t)"", ""file_path"": ""src/Library/public/usbguard/IPCClient.cpp""}]}]","The vulnerability arises from missing Polkit authorization checks in D-Bus method handlers. Specifically: 1. `handleRootMethodCall` (src/DBus/DBusBridge.cpp:78-91) allows `setParameter` to modify device policies without authorization. 2. `handleDevicesMethodCall` (src/DBus/DBusBridge.cpp:166-202) permits `applyDevicePolicy` to alter device rules without checks. 3. `handlePolicyMethodCall` (src/DBus/DBusBridge.cpp:105-156) enables `appendRule`/`removeRule` to modify policy rules without authorization. These methods directly interact with `Daemon`/`IPCClient` implementations (e.g., `Daemon::setParameter` in src/Daemon/Daemon.cpp:697-718) to enforce policy changes. The absence of `isAuthorizedByPolkit` checks (added in the patch) allowed unprivileged users to bypass restrictions and allow all USB devices.",0.95,./github/other_context/CVE-2019-25058
36,CVE-2020-15260,CWE-295,c_cpp,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872,Merge pull request from GHSA-8hcp-hm38-mfph\n\n* Check hostname during TLS transport selection\n\n* revision based on feedback\n\n* remove the code in create_request that has been moved,6,"[{""func_name"": ""dlg_create_request_throw"", ""file_path"": ""pjsip/src/pjsip/sip_dialog.c"", ""func_code"": ""static pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_method *method,\n\t\t\t\t\t     int cseq,\n\t\t\t\t\t     pjsip_tx_data **p_tdata )\n{\n    pjsip_tx_data *tdata;\n    pjsip_contact_hdr *contact;\n    pjsip_route_hdr *route, *end_list;\n    pj_status_t status;\n\n    /* Contact Header field.\n     * Contact can only be present in requests that establish dialog (in the\n     * core SIP spec, only INVITE).\n     */\n    if (pjsip_method_creates_dialog(method))\n\tcontact = dlg->local.contact;\n    else\n\tcontact = NULL;\n\n    /*\n     * Create the request by cloning from the headers in the\n     * dialog.\n     */\n    status = pjsip_endpt_create_request_from_hdr(dlg->endpt,\n\t\t\t\t\t\t method,\n\t\t\t\t\t\t dlg->target,\n\t\t\t\t\t\t dlg->local.info,\n\t\t\t\t\t\t dlg->remote.info,\n\t\t\t\t\t\t contact,\n\t\t\t\t\t\t dlg->call_id,\n\t\t\t\t\t\t cseq,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* Just copy dialog route-set to Route header.\n     * The transaction will do the processing as specified in Section 12.2.1\n     * of RFC 3261 in function tsx_process_route() in sip_transaction.c.\n     */\n    route = dlg->route_set.next;\n    end_list = &dlg->route_set;\n    for (; route != end_list; route = route->next ) {\n\tpjsip_route_hdr *r;\n\tr = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );\n\tpjsip_routing_hdr_set_route(r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);\n    }\n\n    /* Copy authorization headers, if request is not ACK or CANCEL. */\n    if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {\n\tstatus = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Done. */\n    *p_tdata = tdata;\n\n    return PJ_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""create_uas_dialog"", ""file_path"": ""pjsip/src/pjsip/sip_dialog.c"", ""func_code"": ""pj_status_t create_uas_dialog( pjsip_user_agent *ua,\n\t\t\t       pjsip_rx_data *rdata,\n\t\t\t       const pj_str_t *contact,\n\t\t\t       pj_bool_t inc_lock,\n\t\t\t       pjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pjsip_hdr *pos = NULL;\n    pjsip_contact_hdr *contact_hdr;\n    pjsip_rr_hdr *rr;\n    pjsip_transaction *tsx = NULL;\n    pj_str_t tmp;\n    enum { TMP_LEN=PJSIP_MAX_URL_SIZE };\n    pj_ssize_t len;\n    pjsip_dialog *dlg;\n    pj_bool_t lock_incremented = PJ_FALSE;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);\n\n    /* rdata must have request message. */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Request must not have To tag.\n     * This should have been checked in the user agent (or application?).\n     */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);\n\n    /* The request must be a dialog establishing request. */\n    PJ_ASSERT_RETURN(\n\tpjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),\n\tPJ_EINVALIDOP);\n\n    /* Create dialog instance. */\n    status = create_dialog(ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Temprary string for getting the string representation of\n     * both local and remote URI.\n     */\n    tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);\n\n    /* Init local info from the To header. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);\n    pjsip_fromto_hdr_set_from(dlg->local.info);\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n\n    /* Print the local info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->local.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \""<-error: uri too long->\"");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the local info. */\n    pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);\n\n\n    /* Randomize local cseq */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    /* TODO:\n     *  Section 12.1.1, paragraph about using SIPS URI in Contact.\n     *  If the request that initiated the dialog contained a SIPS URI\n     *  in the Request-URI or in the top Record-Route header field value,\n     *  if there was any, or the Contact header field if there was no\n     *  Record-Route header field, the Contact header field in the response\n     *  MUST be a SIPS URI.\n     */\n    if (contact) {\n\tpj_str_t tmp2;\n\n\tpj_strdup_with_null(dlg->pool, &tmp2, contact);\n\tdlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t     pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,\n\t\t\t\t\t     tmp2.slen, NULL);\n\tif (!dlg->local.contact) {\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n    } else {\n\tdlg->local.contact = pjsip_contact_hdr_create(dlg->pool);\n\tdlg->local.contact->uri = dlg->local.info->uri;\n    }\n\n    /* Init remote info from the From header. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);\n    pjsip_fromto_hdr_set_to(dlg->remote.info);\n\n    /* Print the remote info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->remote.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \""<-error: uri too long->\"");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the remote info. */\n    pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);\n\n\n    /* Init remote's contact from Contact header.\n     * Iterate the Contact URI until we find sip: or sips: scheme.\n     */\n    do {\n\tcontact_hdr = (pjsip_contact_hdr*)\n\t\t      pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t         pos);\n\tif (contact_hdr) {\n\t    if (!contact_hdr->uri ||\n\t\t(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&\n\t\t !PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))\n\t    {\n\t\tpos = (pjsip_hdr*)contact_hdr->next;\n\t\tif (pos == &rdata->msg_info.msg->hdr)\n\t\t    contact_hdr = NULL;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    } while (contact_hdr);\n\n    if (!contact_hdr) {\n\tstatus = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);\n\tgoto on_error;\n    }\n\n    dlg->remote.contact = (pjsip_contact_hdr*)\n    \t\t\t  pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);\n\n    /* Init remote's CSeq from CSeq header */\n    dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Set initial target to remote's Contact. */\n    dlg->target = dlg->remote.contact->uri;\n\n    /* Initial role is UAS */\n    dlg->role = PJSIP_ROLE_UAS;\n\n    /* Secure?\n     *  RFC 3261 Section 12.1.1:\n     *  If the request arrived over TLS, and the Request-URI contained a\n     *  SIPS URI, the 'secure' flag is set to TRUE.\n     */\n    dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&\n\t\t  PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);\n\n    /* Call-ID */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);\n\n    /* Route set.\n     *  RFC 3261 Section 12.1.1:\n     *  The route set MUST be set to the list of URIs in the Record-Route\n     *  header field from the request, taken in order and preserving all URI\n     *  parameters. If no Record-Route header field is present in the request,\n     * the route set MUST be set to the empty set.\n     */\n    pj_list_init(&dlg->route_set);\n    rr = rdata->msg_info.record_route;\n    while (rr != NULL) {\n\tpjsip_route_hdr *route;\n\n\t/* Clone the Record-Route, change the type to Route header. */\n\troute = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);\n\tpjsip_routing_hdr_set_route(route);\n\n\t/* Add to route set. */\n\tpj_list_push_back(&dlg->route_set, route);\n\n\t/* Find next Record-Route header. */\n\trr = rr->next;\n\tif (rr == (void*)&rdata->msg_info.msg->hdr)\n\t    break;\n\trr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t   PJSIP_H_RECORD_ROUTE, rr);\n    }\n    dlg->route_set_frozen = PJ_TRUE;\n\n    /* Increment the dialog's lock since tsx may cause the dialog to be\n     * destroyed prematurely (such as in case of transport error).\n     */\n    if (inc_lock) {\n        pjsip_dlg_inc_lock(dlg);\n        lock_incremented = PJ_TRUE;\n    }\n\n    /* Create UAS transaction for this request. */\n    status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Associate this dialog to the transaction. */\n    tsx->mod_data[dlg->ua->id] = dlg;\n\n    /* Increment tsx counter */\n    ++dlg->tsx_count;\n\n    /* Calculate hash value of remote tag. */\n    dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);\n\n    /* Update remote capabilities info */\n    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Put this dialog in rdata's mod_data */\n    rdata->endpt_info.mod_data[ua->id] = dlg;\n\n    PJ_TODO(DIALOG_APP_TIMER);\n\n    /* Feed the first request to the transaction. */\n    pjsip_tsx_recv_msg(tsx, rdata);\n\n    /* Done. */\n    *p_dlg = dlg;\n    PJ_LOG(5,(dlg->obj_name, \""UAS dialog created\""));\n    return PJ_SUCCESS;\n\non_error:\n    if (tsx) {\n\tpjsip_tsx_terminate(tsx, 500);\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n    }\n\n    if (lock_incremented) {\n        pjsip_dlg_dec_lock(dlg);\n    } else {\n        destroy_dialog(dlg, PJ_FALSE);\n    }\n\n    return status;\n}"", ""target"": 0}, {""func_name"": ""dlg_update_routeset"", ""file_path"": ""pjsip/src/pjsip/sip_dialog.c"", ""func_code"": ""static void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)\n{\n    const pjsip_hdr *hdr, *end_hdr;\n    //pj_int32_t msg_cseq;\n    const pjsip_msg *msg;\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\""UPDATE\"", 6}};\n\n    msg = rdata->msg_info.msg;\n    //msg_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Ignore if route set has been frozen */\n    if (dlg->route_set_frozen)\n\treturn;\n\n    /* Ignore if the message is an UPDATE response (see ticket #1781) */\n    if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)\n\treturn;\n\n    /* Only update route set if this message belongs to the same\n     * transaction as the initial transaction that establishes dialog.\n     */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\n\t/* Ignore subsequent request from remote */\n\tif (msg->type != PJSIP_RESPONSE_MSG)\n\t    return;\n\n\t/* Ignore subsequent responses with higher CSeq than initial CSeq.\n\t * Unfortunately this would be broken when the first request is\n\t * challenged!\n\t */\n\t//if (msg_cseq != dlg->local.first_cseq)\n\t//    return;\n\n    } else {\n\n\t/* For callee dialog, route set should have been set by initial\n\t * request and it will have been rejected by dlg->route_set_frozen\n\t * check above.\n\t */\n\tpj_assert(!\""Should not happen\"");\n\n    }\n\n    /* Based on the checks above, we should only get response message here */\n    pj_assert(msg->type == PJSIP_RESPONSE_MSG);\n\n    /* Ignore if this is not 1xx or 2xx response */\n    if (msg->line.status.code >= 300)\n\treturn;\n\n    /* Reset route set */\n    pj_list_init(&dlg->route_set);\n\n    /* Update route set */\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    PJ_LOG(5,(dlg->obj_name, \""Route-set updated\""));\n\n    /* Freeze the route set only when the route set comes in 2xx response.\n     * If it is in 1xx response, prepare to recompute the route set when\n     * the 2xx response comes in.\n     *\n     * There is a debate whether route set should be frozen when the dialog\n     * is established with reliable provisional response, but I think\n     * it is safer to not freeze the route set (thus recompute the route set\n     * upon receiving 2xx response). Also RFC 3261 says so in 13.2.2.4.\n     *\n     * The pjsip_method_creates_dialog() check protects from wrongly\n     * freezing the route set upon receiving 200/OK response for PRACK.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tPJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))\n    {\n\tdlg->route_set_frozen = PJ_TRUE;\n\tPJ_LOG(5,(dlg->obj_name, \""Route-set frozen\""));\n    }\n}"", ""target"": 0}, {""func_name"": ""pjsip_tpmgr_acquire_transport2"", ""file_path"": ""pjsip/src/pjsip/sip_transport.c"", ""func_code"": ""PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t   pjsip_transport_type_e type,\n\t\t\t\t\t\t   const pj_sockaddr_t *remote,\n\t\t\t\t\t\t   int addr_len,\n\t\t\t\t\t\t   const pjsip_tpselector *sel,\n\t\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t\t   pjsip_transport **tp)\n{\n    pjsip_tpfactory *factory;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE,\""Acquiring transport type=%s, sel=%s remote=%s:%d\"",\n\t\t       pjsip_transport_get_type_name(type),\n\t\t       print_tpsel_info(sel),\n\t\t       addr_string(remote),\n\t\t       pj_sockaddr_get_port(remote)));\n\n    pj_lock_acquire(mgr->lock);\n\n    /* If transport is specified, then just use it if it is suitable\n     * for the destination.\n     */\n    if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tsel->u.transport) \n    {\n\tpjsip_transport *seltp = sel->u.transport;\n\n\t/* See if the transport is (not) suitable */\n\tif (seltp->key.type != type) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE, \""Transport type in tpsel not matched\""));\n\t    return PJSIP_ETPNOTSUITABLE;\n\t}\n\n\t/* Make sure the transport is not being destroyed */\n\tif (seltp->is_destroying) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE,\""Transport to be acquired is being destroyed\""));\n\t    return PJ_ENOTFOUND;\n\t}\n\n\t/* We could also verify that the destination address is reachable\n\t * from this transport (i.e. both are equal), but if application\n\t * has requested a specific transport to be used, assume that\n\t * it knows what to do.\n\t *\n\t * In other words, I don't think destination verification is a good\n\t * idea for now.\n\t */\n\n\t/* Transport looks to be suitable to use, so just use it. */\n\tpjsip_transport_add_ref(seltp);\n\tpj_lock_release(mgr->lock);\n\t*tp = seltp;\n\n\tTRACE_((THIS_FILE, \""Transport %s acquired\"", seltp->obj_name));\n\treturn PJ_SUCCESS;\n\n    } else {\n\n\t/*\n\t * This is the \""normal\"" flow, where application doesn't specify\n\t * specific transport to be used to send message to.\n\t * In this case, lookup the transport from the hash table.\n\t */\n\tpjsip_transport_key key;\n\tint key_len;\n\tpjsip_transport *tp_ref = NULL;\n\ttransport *tp_entry = NULL;\n\n\n\t/* If listener is specified, verify that the listener type matches\n\t * the destination type.\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \""Listener type in tpsel not matched\""));\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t}\n\n\tif (!sel || sel->disable_connection_reuse == PJ_FALSE) {\n\t    pj_bzero(&key, sizeof(key));\n\t    key_len = sizeof(key.type) + addr_len;\n\n\t    /* First try to get exact destination. */\n\t    key.type = type;\n\t    pj_memcpy(&key.rem_addr, remote, addr_len);\n\n\t    tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,\n\t\t\t\t\t\tNULL);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\t\tdo {\n\t\t    /* Don't use transport being shutdown/destroyed */\n\t\t    if (!tp_iter->tp->is_shutdown &&\n\t\t\t!tp_iter->tp->is_destroying)\n\t\t    {\n\t\t\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t\t    sel->u.listener)\n\t\t\t{\n\t\t\t    /* Match listener if selector is set */\n\t\t\t    if (tp_iter->tp->factory == sel->u.listener) {\n\t\t\t\ttp_ref = tp_iter->tp;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    tp_ref = tp_iter->tp;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t}\n\n\tif (tp_ref == NULL &&\n\t    (!sel || sel->disable_connection_reuse == PJ_FALSE))\n\t{\n\t    unsigned flag = pjsip_transport_get_flag_from_type(type);\n\t    const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;\n\n\n\t    /* Ignore address for loop transports. */\n\t    if (type == PJSIP_TRANSPORT_LOOP ||\n\t\ttype == PJSIP_TRANSPORT_LOOP_DGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t    /* For datagram transports, try lookup with zero address.\n\t     */\n\t    else if (flag & PJSIP_TRANSPORT_DATAGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\taddr->addr.sa_family = remote_addr->addr.sa_family;\n\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t}\n\n\t/* If transport is found and listener is specified, verify listener */\n\telse if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t sel->u.listener && tp_ref->factory != sel->u.listener)\n\t{\n\t    tp_ref = NULL;\n\t    /* This will cause a new transport to be created which will be a\n\t     * 'duplicate' of the existing transport (same type & remote addr,\n\t     * but different factory).\n\t     */\n\t    TRACE_((THIS_FILE, \""Transport found but from different listener\""));\n\t}\n\n\tif (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {\n\t    /*\n\t     * Transport found!\n\t     */\n\t    pjsip_transport_add_ref(tp_ref);\n\t    pj_lock_release(mgr->lock);\n\t    *tp = tp_ref;\n\n\t    TRACE_((THIS_FILE, \""Transport %s acquired\"", tp_ref->obj_name));\n\t    return PJ_SUCCESS;\n\t}\n\n\n\t/*\n\t * Either transport not found, or we don't want to use the existing\n\t * transport (such as in the case of different factory or\n\t * if connection reuse is disabled). So we need to create one,\n\t * find factory that can create such transport.\n\t *\n\t * If there's an existing transport, its place in the hash table\n\t * will be replaced by this new one. And eventually the existing\n\t * transport will still be freed (by application or #1774).\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    /* Application has requested that a specific listener is to\n\t     * be used.\n\t     */\n\n\t    /* Verify that the listener type matches the destination type */\n\t    /* Already checked above. */\n\t    /*\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t    */\n\n\t    /* We'll use this listener to create transport */\n\t    factory = sel->u.listener;\n\n\t    /* Verify if listener is still valid */\n\t    if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {\n\t\tpj_lock_release(mgr->lock);\n\t\tPJ_LOG(3,(THIS_FILE, \""Specified factory for creating \""\n\t\t\t\t     \""transport is not found\""));\n\t\treturn PJ_ENOTFOUND;\n\t    }\n\n\t} else {\n\n\t    /* Find factory with type matches the destination type */\n\t    factory = mgr->factory_list.next;\n\t    while (factory != &mgr->factory_list) {\n\t\tif (factory->type == type)\n\t\t    break;\n\t\tfactory = factory->next;\n\t    }\n\n\t    if (factory == &mgr->factory_list) {\n\t\t/* No factory can create the transport! */\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \""No suitable factory was found either\""));\n\t\treturn PJSIP_EUNSUPTRANSPORT;\n\t    }\n\t}\n    }\n\n    TRACE_((THIS_FILE, \""Creating new transport from factory\""));\n\n    /* Request factory to create transport. */\n    if (factory->create_transport2) {\n\tstatus = factory->create_transport2(factory, mgr, mgr->endpt,\n\t\t\t\t\t    (const pj_sockaddr*) remote,\n\t\t\t\t\t    addr_len, tdata, tp);\n    } else {\n\tstatus = factory->create_transport(factory, mgr, mgr->endpt,\n\t\t\t\t\t   (const pj_sockaddr*) remote,\n\t\t\t\t\t   addr_len, tp);\n    }\n    if (status == PJ_SUCCESS) {\n\tPJ_ASSERT_ON_FAIL(tp!=NULL,\n\t    {pj_lock_release(mgr->lock); return PJ_EBUG;});\n\tpjsip_transport_add_ref(*tp);\n\t(*tp)->factory = factory;\n    }"", ""target"": 0}, {""func_name"": ""pjsip_endpt_send_response"", ""file_path"": ""pjsip/src/pjsip/sip_util.c"", ""func_code"": ""PJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,\n\t\t\t\t\t       pjsip_response_addr *res_addr,\n\t\t\t\t\t       pjsip_tx_data *tdata,\n\t\t\t\t\t       void *token,\n\t\t\t\t\t       pjsip_send_callback cb)\n{\n    /* Determine which transports and addresses to send the response,\n     * based on Section 18.2.2 of RFC 3261.\n     */\n    pjsip_send_state *send_state;\n    pj_status_t status;\n\n    /* Create structure to keep the sending state. */\n    send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    send_state->endpt = endpt;\n    send_state->tdata = tdata;\n    send_state->token = token;\n    send_state->app_cb = cb;\n\n    if (res_addr->transport != NULL) {\n\tsend_state->cur_transport = res_addr->transport;\n\tpjsip_transport_add_ref(send_state->cur_transport);\n\n\tstatus = pjsip_transport_send( send_state->cur_transport, tdata, \n\t\t\t\t       &res_addr->addr,\n\t\t\t\t       res_addr->addr_len,\n\t\t\t\t       send_state,\n\t\t\t\t       &send_response_transport_cb );\n\tif (status == PJ_SUCCESS) {\n\t    pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;\n\t    send_response_transport_cb(send_state, tdata, sent);\n\t    return PJ_SUCCESS;\n\t} else if (status == PJ_EPENDING) {\n\t    /* Callback will be called later. */\n\t    return PJ_SUCCESS;\n\t} else {\n\t    pjsip_transport_dec_ref(send_state->cur_transport);\n\t    return status;\n\t}\n    } else {\n\t/* Copy the destination host name to TX data */\n\tpj_strdup(tdata->pool, &tdata->dest_info.name, \n\t\t  &res_addr->dst_host.addr.host);\n\n\tpjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, \n\t\t\t    send_state, &send_response_resolver_cb);\n\treturn PJ_SUCCESS;\n    }\n}"", ""target"": 0}, {""func_name"": ""pjsip_endpt_send_request_stateless"", ""file_path"": ""pjsip/src/pjsip/sip_util.c"", ""func_code"": ""PJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, \n\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t   void *token,\n\t\t\t\t   pjsip_send_callback cb)\n{\n    pjsip_host_info dest_info;\n    pjsip_send_state *stateless_data;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);\n\n    /* Get destination name to contact. */\n    status = pjsip_process_route_set(tdata, &dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Keep stateless data. */\n    stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    stateless_data->token = token;\n    stateless_data->endpt = endpt;\n    stateless_data->tdata = tdata;\n    stateless_data->app_cb = cb;\n\n    /* If destination info has not been initialized (this applies for most\n     * all requests except CANCEL), resolve destination host. The processing\n     * then resumed when the resolving callback is called. For CANCEL, the\n     * destination info must have been copied from the original INVITE so\n     * proceed to sending the request directly.\n     */\n    if (tdata->dest_info.addr.count == 0) {\n\t/* Copy the destination host name to TX data */\n\tpj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);\n\n\tpjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,\n\t\t\t     &stateless_send_resolver_callback);\n    } else {\n\tPJ_LOG(5,(THIS_FILE, \""%s: skipping target resolution because \""\n\t                     \""address is already set\"",\n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\tstateless_send_resolver_callback(PJ_SUCCESS, stateless_data,\n\t\t\t\t\t &tdata->dest_info.addr);\n    }\n    return PJ_SUCCESS;\n}"", ""target"": 0}]","[{""func_name"": ""dlg_create_request_throw"", ""file_path"": ""pjsip/src/pjsip/sip_dialog.c"", ""func_code"": ""static pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_method *method,\n\t\t\t\t\t     int cseq,\n\t\t\t\t\t     pjsip_tx_data **p_tdata )\n{\n    pjsip_tx_data *tdata;\n    pjsip_contact_hdr *contact;\n    pjsip_route_hdr *route, *end_list;\n    pj_status_t status;\n\n    /* Contact Header field.\n     * Contact can only be present in requests that establish dialog (in the\n     * core SIP spec, only INVITE).\n     */\n    if (pjsip_method_creates_dialog(method))\n\tcontact = dlg->local.contact;\n    else\n\tcontact = NULL;\n\n    /*\n     * Create the request by cloning from the headers in the\n     * dialog.\n     */\n    status = pjsip_endpt_create_request_from_hdr(dlg->endpt,\n\t\t\t\t\t\t method,\n\t\t\t\t\t\t dlg->target,\n\t\t\t\t\t\t dlg->local.info,\n\t\t\t\t\t\t dlg->remote.info,\n\t\t\t\t\t\t contact,\n\t\t\t\t\t\t dlg->call_id,\n\t\t\t\t\t\t cseq,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* Just copy dialog route-set to Route header.\n     * The transaction will do the processing as specified in Section 12.2.1\n     * of RFC 3261 in function tsx_process_route() in sip_transaction.c.\n     */\n    route = dlg->route_set.next;\n    end_list = &dlg->route_set;\n    for (; route != end_list; route = route->next ) {\n\tpjsip_route_hdr *r;\n\tr = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );\n\tpjsip_routing_hdr_set_route(r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);\n    }\n\n    /* Copy authorization headers, if request is not ACK or CANCEL. */\n    if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {\n\tstatus = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Copy the initial destination host to tdata. This information can be\n     * used later by transport for transport selection.\n     */\n    if (dlg->initial_dest.slen)\n    \tpj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);\n\n    /* Done. */\n    *p_tdata = tdata;\n\n    return PJ_SUCCESS;\n}""}, {""func_name"": ""create_uas_dialog"", ""file_path"": ""pjsip/src/pjsip/sip_dialog.c"", ""func_code"": ""pj_status_t create_uas_dialog( pjsip_user_agent *ua,\n\t\t\t       pjsip_rx_data *rdata,\n\t\t\t       const pj_str_t *contact,\n\t\t\t       pj_bool_t inc_lock,\n\t\t\t       pjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pjsip_hdr *pos = NULL;\n    pjsip_contact_hdr *contact_hdr;\n    pjsip_rr_hdr *rr;\n    pjsip_transaction *tsx = NULL;\n    pj_str_t tmp;\n    enum { TMP_LEN=PJSIP_MAX_URL_SIZE };\n    pj_ssize_t len;\n    pjsip_dialog *dlg;\n    pj_bool_t lock_incremented = PJ_FALSE;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);\n\n    /* rdata must have request message. */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Request must not have To tag.\n     * This should have been checked in the user agent (or application?).\n     */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);\n\n    /* The request must be a dialog establishing request. */\n    PJ_ASSERT_RETURN(\n\tpjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),\n\tPJ_EINVALIDOP);\n\n    /* Create dialog instance. */\n    status = create_dialog(ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Temprary string for getting the string representation of\n     * both local and remote URI.\n     */\n    tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);\n\n    /* Init local info from the To header. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);\n    pjsip_fromto_hdr_set_from(dlg->local.info);\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n\n    /* Print the local info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->local.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \""<-error: uri too long->\"");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the local info. */\n    pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);\n\n\n    /* Randomize local cseq */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    /* TODO:\n     *  Section 12.1.1, paragraph about using SIPS URI in Contact.\n     *  If the request that initiated the dialog contained a SIPS URI\n     *  in the Request-URI or in the top Record-Route header field value,\n     *  if there was any, or the Contact header field if there was no\n     *  Record-Route header field, the Contact header field in the response\n     *  MUST be a SIPS URI.\n     */\n    if (contact) {\n\tpj_str_t tmp2;\n\n\tpj_strdup_with_null(dlg->pool, &tmp2, contact);\n\tdlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t     pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,\n\t\t\t\t\t     tmp2.slen, NULL);\n\tif (!dlg->local.contact) {\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n    } else {\n\tdlg->local.contact = pjsip_contact_hdr_create(dlg->pool);\n\tdlg->local.contact->uri = dlg->local.info->uri;\n    }\n\n    /* Init remote info from the From header. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);\n    pjsip_fromto_hdr_set_to(dlg->remote.info);\n\n    /* Print the remote info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->remote.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \""<-error: uri too long->\"");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the remote info. */\n    pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);\n    \n    /* Save initial destination host from transport's info */\n    pj_strdup(dlg->pool, &dlg->initial_dest,\n    \t      &rdata->tp_info.transport->remote_name.host);\n\n\n    /* Init remote's contact from Contact header.\n     * Iterate the Contact URI until we find sip: or sips: scheme.\n     */\n    do {\n\tcontact_hdr = (pjsip_contact_hdr*)\n\t\t      pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t         pos);\n\tif (contact_hdr) {\n\t    if (!contact_hdr->uri ||\n\t\t(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&\n\t\t !PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))\n\t    {\n\t\tpos = (pjsip_hdr*)contact_hdr->next;\n\t\tif (pos == &rdata->msg_info.msg->hdr)\n\t\t    contact_hdr = NULL;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    } while (contact_hdr);\n\n    if (!contact_hdr) {\n\tstatus = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);\n\tgoto on_error;\n    }\n\n    dlg->remote.contact = (pjsip_contact_hdr*)\n    \t\t\t  pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);\n\n    /* Init remote's CSeq from CSeq header */\n    dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Set initial target to remote's Contact. */\n    dlg->target = dlg->remote.contact->uri;\n\n    /* Initial role is UAS */\n    dlg->role = PJSIP_ROLE_UAS;\n\n    /* Secure?\n     *  RFC 3261 Section 12.1.1:\n     *  If the request arrived over TLS, and the Request-URI contained a\n     *  SIPS URI, the 'secure' flag is set to TRUE.\n     */\n    dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&\n\t\t  PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);\n\n    /* Call-ID */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);\n\n    /* Route set.\n     *  RFC 3261 Section 12.1.1:\n     *  The route set MUST be set to the list of URIs in the Record-Route\n     *  header field from the request, taken in order and preserving all URI\n     *  parameters. If no Record-Route header field is present in the request,\n     * the route set MUST be set to the empty set.\n     */\n    pj_list_init(&dlg->route_set);\n    rr = rdata->msg_info.record_route;\n    while (rr != NULL) {\n\tpjsip_route_hdr *route;\n\n\t/* Clone the Record-Route, change the type to Route header. */\n\troute = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);\n\tpjsip_routing_hdr_set_route(route);\n\n\t/* Add to route set. */\n\tpj_list_push_back(&dlg->route_set, route);\n\n\t/* Find next Record-Route header. */\n\trr = rr->next;\n\tif (rr == (void*)&rdata->msg_info.msg->hdr)\n\t    break;\n\trr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t   PJSIP_H_RECORD_ROUTE, rr);\n    }\n    dlg->route_set_frozen = PJ_TRUE;\n\n    /* Increment the dialog's lock since tsx may cause the dialog to be\n     * destroyed prematurely (such as in case of transport error).\n     */\n    if (inc_lock) {\n        pjsip_dlg_inc_lock(dlg);\n        lock_incremented = PJ_TRUE;\n    }\n\n    /* Create UAS transaction for this request. */\n    status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Associate this dialog to the transaction. */\n    tsx->mod_data[dlg->ua->id] = dlg;\n\n    /* Increment tsx counter */\n    ++dlg->tsx_count;\n\n    /* Calculate hash value of remote tag. */\n    dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);\n\n    /* Update remote capabilities info */\n    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Put this dialog in rdata's mod_data */\n    rdata->endpt_info.mod_data[ua->id] = dlg;\n\n    PJ_TODO(DIALOG_APP_TIMER);\n\n    /* Feed the first request to the transaction. */\n    pjsip_tsx_recv_msg(tsx, rdata);\n\n    /* Done. */\n    *p_dlg = dlg;\n    PJ_LOG(5,(dlg->obj_name, \""UAS dialog created\""));\n    return PJ_SUCCESS;\n\non_error:\n    if (tsx) {\n\tpjsip_tsx_terminate(tsx, 500);\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n    }\n\n    if (lock_incremented) {\n        pjsip_dlg_dec_lock(dlg);\n    } else {\n        destroy_dialog(dlg, PJ_FALSE);\n    }\n\n    return status;\n}""}, {""func_name"": ""dlg_update_routeset"", ""file_path"": ""pjsip/src/pjsip/sip_dialog.c"", ""func_code"": ""static void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)\n{\n    const pjsip_hdr *hdr, *end_hdr;\n    //pj_int32_t msg_cseq;\n    const pjsip_msg *msg;\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\""UPDATE\"", 6}};\n\n    msg = rdata->msg_info.msg;\n    //msg_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Ignore if route set has been frozen */\n    if (dlg->route_set_frozen)\n\treturn;\n\n    /* Ignore if the message is an UPDATE response (see ticket #1781) */\n    if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)\n\treturn;\n\n    /* Only update route set if this message belongs to the same\n     * transaction as the initial transaction that establishes dialog.\n     */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n    \t/* Save initial destination host from transport's info. */\n    \tif (!dlg->initial_dest.slen) {\n    \t    pj_strdup(dlg->pool, &dlg->initial_dest,\n    \t      \t      &rdata->tp_info.transport->remote_name.host);\n    \t}\n\n\t/* Ignore subsequent request from remote */\n\tif (msg->type != PJSIP_RESPONSE_MSG)\n\t    return;\n\n\t/* Ignore subsequent responses with higher CSeq than initial CSeq.\n\t * Unfortunately this would be broken when the first request is\n\t * challenged!\n\t */\n\t//if (msg_cseq != dlg->local.first_cseq)\n\t//    return;\n\n    } else {\n\n\t/* For callee dialog, route set should have been set by initial\n\t * request and it will have been rejected by dlg->route_set_frozen\n\t * check above.\n\t */\n\tpj_assert(!\""Should not happen\"");\n\n    }\n\n    /* Based on the checks above, we should only get response message here */\n    pj_assert(msg->type == PJSIP_RESPONSE_MSG);\n\n    /* Ignore if this is not 1xx or 2xx response */\n    if (msg->line.status.code >= 300)\n\treturn;\n\n    /* Reset route set */\n    pj_list_init(&dlg->route_set);\n\n    /* Update route set */\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    PJ_LOG(5,(dlg->obj_name, \""Route-set updated\""));\n\n    /* Freeze the route set only when the route set comes in 2xx response.\n     * If it is in 1xx response, prepare to recompute the route set when\n     * the 2xx response comes in.\n     *\n     * There is a debate whether route set should be frozen when the dialog\n     * is established with reliable provisional response, but I think\n     * it is safer to not freeze the route set (thus recompute the route set\n     * upon receiving 2xx response). Also RFC 3261 says so in 13.2.2.4.\n     *\n     * The pjsip_method_creates_dialog() check protects from wrongly\n     * freezing the route set upon receiving 200/OK response for PRACK.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tPJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))\n    {\n\tdlg->route_set_frozen = PJ_TRUE;\n\tPJ_LOG(5,(dlg->obj_name, \""Route-set frozen\""));\n    }\n}""}, {""func_name"": ""pjsip_tpmgr_acquire_transport2"", ""file_path"": ""pjsip/src/pjsip/sip_transport.c"", ""func_code"": ""PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t   pjsip_transport_type_e type,\n\t\t\t\t\t\t   const pj_sockaddr_t *remote,\n\t\t\t\t\t\t   int addr_len,\n\t\t\t\t\t\t   const pjsip_tpselector *sel,\n\t\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t\t   pjsip_transport **tp)\n{\n    pjsip_tpfactory *factory;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE,\""Acquiring transport type=%s, sel=%s remote=%s:%d\"",\n\t\t       pjsip_transport_get_type_name(type),\n\t\t       print_tpsel_info(sel),\n\t\t       addr_string(remote),\n\t\t       pj_sockaddr_get_port(remote)));\n\n    pj_lock_acquire(mgr->lock);\n\n    /* If transport is specified, then just use it if it is suitable\n     * for the destination.\n     */\n    if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tsel->u.transport) \n    {\n\tpjsip_transport *seltp = sel->u.transport;\n\n\t/* See if the transport is (not) suitable */\n\tif (seltp->key.type != type) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE, \""Transport type in tpsel not matched\""));\n\t    return PJSIP_ETPNOTSUITABLE;\n\t}\n\n\t/* Make sure the transport is not being destroyed */\n\tif (seltp->is_destroying) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE,\""Transport to be acquired is being destroyed\""));\n\t    return PJ_ENOTFOUND;\n\t}\n\n\t/* We could also verify that the destination address is reachable\n\t * from this transport (i.e. both are equal), but if application\n\t * has requested a specific transport to be used, assume that\n\t * it knows what to do.\n\t *\n\t * In other words, I don't think destination verification is a good\n\t * idea for now.\n\t */\n\n\t/* Transport looks to be suitable to use, so just use it. */\n\tpjsip_transport_add_ref(seltp);\n\tpj_lock_release(mgr->lock);\n\t*tp = seltp;\n\n\tTRACE_((THIS_FILE, \""Transport %s acquired\"", seltp->obj_name));\n\treturn PJ_SUCCESS;\n\n    } else {\n\n\t/*\n\t * This is the \""normal\"" flow, where application doesn't specify\n\t * specific transport to be used to send message to.\n\t * In this case, lookup the transport from the hash table.\n\t */\n\tpjsip_transport_key key;\n\tint key_len;\n\tpjsip_transport *tp_ref = NULL;\n\ttransport *tp_entry = NULL;\n\n\n\t/* If listener is specified, verify that the listener type matches\n\t * the destination type.\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \""Listener type in tpsel not matched\""));\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t}\n\n\tif (!sel || sel->disable_connection_reuse == PJ_FALSE) {\n\t    pj_bzero(&key, sizeof(key));\n\t    key_len = sizeof(key.type) + addr_len;\n\n\t    /* First try to get exact destination. */\n\t    key.type = type;\n\t    pj_memcpy(&key.rem_addr, remote, addr_len);\n\n\t    tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,\n\t\t\t\t\t\tNULL);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\t\tdo {\n\t\t    /* Don't use transport being shutdown/destroyed */\n\t\t    if (!tp_iter->tp->is_shutdown &&\n\t\t\t!tp_iter->tp->is_destroying)\n\t\t    {\n\t\t\tif ((type & PJSIP_TRANSPORT_SECURE) && tdata) {\n\t\t\t    /* For secure transport, make sure tdata's\n\t\t\t     * destination host matches the transport's\n\t\t\t     * remote host.\n\t\t\t     */\n\t\t\t    if (pj_stricmp(&tdata->dest_info.name,\n\t\t\t\t  \t   &tp_iter->tp->remote_name.host))\n\t\t\t    {\n\t\t\t    \ttp_iter = tp_iter->next;\n\t\t\t    \tcontinue;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t\t    sel->u.listener)\n\t\t\t{\n\t\t\t    /* Match listener if selector is set */\n\t\t\t    if (tp_iter->tp->factory == sel->u.listener) {\n\t\t\t\ttp_ref = tp_iter->tp;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    tp_ref = tp_iter->tp;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t}\n\n\tif (tp_ref == NULL &&\n\t    (!sel || sel->disable_connection_reuse == PJ_FALSE))\n\t{\n\t    unsigned flag = pjsip_transport_get_flag_from_type(type);\n\t    const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;\n\n\n\t    /* Ignore address for loop transports. */\n\t    if (type == PJSIP_TRANSPORT_LOOP ||\n\t\ttype == PJSIP_TRANSPORT_LOOP_DGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t    /* For datagram transports, try lookup with zero address.\n\t     */\n\t    else if (flag & PJSIP_TRANSPORT_DATAGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\taddr->addr.sa_family = remote_addr->addr.sa_family;\n\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t}\n\n\t/* If transport is found and listener is specified, verify listener */\n\telse if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t sel->u.listener && tp_ref->factory != sel->u.listener)\n\t{\n\t    tp_ref = NULL;\n\t    /* This will cause a new transport to be created which will be a\n\t     * 'duplicate' of the existing transport (same type & remote addr,\n\t     * but different factory).\n\t     */\n\t    TRACE_((THIS_FILE, \""Transport found but from different listener\""));\n\t}\n\n\tif (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {\n\t    /*\n\t     * Transport found!\n\t     */\n\t    pjsip_transport_add_ref(tp_ref);\n\t    pj_lock_release(mgr->lock);\n\t    *tp = tp_ref;\n\n\t    TRACE_((THIS_FILE, \""Transport %s acquired\"", tp_ref->obj_name));\n\t    return PJ_SUCCESS;\n\t}\n\n\n\t/*\n\t * Either transport not found, or we don't want to use the existing\n\t * transport (such as in the case of different factory or\n\t * if connection reuse is disabled). So we need to create one,\n\t * find factory that can create such transport.\n\t *\n\t * If there's an existing transport, its place in the hash table\n\t * will be replaced by this new one. And eventually the existing\n\t * transport will still be freed (by application or #1774).\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    /* Application has requested that a specific listener is to\n\t     * be used.\n\t     */\n\n\t    /* Verify that the listener type matches the destination type */\n\t    /* Already checked above. */\n\t    /*\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t    */\n\n\t    /* We'll use this listener to create transport */\n\t    factory = sel->u.listener;\n\n\t    /* Verify if listener is still valid */\n\t    if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {\n\t\tpj_lock_release(mgr->lock);\n\t\tPJ_LOG(3,(THIS_FILE, \""Specified factory for creating \""\n\t\t\t\t     \""transport is not found\""));\n\t\treturn PJ_ENOTFOUND;\n\t    }\n\n\t} else {\n\n\t    /* Find factory with type matches the destination type */\n\t    factory = mgr->factory_list.next;\n\t    while (factory != &mgr->factory_list) {\n\t\tif (factory->type == type)\n\t\t    break;\n\t\tfactory = factory->next;\n\t    }\n\n\t    if (factory == &mgr->factory_list) {\n\t\t/* No factory can create the transport! */\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \""No suitable factory was found either\""));\n\t\treturn PJSIP_EUNSUPTRANSPORT;\n\t    }\n\t}\n    }\n\n    TRACE_((THIS_FILE, \""Creating new transport from factory\""));\n\n    /* Request factory to create transport. */\n    if (factory->create_transport2) {\n\tstatus = factory->create_transport2(factory, mgr, mgr->endpt,\n\t\t\t\t\t    (const pj_sockaddr*) remote,\n\t\t\t\t\t    addr_len, tdata, tp);\n    } else {\n\tstatus = factory->create_transport(factory, mgr, mgr->endpt,\n\t\t\t\t\t   (const pj_sockaddr*) remote,\n\t\t\t\t\t   addr_len, tp);\n    }\n    if (status == PJ_SUCCESS) {\n\tPJ_ASSERT_ON_FAIL(tp!=NULL,\n\t    {pj_lock_release(mgr->lock); return PJ_EBUG;});\n\tpjsip_transport_add_ref(*tp);\n\t(*tp)->factory = factory;\n    }""}, {""func_name"": ""pjsip_endpt_send_response"", ""file_path"": ""pjsip/src/pjsip/sip_util.c"", ""func_code"": ""PJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,\n\t\t\t\t\t       pjsip_response_addr *res_addr,\n\t\t\t\t\t       pjsip_tx_data *tdata,\n\t\t\t\t\t       void *token,\n\t\t\t\t\t       pjsip_send_callback cb)\n{\n    /* Determine which transports and addresses to send the response,\n     * based on Section 18.2.2 of RFC 3261.\n     */\n    pjsip_send_state *send_state;\n    pj_status_t status;\n\n    /* Create structure to keep the sending state. */\n    send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    send_state->endpt = endpt;\n    send_state->tdata = tdata;\n    send_state->token = token;\n    send_state->app_cb = cb;\n\n    if (res_addr->transport != NULL) {\n\tsend_state->cur_transport = res_addr->transport;\n\tpjsip_transport_add_ref(send_state->cur_transport);\n\n\tstatus = pjsip_transport_send( send_state->cur_transport, tdata, \n\t\t\t\t       &res_addr->addr,\n\t\t\t\t       res_addr->addr_len,\n\t\t\t\t       send_state,\n\t\t\t\t       &send_response_transport_cb );\n\tif (status == PJ_SUCCESS) {\n\t    pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;\n\t    send_response_transport_cb(send_state, tdata, sent);\n\t    return PJ_SUCCESS;\n\t} else if (status == PJ_EPENDING) {\n\t    /* Callback will be called later. */\n\t    return PJ_SUCCESS;\n\t} else {\n\t    pjsip_transport_dec_ref(send_state->cur_transport);\n\t    return status;\n\t}\n    } else {\n\t/* Copy the destination host name to TX data */\n\tif (!tdata->dest_info.name.slen) {\n\t    pj_strdup(tdata->pool, &tdata->dest_info.name, \n\t\t      &res_addr->dst_host.addr.host);\n\t}\n\n\tpjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, \n\t\t\t    send_state, &send_response_resolver_cb);\n\treturn PJ_SUCCESS;\n    }\n}""}, {""func_name"": ""pjsip_endpt_send_request_stateless"", ""file_path"": ""pjsip/src/pjsip/sip_util.c"", ""func_code"": ""PJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, \n\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t   void *token,\n\t\t\t\t   pjsip_send_callback cb)\n{\n    pjsip_host_info dest_info;\n    pjsip_send_state *stateless_data;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);\n\n    /* Get destination name to contact. */\n    status = pjsip_process_route_set(tdata, &dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Keep stateless data. */\n    stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    stateless_data->token = token;\n    stateless_data->endpt = endpt;\n    stateless_data->tdata = tdata;\n    stateless_data->app_cb = cb;\n\n    /* If destination info has not been initialized (this applies for most\n     * all requests except CANCEL), resolve destination host. The processing\n     * then resumed when the resolving callback is called. For CANCEL, the\n     * destination info must have been copied from the original INVITE so\n     * proceed to sending the request directly.\n     */\n    if (tdata->dest_info.addr.count == 0) {\n\t/* Copy the destination host name to TX data */\n\tif (!tdata->dest_info.name.slen) {\n\t    pj_strdup(tdata->pool, &tdata->dest_info.name,\n\t    \t      &dest_info.addr.host);\n\t}\n\n\tpjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,\n\t\t\t     &stateless_send_resolver_callback);\n    } else {\n\tPJ_LOG(5,(THIS_FILE, \""%s: skipping target resolution because \""\n\t                     \""address is already set\"",\n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\tstateless_send_resolver_callback(PJ_SUCCESS, stateless_data,\n\t\t\t\t\t &tdata->dest_info.addr);\n    }\n    return PJ_SUCCESS;\n}""}]",{},[],"Transports were reused based on IP+port+protocol without verifying the remote hostname. The patch adds storage of initial destination hostnames in sip_dialog.c (create_uas_dialog:468-472, dlg_update_routeset:1823-1828) and enforces hostname validation during transport selection in sip_transport.c (pjsip_tpmgr_acquire_transport2:2331-2345).",0.95,./github/other_context/CVE-2020-15260
37,CVE-2020-29074,CWE-732,c_cpp,"scan.c in x11vnc 0.9.16 uses IPC_CREAT|0777 in shmget calls, which allows access by actors other than the current user.",https://github.com/LibVNC/x11vnc/commit/69eeb9f7baa14ca03b16c9de821f9876def7a36a,scan: limit access to shared memory segments to current user,1,"[{""func_name"": ""shm_create"", ""file_path"": ""src/scan.c"", ""func_code"": ""static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\""XCreateImage(%s) failed.\\n\"", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \""XCreateImage(%s) failed.\\n\"",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \""shm_create simple %d %d\\t%p %s\\n\"", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\""XCreateImage(%s) data malloc failed.\\n\"", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \""XCreateImage(%s) data malloc\""\n\t\t\t\t    \"" failed.\\n\"", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\""Changing XImage byte order\""\n\t\t\t\t    \"" to %s\\n\"", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\""XShmCreateImage(%s) failed.\\n\"", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \""XShmCreateImage(%s) failed.\\n\"", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\""shmget(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmget\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\""shmat(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmat\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\""XShmAttach(%s) failed.\\n\"", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}"", ""target"": 0}]","[{""func_name"": ""shm_create"", ""file_path"": ""src/scan.c"", ""func_code"": ""static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\""XCreateImage(%s) failed.\\n\"", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \""XCreateImage(%s) failed.\\n\"",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \""shm_create simple %d %d\\t%p %s\\n\"", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\""XCreateImage(%s) data malloc failed.\\n\"", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \""XCreateImage(%s) data malloc\""\n\t\t\t\t    \"" failed.\\n\"", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\""Changing XImage byte order\""\n\t\t\t\t    \"" to %s\\n\"", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\""XShmCreateImage(%s) failed.\\n\"", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \""XShmCreateImage(%s) failed.\\n\"", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0600);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\""shmget(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmget\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\""shmat(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmat\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\""XShmAttach(%s) failed.\\n\"", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}""}]","{""code"": 8, ""function"": 2}","[{""source"": ""code_info(file:scan.c, lines:300-400)"", ""result"": ""\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\""XShmCreateImage(%s) failed.\\n\"", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \""XShmCreateImage(%s) failed.\\n\"", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\""shmget(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmget\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\""shmat(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmat\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\""XShmAttach(%s) failed.\\n\"", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}\n\nvoid shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\""X11VNC_SHM_DEBUG\"")) fprintf(stderr, \""shm_delete:    %p\\n\"", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \""shm_clean: called:  %p\\n\"", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \""shm_clean: XShmDetach_wr\\n\"");\n\t\tXShmDetach_wr(dpy, shm);\n""}, {""source"": ""code_info(file:scan.c, lines:1-600)"", ""result"": ""/*\n   Copyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com> \n   All rights reserved.\n\nThis file is part of x11vnc.\n\nx11vnc is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or (at\nyour option) any later version.\n\nx11vnc is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with x11vnc; if not, write to the Free Software\nFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA\nor see <http://www.gnu.org/licenses/>.\n\nIn addition, as a special exception, Karl J. Runge\ngives permission to link the code of its release of x11vnc with the\nOpenSSL project's \""OpenSSL\"" library (or with modified versions of it\nthat use the same license as the \""OpenSSL\"" library), and distribute\nthe linked executables.  You must obey the GNU General Public License\nin all respects for all of the code used other than \""OpenSSL\"".  If you\nmodify this file, you may extend this exception to your version of the\nfile, but you are not obligated to do so.  If you do not wish to do\nso, delete this exception statement from your version.\n*/\n\n/* -- scan.c -- */\n\n#include \""x11vnc.h\""\n#include \""xinerama.h\""\n#include \""xwrappers.h\""\n#include \""xdamage.h\""\n#include \""xrandr.h\""\n#include \""win_utils.h\""\n#include \""8to24.h\""\n#include \""screen.h\""\n#include \""pointer.h\""\n#include \""cleanup.h\""\n#include \""unixpw.h\""\n#include \""screen.h\""\n#include \""macosx.h\""\n#include \""userinput.h\""\n\n/*\n * routines for scanning and reading the X11 display for changes, and\n * for doing all the tile work (shm, etc).\n */\nvoid initialize_tiles(void);\nvoid free_tiles(void);\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nvoid initialize_polling_images(void);\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\nint copy_screen(void);\nint copy_snap(void);\nvoid nap_sleep(int ms, int split);\nvoid set_offset(void);\nint scan_for_updates(int count_only);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nstatic void set_fs_factor(int max);\nstatic char *flip_ximage_byte_order(XImage *xim);\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint);\nstatic void save_hint(hint_t hint, int loc);\nstatic void hint_updates(void);\nstatic void mark_hint(hint_t hint);\nstatic int copy_tiles(int tx, int ty, int nt);\nstatic int copy_all_tiles(void);\nstatic int copy_all_tile_runs(void);\nstatic int copy_tiles_backward_pass(void);\nstatic int copy_tiles_additional_pass(void);\nstatic int gap_try(int x, int y, int *run, int *saw, int along_x);\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\nstatic void blackout_regions(void);\nstatic void nap_set(int tile_cnt);\nstatic void nap_check(int tile_cnt);\nstatic void ping_clients(int tile_cnt);\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int blackout_line_cmpskip(int n, int x, int y, char *dst, char *src,\n    int w, int pixelsize);\nstatic int scan_display(int ystart, int rescan);\n\n\n/* array to hold the hints: */\nstatic hint_t *hint_list;\n\n/* nap state */\nint nap_ok = 0;\nstatic int nap_diff_count = 0;\n\nstatic int scan_count = 0;\t/* indicates which scan pattern we are on  */\nstatic int scan_in_progress = 0;\t\n\n\ntypedef struct tile_change_region {\n\t/* start and end lines, along y, of the changed area inside a tile. */\n\tunsigned short first_line, last_line;\n\tshort first_x, last_x;\n\t/* info about differences along edges. */\n\tunsigned short left_diff, right_diff;\n\tunsigned short top_diff,  bot_diff;\n} region_t;\n\n/* array to hold the tiles region_t-s. */\nstatic region_t *tile_region;\n\n\n\n\n/*\n * setup tile numbers and allocate the tile and hint arrays:\n */\nvoid initialize_tiles(void) {\n\n\tntiles_x = (dpy_x - 1)/tile_x + 1;\n\tntiles_y = (dpy_y - 1)/tile_y + 1;\n\tntiles = ntiles_x * ntiles_y;\n\n\ttile_has_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_row_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles_y * sizeof(unsigned char)), 1);\n\ttile_tried    = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_copied   = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_blackout    = (tile_blackout_t *)\n\t\tcalloc((size_t) (ntiles * sizeof(tile_blackout_t)), 1);\n\ttile_region = (region_t *) calloc((size_t) (ntiles * sizeof(region_t)), 1);\n\n\ttile_row = (XImage **)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XImage *)), 1);\n\ttile_row_shm = (XShmSegmentInfo *)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo)), 1);\n\n\t/* there will never be more hints than tiles: */\n\thint_list = (hint_t *) calloc((size_t) (ntiles * sizeof(hint_t)), 1);\n}\n\nvoid free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}\n\n/*\n * silly function to factor dpy_y until fullscreen shm is not bigger than max.\n * should always work unless dpy_y is a large prime or something... under\n * failure fs_factor remains 0 and no fullscreen updates will be tried.\n */\nstatic int fs_factor = 0;\n\nstatic void set_fs_factor(int max) {\n\tint f, fac = 1, n = dpy_y;\n\n\tfs_factor = 0;\n\tif ((bpp/8) * dpy_x * dpy_y <= max)  {\n\t\tfs_factor = 1;\n\t\treturn;\n\t}\n\tfor (f=2; f <= 101; f++) {\n\t\twhile (n % f == 0) {\n\t\t\tn = n / f;\n\t\t\tfac = fac * f;\n\t\t\tif ( (bpp/8) * dpy_x * (dpy_y/fac) <= max )  {\n\t\t\t\tfs_factor = fac;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \""MSBFirst\"";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \""LSBFirst\"";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}\n\n/*\n * set up an XShm image, or if not using shm just create the XImage.\n */\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\""XCreateImage(%s) failed.\\n\"", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \""XCreateImage(%s) failed.\\n\"",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \""shm_create simple %d %d\\t%p %s\\n\"", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\""XCreateImage(%s) data malloc failed.\\n\"", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \""XCreateImage(%s) data malloc\""\n\t\t\t\t    \"" failed.\\n\"", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\""Changing XImage byte order\""\n\t\t\t\t    \"" to %s\\n\"", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\""XShmCreateImage(%s) failed.\\n\"", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \""XShmCreateImage(%s) failed.\\n\"", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\""shmget(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmget\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\""shmat(%s) failed.\\n\"", name);\n\t\trfbLogPerror(\""shmat\"");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\""XShmAttach(%s) failed.\\n\"", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}\n\nvoid shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\""X11VNC_SHM_DEBUG\"")) fprintf(stderr, \""shm_delete:    %p\\n\"", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \""shm_clean: called:  %p\\n\"", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \""shm_clean: XShmDetach_wr\\n\"");\n\t\tXShmDetach_wr(dpy, shm);\n\t}\n#endif\n\tif (xim != NULL) {\n\t\tif (! raw_fb_back_to_X) {\t/* raw_fb hack */\n\t\t\tif (xim->bitmap_unit != -1) {\n\t\t\t\tif (db) fprintf(stderr, \""shm_clean: XDestroyImage  %p\\n\"", (void *)xim);\n\t\t\t\tXDestroyImage(xim);\n\t\t\t} else {\n\t\t\t\tif (xim->data) {\n\t\t\t\t\tif (db) fprintf(stderr, \""shm_clean: free xim->data  %p %p\\n\"", (void *)xim, (void *)(xim->data));\n\t\t\t\t\tfree(xim->data);\n\t\t\t\t\txim->data = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txim = NULL;\n\t}\n\tX_UNLOCK;\n\n\tshm_delete(shm);\n}\n\nvoid initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \""none\"" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \""scanline\"")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \""Linux\"")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\""warning: fullscreen updates are disabled.\\n\"");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \""fullscreen\"")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\""warning: disabling -snapfb mode.\\n\"");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \""snaprect\"")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \""tile_row\"")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\""shm: Error creating shared memory tile-row for\""\n\t\t\t    \"" len=%d,\\n\"", i);\n\t\t\trfbLog(\""shm: reverting to -onetile mode. If this\""\n\t\t\t    \"" problem persists\\n\"");\n\t\t\trfbLog(\""shm: try using the -onetile or -noshm options\""\n\t\t\t    \"" to limit\\n\"");\n\t\t\trfbLog(\""shm: shared memory usage, or run ipcrm(1)\""\n\t\t\t    \"" to manually\\n\"");\n\t\t\trfbLog(\""shm: delete unattached shm segments.\\n\"");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\""created %d tile_row shm polling images.\\n\"",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\""created %d tile_row polling images.\\n\"",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}\n\n/*\n * A hint is a rectangular region built from 1 or more adjacent tiles\n * glued together.  Ultimately, this information in a single hint is sent\n * to libvncserver rather than sending each tile separately.\n */\nstatic void create_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\thint->x = x;\n\thint->y = y;\n\thint->w = w;\n\thint->h = h;\n}\n\nstatic void extend_tile_hint(int x, int y, int tw, int th, hint_t *hint) {\n\tint w = dpy_x - x;\n\tint h = dpy_y - y;\n\n\tif (w > tw) {\n\t\tw = tw;\n\t}\n\tif (h > th) {\n\t\th = th;\n\t}\n\n\tif (hint->x > x) {\t\t\t/* extend to the left */\n\t\thint->w += hint->x - x;\n\t\thint->x = x;\n\t}\n\tif (hint->y > y) {\t\t\t/* extend upward */\n\t\thint->h += hint->y - y;\n\t\thint->y = y;\n\t}\n\n\tif (hint->x + hint->w < x + w) {\t/* extend to the right */\n\t\thint->w = x + w - hint->x;\n\t}\n\tif (hint->y + hint->h < y + h) {\t/* extend downward */\n\t\thint->h = y + h - hint->y;\n\t}\n}\n\nstatic void save_hint(hint_t hint, int loc) {\n\t/* simply copy it to the global array for later use. */\n\thint_list[loc].x = hint.x;\n\thint_list[loc].y = hint.y;\n\thint_list[loc].w = hint.w;\n\thint_list[loc].h = hint.h;\n}\n\n/*\n * Glue together horizontal \""runs\"" of adjacent changed tiles into one big\n * rectangle change \""hint\"" to be passed to the vnc machinery.\n */\nstatic void hint_updates(void) {\n\thint_t hint;\n\tint x, y, i, n, ty, th, tx, tw;\n\tint hint_count = 0, in_run = 0;\n\n\thint.x = hint.y = hint.w = hint.h = 0;\n\n\tfor (y=0; y < ntiles_y; y++) {\n\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\tn = x + y * ntiles_x;\n\n\t\t\tif (tile_has_diff[n]) {\n\t\t\t\tty = tile_region[n].first_line;\n\t\t\t\tth = tile_region[n].last_line - ty + 1;\n\n\t\t\t\ttx = tile_region[n].first_x;\n\t\t\t\ttw = tile_region[n].last_x - tx + 1;\n""}, {""source"": ""func_info(file:scan.c, func:shm_delete)"", ""result"": [{""code"": ""void shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\""X11VNC_SHM_DEBUG\"")) fprintf(stderr, \""shm_delete:    %p\\n\"", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}"", ""start_line"": 374, ""end_line"": 390, ""full_name"": ""shm_delete"", ""file_path"": ""src/scan.c""}]}, {""source"": ""code_info(file:x11vnc.c, lines:1-600)"", ""result"": ""/*\n * x11vnc: a VNC server for X displays.\n *\n * Copyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com>\n * All rights reserved.\n *\n *  This file is part of x11vnc.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; version 2 of the License, or (at\n *  your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA  or see <http://www.gnu.org/licenses/>.\n *\n *  In addition, as a special exception, Karl J. Runge\n *  gives permission to link the code of its release of x11vnc with the\n *  OpenSSL project's \""OpenSSL\"" library (or with modified versions of it\n *  that use the same license as the \""OpenSSL\"" library), and distribute\n *  the linked executables.  You must obey the GNU General Public License\n *  in all respects for all of the code used other than \""OpenSSL\"".  If you\n *  modify this file, you may extend this exception to your version of the\n *  file, but you are not obligated to do so.  If you do not wish to do\n *  so, delete this exception statement from your version.\n */\n\n/*\n * This program is based on some ideas from the following programs:\n *\n *       the initial x11vnc.c in libvncserver (Johannes E. Schindelin)\n *\t x0rfbserver, the original native X vnc server (Jens Wagner)\n *       krfb, the KDE desktopsharing project (Tim Jansen)\n *\n * Please see http://www.karlrunge.com/x11vnc for the most up-to-date\n * information about x11vnc.  Some of the following text may be out\n * of date.\n *\n * The primary goal of this program is to create a portable and simple\n * command-line server utility that allows a VNC viewer to connect\n * to an actual X display (as the above do).  The only non-standard\n * dependency of this program is the static library libvncserver.a.\n * Although in some environments libjpeg.so or libz.so may not be\n * readily available and needs to be installed, they may be found\n * at ftp://ftp.uu.net/graphics/jpeg/ and http://www.gzip.org/zlib/,\n * respectively.  To increase portability it is written in plain C.\n *\n * Another goal is to improve performance and interactive response.\n * The algorithm of x0rfbserver was used as a base.  Many additional\n * heuristics are also applied.\n *\n * Another goal is to add many features that enable and incourage creative\n * usage and application of the tool.  Apologies for the large number\n * of options!\n *\n * To build:\n *\n * Obtain the libvncserver package (http://libvncserver.sourceforge.net).\n * As of 12/2002 this version of x11vnc.c is contained in the libvncserver\n * CVS tree and released in version 0.5.\n *\n * gcc should be used on all platforms.  To build a threaded version put\n * \""-D_REENTRANT -DX11VNC_THREADED\"" in the environment variable CFLAGS\n * or CPPFLAGS (e.g. before running the libvncserver configure).  The\n * threaded mode is a bit more responsive, but can be unstable (e.g.\n * if more than one client the same tight or zrle encoding).\n *\n * Known shortcomings:\n *\n * The screen updates are good, but of course not perfect since the X\n * display must be continuously polled and read for changes and this is\n * slow for most hardware. This can be contrasted with receiving a change\n * callback from the X server, if that were generally possible... (UPDATE:\n * this is handled now with the X DAMAGE extension, but unfortunately\n * that doesn't seem to address the slow read from the video h/w).  So,\n * e.g., opaque moves and similar window activity can be very painful;\n * one has to modify one's behavior a bit.\n *\n * General audio at the remote display is lost unless one separately\n * sets up some audio side-channel such as esd.\n *\n * It does not appear possible to query the X server for the current\n * cursor shape.  We can use XTest to compare cursor to current window's\n * cursor, but we cannot extract what the cursor is... (UPDATE: we now\n * use XFIXES extension for this.  Also on Solaris and IRIX Overlay\n * extensions exists that allow drawing the mouse into the framebuffer)\n * \n * The current *position* of the remote X mouse pointer is shown with\n * the -cursor option.  Further, if -cursor X is used, a trick\n * is done to at least show the root window cursor vs non-root cursor.\n * (perhaps some heuristic can be done to further distinguish cases...,\n * currently \""-cursor some\"" is a first hack at this)\n *\n * Under XFIXES mode for showing the cursor shape, the cursor may be\n * poorly approximated if it has transparency (alpha channel).\n *\n * Windows using visuals other than the default X visual may have\n * their colors messed up.  When using 8bpp indexed color, the colormap\n * is attempted to be followed, but may become out of date.  Use the\n * -flashcmap option to have colormap flashing as the pointer moves\n * windows with private colormaps (slow).  Displays with mixed depth 8 and\n * 24 visuals will incorrectly display windows using the non-default one.\n * On Sun and Sgi hardware we can to work around this with -overlay.\n *\n * Feature -id <windowid> can be picky: it can crash for things like\n * the window not sufficiently mapped into server memory, etc (UPDATE:\n * we now use the -xrandr mechanisms to trap errors more robustly for\n * this mode).  SaveUnders menus, popups, etc will not be seen.\n *\n * Under some situations the keysym unmapping is not correct, especially\n * if the two keyboards correspond to different languages.  The -modtweak\n * option is the default and corrects most problems. One can use the\n * -xkb option to try to use the XKEYBOARD extension to clear up any\n * remaining problems.\n *\n * Occasionally, a few tile updates can be missed leaving a patch of\n * color that needs to be refreshed.  This may only be when threaded,\n * which is no longer the default.\n *\n * There seems to be a serious bug with simultaneous clients when\n * threaded, currently the only workaround in this case is -nothreads\n * (which is now the default).\n */\n\n\n/* -- x11vnc.c -- */\n\n#include \""x11vnc.h\""\n#include \""xwrappers.h\""\n#include \""xdamage.h\""\n#include \""xrecord.h\""\n#include \""xevents.h\""\n#include \""xinerama.h\""\n#include \""xrandr.h\""\n#include \""xkb_bell.h\""\n#include \""win_utils.h\""\n#include \""remote.h\""\n#include \""scan.h\""\n#include \""gui.h\""\n#include \""help.h\""\n#include \""user.h\""\n#include \""cleanup.h\""\n#include \""keyboard.h\""\n#include \""pointer.h\""\n#include \""cursor.h\""\n#include \""userinput.h\""\n#include \""screen.h\""\n#include \""connections.h\""\n#include \""rates.h\""\n#include \""unixpw.h\""\n#include \""inet.h\""\n#include \""sslcmds.h\""\n#include \""sslhelper.h\""\n#include \""selection.h\""\n#include \""pm.h\""\n#include \""solid.h\""\n#include \""xi2_devices.h\""\n\n/*\n * main routine for the x11vnc program\n */\nvoid watch_loop(void);\n\nstatic int limit_shm(void);\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void print_settings(int try_http, int bg, char *gui_str);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\n\nstatic int tsdo_timeout_flag;\n\nstatic void tsdo_timeout (int sig) {\n\ttsdo_timeout_flag = 1;\n\tif (sig) {};\n}\n\n#define TASKMAX 32\nstatic pid_t ts_tasks[TASKMAX];\nstatic int ts_taskn = -1;\n\nint tsdo(int port, int lsock, int *conn) {\n\tint csock, rsock, i, db = 1;\n\tpid_t pid;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tif (*conn < 0) {\n\t\tsignal(SIGALRM, tsdo_timeout);\n\t\ttsdo_timeout_flag = 0;\n\n\t\talarm(10);\n\t\tcsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tif (db) rfbLog(\""tsdo: accept: lsock: %d, csock: %d, port: %d\\n\"", lsock, csock, port);\n\n\t\tif (tsdo_timeout_flag > 0 || csock < 0) {\n\t\t\tclose(csock);\n\t\t\t*conn = -1;\n\t\t\treturn 1;\n\t\t}\n\t\t*conn = csock;\n\t} else {\n\t\tcsock = *conn;\n\t\tif (db) rfbLog(\""tsdo: using existing csock: %d, port: %d\\n\"", csock, port);\n\t}\n\n\trsock = connect_tcp(\""127.0.0.1\"", port);\n\tif (rsock < 0) {\n\t\tif (db) rfbLog(\""tsdo: connect_tcp(port=%d) failed.\\n\"", port);\n\t\tclose(csock);\n\t\treturn 2;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\treturn 3;\n\t}\n\tif (pid > 0) {\n\t\tts_taskn = (ts_taskn+1) % TASKMAX;\n\t\tts_tasks[ts_taskn] = pid;\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\t*conn = -1;\n\t\treturn 0;\n\t}\n\tif (pid == 0) {\n\t\tfor (i=0; i<255; i++) {\n\t\t\tif (i != csock && i != rsock && i != 2) {\n\t\t\t\tclose(i);\n\t\t\t}\n\t\t}\n#if HAVE_SETSID\n\t\tif (setsid() == -1) {\n\t\t\tperror(\""setsid\"");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setpgrp() == -1) {\n\t\t\tperror(\""setpgrp\"");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#endif\t/* SETSID */\n\t\traw_xfer(rsock, csock, csock);\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\texit(0);\n\t}\n\treturn 0;\n}\n\nvoid set_redir_properties(void);\n\n#define TSMAX 32\n#define TSSTK 16\n\nvoid terminal_services(char *list) {\n\tint i, j, n, db = 1;\n\tchar *p, *q, *r, *str;\n#if !NO_X11\n\tchar *tag[TSMAX];\n\tint listen[TSMAX], redir[TSMAX][TSSTK], socks[TSMAX], tstk[TSSTK];\n\tdouble rate_start;\n\tint rate_count;\n\tAtom at, atom[TSMAX];\n\tfd_set rd;\n\tWindow rwin;\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\tchar num[32];\n\ttime_t last_clean = time(NULL);\n\n\tif (getenv(\""TS_REDIR_DEBUG\"")) {\n\t\tdb = 2;\n\t}\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\trwin = RootWindow(dpy, DefaultScreen(dpy));\n\n\tat = XInternAtom(dpy, \""TS_REDIR_LIST\"", False);\n\tif (at != None) {\n\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)list, strlen(list));\n\t\tXSync(dpy, False);\n\t}\n\tif (db) fprintf(stderr, \""TS_REDIR_LIST Atom: %d.\\n\"", (int) at);\n\n\toh_restart_it_all:\n\n\tfor (i=0; i<TASKMAX; i++) {\n\t\tts_tasks[i] = 0;\n\t}\n\tfor (i=0; i<TSMAX; i++) {\n\t\tsocks[i] = -1;\n\t\tlisten[i] = -1;\n\t\tfor (j=0; j<TSSTK; j++) {\n\t\t\tredir[i][j] = 0;\n\t\t}\n\t}\n\n\trate_start = 0.0;\n\trate_count = 0;\n\n\tn = 0;\n\tstr = strdup(list);\n\tp = strtok(str, \"",\"");\n\twhile (p) {\n\t\tint m1, m2;\n\t\tif (db) fprintf(stderr, \""item: %s\\n\"", p);\n\t\tq = strrchr(p, ':');\n\t\tif (!q) {\n\t\t\tp = strtok(NULL, \"",\"");\n\t\t\tcontinue;\n\t\t}\n\t\tr = strchr(p, ':');\n\t\tif (!r || r == q) {\n\t\t\tp = strtok(NULL, \"",\"");\n\t\t\tcontinue;\n\t\t}\n\n\t\tm1 = atoi(q+1);\n\t\t*q = '\\0';\n\t\tm2 = atoi(r+1);\n\t\t*r = '\\0';\n\n\t\tif (m1 <= 0 || m2 <= 0 || m1 >= 0xffff || m2 >= 0xffff) {\n\t\t\tp = strtok(NULL, \"",\"");\n\t\t\tcontinue;\n\t\t}\n\n\t\tredir[n][0] = m1;\n\t\tlisten[n] = m2;\n\t\ttag[n] = strdup(p);\n\n\t\tif (db) fprintf(stderr, \""     %d %d %s\\n\"", redir[n][0], listen[n], tag[n]);\n\n\t\t*r = ':';\n\t\t*q = ':';\n\n\t\tn++;\n\t\tif (n >= TSMAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \"",\"");\n\t}\n\tfree(str);\n\n\tif (n==0) {\n\t\treturn;\n\t}\n\n\tat = XInternAtom(dpy, \""TS_REDIR_PID\"", False);\n\tif (at != None) {\n\t\tsprintf(num, \""%d\"", getpid());\n\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\tXSync(dpy, False);\n\t}\n\n\tfor (i=0; i<n; i++) {\n\t\tint k;\n\t\tatom[i] = XInternAtom(dpy, tag[i], False);\n\t\tif (db) fprintf(stderr, \""tag: %s atom: %d\\n\"", tag[i], (int) atom[i]);\n\t\tif (atom[i] == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \""%d\"", redir[i][0]);\n\t\tif (db) fprintf(stderr, \""     listen: %d  redir: %s\\n\"", listen[i], num);\n\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\tXSync(dpy, False);\n\n\t\tfor (k=1; k <= 5; k++) {\n\t\t\t/* XXX ::1 fallback? */\n\t\t\tsocks[i] = listen_tcp(listen[i], htonl(INADDR_LOOPBACK), 1);\n\t\t\tif (socks[i] >= 0) {\n\t\t\t\tif (db) fprintf(stderr, \""     listen succeeded: %d\\n\"", listen[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \""     listen failed***: %d\\n\"", listen[i]);\n\t\t\tusleep(k * 2000*1000);\n\t\t}\n\t}\n\n\tif (getenv(\""TSD_RESTART\"")) {\n\t\tif (!strcmp(getenv(\""TSD_RESTART\""), \""1\"")) {\n\t\t\tset_redir_properties();\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tstruct timeval tv;\n\t\tint nfd;\n\t\tint fmax = -1;\n\n\t\ttv.tv_sec  = 3;\n\t\ttv.tv_usec = 0;\n\n\t\tFD_ZERO(&rd);\n\t\tfor (i=0; i<n; i++) {\n\t\t\tif (socks[i] >= 0) {\n\t\t\t\tFD_SET(socks[i], &rd);\n\t\t\t\tif (socks[i] > fmax) {\n\t\t\t\t\tfmax = socks[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnfd = select(fmax+1, &rd, NULL, NULL, &tv);\n\n\t\tif (db && 0) fprintf(stderr, \""nfd=%d\\n\"", nfd);\n\t\tif (nfd < 0 && errno == EINTR) {\n\t\t\tXSync(dpy, True);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfd > 0) {\n\t\t\tint did_ts = 0;\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint k = 0;\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\ttstk[j] = 0;\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\tif (redir[i][j] != 0) {\n\t\t\t\t\t\ttstk[k++] = redir[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\tredir[i][j] = tstk[j];\nif (tstk[j] != 0) fprintf(stderr, \""B redir[%d][%d] = %d  %s\\n\"", i, j, tstk[j], tag[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint s = socks[i];\n\t\t\t\tif (s < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (FD_ISSET(s, &rd)) {\n\t\t\t\t\tint p0, p, found = -1, jzero = -1;\n\t\t\t\t\tint conn = -1;\n\n\t\t\t\t\tget_prop(num, sizeof num, atom[i], None);\n\t\t\t\t\tp0 = atoi(num);\n\n\t\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\t\tif (redir[i][j] == 0) {\n\t\t\t\t\t\t\tjzero = j;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p0 > 0 && p0 < 0xffff) {\n\t\t\t\t\t\t\tif (redir[i][j] == p0) {\n\t\t\t\t\t\t\t\tfound = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (jzero < 0) {\n\t\t\t\t\t\tjzero = TSSTK-1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found < 0) {\n\t\t\t\t\t\tif (p0 > 0 && p0 < 0xffff) {\n\t\t\t\t\t\t\tredir[i][jzero] = p0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\t\tint rc;\n\t\t\t\t\t\tp = redir[i][j];\n\t\t\t\t\t\tif (p <= 0 || p >= 0xffff) {\n\t\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (dnow() > rate_start + 10.0) {\n\t\t\t\t\t\t\trate_start = dnow();\n\t\t\t\t\t\t\trate_count = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trate_count++;\n\n\t\t\t\t\t\trc = tsdo(p, s, &conn);\n\t\t\t\t\t\tdid_ts++;\n\n\t\t\t\t\t\tif (rc == 0) {\n\t\t\t\t\t\t\t/* AOK */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \""tsdo[%d] OK: %d\\n\"", i, p);\n\t\t\t\t\t\t\tif (p != p0) {\n\t\t\t\t\t\t\t\tsprintf(num, \""%d\"", p);\n\t\t\t\t\t\t\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t\t\t\t\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (rc == 1) {\n\t\t\t\t\t\t\t/* accept failed */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \""tsdo[%d] accept failed: %d, sleep 50ms\\n\"", i, p);\n\t\t\t\t\t\t\tusleep(50*1000);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (rc == 2) {\n\t\t\t\t\t\t\t/* connect failed */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \""tsdo[%d] connect failed: %d, sleep 50ms  rate: %d/10s\\n\"", i, p, rate_count);\n\t\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\t\tusleep(50*1000);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (rc == 3) {\n\t\t\t\t\t\t\t/* fork failed */\n\t\t\t\t\t\t\tusleep(500*1000);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\t\tif (redir[i][j] != 0) fprintf(stderr, \""A redir[%d][%d] = %d  %s\\n\"", i, j, redir[i][j], tag[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (did_ts && rate_count > 100) {\n\t\t\t\tint db_netstat = 1;\n\t\t\t\tchar dcmd[100];\n\n\t\t\t\tif (no_external_cmds) {\n\t\t\t\t\tdb_netstat = 0;\n\t\t\t\t}\n\n\t\t\t\trfbLog(\""terminal_services: throttling high connect rate %d/10s\\n\"", rate_count);\n\t\t\t\tusleep(2*1000*1000);\n\t\t\t\trfbLog(\""terminal_services: stopping ts services.\\n\"");\n\t\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\t\tint s = socks[i];\n\t\t\t\t\tif (s < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\""terminal_services: closing listen=%d sock=%d.\\n\"", listen[i], socks[i]);\n\t\t\t\t\tif (listen[i] >= 0 && db_netstat) {\n\t\t\t\t\t\tsprintf(dcmd, \""netstat -an | grep -w '%d'\"", listen[i]);\n\t\t\t\t\t\tfprintf(stderr, \""#1 %s\\n\"", dcmd);\n\t\t\t\t\t\tsystem(dcmd);\n\t\t\t\t\t}\n\t\t\t\t\tclose(s);\n\t\t\t\t\tsocks[i] = -1;\n\t\t\t\t\tusleep(2*1000*1000);\n\t\t\t\t\tif (listen[i] >= 0 && db_netstat) {\n\t\t\t\t\t\tfprintf(stderr, \""#2 %s\\n\"", dcmd);\n\t\t\t\t\t\tsystem(dcmd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tusleep(10*1000*1000);\n\n\t\t\t\trfbLog(\""terminal_services: restarting ts services\\n\"");\n\t\t\t\tgoto oh_restart_it_all;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i<TASKMAX; i++) {\n\t\t\tpid_t p = ts_tasks[i];\n\t\t\tif (p > 0) {\n\t\t\t\tint status;\n\t\t\t\tpid_t p2 = waitpid(p, &status, WNOHANG); \n\t\t\t\tif (p2 == p) {\n\t\t\t\t\tts_tasks[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* this is to drop events and exit when X server is gone. */\n\t\told_handler1 = XSetErrorHandler(trap_xerror);\n\t\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\t\ttrapped_xerror = 0;\n\t\ttrapped_xioerror = 0;\n\n\t\tXSync(dpy, True);\n\n\t\tsprintf(num, \""%d\"", (int) time(NULL));\n\t\tat = XInternAtom(dpy, \""TS_REDIR\"", False);\n\t\tif (at != None) {\n\t\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\tif (time(NULL) > last_clean + 20 * 60) {\n\t\t\tint i, j;\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint first = 1;\n\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n""}, {""source"": ""code_info(file:xshm.c, lines:1-600)"", ""result"": ""error code""}, {""source"": ""func_info(file:scan.c, func:initialize_polling_images)"", ""result"": [{""code"": ""void initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \""none\"" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \""scanline\"")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \""Linux\"")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\""warning: fullscreen updates are disabled.\\n\"");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \""fullscreen\"")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\""warning: disabling -snapfb mode.\\n\"");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \""snaprect\"")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \""tile_row\"")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\""shm: Error creating shared memory tile-row for\""\n\t\t\t    \"" len=%d,\\n\"", i);\n\t\t\trfbLog(\""shm: reverting to -onetile mode. If this\""\n\t\t\t    \"" problem persists\\n\"");\n\t\t\trfbLog(\""shm: try using the -onetile or -noshm options\""\n\t\t\t    \"" to limit\\n\"");\n\t\t\trfbLog(\""shm: shared memory usage, or run ipcrm(1)\""\n\t\t\t    \"" to manually\\n\"");\n\t\t\trfbLog(\""shm: delete unattached shm segments.\\n\"");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\""created %d tile_row shm polling images.\\n\"",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\""created %d tile_row polling images.\\n\"",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}\n"", ""start_line"": 423, ""end_line"": 520, ""full_name"": ""initialize_polling_images"", ""file_path"": ""src/scan.c""}]}, {""source"": ""code_info(file:xshm.c, lines:1-600)"", ""result"": ""error code""}, {""source"": ""code_info(file:xshm.c, lines:1-600)"", ""result"": ""error code""}, {""source"": ""code_info(file:xshm.c, lines:1-600)"", ""result"": ""error code""}, {""source"": ""code_info(file:xshm.c, lines:1-600)"", ""result"": ""error code""}]","scan.c:321: `shmget(IPC_PRIVATE, ..., IPC_CREAT | 0777)` allows unrestricted access. Patch changes mode to 0600. `shm_create()` is called in `initialize_polling_images()` (scan.c:423-520) for multiple shared memory segments, inheriting the fixed permission. No other `shmget` calls are visible in the provided context.",0.95,./github/other_context/CVE-2020-29074
38,CVE-2020-36425,CWE-295,c_cpp,"An issue was discovered in Arm Mbed TLS before 2.24.0. It incorrectly uses a revocationDate check when deciding whether to honor certificate revocation via a CRL. In some situations, an attacker can exploit this by changing the local clock.",https://github.com/Mbed-TLS/mbedtls/commit/a4e86141f1451e8097f85a823a4426e1c1cfdf7c,"Always revoke certificate on CRL\n\nRFC5280 does not state that the `revocationDate` should be checked.\n\nIn addition, when no time source is available (i.e., when MBEDTLS_HAVE_TIME_DATE is not defined), `mbedtls_x509_time_is_past` always returns 0. This results in the CRL not being checked at all.\n\nhttps://tools.ietf.org/html/rfc5280\nSigned-off-by: Raoul Strackx <raoul.strackx@fortanix.com>",1,"[{""func_name"": ""mbedtls_x509_crt_is_revoked"", ""file_path"": ""library/x509_crt.c"", ""func_code"": ""int mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )\n{\n    const mbedtls_x509_crl_entry *cur = &crl->entry;\n\n    while( cur != NULL && cur->serial.len != 0 )\n    {\n        if( crt->serial.len == cur->serial.len &&\n            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )\n        {\n            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )\n                return( 1 );\n        }\n\n        cur = cur->next;\n    }\n\n    return( 0 );\n}"", ""target"": 0}]","[{""func_name"": ""mbedtls_x509_crt_is_revoked"", ""file_path"": ""library/x509_crt.c"", ""func_code"": ""int mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )\n{\n    const mbedtls_x509_crl_entry *cur = &crl->entry;\n\n    while( cur != NULL && cur->serial.len != 0 )\n    {\n        if( crt->serial.len == cur->serial.len &&\n            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )\n        {\n            return( 1 );\n        }\n\n        cur = cur->next;\n    }\n\n    return( 0 );\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(func:mbedtls_x509_time_is_past)"", ""result"": [{""code"": ""int mbedtls_x509_time_is_past( const mbedtls_x509_time *to )\n{\n    mbedtls_x509_time now;\n\n    if( x509_get_current_time( &now ) != 0 )\n        return( 1 );\n\n    return( x509_check_time( &now, to ) );\n}"", ""start_line"": 966, ""end_line"": 974, ""full_name"": ""mbedtls_x509_time_is_past"", ""file_path"": ""library/x509.c""}, {""code"": ""int mbedtls_x509_time_is_past( const mbedtls_x509_time *to )\n{\n    ((void) to);\n    return( 0 );\n}"", ""start_line"": 988, ""end_line"": 992, ""full_name"": ""mbedtls_x509_time_is_past<duplicate>0"", ""file_path"": ""library/x509.c""}]}, {""source"": ""code_info(file:x509.c, lines:966-992)"", ""result"": ""int mbedtls_x509_time_is_past( const mbedtls_x509_time *to )\n{\n    mbedtls_x509_time now;\n\n    if( x509_get_current_time( &now ) != 0 )\n        return( 1 );\n\n    return( x509_check_time( &now, to ) );\n}\n\nint mbedtls_x509_time_is_future( const mbedtls_x509_time *from )\n{\n    mbedtls_x509_time now;\n\n    if( x509_get_current_time( &now ) != 0 )\n        return( 1 );\n\n    return( x509_check_time( from, &now ) );\n}\n\n#else  /* MBEDTLS_HAVE_TIME_DATE */\n\nint mbedtls_x509_time_is_past( const mbedtls_x509_time *to )\n{\n    ((void) to);\n    return( 0 );\n}\n""}]","library/x509_crt.c:2325-2327: `mbedtls_x509_crt_is_revoked` calls `mbedtls_x509_time_is_past(&cur->revocation_date)` to check if a certificate is revoked. When `MBEDTLS_HAVE_TIME_DATE` is not defined, the dummy implementation in library/x509.c:988-992 (returning 0) is used, causing the revocation check to fail. This skips CRL validation, allowing revoked certificates to be accepted. The patch removes the revocation date check, making revocation depend solely on serial number matches.",0.95,./github/other_context/CVE-2020-36425
39,CVE-2020-5260,CWE-522,c_cpp,"Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. Git uses external ""credential helper"" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that contain an encoded newline can inject unintended values into the credential helper protocol stream, causing the credential helper to retrieve the password for one server (e.g., good.example.com) for an HTTP request being made to another server (e.g., evil.example.com), resulting in credentials for the former being sent to the latter. There are no restrictions on the relationship between the two, meaning that an attacker can craft a URL that will present stored credentials for any host to a host of their choosing. The vulnerability can be triggered by feeding a malicious URL to git clone. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The problem has been patched in the versions published on April 14th, 2020, going back to v2.17.x. Anyone wishing to backport the change further can do so by applying commit 9a6bbee (the full release includes extra checks for git fsck, but that commit is sufficient to protect clients against the vulnerability). The patched versions are: 2.17.4, 2.18.3, 2.19.4, 2.20.3, 2.21.2, 2.22.3, 2.23.2, 2.24.2, 2.25.3, 2.26.1.",https://github.com/git/git/commit/9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b,"credential: avoid writing values with newlines\n\nThe credential protocol that we use to speak to helpers can't represent\nvalues with newlines in them. This was an intentional design choice to\nkeep the protocol simple, since none of the values we pass should\ngenerally have newlines.\n\nHowever, if we _do_ encounter a newline in a value, we blindly transmit\nit in credential_write(). Such values may break the protocol syntax, or\nworse, inject new valid lines into the protocol stream.\n\nThe most likely way for a newline to end up in a credential struct is by\ndecoding a URL with a percent-encoded newline. However, since the bug\noccurs at the moment we write the value to the protocol, we'll catch it\nthere. That should leave no possibility of accidentally missing a code\npath that can trigger the problem.\n\nAt this level of the code we have little choice but to die(). However,\nsince we'd not ever expect to see this case outside of a malicious URL,\nthat's an acceptable outcome.\n\nReported-by: Felix Wilhelm <fwilhelm@google.com>",1,"[{""func_name"": ""credential_write_item"", ""file_path"": ""credential.c"", ""func_code"": ""static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \""%s=%s\\n\"", key, value);\n}"", ""target"": 0}]","[{""func_name"": ""credential_write_item"", ""file_path"": ""credential.c"", ""func_code"": ""static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\""credential value for %s contains newline\"", key);\n\tfprintf(fp, \""%s=%s\\n\"", key, value);\n}""}]","{""caller"": 1, ""value"": 3, ""function"": 3}","[{""source"": ""caller_info(file:credential.c, func:credential_write_item)"", ""result"": [{""call_line"": 417, ""call_code"": ""credential_write_item(stdout, \""username\"", c->username)"", ""caller_code"": ""static void credential_write(const struct credential *c)\n{\n\t/* only write username/password, if set */\n\tcredential_write_item(stdout, \""username\"", c->username);\n\tcredential_write_item(stdout, \""password\"", c->password);\n}"", ""caller_start"": 414, ""file_path"": ""contrib/credential/gnome-keyring/git-credential-gnome-keyring.c""}, {""call_line"": 418, ""call_code"": ""credential_write_item(stdout, \""password\"", c->password)"", ""caller_code"": ""static void credential_write(const struct credential *c)\n{\n\t/* only write username/password, if set */\n\tcredential_write_item(stdout, \""username\"", c->username);\n\tcredential_write_item(stdout, \""password\"", c->password);\n}"", ""caller_start"": 414, ""file_path"": ""contrib/credential/gnome-keyring/git-credential-gnome-keyring.c""}]}, {""source"": ""value_info(file:credential.c, value:value)"", ""result"": {""value_trace"": [{""full_code"": ""*value = strchr(key, '=')"", ""line"": 150, ""func_name"": ""credential_read<duplicate>1""}, {""full_code"": ""value++"", ""line"": 160, ""func_name"": ""credential_read<duplicate>1""}], ""struct_var"": ""value"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""value_info(file:credential.c, value:c->username)"", ""result"": {""value_trace"": [{""full_code"": ""c->username = xstrdup(value)"", ""line"": 74, ""func_name"": ""credential_config_callback""}, {""full_code"": ""c->username = credential_ask_one(\""Username\"", c,\n\t\t\t\t\t\t PROMPT_ASKPASS|PROMPT_ECHO)"", ""line"": 137, ""func_name"": ""credential_getpass""}, {""full_code"": ""c->username = xstrdup(value)"", ""line"": 164, ""func_name"": ""credential_read<duplicate>1""}, {""full_code"": ""(c->username) = NULL"", ""line"": 317, ""func_name"": ""credential_reject""}], ""struct_var"": ""c"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:credential.c, value:c->password)"", ""result"": {""value_trace"": [{""full_code"": ""c->password = credential_ask_one(\""Password\"", c,\n\t\t\t\t\t\t PROMPT_ASKPASS)"", ""line"": 140, ""func_name"": ""credential_getpass""}, {""full_code"": ""c->password = xstrdup(value)"", ""line"": 167, ""func_name"": ""credential_read<duplicate>1""}, {""full_code"": ""(c->password) = NULL"", ""line"": 318, ""func_name"": ""credential_reject""}, {""full_code"": ""c->password = url_decode_mem(colon + 1, at - (colon + 1))"", ""line"": 353, ""func_name"": ""credential_from_url""}], ""struct_var"": ""c"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:url_decode)"", ""result"": [{""code"": ""char *url_decode(const char *url)\n{\n\treturn url_decode_mem(url, strlen(url));\n}"", ""start_line"": 70, ""end_line"": 73, ""full_name"": ""url_decode"", ""file_path"": ""url.c""}]}, {""source"": ""func_info(file:url.c, func:url_decode_mem)"", ""result"": [{""code"": ""char *url_decode_mem(const char *url, int len)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *colon = memchr(url, ':', len);\n\n\t/* Skip protocol part if present */\n\tif (colon && url < colon) {\n\t\tstrbuf_add(&out, url, colon - url);\n\t\tlen -= colon - url;\n\t\turl = colon;\n\t}\n\treturn url_decode_internal(&url, len, NULL, &out, 0);\n}"", ""start_line"": 75, ""end_line"": 87, ""full_name"": ""url_decode_mem"", ""file_path"": ""url.c""}]}, {""source"": ""func_info(file:url.c, func:url_decode_internal)"", ""result"": [{""code"": ""static char *url_decode_internal(const char **query, int len,\n\t\t\t\t const char *stop_at, struct strbuf *out,\n\t\t\t\t int decode_plus)\n{\n\tconst char *q = *query;\n\n\twhile (len) {\n\t\tunsigned char c = *q;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (stop_at && strchr(stop_at, c)) {\n\t\t\tq++;\n\t\t\tlen--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '%') {\n\t\t\tint val = hex2chr(q + 1);\n\t\t\tif (0 <= val) {\n\t\t\t\tstrbuf_addch(out, val);\n\t\t\t\tq += 3;\n\t\t\t\tlen -= 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (decode_plus && c == '+')\n\t\t\tstrbuf_addch(out, ' ');\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t\tq++;\n\t\tlen--;\n\t}\n\t*query = q;\n\treturn strbuf_detach(out, NULL);\n}"", ""start_line"": 32, ""end_line"": 68, ""full_name"": ""url_decode_internal"", ""file_path"": ""url.c""}]}]","credential.c:409: credential_write_item writes credential values (c->username/password) to the helper protocol without validating newlines. c->password is populated via credential_from_url (credential.c:353) using url_decode_mem (url.c:75-87), which delegates to url_decode_internal (url.c:32-68). url_decode_internal decodes %0A into a newline character via hex2chr. This newline is stored in the credential struct and written to the protocol, causing injection. The patch (credential.c:+409,+410) adds a newline validation check.",0.95,./github/other_context/CVE-2020-5260
40,CVE-2020-7041,CWE-295,c_cpp,An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL 1.0.2 or later. tunnel.c mishandles certificate validation because an X509_check_host negative error code is interpreted as a successful return value.,https://github.com/adrienverge/openfortivpn/commit/60660e00b80bad0fadcf39aee86f6f8756c94f91,correctly check return value of X509_check_host\n\nCVE-2020-7041 incorrect use of X509_check_host (regarding return value)\nis fixed with this commit.\n\nThe flaw came in with #242 and prevented proper host name verification\nwhen openssl >= 1.0.2 was in use since openfortivpn 1.7.0.,1,"[{""func_name"": ""ssl_verify_cert"", ""file_path"": ""src/tunnel.c"", ""func_code"": ""static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\tchar common_name[FIELD_SIZE + 1];\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\""Unable to get gateway certificate.\\n\"");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL))\n\t\tcert_valid = 1;\n#else\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\""Gateway certificate validation succeeded.\\n\"");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\""Gateway certificate validation failed.\\n\"");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\""Could not compute certificate sha256 digest.\\n\"");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \""%02x\"", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\""Gateway certificate digest found in white list.\\n\"");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\"");\n\tlog_error(\""    --trusted-cert %s\\n\"", digest_str);\n\tlog_error(\""or add this line to your config file:\\n\"");\n\tlog_error(\""    trusted-cert = %s\\n\"", digest_str);\n\tlog_error(\""Gateway certificate:\\n\"");\n\tlog_error(\""    subject:\\n\"");\n\tfor (line = strtok(subject, \""/\""); line != NULL;\n\t     line = strtok(NULL, \""/\""))\n\t\tlog_error(\""        %s\\n\"", line);\n\tlog_error(\""    issuer:\\n\"");\n\tfor (line = strtok(issuer, \""/\""); line != NULL;\n\t     line = strtok(NULL, \""/\""))\n\t\tlog_error(\""        %s\\n\"", line);\n\tlog_error(\""    sha256 digest:\\n\"");\n\tlog_error(\""        %s\\n\"", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}"", ""target"": 0}]","[{""func_name"": ""ssl_verify_cert"", ""file_path"": ""src/tunnel.c"", ""func_code"": ""static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\tchar common_name[FIELD_SIZE + 1];\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\""Unable to get gateway certificate.\\n\"");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// correctly check return value of X509_check_host\n\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\""Gateway certificate validation succeeded.\\n\"");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\""Gateway certificate validation failed.\\n\"");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\""Could not compute certificate sha256 digest.\\n\"");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \""%02x\"", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\""Gateway certificate digest found in white list.\\n\"");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\"");\n\tlog_error(\""    --trusted-cert %s\\n\"", digest_str);\n\tlog_error(\""or add this line to your config file:\\n\"");\n\tlog_error(\""    trusted-cert = %s\\n\"", digest_str);\n\tlog_error(\""Gateway certificate:\\n\"");\n\tlog_error(\""    subject:\\n\"");\n\tfor (line = strtok(subject, \""/\""); line != NULL;\n\t     line = strtok(NULL, \""/\""))\n\t\tlog_error(\""        %s\\n\"", line);\n\tlog_error(\""    issuer:\\n\"");\n\tfor (line = strtok(issuer, \""/\""); line != NULL;\n\t     line = strtok(NULL, \""/\""))\n\t\tlog_error(\""        %s\\n\"", line);\n\tlog_error(\""    sha256 digest:\\n\"");\n\tlog_error(\""        %s\\n\"", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}""}]","{""code"": 2}","[{""source"": ""code_info(file:tunnel.c, lines:665-675)"", ""result"": ""\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL))\n\t\tcert_valid = 1;\n#else\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n""}, {""source"": ""code_info(file:tunnel.c, lines:675-700)"", ""result"": ""\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\""Gateway certificate validation succeeded.\\n\"");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\""Gateway certificate validation failed.\\n\"");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\""Could not compute certificate sha256 digest.\\n\"");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \""%02x\"", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n""}]","The vulnerability stems from treating any non-zero return value of X509_check_host as success in `src/tunnel.c:667`. X509_check_host returns 1 for success, 0 for failure, and negative values for errors. The original code incorrectly accepted negative error codes as valid, leading to `cert_valid = 1` being set (src/tunnel.c:667). This flag is then used in `src/tunnel.c:675-700` as part of a condition (`if (cert_valid && SSL_get_verify_result(...) == X509_V_OK)`) to determine certificate validation success. The patch corrects the check to explicitly require a return value of 1, ensuring only valid host matches trigger certificate validation success.",0.95,./github/other_context/CVE-2020-7041
41,CVE-2021-36368,CWE-287,c_cpp,"An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is ""this is not an authentication bypass, since nothing is being bypassed.",https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753,added option to disable trivial auth methods,9,"[{""func_name"": ""userauth_passwd"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tauthctxt->is_trivial_auth = 0;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\""Permission denied, please try again.\"");\n\n\txasprintf(&prompt, \""%s@%s's password: \"", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\t\t\n\treturn 1;\n}"", ""target"": 1}, {""func_name"": ""fill_default_options"", ""file_path"": ""readconf.c"", ""func_code"": ""int\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tchar *def_cipher, *def_mac, *def_kex, *def_key, *def_sig;\n\tint ret = 0, r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 0;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1) {\n\t\toptions->add_keys_to_agent = 0;\n\t\toptions->add_keys_to_agent_lifespan = 0;\n\t}\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n\t\tadd_identity_file(options, \""~/\"",\n\t\t    _PATH_SSH_CLIENT_ID_ECDSA_SK, 0);\n#endif\n\t\tadd_identity_file(options, \""~/\"",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \""~/\"",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519_SK, 0);\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->update_hostkeys == -1) {\n\t\tif (options->verify_host_key_dns <= 0 &&\n\t\t    (options->num_user_hostfiles == 0 ||\n\t\t    (options->num_user_hostfiles == 1 && strcmp(options->\n\t\t    user_hostfiles[0], _PATH_SSH_USER_HOSTFILE) == 0)))\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_YES;\n\t\telse\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_NO;\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n#ifdef ENABLE_SK_INTERNAL\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\""internal\"");\n#else\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\""$SSH_SK_PROVIDER\"");\n#endif\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n\t/* remove unsupported algos from default lists */\n\tdef_cipher = match_filter_allowlist(KEX_CLIENT_ENCRYPT, all_cipher);\n\tdef_mac = match_filter_allowlist(KEX_CLIENT_MAC, all_mac);\n\tdef_kex = match_filter_allowlist(KEX_CLIENT_KEX, all_kex);\n\tdef_key = match_filter_allowlist(KEX_DEFAULT_PK_ALG, all_key);\n\tdef_sig = match_filter_allowlist(SSH_ALLOWED_CA_SIGALGS, all_sig);\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) { \\\n\t\t\terror_fr(r, \""%s\"", #what); \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\tASSEMBLE(ciphers, def_cipher, all_cipher);\n\tASSEMBLE(macs, def_mac, all_mac);\n\tASSEMBLE(kex_algorithms, def_kex, all_kex);\n\tASSEMBLE(hostbased_accepted_algos, def_key, all_key);\n\tASSEMBLE(pubkey_accepted_algos, def_key, all_key);\n\tASSEMBLE(ca_sign_algorithms, def_sig, all_sig);\n#undef ASSEMBLE\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tCLEAR_ON_NONE(options->pkcs11_provider);\n\tCLEAR_ON_NONE(options->sk_provider);\n\tCLEAR_ON_NONE(options->known_hosts_command);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \""none\"") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n\n\t/* success */\n\tret = 0;\n fail:\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\tfree(def_cipher);\n\tfree(def_mac);\n\tfree(def_kex);\n\tfree(def_key);\n\tfree(def_sig);\n\treturn ret;\n}"", ""target"": 2}, {""func_name"": ""dump_client_config"", ""file_path"": ""readconf.c"", ""func_code"": ""void\ndump_client_config(Options *o, const char *host)\n{\n\tint i, r;\n\tchar buf[8], *all_key;\n\n\t/*\n\t * Expand HostKeyAlgorithms name lists. This isn't handled in\n\t * fill_default_options() like the other algorithm lists because\n\t * the host key algorithms are by default dynamically chosen based\n\t * on the host's keys found in known_hosts.\n\t */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&o->hostkeyalgorithms, kex_default_pk_alg(),\n\t    all_key)) != 0)\n\t\tfatal_fr(r, \""expand HostKeyAlgorithms\"");\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostname, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedAcceptedAlgorithms, o->hostbased_accepted_algos);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oSecurityKeyProvider, o->sk_provider);\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedAlgorithms, o->pubkey_accepted_algos);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\tdump_cfg_string(oKnownHostsCommand, o->known_hosts_command);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(oLogVerbose,\n\t    o->num_log_verbose, o->log_verbose);\n\n\t/* Special cases */\n\n\t/* PermitRemoteOpen */\n\tif (o->num_permitted_remote_opens == 0)\n\t\tprintf(\""%s any\\n\"", lookup_opcode_name(oPermitRemoteOpen));\n\telse\n\t\tdump_cfg_strarray_oneline(oPermitRemoteOpen,\n\t\t    o->num_permitted_remote_opens, o->permitted_remote_opens);\n\n\t/* AddKeysToAgent */\n\tif (o->add_keys_to_agent_lifespan <= 0)\n\t\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\telse {\n\t\tprintf(\""addkeystoagent%s %d\\n\"",\n\t\t    o->add_keys_to_agent == 3 ? \"" confirm\"" : \""\"",\n\t\t    o->add_keys_to_agent_lifespan);\n\t}\n\n\t/* oForwardAgent */\n\tif (o->forward_agent_sock_path == NULL)\n\t\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\telse\n\t\tdump_cfg_string(oForwardAgent, o->forward_agent_sock_path);\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\""connecttimeout none\\n\"");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\""tunneldevice\"");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\"" any\"");\n\telse\n\t\tprintf(\"" %d\"", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\"":any\"");\n\telse\n\t\tprintf(\"":%d\"", o->tun_remote);\n\tprintf(\""\\n\"");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\""canonicalizePermittedcnames\"");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\"" %s:%s\"", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\""\\n\"");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\""escapechar none\\n\"");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\""escapechar %s\\n\"", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\""ipqos %s \"", iptos2str(o->ip_qos_interactive));\n\tprintf(\""%s\\n\"", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\""rekeylimit %llu %d\\n\"",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\""streamlocalbindmask 0%o\\n\"",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\""syslogfacility %s\\n\"", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \""1234567890.\"") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \""%d\"", o->jump_port);\n\t\tprintf(\""proxyjump %s%s%s%s%s%s%s%s%s\\n\"",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \""\"" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \""\"" : \"",\"",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \""\"" : o->jump_user,\n\t\t    o->jump_user == NULL ? \""\"" : \""@\"",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \""[\"" : \""\"",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \""]\"" : \""\"",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \""\"" : \"":\"",\n\t\t    o->jump_port <= 0 ? \""\"" : buf);\n\t}\n}"", ""target"": 0}, {""func_name"": ""initialize_options"", ""file_path"": ""readconf.c"", ""func_code"": ""void\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_agent_sock_path = NULL;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\tmemset(options->identity_keys, 0, sizeof(options->identity_keys));\n\toptions->num_certificate_files = 0;\n\tmemset(options->certificates, 0, sizeof(options->certificates));\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->permitted_remote_opens = NULL;\n\toptions->num_permitted_remote_opens = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->num_log_verbose = 0;\n\toptions->log_verbose = NULL;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->sk_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->add_keys_to_agent_lifespan = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_accepted_algos = NULL;\n\toptions->pubkey_accepted_algos = NULL;\n\toptions->known_hosts_command = NULL;\n}"", ""target"": 0}, {""func_name"": ""userauth_passwd"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\""Permission denied, please try again.\"");\n\n\txasprintf(&prompt, \""%s@%s's password: \"", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\n\treturn 1;\n}"", ""target"": 0}, {""func_name"": ""input_userauth_info_req"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\ninput_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *name = NULL, *inst = NULL, *lang = NULL, *prompt = NULL;\n\tchar *display_prompt = NULL, *response = NULL;\n\tu_char echo = 0;\n\tu_int num_prompts, i;\n\tint r;\n\n\tdebug2_f(\""entering\"");\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\""no authentication context\"");\n\n\tauthctxt->info_req_seen = 1;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &inst, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(name) > 0)\n\t\tlogit(\""%s\"", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\""%s\"", inst);\n\n\tif ((r = sshpkt_get_u32(ssh, &num_prompts)) != 0)\n\t\tgoto out;\n\t/*\n\t * Begin to build info response packet based on prompts requested.\n\t * We commit to providing the correct number of responses, so if\n\t * further on we run into a problem that prevents this, we have to\n\t * be sure and clean this up and send a correct error response.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, num_prompts)) != 0)\n\t\tgoto out;\n\n\tdebug2_f(\""num_prompts %d\"", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n\t\t\tgoto out;\n\t\tif (asmprintf(&display_prompt, INT_MAX, NULL, \""(%s@%s) %s\"",\n\t\t    authctxt->server_user, options.host_key_alias ?\n\t\t    options.host_key_alias : authctxt->host, prompt) == -1)\n\t\t\tfatal_f(\""asmprintf failed\"");\n\t\tresponse = read_passphrase(display_prompt, echo ? RP_ECHO : 0);\n\t\tif ((r = sshpkt_put_cstring(ssh, response)) != 0)\n\t\t\tgoto out;\n\t\tfreezero(response, strlen(response));\n\t\tfree(prompt);\n\t\tfree(display_prompt);\n\t\tdisplay_prompt = response = prompt = NULL;\n\t}\n\t/* done with parsing incoming message. */\n\tif ((r = sshpkt_get_end(ssh)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0)\n\t\tgoto out;\n\tr = sshpkt_send(ssh);\n out:\n\tif (response)\n\t\tfreezero(response, strlen(response));\n\tfree(prompt);\n\tfree(display_prompt);\n\tfree(name);\n\tfree(inst);\n\tfree(lang);\n\treturn r;\n}"", ""target"": 0}, {""func_name"": ""userauth_pubkey"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tIdentity *id;\n\tint sent = 0;\n\tchar *ident;\n\n\twhile ((id = TAILQ_FIRST(&authctxt->keys))) {\n\t\tif (id->tried++)\n\t\t\treturn (0);\n\t\t/* move key to the end of the queue */\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tTAILQ_INSERT_TAIL(&authctxt->keys, id, next);\n\t\t/*\n\t\t * send a test message if we have the public key. for\n\t\t * encrypted keys we cannot do this and have to load the\n\t\t * private key instead\n\t\t */\n\t\tif (id->key != NULL) {\n\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\tident = format_identity(id);\n\t\t\t\tdebug(\""Offering public key: %s\"", ident);\n\t\t\t\tfree(ident);\n\t\t\t\tsent = send_pubkey_test(ssh, id);\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\""Trying private key: %s\"", id->filename);\n\t\t\tid->key = load_identity_file(id);\n\t\t\tif (id->key != NULL) {\n\t\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\t\tid->isprivate = 1;\n\t\t\t\t\tsent = sign_and_send_pubkey(ssh, id);\n\t\t\t\t}\n\t\t\t\tsshkey_free(id->key);\n\t\t\t\tid->key = NULL;\n\t\t\t\tid->isprivate = 0;\n\t\t\t}\n\t\t}\n\t\tif (sent)\n\t\t\treturn (sent);\n\t}\n\treturn (0);\n}"", ""target"": 0}, {""func_name"": ""ssh_userauth2"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""void\nssh_userauth2(struct ssh *ssh, const char *local_user,\n    const char *server_user, char *host, Sensitive *sensitive)\n{\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \""ssh-connection\"";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\""none\"");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.attempt_kbdint = 0;\n\tauthctxt.attempt_passwd = 0;\n#if GSSAPI\n\tauthctxt.gss_supported_mechs = NULL;\n\tauthctxt.mech_tried = 0;\n#endif\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL) {\n\t\tfatal_f(\""internal error: cannot send userauth none request\"");\n\t}\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""ssh-userauth\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tpubkey_cleanup(ssh);\n\tssh->authctxt = NULL;\n\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\""Authentication failed.\"");\n\tdebug(\""Authentication succeeded (%s).\"", authctxt.method->name);\n}"", ""target"": 0}, {""func_name"": ""process_gssapi_token"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \""send %u packet\"", type);\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \""send completion\"");\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\""sshbuf_new failed\"");\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \""gssapi-with-mic\"",\n\t\t\t    ssh->kex->session_id);\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal_f(\""sshbuf_mutable_ptr failed\"");\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal_fr(r, \""send MIC\"");\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}"", ""target"": 0}]","[{""func_name"": ""userauth_passwd"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tauthctxt->is_trivial_auth = 0;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\""Permission denied, please try again.\"");\n\n\txasprintf(&prompt, \""%s@%s's password: \"", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\treturn 1;\n}""}, {""func_name"": ""fill_default_options"", ""file_path"": ""readconf.c"", ""func_code"": ""int\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tchar *def_cipher, *def_mac, *def_kex, *def_key, *def_sig;\n\tint ret = 0, r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->disable_trivial_auth == -1)\n\t\toptions->disable_trivial_auth = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 0;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1) {\n\t\toptions->add_keys_to_agent = 0;\n\t\toptions->add_keys_to_agent_lifespan = 0;\n\t}\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n\t\tadd_identity_file(options, \""~/\"",\n\t\t    _PATH_SSH_CLIENT_ID_ECDSA_SK, 0);\n#endif\n\t\tadd_identity_file(options, \""~/\"",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \""~/\"",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519_SK, 0);\n\t\tadd_identity_file(options, \""~/\"", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->update_hostkeys == -1) {\n\t\tif (options->verify_host_key_dns <= 0 &&\n\t\t    (options->num_user_hostfiles == 0 ||\n\t\t    (options->num_user_hostfiles == 1 && strcmp(options->\n\t\t    user_hostfiles[0], _PATH_SSH_USER_HOSTFILE) == 0)))\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_YES;\n\t\telse\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_NO;\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n#ifdef ENABLE_SK_INTERNAL\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\""internal\"");\n#else\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\""$SSH_SK_PROVIDER\"");\n#endif\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n\t/* remove unsupported algos from default lists */\n\tdef_cipher = match_filter_allowlist(KEX_CLIENT_ENCRYPT, all_cipher);\n\tdef_mac = match_filter_allowlist(KEX_CLIENT_MAC, all_mac);\n\tdef_kex = match_filter_allowlist(KEX_CLIENT_KEX, all_kex);\n\tdef_key = match_filter_allowlist(KEX_DEFAULT_PK_ALG, all_key);\n\tdef_sig = match_filter_allowlist(SSH_ALLOWED_CA_SIGALGS, all_sig);\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) { \\\n\t\t\terror_fr(r, \""%s\"", #what); \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\tASSEMBLE(ciphers, def_cipher, all_cipher);\n\tASSEMBLE(macs, def_mac, all_mac);\n\tASSEMBLE(kex_algorithms, def_kex, all_kex);\n\tASSEMBLE(hostbased_accepted_algos, def_key, all_key);\n\tASSEMBLE(pubkey_accepted_algos, def_key, all_key);\n\tASSEMBLE(ca_sign_algorithms, def_sig, all_sig);\n#undef ASSEMBLE\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tCLEAR_ON_NONE(options->pkcs11_provider);\n\tCLEAR_ON_NONE(options->sk_provider);\n\tCLEAR_ON_NONE(options->known_hosts_command);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \""none\"") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n\n\t/* success */\n\tret = 0;\n fail:\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\tfree(def_cipher);\n\tfree(def_mac);\n\tfree(def_kex);\n\tfree(def_key);\n\tfree(def_sig);\n\treturn ret;\n}""}, {""func_name"": ""dump_client_config"", ""file_path"": ""readconf.c"", ""func_code"": ""void\ndump_client_config(Options *o, const char *host)\n{\n\tint i, r;\n\tchar buf[8], *all_key;\n\n\t/*\n\t * Expand HostKeyAlgorithms name lists. This isn't handled in\n\t * fill_default_options() like the other algorithm lists because\n\t * the host key algorithms are by default dynamically chosen based\n\t * on the host's keys found in known_hosts.\n\t */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&o->hostkeyalgorithms, kex_default_pk_alg(),\n\t    all_key)) != 0)\n\t\tfatal_fr(r, \""expand HostKeyAlgorithms\"");\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostname, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oDisableTrivialAuth, o->disable_trivial_auth);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedAcceptedAlgorithms, o->hostbased_accepted_algos);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oSecurityKeyProvider, o->sk_provider);\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedAlgorithms, o->pubkey_accepted_algos);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\tdump_cfg_string(oKnownHostsCommand, o->known_hosts_command);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(oLogVerbose,\n\t    o->num_log_verbose, o->log_verbose);\n\n\t/* Special cases */\n\n\t/* PermitRemoteOpen */\n\tif (o->num_permitted_remote_opens == 0)\n\t\tprintf(\""%s any\\n\"", lookup_opcode_name(oPermitRemoteOpen));\n\telse\n\t\tdump_cfg_strarray_oneline(oPermitRemoteOpen,\n\t\t    o->num_permitted_remote_opens, o->permitted_remote_opens);\n\n\t/* AddKeysToAgent */\n\tif (o->add_keys_to_agent_lifespan <= 0)\n\t\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\telse {\n\t\tprintf(\""addkeystoagent%s %d\\n\"",\n\t\t    o->add_keys_to_agent == 3 ? \"" confirm\"" : \""\"",\n\t\t    o->add_keys_to_agent_lifespan);\n\t}\n\n\t/* oForwardAgent */\n\tif (o->forward_agent_sock_path == NULL)\n\t\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\telse\n\t\tdump_cfg_string(oForwardAgent, o->forward_agent_sock_path);\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\""connecttimeout none\\n\"");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\""tunneldevice\"");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\"" any\"");\n\telse\n\t\tprintf(\"" %d\"", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\"":any\"");\n\telse\n\t\tprintf(\"":%d\"", o->tun_remote);\n\tprintf(\""\\n\"");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\""canonicalizePermittedcnames\"");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\"" %s:%s\"", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\""\\n\"");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\""escapechar none\\n\"");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\""escapechar %s\\n\"", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\""ipqos %s \"", iptos2str(o->ip_qos_interactive));\n\tprintf(\""%s\\n\"", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\""rekeylimit %llu %d\\n\"",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\""streamlocalbindmask 0%o\\n\"",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\""syslogfacility %s\\n\"", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \""1234567890.\"") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \""%d\"", o->jump_port);\n\t\tprintf(\""proxyjump %s%s%s%s%s%s%s%s%s\\n\"",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \""\"" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \""\"" : \"",\"",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \""\"" : o->jump_user,\n\t\t    o->jump_user == NULL ? \""\"" : \""@\"",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \""[\"" : \""\"",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \""]\"" : \""\"",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \""\"" : \"":\"",\n\t\t    o->jump_port <= 0 ? \""\"" : buf);\n\t}\n}""}, {""func_name"": ""initialize_options"", ""file_path"": ""readconf.c"", ""func_code"": ""void\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_agent_sock_path = NULL;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->disable_trivial_auth = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\tmemset(options->identity_keys, 0, sizeof(options->identity_keys));\n\toptions->num_certificate_files = 0;\n\tmemset(options->certificates, 0, sizeof(options->certificates));\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->permitted_remote_opens = NULL;\n\toptions->num_permitted_remote_opens = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->num_log_verbose = 0;\n\toptions->log_verbose = NULL;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->sk_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->add_keys_to_agent_lifespan = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_accepted_algos = NULL;\n\toptions->pubkey_accepted_algos = NULL;\n\toptions->known_hosts_command = NULL;\n}""}, {""func_name"": ""userauth_passwd"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tauthctxt->is_trivial_auth = 0;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\""Permission denied, please try again.\"");\n\n\txasprintf(&prompt, \""%s@%s's password: \"", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\t\t\n\treturn 1;\n}""}, {""func_name"": ""input_userauth_info_req"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\ninput_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *name = NULL, *inst = NULL, *lang = NULL, *prompt = NULL;\n\tchar *display_prompt = NULL, *response = NULL;\n\tu_char echo = 0;\n\tu_int num_prompts, i;\n\tint r;\n\n\tdebug2_f(\""entering\"");\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\""no authentication context\"");\n\n\tauthctxt->info_req_seen = 1;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &inst, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(name) > 0)\n\t\tlogit(\""%s\"", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\""%s\"", inst);\n\n\tif ((r = sshpkt_get_u32(ssh, &num_prompts)) != 0)\n\t\tgoto out;\n\t/*\n\t * Begin to build info response packet based on prompts requested.\n\t * We commit to providing the correct number of responses, so if\n\t * further on we run into a problem that prevents this, we have to\n\t * be sure and clean this up and send a correct error response.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, num_prompts)) != 0)\n\t\tgoto out;\n\n\tdebug2_f(\""num_prompts %d\"", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tauthctxt->is_trivial_auth = 0;\n\t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n\t\t\tgoto out;\n\t\tif (asmprintf(&display_prompt, INT_MAX, NULL, \""(%s@%s) %s\"",\n\t\t    authctxt->server_user, options.host_key_alias ?\n\t\t    options.host_key_alias : authctxt->host, prompt) == -1)\n\t\t\tfatal_f(\""asmprintf failed\"");\n\t\tresponse = read_passphrase(display_prompt, echo ? RP_ECHO : 0);\n\t\tif ((r = sshpkt_put_cstring(ssh, response)) != 0)\n\t\t\tgoto out;\n\t\tfreezero(response, strlen(response));\n\t\tfree(prompt);\n\t\tfree(display_prompt);\n\t\tdisplay_prompt = response = prompt = NULL;\n\t}\n\t/* done with parsing incoming message. */\n\tif ((r = sshpkt_get_end(ssh)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0)\n\t\tgoto out;\n\tr = sshpkt_send(ssh);\n out:\n\tif (response)\n\t\tfreezero(response, strlen(response));\n\tfree(prompt);\n\tfree(display_prompt);\n\tfree(name);\n\tfree(inst);\n\tfree(lang);\n\treturn r;\n}""}, {""func_name"": ""userauth_pubkey"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tIdentity *id;\n\tint sent = 0;\n\tchar *ident;\n\n\twhile ((id = TAILQ_FIRST(&authctxt->keys))) {\n\t\tif (id->tried++)\n\t\t\treturn (0);\n\t\t/* move key to the end of the queue */\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tTAILQ_INSERT_TAIL(&authctxt->keys, id, next);\n\t\t/*\n\t\t * send a test message if we have the public key. for\n\t\t * encrypted keys we cannot do this and have to load the\n\t\t * private key instead\n\t\t */\n\t\tif (id->key != NULL) {\n\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\tident = format_identity(id);\n\t\t\t\tdebug(\""Offering public key: %s\"", ident);\n\t\t\t\tfree(ident);\n\t\t\t\tsent = send_pubkey_test(ssh, id);\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\""Trying private key: %s\"", id->filename);\n\t\t\tid->key = load_identity_file(id);\n\t\t\tif (id->key != NULL) {\n\t\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\t\tid->isprivate = 1;\n\t\t\t\t\tsent = sign_and_send_pubkey(ssh, id);\n\t\t\t\t}\n\t\t\t\tsshkey_free(id->key);\n\t\t\t\tid->key = NULL;\n\t\t\t\tid->isprivate = 0;\n\t\t\t}\n\t\t}\n\t\tif (sent) {\n\t\t\tauthctxt->is_trivial_auth = 0;\n\t\t\treturn (sent);\n\t\t}\n\t}\n\treturn (0);\n}""}, {""func_name"": ""ssh_userauth2"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""void\nssh_userauth2(struct ssh *ssh, const char *local_user,\n    const char *server_user, char *host, Sensitive *sensitive)\n{\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\t\n\tauthctxt.is_trivial_auth = 1;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \""ssh-connection\"";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\""none\"");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.attempt_kbdint = 0;\n\tauthctxt.attempt_passwd = 0;\n#if GSSAPI\n\tauthctxt.gss_supported_mechs = NULL;\n\tauthctxt.mech_tried = 0;\n#endif\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL) {\n\t\tfatal_f(\""internal error: cannot send userauth none request\"");\n\t}\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""ssh-userauth\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tpubkey_cleanup(ssh);\n\tssh->authctxt = NULL;\n\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\""Authentication failed.\"");\n\tif (authctxt.is_trivial_auth == 1 && options.disable_trivial_auth == 1) {\n\t\tfatal(\""Trivial authentication disabled.\"");\n\t}\n\tdebug(\""Authentication succeeded (%s).\"", authctxt.method->name);\n}""}, {""func_name"": ""process_gssapi_token"", ""file_path"": ""sshconnect2.c"", ""func_code"": ""static OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \""send %u packet\"", type);\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t\tauthctxt->is_trivial_auth = 0;\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \""send completion\"");\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\""sshbuf_new failed\"");\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \""gssapi-with-mic\"",\n\t\t\t    ssh->kex->session_id);\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal_f(\""sshbuf_mutable_ptr failed\"");\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal_fr(r, \""send MIC\"");\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(file:sshconnect2.c, func:userauth_none)"", ""result"": [{""code"": ""static int\nuserauth_none(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tint r;\n\n\t/* initial userauth request */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n\treturn 1;\n}"", ""start_line"": 1042, ""end_line"": 1056, ""full_name"": ""userauth_none<duplicate>0"", ""file_path"": ""sshconnect2.c""}]}, {""source"": ""value_info(file:sshconnect2.c, value:is_trivial_auth)"", ""result"": {""value_trace"": [{""full_code"": ""authctxt.is_trivial_auth = 1"", ""line"": 454, ""func_name"": ""ssh_userauth2""}, {""full_code"": ""authctxt->is_trivial_auth = 0"", ""line"": 1062, ""func_name"": ""userauth_passwd<duplicate>0""}, {""full_code"": ""authctxt->is_trivial_auth = 0"", ""line"": 1874, ""func_name"": ""userauth_pubkey<duplicate>0""}, {""full_code"": ""authctxt->is_trivial_auth = 0"", ""line"": 1957, ""func_name"": ""input_userauth_info_req""}], ""struct_var"": ""is_trivial_auth"", ""struct_type"": null, ""struct_definition"": null}}]","The 'userauth_none' function (sshconnect2.c:1042-1056) does not set 'is_trivial_auth' on the 'authctxt' struct. The 'is_trivial_auth' flag is initialized to 1 in 'ssh_userauth2' (sshconnect2.c:454) and remains 1 during 'None' authentication. If 'disable_trivial_auth' is not enabled, the check in 'ssh_userauth2' (sshconnect2.c:492) is bypassed, allowing 'None' authentication to proceed without user awareness. This enables an attacker-controlled server to exploit agent forwarding without the client detecting the use of trivial authentication.",0.95,./github/other_context/CVE-2021-36368
42,CVE-2021-4300,CWE-284,c_cpp,A vulnerability has been found in ghostlander Halcyon and classified as critical. Affected by this vulnerability is the function CBlock::AddToBlockIndex of the file src/main.cpp of the component Block Verification. The manipulation leads to improper access controls. The attack can be launched remotely. Upgrading to version 1.1.1.0-hal is able to address this issue. The identifier of the patch is 0675b25ae9cc10b5fdc8ea3a32c642979762d45e. It is recommended to upgrade the affected component. The identifier VDB-217417 was assigned to this vulnerability.,https://github.com/ghostlander/Halcyon/commit/0675b25ae9cc10b5fdc8ea3a32c642979762d45e,Block Verification Vulnerability Eliminated\n\nFixed a critical vulnerability allowing to accept a proof-of-work block\ncontaining one or more coin stake transactions in addition to a valid\ncoin base. Output values of such coin stakes were out of control.,1,"[{""func_name"": ""CBlock::CheckBlock"", ""file_path"": ""src/main.cpp"", ""func_code"": ""bool CBlock::CheckBlock() const {\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\""CheckBlock() : size limits failed\""));\n\n    if(IsProofOfWork()) {\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\""CheckBlock() : proof-of-work verification failed\"")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\""CheckBlock() : bad proof-of-work block signature\"")));\n    }\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\""CheckBlock() : block timestamp too far in the future\"");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\""CheckBlock() : first tx is not coinbase\""));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\""CheckBlock() : more than one coinbase\""));\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\""CheckBlock() : coinbase timestamp is too early\""));\n\n    if (IsProofOfStake())\n    {\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\""CheckBlock() : coinbase output not empty for proof-of-stake block\""));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\""CheckBlock() : second tx is not coinstake\""));\n        for (unsigned int i = 2; i < vtx.size(); i++)\n            if (vtx[i].IsCoinStake())\n                return DoS(100, error(\""CheckBlock() : more than one coinstake\""));\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\""CheckBlock() : coinstake timestamp violation nTimeBlock=%\""PRId64\"" nTimeTx=%u\"", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\""CheckBlock() : bad proof-of-stake block signature\""));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\""CheckBlock() : CheckTransaction failed\""));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\""CheckBlock() : block timestamp earlier than transaction timestamp\""));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\""CheckBlock() : merkle root verification failed\"")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\""CheckBlock() : duplicate transaction found\"")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\""CheckBlock() : out-of-bounds SigOpCount\""));\n\n    return(true);\n}"", ""target"": 0}]","[{""func_name"": ""CBlock::CheckBlock"", ""file_path"": ""src/main.cpp"", ""func_code"": ""bool CBlock::CheckBlock() const {\n    uint i;\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\""CheckBlock() : size limits failed\""));\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\""CheckBlock() : block timestamp too far in the future\"");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\""CheckBlock() : first tx is not coinbase\""));\n    for(i = 1; i < vtx.size(); i++) {\n        if(vtx[i].IsCoinBase())\n          return(DoS(100, error(\""CheckBlock() : more than one coin base\"")));\n    }\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\""CheckBlock() : coinbase timestamp is too early\""));\n\n    if(IsProofOfStake()) {\n\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\""CheckBlock() : coinbase output not empty for proof-of-stake block\""));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\""CheckBlock() : second tx is not coinstake\""));\n        for(i = 2; i < vtx.size(); i++) {\n            if(vtx[i].IsCoinStake())\n              return(DoS(100, error(\""CheckBlock() : more than one coin stake\"")));\n        }\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\""CheckBlock() : coinstake timestamp violation nTimeBlock=%\""PRId64\"" nTimeTx=%u\"", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\""CheckBlock() : bad proof-of-stake block signature\""));\n\n    } else {\n\n        /* No coin stakes in PoW blocks */\n        for(i = 1; i < vtx.size(); i++) {\n            if(vtx[i].IsCoinStake() && (vtx[i].nTime > 1626307200))\n              return(DoS(100, error(\""CheckBlock() : rogue coin stake\"")));\n        }\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\""CheckBlock() : proof-of-work verification failed\"")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\""CheckBlock() : bad proof-of-work block signature\"")));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\""CheckBlock() : CheckTransaction failed\""));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\""CheckBlock() : block timestamp earlier than transaction timestamp\""));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\""CheckBlock() : merkle root verification failed\"")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\""CheckBlock() : duplicate transaction found\"")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\""CheckBlock() : out-of-bounds SigOpCount\""));\n\n    return(true);\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(file:main.cpp, func:CheckBlock)"", ""result"": [{""call_line"": 2444, ""call_code"": ""pblock->CheckBlock()"", ""caller_code"": ""bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\""ProcessBlock() : already have block %d %s\"", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\""ProcessBlock() : already have block (orphan) %s\"", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\""ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\"", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\""ProcessBlock() : CheckBlock FAILED\"");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\""ProcessBlock: ORPHAN BLOCK, prev=%s\\n\"", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\""ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\"", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\""ProcessBlock() : AcceptBlock FAILED\"");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\""ProcessBlock: ACCEPTED\\n\"");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}\n"", ""caller_start"": 2428, ""file_path"": ""src/main.cpp""}, {""call_line"": 464, ""call_code"": ""block.CheckBlock()"", ""caller_code"": ""bool CTxDB::LoadBlockIndex()\n{\n    if (mapBlockIndex.size() > 0) {\n        // Already loaded once in this session. It can happen during migration\n        // from BDB.\n        return true;\n    }\n    // The block index is an in-memory structure that maps hashes to on-disk\n    // locations where the contents of the block can be found. Here, we scan it\n    // out of the DB and into mapBlockIndex.\n    leveldb::Iterator *iterator = pdb->NewIterator(leveldb::ReadOptions());\n    // Seek to start key.\n    CDataStream ssStartKey(SER_DISK, CLIENT_VERSION);\n    ssStartKey << make_pair(string(\""blockindex\""), uint256(0));\n    iterator->Seek(ssStartKey.str());\n    // Now read each entry.\n    while (iterator->Valid())\n    {\n        // Unpack keys and values.\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.write(iterator->key().data(), iterator->key().size());\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.write(iterator->value().data(), iterator->value().size());\n        string strType;\n        ssKey >> strType;\n        // Did we reach the end of the data to read?\n        if (fRequestShutdown || strType != \""blockindex\"")\n            break;\n        CDiskBlockIndex diskindex;\n        ssValue >> diskindex;\n\n        uint256 blockHash = diskindex.GetBlockHash();\n\n        // Construct block index object\n        CBlockIndex* pindexNew    = InsertBlockIndex(blockHash);\n        pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n        pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n        pindexNew->nFile          = diskindex.nFile;\n        pindexNew->nBlockPos      = diskindex.nBlockPos;\n        pindexNew->nHeight        = diskindex.nHeight;\n        pindexNew->nMint          = diskindex.nMint;\n        pindexNew->nMoneySupply   = diskindex.nMoneySupply;\n        pindexNew->nFlags         = diskindex.nFlags;\n        pindexNew->nStakeModifier = diskindex.nStakeModifier;\n        pindexNew->prevoutStake   = diskindex.prevoutStake;\n        pindexNew->nStakeTime     = diskindex.nStakeTime;\n        pindexNew->hashProofOfStake = diskindex.hashProofOfStake;\n        pindexNew->nVersion       = diskindex.nVersion;\n        pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n        pindexNew->nTime          = diskindex.nTime;\n        pindexNew->nBits          = diskindex.nBits;\n        pindexNew->nNonce         = diskindex.nNonce;\n\n        // Watch for genesis block\n        if (pindexGenesisBlock == NULL && blockHash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n            pindexGenesisBlock = pindexNew;\n\n        if (!pindexNew->CheckIndex()) {\n            delete iterator;\n            return error(\""LoadBlockIndex() : CheckIndex failed at %d\"", pindexNew->nHeight);\n        }\n\n        // NovaCoin: build setStakeSeen\n        if (pindexNew->IsProofOfStake())\n            setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n\n        iterator->Next();\n    }\n    delete iterator;\n\n    if (fRequestShutdown)\n        return true;\n\n    // Calculate nChainTrust\n    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n    vSortedByHeight.reserve(mapBlockIndex.size());\n    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n    {\n        CBlockIndex* pindex = item.second;\n        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n    }\n    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n    {\n        CBlockIndex* pindex = item.second;\n        pindex->nChainTrust = (pindex->pprev ? pindex->pprev->nChainTrust : 0) + pindex->GetBlockTrust();\n        // NovaCoin: calculate stake modifier checksum\n        pindex->nStakeModifierChecksum = GetStakeModifierChecksum(pindex);\n        if (!CheckStakeModifierCheckpoints(pindex->nHeight, pindex->nStakeModifierChecksum))\n            return error(\""CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\""PRIx64, pindex->nHeight, pindex->nStakeModifier);\n    }\n\n    // Load hashBestChain pointer to end of best chain\n    if (!ReadHashBestChain(hashBestChain))\n    {\n        if (pindexGenesisBlock == NULL)\n            return true;\n        return error(\""CTxDB::LoadBlockIndex() : hashBestChain not loaded\"");\n    }\n    if (!mapBlockIndex.count(hashBestChain))\n        return error(\""CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\"");\n    pindexBest = mapBlockIndex[hashBestChain];\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexBest->nChainTrust;\n\n    printf(\""LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\"",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, CBigNum(nBestChainTrust).ToString().c_str(),\n      DateTimeStrFormat(\""%x %H:%M:%S\"", pindexBest->GetBlockTime()).c_str());\n\n    // NovaCoin: load hashSyncCheckpoint\n    if (!ReadSyncCheckpoint(Checkpoints::hashSyncCheckpoint))\n        return error(\""CTxDB::LoadBlockIndex() : hashSyncCheckpoint not loaded\"");\n    printf(\""LoadBlockIndex(): synchronized checkpoint %s\\n\"", Checkpoints::hashSyncCheckpoint.ToString().c_str());\n\n    // Load bnBestInvalidTrust, OK if it doesn't exist\n    CBigNum bnBestInvalidTrust;\n    ReadBestInvalidTrust(bnBestInvalidTrust);\n    nBestInvalidTrust = bnBestInvalidTrust.getuint256();\n\n    // Verify blocks in the best chain\n    int nCheckLevel = GetArg(\""-checklevel\"", 1);\n    int nCheckDepth = GetArg( \""-checkblocks\"", 500);\n    if (nCheckDepth == 0)\n        nCheckDepth = 1000000000; // suffices until the year 19000\n    if (nCheckDepth > nBestHeight)\n        nCheckDepth = nBestHeight;\n    printf(\""Verifying last %i blocks at level %i\\n\"", nCheckDepth, nCheckLevel);\n    CBlockIndex* pindexFork = NULL;\n    map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n    {\n        if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n            break;\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\""LoadBlockIndex() : block.ReadFromDisk failed\"");\n        // check level 1: verify block validity\n        if((nCheckLevel > 0) && !block.CheckBlock()) {\n            printf(\""LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\"", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n            pindexFork = pindex->pprev;\n        }\n        // check level 2: verify transaction index validity\n        if (nCheckLevel>1)\n        {\n            pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n            mapBlockPos[pos] = pindex;\n            BOOST_FOREACH(const CTransaction &tx, block.vtx)\n            {\n                uint256 hashTx = tx.GetHash();\n                CTxIndex txindex;\n                if (ReadTxIndex(hashTx, txindex))\n                {\n                    // check level 3: checker transaction hashes\n                    if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                    {\n                        // either an error or a duplicate transaction\n                        CTransaction txFound;\n                        if (!txFound.ReadFromDisk(txindex.pos))\n                        {\n                            printf(\""LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\"", hashTx.ToString().c_str());\n                            pindexFork = pindex->pprev;\n                        }\n                        else\n                            if (txFound.GetHash() != hashTx) // not a duplicate tx\n                            {\n                                printf(\""LoadBlockIndex(): *** invalid tx position for %s\\n\"", hashTx.ToString().c_str());\n                                pindexFork = pindex->pprev;\n                            }\n                    }\n                    // check level 4: check whether spent txouts were spent within the main chain\n                    unsigned int nOutput = 0;\n                    if (nCheckLevel>3)\n                    {\n                        BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n                        {\n                            if (!txpos.IsNull())\n                            {\n                                pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n                                if (!mapBlockPos.count(posFind))\n                                {\n                                    printf(\""LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\"", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                    pindexFork = pindex->pprev;\n                                }\n                                // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                if (nCheckLevel>5)\n                                {\n                                    CTransaction txSpend;\n                                    if (!txSpend.ReadFromDisk(txpos))\n                                    {\n                                        printf(\""LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\"", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else if (!txSpend.CheckTransaction())\n                                    {\n                                        printf(\""LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\"", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else\n                                    {\n                                        bool fFound = false;\n                                        BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n                                            if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n                                                fFound = true;\n                                        if (!fFound)\n                                        {\n                                            printf(\""LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\"", hashTx.ToString().c_str(), nOutput);\n                                            pindexFork = pindex->pprev;\n                                        }\n                                    }\n                                }\n                            }\n                            nOutput++;\n                        }\n                    }\n                }\n                // check level 5: check whether all prevouts are marked spent\n                if (nCheckLevel>4)\n                {\n                     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n                     {\n                          CTxIndex txindex;\n                          if (ReadTxIndex(txin.prevout.hash, txindex))\n                              if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n                              {\n                                  printf(\""LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\"", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n                                  pindexFork = pindex->pprev;\n                              }\n                     }\n                }\n            }\n        }\n    }\n    if (pindexFork && !fRequestShutdown)\n    {\n        // Reorg back to the fork\n        printf(\""LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\"", pindexFork->nHeight);\n        CBlock block;\n        if (!block.ReadFromDisk(pindexFork))\n            return error(\""LoadBlockIndex() : block.ReadFromDisk failed\"");\n        CTxDB txdb;\n        block.SetBestChain(txdb, pindexFork);\n    }\n\n    return true;\n}\n"", ""caller_start"": 327, ""file_path"": ""src/txdb-leveldb.cpp""}]}]","src/main.cpp:2162-2167 (patched check for PoW blocks rejecting coin stake transactions)  src/main.cpp:2444 (ProcessBlock calls CheckBlock during block processing)  src/txdb-leveldb.cpp:464 (LoadBlockIndex calls CheckBlock during block index validation). The vulnerability stemmed from missing validation in PoW blocks before the patch allowed coin stake transactions, leading to improper access controls.",0.95,./github/other_context/CVE-2021-4300
43,CVE-2021-43820,CWE-639,c_cpp,"Seafile is an open source cloud storage system. A sync token is used in Seafile file syncing protocol to authorize access to library data. To improve performance, the token is cached in memory in seaf-server. Upon receiving a token from sync client or SeaDrive client, the server checks whether the token exist in the cache. However, if the token exists in cache, the server doesn't check whether it's associated with the specific library in the URL. This vulnerability makes it possible to use any valid sync token to access data from any **known** library. Note that the attacker has to first find out the ID of a library which it has no access to. The library ID is a random UUID, which is not possible to be guessed. There are no workarounds for this issue.",https://github.com/haiwen/seafile-server/commit/c7c38c129fb8cee5ee14f44982283f4527133dcf,Validate repo_id when validate token from cache,1,"[{""func_name"": ""validate_token"", ""file_path"": ""server/http-server.c"", ""func_code"": ""static int\nvalidate_token (HttpServer *htp_server, evhtp_request_t *req,\n                const char *repo_id, char **username,\n                gboolean skip_cache)\n{\n    char *email = NULL;\n    TokenInfo *token_info;\n\n    const char *token = evhtp_kv_find (req->headers_in, \""Seafile-Repo-Token\"");\n    if (token == NULL) {\n        evhtp_send_reply (req, EVHTP_RES_BADREQ);\n        return EVHTP_RES_BADREQ;\n    }\n\n    if (!skip_cache) {\n        pthread_mutex_lock (&htp_server->token_cache_lock);\n\n        token_info = g_hash_table_lookup (htp_server->token_cache, token);\n        if (token_info) {\n            if (username)\n                *username = g_strdup(token_info->email);\n            pthread_mutex_unlock (&htp_server->token_cache_lock);\n            return EVHTP_RES_OK;\n        }\n\n        pthread_mutex_unlock (&htp_server->token_cache_lock);\n    }\n\n    email = seaf_repo_manager_get_email_by_token (seaf->repo_mgr,\n                                                  repo_id, token);\n    if (email == NULL) {\n        pthread_mutex_lock (&htp_server->token_cache_lock);\n        g_hash_table_remove (htp_server->token_cache, token);\n        pthread_mutex_unlock (&htp_server->token_cache_lock);\n        return EVHTP_RES_FORBIDDEN;\n    }\n\n    token_info = g_new0 (TokenInfo, 1);\n    token_info->repo_id = g_strdup (repo_id);\n    token_info->expire_time = (gint64)time(NULL) + TOKEN_EXPIRE_TIME;\n    token_info->email = email;\n\n    pthread_mutex_lock (&htp_server->token_cache_lock);\n    g_hash_table_insert (htp_server->token_cache, g_strdup (token), token_info);\n    pthread_mutex_unlock (&htp_server->token_cache_lock);\n\n    if (username)\n        *username = g_strdup(email);\n    return EVHTP_RES_OK;\n}"", ""target"": 0}]","[{""func_name"": ""validate_token"", ""file_path"": ""server/http-server.c"", ""func_code"": ""static int\nvalidate_token (HttpServer *htp_server, evhtp_request_t *req,\n                const char *repo_id, char **username,\n                gboolean skip_cache)\n{\n    char *email = NULL;\n    TokenInfo *token_info;\n\n    const char *token = evhtp_kv_find (req->headers_in, \""Seafile-Repo-Token\"");\n    if (token == NULL) {\n        evhtp_send_reply (req, EVHTP_RES_BADREQ);\n        return EVHTP_RES_BADREQ;\n    }\n\n    if (!skip_cache) {\n        pthread_mutex_lock (&htp_server->token_cache_lock);\n\n        token_info = g_hash_table_lookup (htp_server->token_cache, token);\n        if (token_info && strcmp (token_info->repo_id, repo_id) == 0) {\n            if (username)\n                *username = g_strdup(token_info->email);\n            pthread_mutex_unlock (&htp_server->token_cache_lock);\n            return EVHTP_RES_OK;\n        }\n\n        pthread_mutex_unlock (&htp_server->token_cache_lock);\n    }\n\n    email = seaf_repo_manager_get_email_by_token (seaf->repo_mgr,\n                                                  repo_id, token);\n    if (email == NULL) {\n        pthread_mutex_lock (&htp_server->token_cache_lock);\n        g_hash_table_remove (htp_server->token_cache, token);\n        pthread_mutex_unlock (&htp_server->token_cache_lock);\n        return EVHTP_RES_FORBIDDEN;\n    }\n\n    token_info = g_new0 (TokenInfo, 1);\n    token_info->repo_id = g_strdup (repo_id);\n    token_info->expire_time = (gint64)time(NULL) + TOKEN_EXPIRE_TIME;\n    token_info->email = email;\n\n    pthread_mutex_lock (&htp_server->token_cache_lock);\n    g_hash_table_insert (htp_server->token_cache, g_strdup (token), token_info);\n    pthread_mutex_unlock (&htp_server->token_cache_lock);\n\n    if (username)\n        *username = g_strdup(email);\n    return EVHTP_RES_OK;\n}""}]","{""value"": 3}","[{""source"": ""value_info(file:http-server.c, value:repo_id)"", ""result"": {""value_trace"": [{""full_code"": ""*repo_id = seaf_db_row_get_column_text (row, 0)"", ""line"": 421, ""func_name"": ""get_vir_repo_info""}, {""full_code"": ""*repo_id = parts[1]"", ""line"": 708, ""func_name"": ""get_check_permission_cb""}, {""full_code"": ""*repo_id = parts[1]"", ""line"": 801, ""func_name"": ""get_check_quota_cb""}, {""full_code"": ""*repo_id = parts[1]"", ""line"": 859, ""func_name"": ""get_head_commit_cb""}, {""full_code"": ""repo_id = parts[1]"", ""line"": 1076, ""func_name"": ""put_update_branch_cb""}], ""struct_var"": ""repo_id"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""value_info(file:http-server.c, value:token_info->repo_id)"", ""result"": {""value_trace"": [{""full_code"": ""token_info->repo_id = g_strdup (repo_id)"", ""line"": 326, ""func_name"": ""validate_token""}], ""struct_var"": ""token_info"", ""struct_type"": ""TokenInfo*"", ""struct_definition"": ""typedef struct TokenInfo {\n    char *repo_id;\n    char *email;\n    gint64 expire_time;\n}\n\ntypedef struct TokenInfo {\n    char *repo_id;\n    char *email;\n    gint64 expire_time;\n} TokenInfo;""}}, {""source"": ""value_info(file:http-server.c, value:parts)"", ""result"": {""value_trace"": [{""full_code"": ""**parts = g_strsplit (req->uri->path->full + 1, \""/\"", 0)"", ""line"": 707, ""func_name"": ""get_check_permission_cb""}, {""full_code"": ""**parts = g_strsplit (req->uri->path->full + 1, \""/\"", 0)"", ""line"": 800, ""func_name"": ""get_check_quota_cb""}, {""full_code"": ""**parts = g_strsplit (req->uri->path->full + 1, \""/\"", 0)"", ""line"": 858, ""func_name"": ""get_head_commit_cb""}, {""full_code"": ""parts = g_strsplit (req->uri->path->full + 1, \""/\"", 0)"", ""line"": 1075, ""func_name"": ""put_update_branch_cb""}, {""full_code"": ""**parts = g_strsplit (req->uri->path->full + 1, \""/\"", 0)"", ""line"": 1263, ""func_name"": ""get_commit_info_cb""}], ""struct_var"": ""parts"", ""struct_type"": ""char**"", ""struct_definition"": ""char""}}]","Original code at http-server.c:304 checked token existence in cache but omitted repo_id validation. Patch added 'strcmp(token_info->repo_id, repo_id) == 0' to enforce binding. Repo_id is initialized via '*repo_id = parts[1]' in functions like get_check_permission_cb:708, where 'parts' is derived from splitting the request URI path (e.g., 'g_strsplit(req->uri->path->full + 1, ""/"", 0)' at get_check_permission_cb:707). Token_info->repo_id is set via 'g_strdup(repo_id)' in validate_token:326. This allows attackers to reuse valid tokens across repositories if repo_id validation is skipped.",0.95,./github/other_context/CVE-2021-43820
