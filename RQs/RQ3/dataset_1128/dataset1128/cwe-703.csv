id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2012-3236,CWE-476,c_cpp,"fits-io.c in GIMP before 2.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a malformed XTENSION header of a .fit file, as demonstrated using a long string.",https://github.com/GNOME/gimp/commit/0474376d234bc3d0901fd5e86f89d778a6473dd8,Bug 676804 - file handling DoS for fit file format\n\nApply patch from joe@reactionis.co.uk which fixes a buffer overflow on\nbroken/malicious fits files.\n(cherry picked from commit ace45631595e8781a1420842582d67160097163c),1,"[{""func_name"": ""fits_decode_header"", ""file_path"": ""plug-ins/file-fits/fits-io.c"", ""func_code"": ""static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\""fits_decode_header: Not enough memory\"", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \""SIMPLE  \"", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \""XTENSION\"", 8) == 0);\n if (hdulist->used.xtension)\n {\n   fdat = fits_decode_card (fits_search_card (hdr, \""XTENSION\""), typ_fstring);\n   strcpy (hdulist->xtension, fdat->fstring);\n }\n\n FITS_DECODE_CARD (hdr, \""NAXIS\"", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \""BITPIX\"", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \""fits_decode_header: Invalid BITPIX-value\"");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \""GCOUNT\"", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \""PCOUNT\"", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""GROUPS\"", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \""EXTEND\"", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \""fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\"");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \""NAXIS%-3d\"", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \""fits_decode_header: Negative value in NAXISn\"");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \""fits_decode_header: Random groups with NAXIS1 != 0\"");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \""fits_decode_card: Not enough NAXISn-cards\"");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \""BLANK\"", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""DATAMIN\"", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""DATAMAX\"", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \""BZERO\"", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""BSCALE\"", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \""IMAGE\"", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \""fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\"", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \""fits_decode_header: missing/invalid %s card\"", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}"", ""target"": 0}]","[{""func_name"": ""fits_decode_header"", ""file_path"": ""plug-ins/file-fits/fits-io.c"", ""func_code"": ""static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\""fits_decode_header: Not enough memory\"", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \""SIMPLE  \"", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \""XTENSION\"", 8) == 0);\n if (hdulist->used.xtension)\n   {\n     fdat = fits_decode_card (fits_search_card (hdr, \""XTENSION\""), typ_fstring);\n     if (fdat != NULL)\n       {\n         strcpy (hdulist->xtension, fdat->fstring);\n       }\n     else\n       {\n         strcpy (errmsg, \""No valid XTENSION header found.\"");\n         goto err_return;\n       }\n   }\n\n FITS_DECODE_CARD (hdr, \""NAXIS\"", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \""BITPIX\"", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \""fits_decode_header: Invalid BITPIX-value\"");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \""GCOUNT\"", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \""PCOUNT\"", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""GROUPS\"", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \""EXTEND\"", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \""fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\"");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \""NAXIS%-3d\"", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \""fits_decode_header: Negative value in NAXISn\"");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \""fits_decode_header: Random groups with NAXIS1 != 0\"");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \""fits_decode_card: Not enough NAXISn-cards\"");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \""BLANK\"", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""DATAMIN\"", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""DATAMAX\"", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \""BZERO\"", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""BSCALE\"", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \""IMAGE\"", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \""fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\"", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \""fits_decode_header: missing/invalid %s card\"", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}""}]","{""function"": 2}","[{""source"": ""func_info(file:fits-io.c, func:fits_search_card)"", ""result"": [{""code"": ""char *fits_search_card (FITS_RECORD_LIST *rl, char *keyword)\n\n{int key_len, k;\n char *card;\n char key[9];\n\n key_len = strlen (keyword);\n if (key_len > 8) key_len = 8;\n if (key_len == 0)\n   FITS_RETURN (\""fits_search_card: Invalid parameter\"", NULL);\n\n strcpy (key, \""        \"");\n memcpy (key, keyword, key_len);\n\n while (rl != NULL)\n {\n   card = (char *)rl->data;\n   for (k = 0; k < FITS_RECORD_SIZE / FITS_CARD_SIZE; k++)\n   {\n     if (strncmp (card, key, 8) == 0) return (card);\n     card += FITS_CARD_SIZE;\n   }\n   rl = rl->next_record;\n }\n return (NULL);\n}"", ""start_line"": 1652, ""end_line"": 1677, ""full_name"": ""fits_search_card"", ""file_path"": ""plug-ins/file-fits/fits-io.c""}]}, {""source"": ""func_info(file:fits-io.c, func:fits_decode_card)"", ""result"": [{""code"": ""FITS_DATA *fits_decode_card (const char *card, FITS_DATA_TYPES data_type)\n\n{static FITS_DATA data;\n long l_long;\n double l_double;\n char l_card[FITS_CARD_SIZE+1], msg[256];\n char *cp, *dst, *end;\n int ErrCount = 0;\n\n if (card == NULL) return (NULL);\n\n memcpy (l_card, card, FITS_CARD_SIZE);\n l_card[FITS_CARD_SIZE] = '\\0';\n\n if (strncmp (card+8, \""= \"", 2) != 0)\n {\n   sprintf (msg, \""fits_decode_card (warning): Missing value indicator\\\n '= ' for %8.8s\"", l_card);\n   fits_set_error (msg);\n   ErrCount++;\n }\n\n switch (data_type)\n {\n   case typ_bitpix8:\n     data.bitpix8 = (FITS_BITPIX8)(l_card[10]);\n     break;\n\n   case typ_bitpix16:\n     if (sscanf (l_card+10, \""%ld\"", &l_long) != 1)\n     {\n       fits_set_error (\""fits_decode_card: error decoding typ_bitpix16\"");\n       ErrCount++;\n       break;\n     }\n     data.bitpix16 = (FITS_BITPIX16)l_long;\n     break;\n\n   case typ_bitpix32:\n     if (sscanf (l_card+10, \""%ld\"", &l_long) != 1)\n     {\n       fits_set_error (\""fits_decode_card: error decoding t..."", ""start_line"": 1489, ""end_line"": 1628, ""full_name"": ""fits_decode_card"", ""file_path"": ""plug-ins/file-fits/fits-io.c""}]}]","plug-ins/file-fits/fits-io.c:1058-1063: Original code calls fits_search_card(hdr, ""XTENSION"") without checking if it returns NULL. If the XTENSION keyword is missing, fits_search_card (plug-ins/file-fits/fits-io.c:1652-1677) returns NULL, which is passed to fits_decode_card. fits_decode_card (plug-ins/file-fits/fits-io.c:1489-1628) returns NULL when given a NULL card, leaving fdat as NULL. The subsequent strcpy(hdulist->xtension, fdat->fstring) dereferences the NULL pointer, causing a crash.",0.95,./github/other_context/CVE-2012-3236
2,CVE-2013-4119,CWE-476,c_cpp,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished.,7,"[{""func_name"": ""peer_recv_callback"", ""file_path"": ""libfreerdp/core/peer.c"", ""func_code"": ""static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \""Invalid state %d\\n\"", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""credssp_new"", ""file_path"": ""libfreerdp/core/nla.c"", ""func_code"": ""rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\""Software\\\\FreeRDP\\\\Server\""),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\""Using SSPI Module: %s\\n\""), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}"", ""target"": 0}, {""func_name"": ""DeleteSecurityContext"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DeleteSecurityContext(phContext);\n\n\treturn status;\n}"", ""target"": 0}, {""func_name"": ""sspi_SecureHandleGetUpperPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}"", ""target"": 0}, {""func_name"": ""sspi_SecureHandleGetLowerPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}"", ""target"": 0}, {""func_name"": ""transport_connect_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \""Authentication failure, check credentials.\\n\""\n\t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}"", ""target"": 0}, {""func_name"": ""transport_accept_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \""client authentication failure\\n\"");\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}"", ""target"": 1}]","[{""func_name"": ""peer_recv_callback"", ""file_path"": ""libfreerdp/core/peer.c"", ""func_code"": ""static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t\trdp->nego->transport->credssp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \""Invalid state %d\\n\"", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}""}, {""func_name"": ""credssp_new"", ""file_path"": ""libfreerdp/core/nla.c"", ""func_code"": ""rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\""Software\\\\FreeRDP\\\\Server\""),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\""Using SSPI Module: %s\\n\""), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}""}, {""func_name"": ""DeleteSecurityContext"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name = NULL;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DeleteSecurityContext(phContext);\n\n\treturn status;\n}""}, {""func_name"": ""sspi_SecureHandleGetUpperPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}""}, {""func_name"": ""sspi_SecureHandleGetLowerPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}""}, {""func_name"": ""transport_connect_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \""Authentication failure, check credentials.\\n\""\n\t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}""}, {""func_name"": ""transport_accept_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \""client authentication failure\\n\"");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}""}]","{""value"": 1, ""caller"": 2}","[{""source"": ""value_info(file:nla.c, value:credssp)"", ""result"": {""value_trace"": [{""full_code"": ""credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp))"", ""line"": 1229, ""func_name"": ""credssp_new""}], ""struct_var"": ""credssp"", ""struct_type"": ""rdpCredssp*"", ""struct_definition"": ""typedef struct rdp_credssp rdpCredssp;""}}, {""source"": ""caller_info(func:sspi_SecureHandleGetUpperPointer)"", ""result"": [{""call_line"": 725, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY FreeCredentialsHandle(PCredHandle phCredential)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->FreeCredentialsHandle == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->FreeCredentialsHandle(phCredential);\n\n\treturn status;\n}"", ""caller_start"": 719, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}, {""call_line"": 759, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY QueryCredentialsAttributesW(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_WCHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_WCHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameW(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesW(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}"", ""caller_start"": 753, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}, {""call_line"": 783, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY QueryCredentialsAttributesA(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesA(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}"", ""caller_start"": 777, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}, {""call_line"": 811, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY AcceptSecurityContext(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tPSecBufferDesc pInput, ULONG fContextReq, ULONG TargetDataRep, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsTimeStamp)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcceptSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcceptSecurityContext(phCredential, phContext, pInput, fContextReq,\n\t\t\tTargetDataRep, phNewContext, pOutput, pfContextAttr, ptsTimeStamp);\n\n\treturn status;\n}"", ""caller_start"": 803, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}]}, {""source"": ""caller_info(func:sspi_SecureHandleGetLowerPointer)"", ""result"": [{""call_line"": 49, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phContext)"", ""caller_code"": ""SEC_ENTRY credssp_InitializeSecurityContextA(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_CHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tCREDSSP_CONTEXT* context;\n\tCREDENTIALS* credentials;\n\n\tcontext = sspi_SecureHandleGetLowerPointer(phContext);\n\n\tif (!context)\n\t{\n\t\tcontext = credssp_ContextNew();\n\n\t\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\t\tsspi_SecureHandleSetLowerPointer(phNewContext, context);\n\t\tsspi_SecureHandleSetUpperPointer(phNewContext, (void*) CREDSSP_PACKAGE_NAME);\n\t}\n\n\treturn SEC_E_OK;\n\n}"", ""caller_start"": 41, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}, {""call_line"": 55, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY credssp_InitializeSecurityContextA(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_CHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tCREDSSP_CONTEXT* context;\n\tCREDENTIALS* credentials;\n\n\tcontext = sspi_SecureHandleGetLowerPointer(phContext);\n\n\tif (!context)\n\t{\n\t\tcontext = credssp_ContextNew();\n\n\t\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\t\tsspi_SecureHandleSetLowerPointer(phNewContext, context);\n\t\tsspi_SecureHandleSetUpperPointer(phNewContext, (void*) CREDSSP_PACKAGE_NAME);\n\t}\n\n\treturn SEC_E_OK;\n\n}"", ""caller_start"": 41, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}, {""call_line"": 139, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY credssp_QueryCredentialsAttributesA(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tif (ulAttribute == SECPKG_CRED_ATTR_NAMES)\n\t{\n\t\tCREDENTIALS* credentials;\n\n\t\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\t\treturn SEC_E_OK;\n\t}\n\n\treturn SEC_E_UNSUPPORTED_FUNCTION;\n}"", ""caller_start"": 133, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}, {""call_line"": 154, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY credssp_FreeCredentialsHandle(PCredHandle phCredential)\n{\n\tCREDENTIALS* credentials;\n\n\tif (!phCredential)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\tif (!credentials)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tsspi_CredentialsFree(credentials);\n\n\treturn SEC_E_OK;\n}"", ""caller_start"": 147, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}]}]",libfreerdp/core/peer.c:273 (credssp pointer not NULL after free) → libfreerdp/core/transport.c:160 (similar issue) → winpr/libwinpr/sspi/sspi.c:249/269 (dereference without handle validity check). Patch adds NULLing and SecInvalidateHandle in libfreerdp/core/nla.c:1246 and SecIsValidHandle checks in sspi.c to prevent invalid dereference.,0.95,./github/other_context/CVE-2013-4119
3,CVE-2015-6569,"CWE-362, CWE-476",java,Race condition in the LoadBalancer module in the Atlassian Floodlight Controller before 1.2 allows remote attackers to cause a denial of service (NULL pointer dereference and thread crash) via a state manipulation attack.,https://github.com/floodlight/floodlight/commit/7f5bedb625eec3ff4d29987c31cef2553a962b36,fix data races bug in LoadBalancer module,2,"[{""func_name"": ""processPacketIn"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    LBMember member = members.get(pool.pickMember(client));\n\n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }"", ""target"": 0}, {""func_name"": ""removePool"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""@Override\n    public int removePool(String poolId) {\n        LBPool pool;\n        if (pools != null) {\n            pool = pools.get(poolId);\n            if (pool.vipId != null)\n                vips.get(pool.vipId).pools.remove(poolId);\n            pools.remove(poolId);\n            return 0;\n        } else {\n            return -1;\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""processPacketIn"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    if (vip == null)\t\t\t// fix deference violations           \n                    \treturn Command.CONTINUE;\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    if (pool == null)\t\t\t// fix deference violations\n                    \treturn Command.CONTINUE;\n                    LBMember member = members.get(pool.pickMember(client));\n                    if(member == null)\t\t\t//fix deference violations\n                    \treturn Command.CONTINUE;\n                    \n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }""}, {""func_name"": ""removePool"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""@Override\n    public int removePool(String poolId) {\n        LBPool pool;\n        if (pools != null) {\n            pool = pools.get(poolId);\n            if (pool == null)\t// fix deference violations\n            \treturn -1;\n            if (pool.vipId != null)\n                vips.get(pool.vipId).pools.remove(poolId);\n            pools.remove(poolId);\n            return 0;\n        } else {\n            return -1;\n        }\n    }""}]","{""code"": 3, ""value"": 3, ""caller"": 1}","[{""source"": ""code_info(file:LoadBalancer.java, lines:100-150)"", ""result"": ""    protected IFloodlightProviderService floodlightProviderService;\n    protected IRestApiService restApiService;\n    \n    protected IDebugCounterService debugCounterService;\n    private IDebugCounter counterPacketOut;\n    protected IDeviceService deviceManagerService;\n    protected IRoutingService routingEngineService;\n    protected ITopologyService topologyService;\n    protected IStaticFlowEntryPusherService sfpService;\n    protected IOFSwitchService switchService;\n    \n    protected HashMap<String, LBVip> vips;\n    protected HashMap<String, LBPool> pools;\n    protected HashMap<String, LBMember> members;\n    protected HashMap<Integer, String> vipIpToId;\n    protected HashMap<Integer, MacAddress> vipIpToMac;\n    protected HashMap<Integer, String> memberIpToId;\n    protected HashMap<IPClient, LBMember> clientToMember;\n    \n    //Copied from Forwarding with message damper routine for pushing proxy Arp \n    protected static int OFMESSAGE_DAMPER_CAPACITY = 10000; // ms. \n    protected static int OFMESSAGE_DAMPER_TIMEOUT = 250; // ms \n    protected static String LB_ETHER_TYPE = \""0x800\"";\n    protected static int LB_PRIORITY = 32768;\n    \n    // Comparator for sorting by SwitchCluster\n    public Comparator<SwitchPort> clusterIdComparator =\n            new Comparator<SwitchPort>() {\n                @Override\n                public int compare(SwitchPort d1, SwitchPort d2) {\n                    DatapathId d1ClusterId = topologyService.getL2DomainId(d1.getSwitchDPID());\n                    DatapathId d2ClusterId = topologyService.getL2DomainId(d2.getSwitchDPID());\n                    return d1ClusterId.compareTo(d2ClusterId);\n                }\n            };\n\n    // data structure for storing connected\n    public class IPClient {\n        IPv4Address ipAddress;\n        IpProtocol nw_proto;\n        TransportPort srcPort; // tcp/udp src port. icmp type (OFMatch convention)\n        TransportPort targetPort; // tcp/udp dst port, icmp code (OFMatch convention)\n        \n        public IPClient() {\n            ipAddress = IPv4Address.NONE;\n            nw_proto = IpProtocol.NONE;\n            srcPort = TransportPort.NONE;\n            targetPort = TransportPort.NONE;\n        }\n    }\n    \n    @Override\n""}, {""source"": ""value_info(file:LoadBalancer.java, value:vips)"", ""result"": {""value_trace"": [{""full_code"": ""this.vips = new HashMap<String, LBVip>()"", ""line"": 810, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""vips"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:LoadBalancer.java, value:pools)"", ""result"": {""value_trace"": [{""full_code"": ""this.pools = new HashMap<String, LBPool>()"", ""line"": 811, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""pools"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:LoadBalancer.java, value:members)"", ""result"": {""value_trace"": [{""full_code"": ""this.members = new HashMap<String, LBMember>()"", ""line"": 812, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""members"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:LoadBalancer.java, lines:800-820)"", ""result"": ""                                                 throws FloodlightModuleException {\n        floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);\n        restApiService = context.getServiceImpl(IRestApiService.class);\n        debugCounterService = context.getServiceImpl(IDebugCounterService.class);\n        deviceManagerService = context.getServiceImpl(IDeviceService.class);\n        routingEngineService = context.getServiceImpl(IRoutingService.class);\n        topologyService = context.getServiceImpl(ITopologyService.class);\n        sfpService = context.getServiceImpl(IStaticFlowEntryPusherService.class);\n        switchService = context.getServiceImpl(IOFSwitchService.class);\n        \n        vips = new HashMap<String, LBVip>();\n        pools = new HashMap<String, LBPool>();\n        members = new HashMap<String, LBMember>();\n        vipIpToId = new HashMap<Integer, String>();\n        vipIpToMac = new HashMap<Integer, MacAddress>();\n        memberIpToId = new HashMap<Integer, String>();\n    }\n\n    @Override\n    public void startUp(FloodlightModuleContext context) {\n        floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this);\n        restApiService.addRestletRoutable(new LoadBalancerWebRoutable());\n""}, {""source"": ""caller_info(file:LoadBalancer.java, func:processPacketIn)"", ""result"": [{""call_line"": 174, ""call_code"": ""processPacketIn(sw, (OFPacketIn) msg, cntx)"", ""caller_code"": ""    @Override\n    public net.floodlightcontroller.core.IListener.Command\n            receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n        switch (msg.getType()) {\n            case PACKET_IN:\n                return processPacketIn(sw, (OFPacketIn)msg, cntx);\n            default:\n                break;\n        }\n        log.warn(\""Received unexpected message {}\"", msg);\n        return Command.CONTINUE;\n    }\n"", ""caller_start"": 169, ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java""}, {""call_line"": 347, ""call_code"": ""processPacketIn(sw, (OFPacketIn) msg, cntx)"", ""caller_code"": ""\t@Override\n\tpublic Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n\t\tswitch (msg.getType()) {\n\t\tcase PACKET_IN:\n\t\t\treturn processPacketIn(sw, (OFPacketIn)msg, cntx);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tlog.warn(\""Received unexpected message {}\"", msg);\n\t\treturn Command.CONTINUE;\n\t}\n"", ""caller_start"": 343, ""file_path"": ""src/main/java/net/floodlightcontroller/virtualnetwork/VirtualNetworkFilter.java""}]}, {""source"": ""code_info(file:LoadBalancer.java, lines:150-200)"", ""result"": ""    \n    @Override\n    public String getName() {\n        return \""loadbalancer\"";\n    }\n\n    @Override\n    public boolean isCallbackOrderingPrereq(OFType type, String name) {\n        return (type.equals(OFType.PACKET_IN) && \n                (name.equals(\""topology\"") || \n                 name.equals(\""devicemanager\"") ||\n                 name.equals(\""virtualizer\"")));\n    }\n\n    @Override\n    public boolean isCallbackOrderingPostreq(OFType type, String name) {\n        return (type.equals(OFType.PACKET_IN) && name.equals(\""forwarding\""));\n   }\n\n    @Override\n    public net.floodlightcontroller.core.IListener.Command\n            receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n        switch (msg.getType()) {\n            case PACKET_IN:\n                return processPacketIn(sw, (OFPacketIn)msg, cntx);\n            default:\n                break;\n        }\n        log.warn(\""Received unexpected message {}\"", msg);\n        return Command.CONTINUE;\n    }\n\n    private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n""}]","Race condition in concurrent access of shared HashMaps (vips, pools, members) in LoadBalancer.java. These collections are initialized as non-thread-safe HashMaps (LoadBalancer.java:810-812) and accessed/modified without synchronization. For example: \n1. `processPacketIn` (LoadBalancer.java:227-233) accesses `vips`, `pools`, and `members` without synchronization. \n2. `removePool` (LoadBalancer.java:90-92) modifies `pools` and `vips` without synchronization. \nConcurrent execution of these functions can lead to NULL dereference when entries are removed during access.",0.95,./github/other_context/CVE-2015-6569
4,CVE-2016-10129,CWE-476,c_cpp,The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,"smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line ""0004""). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",3,"[{""func_name"": ""git_pkt_parse_line"", ""file_path"": ""src/transports/smart_pkt.c"", ""func_code"": ""int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \""PACK\"")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ACK\""))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""NAK\""))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \""ERR \""))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ok\""))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ng\""))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""unpack\""))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}"", ""target"": 0}, {""func_name"": ""parse_report"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \""report-status: Error reported: %s\"",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \""Incomplete pack data pkt-line\"");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}"", ""target"": 0}, {""func_name"": ""add_push_report_sideband_pkt"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}"", ""target"": 0}]","[{""func_name"": ""git_pkt_parse_line"", ""file_path"": ""src/transports/smart_pkt.c"", ""func_code"": ""int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \""PACK\"")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \""Invalid empty packet\"");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ACK\""))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""NAK\""))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \""ERR \""))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ok\""))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ng\""))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""unpack\""))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}""}, {""func_name"": ""parse_report"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \""report-status: Error reported: %s\"",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \""Incomplete pack data pkt-line\"");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}""}, {""func_name"": ""add_push_report_sideband_pkt"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(file:smart_pkt.c, func:git_pkt_parse_line)"", ""result"": [{""call_line"": 42, ""call_code"": ""git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset)"", ""caller_code"": ""int git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \""Remote error: %s\"", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->..."", ""caller_start"": 22, ""file_path"": ""src/transports/smart_protocol.c""}, {""call_line"": 215, ""call_code"": ""git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset)"", ""caller_code"": ""static int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret == 0) {\n\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\treturn GIT_EEOF;\n\t\t}\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}"", ""caller_start"": 207, ""file_path"": ""src/transports/smart_protocol.c""}, {""call_line"": 749, ""call_code"": ""git_pkt_parse_line(&pkt, line, &line_end, line_len)"", ""caller_code"": ""static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t..."", ""caller_start"": 728, ""file_path"": ""src/transports/smart_protocol.c""}, {""call_line"": 800, ""call_code"": ""git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset)"", ""caller_code"": ""static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITE..."", ""caller_start"": 790, ""file_path"": ""src/transports/smart_protocol.c""}]}]","src/transports/smart_pkt.c:438-445: git_pkt_parse_line returned 0 with *head = NULL for empty packet lines (e.g., ""0004""). Callers like parse_report (src/transports/smart_protocol.c:800) and add_push_report_sideband_pkt (src/transports/smart_protocol.c:749) used pkt without checking for NULL, causing a NULL dereference when accessing pkt->type. The patch fixes this by returning GIT_ERROR, which is propagated and checked by callers (e.g., error handling in git_smart__store_refs (src/transports/smart_protocol.c:42)).",0.95,./github/other_context/CVE-2016-10129
5,CVE-2016-9631,CWE-476,c_cpp,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,https://github.com/tats/w3m/commit/a8cba1bd912a65ed40acded2bd5013d1f01253e1,Prevent deref null pointer in HTMLlineproc0()\n\nBug-Debian: https://github.com/tats/w3m/issues/42\nOrigin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=ecfdcbe1131591502c5e7f9ff4f34b24c5a2db97,1,"[{""func_name"": ""HTMLlineproc0"", ""file_path"": ""file.c"", ""func_code"": ""void\nHTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)\n{\n    Lineprop mode;\n    int cmd;\n    struct readbuffer *obuf = h_env->obuf;\n    int indent, delta;\n    struct parsed_tag *tag;\n    Str tokbuf;\n    struct table *tbl = NULL;\n    struct table_mode *tbl_mode = NULL;\n    int tbl_width = 0;\n#ifdef USE_M17N\n    int is_hangul, prev_is_hangul = 0;\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *f = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(f, \""%c%c%c%c\"",\n\t\t(obuf->flag & RB_PREMODE) ? 'P' : ' ',\n\t\t(obuf->table_level >= 0) ? 'T' : ' ',\n\t\t(obuf->flag & RB_INTXTA) ? 'X' : ' ',\n\t\t(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');\n\tfprintf(f, \""HTMLlineproc1(\\\""%s\\\"",%d,%lx)\\n\"", line, h_env->limit,\n\t\t(unsigned long)h_env);\n\tfclose(f);\n    }\n#endif\n\n    tokbuf = Strnew();\n\n  table_start:\n    if (obuf->table_level >= 0) {\n\tint level = min(obuf->table_level, MAX_TABLE - 1);\n\ttbl = tables[level];\n\ttbl_mode = &table_mode[level];\n\ttbl_width = table_width(h_env, level);\n    }\n\n    while (*line != '\\0') {\n\tchar *str, *p;\n\tint is_tag = FALSE;\n\tint pre_mode = (obuf->table_level >= 0) ? tbl_mode->pre_mode :\n\t    obuf->flag;\n\tint end_tag = (obuf->table_level >= 0) ? tbl_mode->end_tag :\n\t    obuf->end_tag;\n\n\tif (*line == '<' || obuf->status != R_ST_NORMAL) {\n\t    /* \n\t     * Tag processing\n\t     */\n\t    if (obuf->status == R_ST_EOL)\n\t\tobuf->status = R_ST_NORMAL;\n\t    else {\n\t\tread_token(h_env->tagbuf, &line, &obuf->status,\n\t\t\t   pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);\n\t\tif (obuf->status != R_ST_NORMAL)\n\t\t    return;\n\t    }\n\t    if (h_env->tagbuf->length == 0)\n\t\tcontinue;\n\t    str = h_env->tagbuf->ptr;\n\t    if (*str == '<') {\n\t\tif (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))\n\t\t    is_tag = TRUE;\n\t\telse if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |\n\t\t\t\t       RB_SCRIPT | RB_STYLE | RB_TITLE))) {\n\t\t    line = Strnew_m_charp(str + 1, line, NULL)->ptr;\n\t\t    str = \""&lt;\"";\n\t\t}\n\t    }\n\t}\n\telse {\n\t    read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);\n\t    if (obuf->status != R_ST_NORMAL)\t/* R_ST_AMP ? */\n\t\tobuf->status = R_ST_NORMAL;\n\t    str = tokbuf->ptr;\n\t}\n\n\tif (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |\n\t\t\tRB_STYLE | RB_TITLE)) {\n\t    if (is_tag) {\n\t\tp = str;\n\t\tif ((tag = parse_tag(&p, internal))) {\n\t\t    if (tag->tagid == end_tag ||\n\t\t\t(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)\n\t\t\t|| (pre_mode & RB_TITLE\n\t\t\t    && (tag->tagid == HTML_N_HEAD\n\t\t\t\t|| tag->tagid == HTML_BODY)))\n\t\t\tgoto proc_normal;\n\t\t}\n\t    }\n\t    /* title */\n\t    if (pre_mode & RB_TITLE) {\n\t\tfeed_title(str);\n\t\tcontinue;\n\t    }\n\t    /* select */\n\t    if (pre_mode & RB_INSELECT) {\n\t\tif (obuf->table_level >= 0)\n\t\t    goto proc_normal;\n\t\tfeed_select(str);\n\t\tcontinue;\n\t    }\n\t    if (is_tag) {\n\t\tif (strncmp(str, \""<!--\"", 4) && (p = strchr(str + 1, '<'))) {\n\t\t    str = Strnew_charp_n(str, p - str)->ptr;\n\t\t    line = Strnew_m_charp(p, line, NULL)->ptr;\n\t\t}\n\t\tis_tag = FALSE;\n\t    }\n\t    if (obuf->table_level >= 0)\n\t\tgoto proc_normal;\n\t    /* textarea */\n\t    if (pre_mode & RB_INTXTA) {\n\t\tfeed_textarea(str);\n\t\tcontinue;\n\t    }\n\t    /* script */\n\t    if (pre_mode & RB_SCRIPT)\n\t\tcontinue;\n\t    /* style */\n\t    if (pre_mode & RB_STYLE)\n\t\tcontinue;\n\t}\n\n      proc_normal:\n\tif (obuf->table_level >= 0) {\n\t    /* \n\t     * within table: in <table>..</table>, all input tokens\n\t     * are fed to the table renderer, and then the renderer\n\t     * makes HTML output.\n\t     */\n\t    switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {\n\t    case 0:\n\t\t/* </table> tag */\n\t\tobuf->table_level--;\n\t\tif (obuf->table_level >= MAX_TABLE - 1)\n\t\t    continue;\n\t\tend_table(tbl);\n\t\tif (obuf->table_level >= 0) {\n\t\t    struct table *tbl0 = tables[obuf->table_level];\n\t\t    str = Sprintf(\""<table_alt tid=%d>\"", tbl0->ntable)->ptr;\n\t\t    pushTable(tbl0, tbl);\n\t\t    tbl = tbl0;\n\t\t    tbl_mode = &table_mode[obuf->table_level];\n\t\t    tbl_width = table_width(h_env, obuf->table_level);\n\t\t    feed_table(tbl, str, tbl_mode, tbl_width, TRUE);\n\t\t    continue;\n\t\t    /* continue to the next */\n\t\t}\n\t\tif (obuf->flag & RB_DEL)\n\t\t    continue;\n\t\t/* all tables have been read */\n\t\tif (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t}\n\t\tsave_fonteffect(h_env, obuf);\n\t\tinitRenderTable();\n\t\trenderTable(tbl, tbl_width, h_env);\n\t\trestore_fonteffect(h_env, obuf);\n\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\tif (tbl->vspace > 0) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    obuf->flag |= RB_IGNORE_P;\n\t\t}\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tcontinue;\n\t    case 1:\n\t\t/* <table> tag */\n\t\tbreak;\n\t    default:\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (is_tag) {\n/*** Beginning of a new tag ***/\n\t    if ((tag = parse_tag(&str, internal)))\n\t\tcmd = tag->tagid;\n\t    else\n\t\tcontinue;\n\t    /* process tags */\n\t    if (HTMLtagproc1(tag, h_env) == 0) {\n\t\t/* preserve the tag for second-stage processing */\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    h_env->tagbuf = parsedtag2str(tag);\n\t\tpush_tag(obuf, h_env->tagbuf->ptr, cmd);\n\t    }\n#ifdef ID_EXT\n\t    else {\n\t\tprocess_idattr(obuf, cmd, tag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    obuf->bp.init_flag = 1;\n\t    clear_ignore_p_flag(cmd, obuf);\n\t    if (cmd == HTML_TABLE)\n\t\tgoto table_start;\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (obuf->flag & (RB_DEL | RB_S))\n\t    continue;\n\twhile (*str) {\n\t    mode = get_mctype(str);\n\t    delta = get_mcwidth(str);\n\t    if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {\n\t\tchar ch = *str;\n\t\tif (!(obuf->flag & RB_PLAIN) && (*str == '&')) {\n\t\t    char *p = str;\n\t\t    int ech = getescapechar(&p);\n\t\t    if (ech == '\\n' || ech == '\\r') {\n\t\t\tch = '\\n';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t    else if (ech == '\\t') {\n\t\t\tch = '\\t';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t}\n\t\tif (ch != '\\n')\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif (ch == '\\n') {\n\t\t    str++;\n\t\t    if (obuf->flag & RB_IGNORE_P) {\n\t\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (obuf->flag & RB_PRE_INT)\n\t\t\tPUSH(' ');\n\t\t    else\n\t\t\tflushline(h_env, obuf, h_env->envs[h_env->envc].indent,\n\t\t\t\t  1, h_env->limit);\n\t\t}\n\t\telse if (ch == '\\t') {\n\t\t    do {\n\t\t\tPUSH(' ');\n\t\t    } while ((h_env->envs[h_env->envc].indent + obuf->pos)\n\t\t\t     % Tabstop != 0);\n\t\t    str++;\n\t\t}\n\t\telse if (obuf->flag & RB_PLAIN) {\n\t\t    char *p = html_quote_char(*str);\n\t\t    if (p) {\n\t\t\tpush_charp(obuf, 1, p, PC_ASCII);\n\t\t\tstr++;\n\t\t    }\n\t\t    else {\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t}\n\t\tif (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))\n\t\t    continue;\n\t    }\n\t    else {\n\t\tif (!IS_SPACE(*str))\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {\n\t\t    if (*obuf->prevchar->ptr != ' ') {\n\t\t\tPUSH(' ');\n\t\t    }\n\t\t    str++;\n\t\t}\n\t\telse {\n#ifdef USE_M17N\n\t\t    if (mode == PC_KANJI1)\n\t\t\tis_hangul = wtf_is_hangul((wc_uchar *) str);\n\t\t    else\n\t\t\tis_hangul = 0;\n\t\t    if (!SimplePreserveSpace && mode == PC_KANJI1 &&\n\t\t\t!is_hangul && !prev_is_hangul &&\n\t\t\tobuf->pos > h_env->envs[h_env->envc].indent &&\n\t\t\tStrlastchar(obuf->line) == ' ') {\n\t\t\twhile (obuf->line->length >= 2 &&\n\t\t\t       !strncmp(obuf->line->ptr + obuf->line->length -\n\t\t\t\t\t2, \""  \"", 2)\n\t\t\t       && obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t\tif (obuf->line->length >= 3 &&\n\t\t\t    obuf->prev_ctype == PC_KANJI1 &&\n\t\t\t    Strlastchar(obuf->line) == ' ' &&\n\t\t\t    obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t    }\n\t\t    prev_is_hangul = is_hangul;\n#endif\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,\n\t\t\t\t   mode);\n\t\t}\n\t    }\n\t    if (need_flushline(h_env, obuf, mode)) {\n\t\tchar *bp = obuf->line->ptr + obuf->bp.len;\n\t\tchar *tp = bp - obuf->bp.tlen;\n\t\tint i = 0;\n\n\t\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t\t    i = 1;\n\n\t\tindent = h_env->envs[h_env->envc].indent;\n\t\tif (obuf->bp.pos - i > indent) {\n\t\t    Str line;\n\t\t    append_tags(obuf);\n\t\t    line = Strnew_charp(bp);\n\t\t    Strshrink(obuf->line, obuf->line->length - obuf->bp.len);\n#ifdef FORMAT_NICE\n\t\t    if (obuf->pos - i > h_env->limit)\n\t\t\tobuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    back_to_breakpoint(obuf);\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    HTMLlineproc1(line->ptr, h_env);\n\t\t}\n\t    }\n\t}\n    }\n    if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {\n\tchar *tp;\n\tint i = 0;\n\n\tif (obuf->bp.pos == obuf->pos) {\n\t    tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];\n\t}\n\telse {\n\t    tp = &obuf->line->ptr[obuf->line->length];\n\t}\n\n\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t    i = 1;\n\tindent = h_env->envs[h_env->envc].indent;\n\tif (obuf->pos - i > h_env->limit) {\n#ifdef FORMAT_NICE\n\t    obuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t}\n    }\n}"", ""target"": 0}]","[{""func_name"": ""HTMLlineproc0"", ""file_path"": ""file.c"", ""func_code"": ""void\nHTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)\n{\n    Lineprop mode;\n    int cmd;\n    struct readbuffer *obuf = h_env->obuf;\n    int indent, delta;\n    struct parsed_tag *tag;\n    Str tokbuf;\n    struct table *tbl = NULL;\n    struct table_mode *tbl_mode = NULL;\n    int tbl_width = 0;\n#ifdef USE_M17N\n    int is_hangul, prev_is_hangul = 0;\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *f = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(f, \""%c%c%c%c\"",\n\t\t(obuf->flag & RB_PREMODE) ? 'P' : ' ',\n\t\t(obuf->table_level >= 0) ? 'T' : ' ',\n\t\t(obuf->flag & RB_INTXTA) ? 'X' : ' ',\n\t\t(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');\n\tfprintf(f, \""HTMLlineproc1(\\\""%s\\\"",%d,%lx)\\n\"", line, h_env->limit,\n\t\t(unsigned long)h_env);\n\tfclose(f);\n    }\n#endif\n\n    tokbuf = Strnew();\n\n  table_start:\n    if (obuf->table_level >= 0) {\n\tint level = min(obuf->table_level, MAX_TABLE - 1);\n\ttbl = tables[level];\n\ttbl_mode = &table_mode[level];\n\ttbl_width = table_width(h_env, level);\n    }\n\n    while (*line != '\\0') {\n\tchar *str, *p;\n\tint is_tag = FALSE;\n\tint pre_mode = (obuf->table_level >= 0 && tbl_mode) ?\n\t    tbl_mode->pre_mode : obuf->flag;\n\tint end_tag = (obuf->table_level >= 0 && tbl_mode) ?\n\t    tbl_mode->end_tag : obuf->end_tag;\n\n\tif (*line == '<' || obuf->status != R_ST_NORMAL) {\n\t    /* \n\t     * Tag processing\n\t     */\n\t    if (obuf->status == R_ST_EOL)\n\t\tobuf->status = R_ST_NORMAL;\n\t    else {\n\t\tread_token(h_env->tagbuf, &line, &obuf->status,\n\t\t\t   pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);\n\t\tif (obuf->status != R_ST_NORMAL)\n\t\t    return;\n\t    }\n\t    if (h_env->tagbuf->length == 0)\n\t\tcontinue;\n\t    str = h_env->tagbuf->ptr;\n\t    if (*str == '<') {\n\t\tif (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))\n\t\t    is_tag = TRUE;\n\t\telse if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |\n\t\t\t\t       RB_SCRIPT | RB_STYLE | RB_TITLE))) {\n\t\t    line = Strnew_m_charp(str + 1, line, NULL)->ptr;\n\t\t    str = \""&lt;\"";\n\t\t}\n\t    }\n\t}\n\telse {\n\t    read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);\n\t    if (obuf->status != R_ST_NORMAL)\t/* R_ST_AMP ? */\n\t\tobuf->status = R_ST_NORMAL;\n\t    str = tokbuf->ptr;\n\t}\n\n\tif (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |\n\t\t\tRB_STYLE | RB_TITLE)) {\n\t    if (is_tag) {\n\t\tp = str;\n\t\tif ((tag = parse_tag(&p, internal))) {\n\t\t    if (tag->tagid == end_tag ||\n\t\t\t(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)\n\t\t\t|| (pre_mode & RB_TITLE\n\t\t\t    && (tag->tagid == HTML_N_HEAD\n\t\t\t\t|| tag->tagid == HTML_BODY)))\n\t\t\tgoto proc_normal;\n\t\t}\n\t    }\n\t    /* title */\n\t    if (pre_mode & RB_TITLE) {\n\t\tfeed_title(str);\n\t\tcontinue;\n\t    }\n\t    /* select */\n\t    if (pre_mode & RB_INSELECT) {\n\t\tif (obuf->table_level >= 0)\n\t\t    goto proc_normal;\n\t\tfeed_select(str);\n\t\tcontinue;\n\t    }\n\t    if (is_tag) {\n\t\tif (strncmp(str, \""<!--\"", 4) && (p = strchr(str + 1, '<'))) {\n\t\t    str = Strnew_charp_n(str, p - str)->ptr;\n\t\t    line = Strnew_m_charp(p, line, NULL)->ptr;\n\t\t}\n\t\tis_tag = FALSE;\n\t    }\n\t    if (obuf->table_level >= 0)\n\t\tgoto proc_normal;\n\t    /* textarea */\n\t    if (pre_mode & RB_INTXTA) {\n\t\tfeed_textarea(str);\n\t\tcontinue;\n\t    }\n\t    /* script */\n\t    if (pre_mode & RB_SCRIPT)\n\t\tcontinue;\n\t    /* style */\n\t    if (pre_mode & RB_STYLE)\n\t\tcontinue;\n\t}\n\n      proc_normal:\n\tif (obuf->table_level >= 0 && tbl && tbl_mode) {\n\t    /* \n\t     * within table: in <table>..</table>, all input tokens\n\t     * are fed to the table renderer, and then the renderer\n\t     * makes HTML output.\n\t     */\n\t    switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {\n\t    case 0:\n\t\t/* </table> tag */\n\t\tobuf->table_level--;\n\t\tif (obuf->table_level >= MAX_TABLE - 1)\n\t\t    continue;\n\t\tend_table(tbl);\n\t\tif (obuf->table_level >= 0) {\n\t\t    struct table *tbl0 = tables[obuf->table_level];\n\t\t    str = Sprintf(\""<table_alt tid=%d>\"", tbl0->ntable)->ptr;\n\t\t    pushTable(tbl0, tbl);\n\t\t    tbl = tbl0;\n\t\t    tbl_mode = &table_mode[obuf->table_level];\n\t\t    tbl_width = table_width(h_env, obuf->table_level);\n\t\t    feed_table(tbl, str, tbl_mode, tbl_width, TRUE);\n\t\t    continue;\n\t\t    /* continue to the next */\n\t\t}\n\t\tif (obuf->flag & RB_DEL)\n\t\t    continue;\n\t\t/* all tables have been read */\n\t\tif (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t}\n\t\tsave_fonteffect(h_env, obuf);\n\t\tinitRenderTable();\n\t\trenderTable(tbl, tbl_width, h_env);\n\t\trestore_fonteffect(h_env, obuf);\n\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\tif (tbl->vspace > 0) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    obuf->flag |= RB_IGNORE_P;\n\t\t}\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tcontinue;\n\t    case 1:\n\t\t/* <table> tag */\n\t\tbreak;\n\t    default:\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (is_tag) {\n/*** Beginning of a new tag ***/\n\t    if ((tag = parse_tag(&str, internal)))\n\t\tcmd = tag->tagid;\n\t    else\n\t\tcontinue;\n\t    /* process tags */\n\t    if (HTMLtagproc1(tag, h_env) == 0) {\n\t\t/* preserve the tag for second-stage processing */\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    h_env->tagbuf = parsedtag2str(tag);\n\t\tpush_tag(obuf, h_env->tagbuf->ptr, cmd);\n\t    }\n#ifdef ID_EXT\n\t    else {\n\t\tprocess_idattr(obuf, cmd, tag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    obuf->bp.init_flag = 1;\n\t    clear_ignore_p_flag(cmd, obuf);\n\t    if (cmd == HTML_TABLE)\n\t\tgoto table_start;\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (obuf->flag & (RB_DEL | RB_S))\n\t    continue;\n\twhile (*str) {\n\t    mode = get_mctype(str);\n\t    delta = get_mcwidth(str);\n\t    if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {\n\t\tchar ch = *str;\n\t\tif (!(obuf->flag & RB_PLAIN) && (*str == '&')) {\n\t\t    char *p = str;\n\t\t    int ech = getescapechar(&p);\n\t\t    if (ech == '\\n' || ech == '\\r') {\n\t\t\tch = '\\n';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t    else if (ech == '\\t') {\n\t\t\tch = '\\t';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t}\n\t\tif (ch != '\\n')\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif (ch == '\\n') {\n\t\t    str++;\n\t\t    if (obuf->flag & RB_IGNORE_P) {\n\t\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (obuf->flag & RB_PRE_INT)\n\t\t\tPUSH(' ');\n\t\t    else\n\t\t\tflushline(h_env, obuf, h_env->envs[h_env->envc].indent,\n\t\t\t\t  1, h_env->limit);\n\t\t}\n\t\telse if (ch == '\\t') {\n\t\t    do {\n\t\t\tPUSH(' ');\n\t\t    } while ((h_env->envs[h_env->envc].indent + obuf->pos)\n\t\t\t     % Tabstop != 0);\n\t\t    str++;\n\t\t}\n\t\telse if (obuf->flag & RB_PLAIN) {\n\t\t    char *p = html_quote_char(*str);\n\t\t    if (p) {\n\t\t\tpush_charp(obuf, 1, p, PC_ASCII);\n\t\t\tstr++;\n\t\t    }\n\t\t    else {\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t}\n\t\tif (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))\n\t\t    continue;\n\t    }\n\t    else {\n\t\tif (!IS_SPACE(*str))\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {\n\t\t    if (*obuf->prevchar->ptr != ' ') {\n\t\t\tPUSH(' ');\n\t\t    }\n\t\t    str++;\n\t\t}\n\t\telse {\n#ifdef USE_M17N\n\t\t    if (mode == PC_KANJI1)\n\t\t\tis_hangul = wtf_is_hangul((wc_uchar *) str);\n\t\t    else\n\t\t\tis_hangul = 0;\n\t\t    if (!SimplePreserveSpace && mode == PC_KANJI1 &&\n\t\t\t!is_hangul && !prev_is_hangul &&\n\t\t\tobuf->pos > h_env->envs[h_env->envc].indent &&\n\t\t\tStrlastchar(obuf->line) == ' ') {\n\t\t\twhile (obuf->line->length >= 2 &&\n\t\t\t       !strncmp(obuf->line->ptr + obuf->line->length -\n\t\t\t\t\t2, \""  \"", 2)\n\t\t\t       && obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t\tif (obuf->line->length >= 3 &&\n\t\t\t    obuf->prev_ctype == PC_KANJI1 &&\n\t\t\t    Strlastchar(obuf->line) == ' ' &&\n\t\t\t    obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t    }\n\t\t    prev_is_hangul = is_hangul;\n#endif\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,\n\t\t\t\t   mode);\n\t\t}\n\t    }\n\t    if (need_flushline(h_env, obuf, mode)) {\n\t\tchar *bp = obuf->line->ptr + obuf->bp.len;\n\t\tchar *tp = bp - obuf->bp.tlen;\n\t\tint i = 0;\n\n\t\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t\t    i = 1;\n\n\t\tindent = h_env->envs[h_env->envc].indent;\n\t\tif (obuf->bp.pos - i > indent) {\n\t\t    Str line;\n\t\t    append_tags(obuf);\n\t\t    line = Strnew_charp(bp);\n\t\t    Strshrink(obuf->line, obuf->line->length - obuf->bp.len);\n#ifdef FORMAT_NICE\n\t\t    if (obuf->pos - i > h_env->limit)\n\t\t\tobuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    back_to_breakpoint(obuf);\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    HTMLlineproc1(line->ptr, h_env);\n\t\t}\n\t    }\n\t}\n    }\n    if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {\n\tchar *tp;\n\tint i = 0;\n\n\tif (obuf->bp.pos == obuf->pos) {\n\t    tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];\n\t}\n\telse {\n\t    tp = &obuf->line->ptr[obuf->line->length];\n\t}\n\n\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t    i = 1;\n\tindent = h_env->envs[h_env->envc].indent;\n\tif (obuf->pos - i > h_env->limit) {\n#ifdef FORMAT_NICE\n\t    obuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t}\n    }\n}""}]","{""value"": 2}","[{""source"": ""value_info(file:file.c, value:tbl)"", ""result"": {""value_trace"": [{""full_code"": ""*tbl = NULL"", ""line"": 6271, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl = tables[level]"", ""line"": 6297, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl = tbl0"", ""line"": 6407, ""func_name"": ""HTMLlineproc0""}], ""struct_var"": ""tbl"", ""struct_type"": ""table*"", ""struct_definition"": ""static struct table\n\nextern struct table\n\nextern struct table\n\nstruct table\n\nstruct table {\n    int row;\n    int col;\n    int maxrow;\n    int maxcol;\n    int max_rowsize;\n    int border_mode;\n    int total_width;\n    int total_height;\n    int tabcontentssize;\n    int indent;\n    int cellspacing;\n    int cellpadding;\n    int vcellpadding;\n    int vspace;\n    int flag;\n#ifdef TABLE_EXPAND\n    int real_width;\n#endif\t\t\t\t/* TABLE_EXPAND */\n    Str caption;\n#ifdef ID_EXT\n    Str id;\n#endif\n    GeneralList ***tabdata;\n    table_attr **tabattr;\n    table_attr trattr;\n#ifdef ID_EXT\n    Str **tabidvalue;\n    Str *tridvalue;\n#endif\n    short tabwidth[MAXCOL];\n    short minimum_width[MAXCOL];\n    short fixed_width[MAXCOL];\n    struct table_cell cell;\n    short *tabheight;\n    struct table_in *tables;\n    short ntable;\n    short tables_size;\n    TextList *suspended_data;\n    /* use for counting skipped spaces */\n    struct table_linfo linfo;\n#ifdef MATRIX\n    MAT *matrix;\n    VEC *vector;\n#endif\t\t\t\t/* MATRIX */\n    int sloppy_width;\n}""}}, {""source"": ""value_info(file:file.c, value:tbl_mode)"", ""result"": {""value_trace"": [{""full_code"": ""*tbl_mode = NULL"", ""line"": 6272, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl_mode = &table_mode[level]"", ""line"": 6298, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl_mode = &table_mode[obuf->table_level]"", ""line"": 6408, ""func_name"": ""HTMLlineproc0""}], ""struct_var"": ""tbl_mode"", ""struct_type"": ""table_mode*"", ""struct_definition"": ""static struct table_mode\n\nstruct table_mode {\n    unsigned int pre_mode;\n    char indent_level;\n    char caption;\n    short nobr_offset;\n    char nobr_level;\n    short anchor_offset;\n    unsigned char end_tag;\n}""}}]","In 'HTMLlineproc0' (file.c:6303-6307, 6388), 'tbl_mode' and 'tbl' are dereferenced without null checks. 'tbl_mode' is assigned from 'table_mode[level]' (file.c:6298, 6408), and 'tbl' from 'tables[level]' (file.c:6297, 6407). If 'obuf->table_level' is valid (>=0) but 'table_mode' or 'tables' arrays are not initialized for that level, 'tbl_mode' or 'tbl' become NULL. Dereferencing them (e.g., 'tbl_mode->pre_mode') causes a segfault. The patch adds checks for 'tbl_mode' and 'tbl' being non-NULL.",0.95,./github/other_context/CVE-2016-9631
6,CVE-2017-14318,CWE-476,c_cpp,"An issue was discovered in Xen 4.5.x through 4.9.x. The function `__gnttab_cache_flush` handles GNTTABOP_cache_flush grant table operations. It checks to see if the calling domain is the owner of the page that is to be operated on. If it is not, the owner's grant table is checked to see if a grant mapping to the calling domain exists for the page in question. However, the function does not check to see if the owning domain actually has a grant table or not. Some special domains, such as `DOMID_XEN`, `DOMID_IO` and `DOMID_COW` are created without grant tables. Hence, if __gnttab_cache_flush operates on a page owned by these special domains, it will attempt to dereference a NULL pointer in the domain struct.",https://github.com/xen-project/xen/commit/c3d830b244998b3686e2eb64db95996be5eb5e5c,"grant_table: fix GNTTABOP_cache_flush handling\n\nDon't fall over a NULL grant_table pointer when the owner of the domain\nis a system domain (DOMID_{XEN,IO} etc).\n\nThis is CVE-2017-14318 / XSA-232.\n\nReported-by: Matthew Daley <mattd@bugfuzz.com>\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",1,"[{""func_name"": ""cache_flush"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static int cache_flush(gnttab_cache_flush_t *cflush, grant_ref_t *cur_ref)\n{\n    struct domain *d, *owner;\n    struct page_info *page;\n    unsigned long mfn;\n    void *v;\n    int ret;\n\n    if ( (cflush->offset >= PAGE_SIZE) ||\n         (cflush->length > PAGE_SIZE) ||\n         (cflush->offset + cflush->length > PAGE_SIZE) )\n        return -EINVAL;\n\n    if ( cflush->length == 0 || cflush->op == 0 )\n        return 0;\n\n    /* currently unimplemented */\n    if ( cflush->op & GNTTAB_CACHE_SOURCE_GREF )\n        return -EOPNOTSUPP;\n\n    if ( cflush->op & ~(GNTTAB_CACHE_INVAL|GNTTAB_CACHE_CLEAN) )\n        return -EINVAL;\n\n    d = rcu_lock_current_domain();\n    mfn = cflush->a.dev_bus_addr >> PAGE_SHIFT;\n\n    if ( !mfn_valid(_mfn(mfn)) )\n    {\n        rcu_unlock_domain(d);\n        return -EINVAL;\n    }\n\n    page = mfn_to_page(mfn);\n    owner = page_get_owner_and_reference(page);\n    if ( !owner )\n    {\n        rcu_unlock_domain(d);\n        return -EPERM;\n    }\n\n    if ( d != owner )\n    {\n        grant_read_lock(owner->grant_table);\n\n        ret = grant_map_exists(d, owner->grant_table, mfn, cur_ref);\n        if ( ret != 0 )\n        {\n            grant_read_unlock(owner->grant_table);\n            rcu_unlock_domain(d);\n            put_page(page);\n            return ret;\n        }\n    }\n\n    v = map_domain_page(_mfn(mfn));\n    v += cflush->offset;\n\n    if ( (cflush->op & GNTTAB_CACHE_INVAL) && (cflush->op & GNTTAB_CACHE_CLEAN) )\n        ret = clean_and_invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_INVAL )\n        ret = invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_CLEAN )\n        ret = clean_dcache_va_range(v, cflush->length);\n    else\n        ret = 0;\n\n    if ( d != owner )\n        grant_read_unlock(owner->grant_table);\n    unmap_domain_page(v);\n    put_page(page);\n\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""cache_flush"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static int cache_flush(gnttab_cache_flush_t *cflush, grant_ref_t *cur_ref)\n{\n    struct domain *d, *owner;\n    struct page_info *page;\n    unsigned long mfn;\n    void *v;\n    int ret;\n\n    if ( (cflush->offset >= PAGE_SIZE) ||\n         (cflush->length > PAGE_SIZE) ||\n         (cflush->offset + cflush->length > PAGE_SIZE) )\n        return -EINVAL;\n\n    if ( cflush->length == 0 || cflush->op == 0 )\n        return 0;\n\n    /* currently unimplemented */\n    if ( cflush->op & GNTTAB_CACHE_SOURCE_GREF )\n        return -EOPNOTSUPP;\n\n    if ( cflush->op & ~(GNTTAB_CACHE_INVAL|GNTTAB_CACHE_CLEAN) )\n        return -EINVAL;\n\n    d = rcu_lock_current_domain();\n    mfn = cflush->a.dev_bus_addr >> PAGE_SHIFT;\n\n    if ( !mfn_valid(_mfn(mfn)) )\n    {\n        rcu_unlock_domain(d);\n        return -EINVAL;\n    }\n\n    page = mfn_to_page(mfn);\n    owner = page_get_owner_and_reference(page);\n    if ( !owner || !owner->grant_table )\n    {\n        rcu_unlock_domain(d);\n        return -EPERM;\n    }\n\n    if ( d != owner )\n    {\n        grant_read_lock(owner->grant_table);\n\n        ret = grant_map_exists(d, owner->grant_table, mfn, cur_ref);\n        if ( ret != 0 )\n        {\n            grant_read_unlock(owner->grant_table);\n            rcu_unlock_domain(d);\n            put_page(page);\n            return ret;\n        }\n    }\n\n    v = map_domain_page(_mfn(mfn));\n    v += cflush->offset;\n\n    if ( (cflush->op & GNTTAB_CACHE_INVAL) && (cflush->op & GNTTAB_CACHE_CLEAN) )\n        ret = clean_and_invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_INVAL )\n        ret = invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_CLEAN )\n        ret = clean_dcache_va_range(v, cflush->length);\n    else\n        ret = 0;\n\n    if ( d != owner )\n        grant_read_unlock(owner->grant_table);\n    unmap_domain_page(v);\n    put_page(page);\n\n    return ret;\n}""}]",{},[],"The code in `cache_flush` did not verify if `owner->grant_table` was non-NULL before using it. The patch adds this check at xen/common/grant_table.c:3047, ensuring domains without grant tables (e.g., system domains) are handled safely.",0.95,./github/other_context/CVE-2017-14318
7,CVE-2017-14625,CWE-476,c_cpp,ImageMagick 7.0.7-0 Q16 has a NULL Pointer Dereference vulnerability in the function sixel_output_create in coders/sixel.c.,https://github.com/ImageMagick/ImageMagick/commit/cc797c296c30f3ec31cd02418b58a2c27549b0a9,https://github.com/ImageMagick/ImageMagick/issues/721,2,"[{""func_name"": ""WriteSIXELImage"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""static MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256 * 3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n  exception=(&image->exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  opacity=(-1);\n  if (image->matte == MagickFalse)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelMatteType);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].opacity != OpaqueOpacity)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=(MagickRealType) image->colormap[i].opacity;\n            beta=(MagickRealType) image->colormap[opacity].opacity;\n            if (alpha > beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelMatteType);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].opacity != OpaqueOpacity)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=(MagickRealType) image->colormap[i].opacity;\n                beta=(MagickRealType) image->colormap[opacity].opacity;\n                if (alpha > beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[i * 3 + 0] = ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[i * 3 + 1] = ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[i * 3 + 2] = ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  sixel_pixels =(unsigned char *) AcquireQuantumMemory(image->columns , image->rows);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    (void) GetVirtualPixels(image,0,y,image->columns,1,exception);\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n      sixel_pixels[y * image->columns + x] = (unsigned char) ((ssize_t) GetPixelIndex(indexes + x));\n  }\n  status = sixel_encode_impl(sixel_pixels, image->columns, image->rows,\n                          sixel_palette, image->colors, -1,\n                          output);\n  sixel_pixels =(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output = (sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}"", ""target"": 0}, {""func_name"": ""sixel_output_create"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""sixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n    output->node_free = NULL;\n    output->image = image;\n    output->pos = 0;\n\n    return output;\n}"", ""target"": 0}]","[{""func_name"": ""WriteSIXELImage"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""static MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256 * 3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n  exception=(&image->exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  opacity=(-1);\n  if (image->matte == MagickFalse)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelMatteType);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].opacity != OpaqueOpacity)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=(MagickRealType) image->colormap[i].opacity;\n            beta=(MagickRealType) image->colormap[opacity].opacity;\n            if (alpha > beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelMatteType);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].opacity != OpaqueOpacity)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=(MagickRealType) image->colormap[i].opacity;\n                beta=(MagickRealType) image->colormap[opacity].opacity;\n                if (alpha > beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[i * 3 + 0] = ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[i * 3 + 1] = ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[i * 3 + 2] = ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  if (output == (sixel_output_t *) NULL)\n    ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n  sixel_pixels =(unsigned char *) AcquireQuantumMemory(image->columns,\n    image->rows*sizeof(*sixel_pixels));\n  if (sixel_pixels == (unsigned char *) NULL)\n    {\n      output = (sixel_output_t *) RelinquishMagickMemory(output);\n      ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const PixelPacket\n      *p;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n      sixel_pixels[y*image->columns+x]=(unsigned char)\n        ((ssize_t) GetPixelIndex(indexes+x));\n  }\n  status = sixel_encode_impl(sixel_pixels, image->columns, image->rows,\n    sixel_palette, image->colors, -1, output);\n  sixel_pixels =(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output = (sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}""}, {""func_name"": ""sixel_output_create"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""sixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    if (output == (sixel_output_t *) NULL)\n      return((sixel_output_t *) NULL);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n    output->node_free = NULL;\n    output->image = image;\n    output->pos = 0;\n\n    return output;\n}""}]","{""code"": 1, ""function"": 2}","[{""source"": ""code_info(file:sixel.c, lines:545-555)"", ""result"": ""}\n\nsixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n""}, {""source"": ""func_info(func:AcquireQuantumMemory)"", ""result"": [{""code"": ""void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}"", ""start_line"": 530, ""end_line"": 539, ""full_name"": ""AcquireQuantumMemory"", ""file_path"": ""magick/memory.c""}]}, {""source"": ""func_info(func:GetVirtualPixels)"", ""result"": [{""code"": ""const PixelPacket *GetVirtualPixels(const Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixel_handler !=\n       (GetVirtualPixelHandler) NULL)\n    return(cache_info->methods.get_virtual_pixel_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,columns,rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    columns,rows,cache_info->nexus_info[id],exception));\n}"", ""start_line"": 3423, ""end_line"": 3445, ""full_name"": ""GetVirtualPixels"", ""file_path"": ""magick/cache.c""}]}]","1. In coders/sixel.c:550, sixel_output_create calls AcquireQuantumMemory without checking if the returned 'output' is NULL. 2. AcquireQuantumMemory (memory.c:530-539) returns NULL on allocation failure (e.g., memory exhaustion). 3. Unchecked 'output' is used in coders/sixel.c:1294-1297 in WriteSIXELImage, leading to dereference in sixel_encode_impl when 'output' is NULL. 4. Original code lacked validation for GetVirtualPixels (cache.c:3423-3445) and memory allocation failures in sixel_pixels.",0.95,./github/other_context/CVE-2017-14625
8,CVE-2017-7274,CWE-476,c_cpp,The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file.,https://github.com/radareorg/radare2/commit/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf,Fix #7152 - Null deref in cms,1,"[{""func_name"": ""r_pkcs7_parse_cms"", ""file_path"": ""libr/util/r_pkcs7.c"", ""func_code"": ""RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}"", ""target"": 0}]","[{""func_name"": ""r_pkcs7_parse_cms"", ""file_path"": ""libr/util/r_pkcs7.c"", ""func_code"": ""RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}""}]","{""function"": 1, ""value"": 2, ""code"": 1}","[{""source"": ""func_info(func:r_asn1_create_object)"", ""result"": [{""code"": ""RASN1Object *r_asn1_create_object (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object = asn1_parse_header (buffer, length);\n\tif (object && (object->form == FORM_CONSTRUCTED || object->tag == TAG_BITSTRING || object->tag == TAG_OCTETSTRING)) {\n\t\tut32 i, count;\n\t\tRASN1Object *inner = NULL;\n\t\tconst ut8 *next = object->sector;\n\t\tconst ut8 *end = next + object->length;\n\t\tif (end > buffer + length) {\n\t\t\tfree (object);\n\t\t\treturn NULL;\n\t\t}\n\t\tcount = r_asn1_count_objects (object->sector, object->length);\n\t\tif (count > 0) {\n\t\t\tobject->list.length = count;\n\t\t\tobject->list.objects = R_NEWS0 (RASN1Object*, count);\n\t\t\tif (!object->list.objects) {\n\t\t\t\tr_asn1_free_object (object);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i = 0; next >= buffer && next < end && i < count; ++i) {\n\t\t\t\tinner = r_asn1_create_object (next, end - next);\n\t\t\t\tif (!inner || next == inner->sector) {\n\t\t\t\t\tr_asn1_free_object (inner);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext = inner->sector + inner->length;\n\t\t\t\tR_PTR_MOVE (object->list.objects[i], in..."", ""start_line"": 398, ""end_line"": 429, ""full_name"": ""r_asn1_create_object"", ""file_path"": ""libr/util/r_asn1.c""}]}, {""source"": ""value_info(file:r_pkcs7.c, value:object->list.objects)"", ""result"": {""value_trace"": [{""full_code"": ""object->list.objects = NULL"", ""line"": 444, ""func_name"": ""r_asn1_free_object""}], ""struct_var"": ""object"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:r_asn1.c, lines:430-450)"", ""result"": ""\nvoid r_asn1_free_object (RASN1Object *object) {\n\tut32 i;\n\tif (!object) {\n\t\treturn;\n\t}\n\t//this shall not be freed. it's a pointer into the buffer.\n\tobject->sector = 0;\n\tif (object->list.objects) {\n\t\tfor (i = 0; i < object->list.length; ++i) {\n\t\t\tr_asn1_free_object (object->list.objects[i]);\n\t\t}\n\t\tR_FREE (object->list.objects);\n\t}\n\tobject->list.objects = NULL;\n\tobject->list.length = 0;\n\tR_FREE (object);\n}\n\nvoid r_asn1_free_string (RASN1String* str) {\n\tif (str) {\n\t\tif (str->allocated) {\n""}, {""source"": ""value_info(file:r_asn1.c, value:object->list)"", ""result"": {""value_trace"": [{""full_code"": ""object->list.length = count"", ""line"": 411, ""func_name"": ""r_asn1_create_object""}, {""full_code"": ""object->list.objects = NULL"", ""line"": 444, ""func_name"": ""r_asn1_free_object""}, {""full_code"": ""object->list.length = 0"", ""line"": 445, ""func_name"": ""r_asn1_free_object""}], ""struct_var"": ""object"", ""struct_type"": null, ""struct_definition"": null}}]","libr/util/r_pkcs7.c:285-287: The original code assumes object->list.objects[0]/[1] are non-NULL. In libr/util/r_asn1.c:398-429, r_asn1_create_object allocates object->list.objects via R_NEWS0 (zero-initialized) but may break early during inner object creation (e.g., if 'inner' is NULL). This leaves object->list.objects[1] as NULL when count=2. Accessing object->list.objects[1]->list.length without validating the pointer causes a NULL dereference. The 'list' structure (libr/util/r_asn1.c) contains 'length' and 'objects' members, with 'objects' being an array of RASN1Object* that may contain NULL entries in error cases.",0.95,./github/other_context/CVE-2017-7274
9,CVE-2017-7453,"CWE-476, CWE-125",c_cpp,The iwgif_record_pixel function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.,https://github.com/jsummers/imageworsener/commit/dc74009a3cbcbc51dd29b3856043754d3c107449,"Fixed a GIF decoding bug (buffer overrun)\n\nFixes issues #9, #11",2,"[{""func_name"": ""iwgif_read_image"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int iwgif_read_image(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tstruct lzwdeccontext d;\n\tsize_t subblocksize;\n\tint has_local_ct;\n\tint local_ct_size;\n\n\tunsigned int root_codesize;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\trctx->image_left = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->image_top = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// image_left and _top may be updated in iwgif_init_screen().\n\n\trctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);\n\trctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);\n\n\trctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+local_ct_size);\n\t}\n\n\tif(has_local_ct) {\n\t\t// We only support one image, so we don't need to keep both a global and a\n\t\t// local color table. If an image has both, the local table will overwrite\n\t\t// the global one.\n\t\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\t}\n\n\t// Make the transparent color transparent.\n\tif(rctx->has_transparency) {\n\t    rctx->colortable.entry[rctx->trans_color_index].a = 0;\n\t}\n\n\t// Read LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\troot_codesize = (unsigned int)rctx->rbuf[0];\n\n\t// The spec does not allow the \""minimum code size\"" to be less than 2.\n\t// Sizes >=12 are impossible to support.\n\t// There's no reason for the size to be larger than 8, but the spec\n\t// does not seem to forbid it.\n\tif(root_codesize<2 || root_codesize>11) {\n\t\tiw_set_error(rctx->ctx,\""Invalid LZW minimum code size\"");\n\t\tgoto done;\n\t}\n\n\t// The creation of the global \""screen\"" was deferred until now, to wait until\n\t// we know whether the image has transparency.\n\t// (And if !rctx->include_screen, to wait until we know the size of the image.)\n\tif(!iwgif_init_screen(rctx)) goto done;\n\n\trctx->total_npixels = rctx->image_width * rctx->image_height;\n\n\tif(!iwgif_make_row_pointers(rctx)) goto done;\n\n\tlzw_init(&d,root_codesize);\n\tlzw_clear(&d);\n\n\twhile(1) {\n\t\t// Read size of next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\t\tsubblocksize = (size_t)rctx->rbuf[0];\n\t\tif(subblocksize==0) break;\n\n\t\t// Read next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,subblocksize)) goto done;\n\t\tif(!lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)) goto done;\n\n\t\tif(d.eoi_flag) break;\n\n\t\t// Stop if we reached the end of the image. We don't care if we've read an\n\t\t// EOI code or not.\n\t\tif(rctx->pixels_set >= rctx->total_npixels) break;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}"", ""target"": 0}, {""func_name"": ""iwgif_record_pixel"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs /*,ys*/; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\t// ys = rctx->image_top + yi;\n\n\t// Check if the x-coordinate is on the screen.\n\tif(xs>=(size_t)rctx->screen_width) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""iwgif_read_image"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int iwgif_read_image(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tstruct lzwdeccontext d;\n\tsize_t subblocksize;\n\tint has_local_ct;\n\tint local_ct_size;\n\n\tunsigned int root_codesize;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\trctx->image_left = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->image_top = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// image_left and _top may be updated in iwgif_init_screen().\n\n\trctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);\n\trctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);\n\n\trctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+local_ct_size);\n\t}\n\n\tif(has_local_ct) {\n\t\t// We only support one image, so we don't need to keep both a global and a\n\t\t// local color table. If an image has both, the local table will overwrite\n\t\t// the global one.\n\t\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\t}\n\n\t// Make the transparent color transparent.\n\tif(rctx->has_transparency) {\n\t    rctx->colortable.entry[rctx->trans_color_index].a = 0;\n\t}\n\n\t// Read LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\troot_codesize = (unsigned int)rctx->rbuf[0];\n\n\t// The spec does not allow the \""minimum code size\"" to be less than 2.\n\t// Sizes >=12 are impossible to support.\n\t// There's no reason for the size to be larger than 8, but the spec\n\t// does not seem to forbid it.\n\tif(root_codesize<2 || root_codesize>11) {\n\t\tiw_set_error(rctx->ctx,\""Invalid LZW minimum code size\"");\n\t\tgoto done;\n\t}\n\n\t// The creation of the global \""screen\"" was deferred until now, to wait until\n\t// we know whether the image has transparency.\n\t// (And if !rctx->include_screen, to wait until we know the size of the image.)\n\tif(!iwgif_init_screen(rctx)) goto done;\n\n\trctx->total_npixels = (size_t)rctx->image_width * (size_t)rctx->image_height;\n\n\tif(!iwgif_make_row_pointers(rctx)) goto done;\n\n\tlzw_init(&d,root_codesize);\n\tlzw_clear(&d);\n\n\twhile(1) {\n\t\t// Read size of next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\t\tsubblocksize = (size_t)rctx->rbuf[0];\n\t\tif(subblocksize==0) break;\n\n\t\t// Read next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,subblocksize)) goto done;\n\t\tif(!lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)) goto done;\n\n\t\tif(d.eoi_flag) break;\n\n\t\t// Stop if we reached the end of the image. We don't care if we've read an\n\t\t// EOI code or not.\n\t\tif(rctx->pixels_set >= rctx->total_npixels) break;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}""}, {""func_name"": ""iwgif_record_pixel"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs,ys; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\tys = rctx->image_top + yi;\n\n\t// Make sure the coordinate is within the image, and on the screen.\n\tif(yi>=(size_t)rctx->image_height) return;\n\tif(xs>=(size_t)rctx->screen_width) return;\n\tif(ys>=(size_t)rctx->screen_height) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}""}]","{""code"": 3, ""value"": 3}","[{""source"": ""code_info(file:imagew-gif.c, lines:220-230)"", ""result"": ""\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n""}, {""source"": ""value_info(file:imagew-gif.c, value:ptr)"", ""result"": {""value_trace"": [{""full_code"": ""ptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi]"", ""line"": 239, ""func_name"": ""iwgif_record_pixel""}], ""struct_var"": ""ptr"", ""struct_type"": ""uint8_t*"", ""struct_definition"": ""uint8_t""}}, {""source"": ""value_info(file:imagew-gif.c, value:img)"", ""result"": {""value_trace"": [{""full_code"": ""img = rctx->img"", ""line"": 208, ""func_name"": ""iwgif_record_pixel""}, {""full_code"": ""img = rctx->img"", ""line"": 457, ""func_name"": ""iwgif_init_screen""}, {""full_code"": ""img = rctx->img"", ""line"": 522, ""func_name"": ""iwgif_make_row_pointers""}], ""struct_var"": ""img"", ""struct_type"": ""iw_image*"", ""struct_definition"": ""struct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image {\n\tint imgtype;  // IW_IMGTYPE_*\n\tint bit_depth;\n\tint sampletype; // IW_SAMPLETYPE_*\n\n\t// This is the logical width and height, which does not necessarily\n\t// indicate the order of the pixels in ->pixels.\n\t// (The order is indicated by ->orient_transform.)\n\tint width, height;\n\n\t// Caution: Multi-byte samples with an integer data type use big-endian\n\t// byte order, while floating-point samples use the native byte order of\n\t// the host system (usually little-endian).\n\tiw_byte *pixels;\n\tsize_t bpr; // bytes per row\n\n\t// Describes orientation transformations that need to be made to the\n\t// pixels.\n\t// Used with input images only.\n\tunsigned int orient_transform;\n\n\tint native_grayscale; // For input images: Was the image encoded as grayscale?\n\tint density_code; // IW_DENSITY_*\n\tdouble density_x, density_y;\n\tint has_colorkey_trns;\n\tunsigned int colorkey[3]; // Indexed by IW_CHANNELTYPE_[RED..BLUE]\n\tint reduced_maxcolors;\n\tunsigned int maxcolorcode[5];  // Indexed by IW_CHAN...""}}, {""source"": ""code_info(file:imagew-gif.c, lines:522-540)"", ""result"": ""\timg = rctx->img;\n\n\tif(rctx->interlaced) {\n\t\t// Image is interlaced. Rearrange the row pointers, so that it will be\n\t\t// de-interlaced as it is decoded.\n\t\trowcount=0;\n\t\tfor(pass=1;pass<=4;pass++) {\n\t\t\tif(pass==1) { startrow=0; rowskip=8; }\n\t\t\telse if(pass==2) { startrow=4; rowskip=8; }\n\t\t\telse if(pass==3) { startrow=2; rowskip=4; }\n\t\t\telse { startrow=1; rowskip=2; }\n\n\t\t\tfor(row=startrow;row<rctx->image_height;row+=rowskip) {\n\t\t\t\tif(rctx->image_top+row < rctx->screen_height) {\n\t\t\t\t\trctx->row_pointers[rowcount] = &img->pixels[(rctx->image_top+row)*img->bpr + (rctx->image_left)*rctx->bytes_per_pixel];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trctx->row_pointers[rowcount] = NULL;\n\t\t\t\t}\n\t\t\t\trowcount++;\n""}, {""source"": ""value_info(file:imagew-gif.c, value:rctx->row_pointers)"", ""result"": {""value_trace"": [{""full_code"": ""rctx->row_pointers = (iw_byte**)iw_malloc(rctx->ctx, sizeof(iw_byte*)*rctx->image_height)"", ""line"": 519, ""func_name"": ""iwgif_make_row_pointers""}], ""struct_var"": ""rctx"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:imagew-gif.c, lines:239-245)"", ""result"": ""\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}\n\n////////////////////////////////////////////////////////\n""}]","In src/imagew-gif.c:iwgif_record_pixel, coordinates (yi, xs, ys) derived from GIF data were not validated against image/screen dimensions before being used to index into rctx->row_pointers (src/imagew-gif.c:214-216). This allowed out-of-bounds memory access via ptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi] (src/imagew-gif.c:239). The patch adds bounds checks for yi, xs, and ys (src/imagew-gif.c:214-216) and prevents overflow in total_npixels calculation (src/imagew-gif.c:652).",0.95,./github/other_context/CVE-2017-7453
10,CVE-2018-16428,CWE-476,c_cpp,"In GNOME GLib 2.56.1, g_markup_parse_context_end_parse() in gmarkup.c has a NULL pointer dereference.",https://github.com/GNOME/glib/commit/fccef3cc822af74699cca84cd202719ae61ca3b9,"gmarkup: Fix crash in error handling path for closing elements\n\nIf something which looks like a closing tag is left unfinished, but\nisn’t paired to an opening tag in the document, the error handling code\nwould do a null pointer dereference. Avoid that, at the cost of\nintroducing a new translatable error message.\n\nIncludes a test case, courtesy of pdknsk.\n\nSigned-off-by: Philip Withnall <withnall@endlessm.com>\n\nhttps://gitlab.gnome.org/GNOME/glib/issues/1461",1,"[{""func_name"": ""g_markup_parse_context_end_parse"", ""file_path"": ""glib/gmarkup.c"", ""func_code"": ""gboolean\ng_markup_parse_context_end_parse (GMarkupParseContext  *context,\n                                  GError              **error)\n{\n  g_return_val_if_fail (context != NULL, FALSE);\n  g_return_val_if_fail (!context->parsing, FALSE);\n  g_return_val_if_fail (context->state != STATE_ERROR, FALSE);\n\n  if (context->partial_chunk != NULL)\n    {\n      g_string_free (context->partial_chunk, TRUE);\n      context->partial_chunk = NULL;\n    }\n\n  if (context->document_empty)\n    {\n      set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,\n                         _(\""Document was empty or contained only whitespace\""));\n      return FALSE;\n    }\n\n  context->parsing = TRUE;\n\n  switch (context->state)\n    {\n    case STATE_START:\n      /* Nothing to do */\n      break;\n\n    case STATE_AFTER_OPEN_ANGLE:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly just after an open angle bracket \u201c<\u201d\""));\n      break;\n\n    case STATE_AFTER_CLOSE_ANGLE:\n      if (context->tag_stack != NULL)\n        {\n          /* Error message the same as for INSIDE_TEXT */\n          set_error (context, error, G_MARKUP_ERROR_PARSE,\n                     _(\""Document ended unexpectedly with elements still open \u2014 \""\n                       \""\u201c%s\u201d was the last element opened\""),\n                     current_element (context));\n        }\n      break;\n\n    case STATE_AFTER_ELISION_SLASH:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly, expected to see a close angle \""\n                   \""bracket ending the tag <%s/>\""), current_element (context));\n      break;\n\n    case STATE_INSIDE_OPEN_TAG_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element name\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_NAME:\n    case STATE_AFTER_ATTRIBUTE_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an attribute name\""));\n      break;\n\n    case STATE_BETWEEN_ATTRIBUTES:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element-opening \""\n                           \""tag.\""));\n      break;\n\n    case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly after the equals sign \""\n                           \""following an attribute name; no attribute value\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:\n    case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly while inside an attribute \""\n                           \""value\""));\n      break;\n\n    case STATE_INSIDE_TEXT:\n      g_assert (context->tag_stack != NULL);\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly with elements still open \u2014 \""\n                   \""\u201c%s\u201d was the last element opened\""),\n                 current_element (context));\n      break;\n\n    case STATE_AFTER_CLOSE_TAG_SLASH:\n    case STATE_INSIDE_CLOSE_TAG_NAME:\n    case STATE_AFTER_CLOSE_TAG_NAME:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly inside the close tag for \""\n                   \""element \u201c%s\u201d\""), current_element (context));\n      break;\n\n    case STATE_INSIDE_PASSTHROUGH:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside a comment or \""\n                           \""processing instruction\""));\n      break;\n\n    case STATE_ERROR:\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  context->parsing = FALSE;\n\n  return context->state != STATE_ERROR;\n}"", ""target"": 0}]","[{""func_name"": ""g_markup_parse_context_end_parse"", ""file_path"": ""glib/gmarkup.c"", ""func_code"": ""gboolean\ng_markup_parse_context_end_parse (GMarkupParseContext  *context,\n                                  GError              **error)\n{\n  g_return_val_if_fail (context != NULL, FALSE);\n  g_return_val_if_fail (!context->parsing, FALSE);\n  g_return_val_if_fail (context->state != STATE_ERROR, FALSE);\n\n  if (context->partial_chunk != NULL)\n    {\n      g_string_free (context->partial_chunk, TRUE);\n      context->partial_chunk = NULL;\n    }\n\n  if (context->document_empty)\n    {\n      set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,\n                         _(\""Document was empty or contained only whitespace\""));\n      return FALSE;\n    }\n\n  context->parsing = TRUE;\n\n  switch (context->state)\n    {\n    case STATE_START:\n      /* Nothing to do */\n      break;\n\n    case STATE_AFTER_OPEN_ANGLE:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly just after an open angle bracket \u201c<\u201d\""));\n      break;\n\n    case STATE_AFTER_CLOSE_ANGLE:\n      if (context->tag_stack != NULL)\n        {\n          /* Error message the same as for INSIDE_TEXT */\n          set_error (context, error, G_MARKUP_ERROR_PARSE,\n                     _(\""Document ended unexpectedly with elements still open \u2014 \""\n                       \""\u201c%s\u201d was the last element opened\""),\n                     current_element (context));\n        }\n      break;\n\n    case STATE_AFTER_ELISION_SLASH:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly, expected to see a close angle \""\n                   \""bracket ending the tag <%s/>\""), current_element (context));\n      break;\n\n    case STATE_INSIDE_OPEN_TAG_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element name\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_NAME:\n    case STATE_AFTER_ATTRIBUTE_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an attribute name\""));\n      break;\n\n    case STATE_BETWEEN_ATTRIBUTES:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element-opening \""\n                           \""tag.\""));\n      break;\n\n    case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly after the equals sign \""\n                           \""following an attribute name; no attribute value\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:\n    case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly while inside an attribute \""\n                           \""value\""));\n      break;\n\n    case STATE_INSIDE_TEXT:\n      g_assert (context->tag_stack != NULL);\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly with elements still open \u2014 \""\n                   \""\u201c%s\u201d was the last element opened\""),\n                 current_element (context));\n      break;\n\n    case STATE_AFTER_CLOSE_TAG_SLASH:\n    case STATE_INSIDE_CLOSE_TAG_NAME:\n    case STATE_AFTER_CLOSE_TAG_NAME:\n      if (context->tag_stack != NULL)\n        set_error (context, error, G_MARKUP_ERROR_PARSE,\n                   _(\""Document ended unexpectedly inside the close tag for \""\n                     \""element \u201c%s\u201d\""), current_element (context));\n      else\n        set_error (context, error, G_MARKUP_ERROR_PARSE,\n                   _(\""Document ended unexpectedly inside the close tag for an \""\n                     \""unopened element\""));\n      break;\n\n    case STATE_INSIDE_PASSTHROUGH:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside a comment or \""\n                           \""processing instruction\""));\n      break;\n\n    case STATE_ERROR:\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  context->parsing = FALSE;\n\n  return context->state != STATE_ERROR;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:gmarkup.c, func:current_element)"", ""result"": [{""code"": ""static inline const gchar*\ncurrent_element (GMarkupParseContext *context)\n{\n  return context->tag_stack->data;\n}"", ""start_line"": 890, ""end_line"": 894, ""full_name"": ""current_element"", ""file_path"": ""glib/gmarkup.c""}]}]","Original code: glib/gmarkup.c:1845-1847: `current_element(context)` is called without checking if `context->tag_stack` is NULL. `current_element` (glib/gmarkup.c:890-894) dereferences `context->tag_stack->data`, causing a crash if `tag_stack` is NULL. The patch (glib/gmarkup.c:1845-1855) adds a NULL check, confirming the vulnerability arises from unvalidated access to `tag_stack`.",0.95,./github/other_context/CVE-2018-16428
11,CVE-2018-15861,CWE-476,c_cpp,Unchecked NULL pointer usage in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file that triggers an xkb_intern_atom failure.,https://github.com/xkbcommon/libxkbcommon/commit/38e1766bc6e20108948aec8a0b222a4bad0254e9,"xkbcomp: Don't falsely promise from ExprResolveLhs\n\nEvery user of ExprReturnLhs goes on to unconditionally dereference the\nfield return, which can be NULL if xkb_intern_atom fails. Return false\nif this is the case, so we fail safely.\n\ntestcase: splice geometry data into interp\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>",1,"[{""func_name"": ""ExprResolveLhs"", ""file_path"": ""src/xkbcomp/expr.c"", ""func_code"": ""bool\nExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \""Unexpected operator %d in ResolveLhs\\n\"", expr->expr.op);\n    return false;\n}"", ""target"": 0}]","[{""func_name"": ""ExprResolveLhs"", ""file_path"": ""src/xkbcomp/expr.c"", ""func_code"": ""bool\nExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \""Unexpected operator %d in ResolveLhs\\n\"", expr->expr.op);\n    return false;\n}""}]","{""function"": 6, ""code"": 6, ""caller"": 1}","[{""source"": ""func_info(func:xkb_atom_text)"", ""result"": [{""code"": ""const char *\nxkb_atom_text(struct xkb_context *ctx, xkb_atom_t atom)\n{\n    return atom_text(ctx->atom_table, atom);\n}"", ""start_line"": 70, ""end_line"": 74, ""full_name"": ""xkb_atom_text"", ""file_path"": ""src/context-priv.c""}]}, {""source"": ""code_info(file:expr.c, lines:43-50)"", ""result"": ""        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n""}, {""source"": ""caller_info(file:expr.c, func:ExprResolveLhs)"", ""result"": [{""call_line"": 829, ""call_code"": ""ExprResolveLhs(ctx, field, &elemRtrn, &fieldRtrn, &arrayRtrn)"", ""caller_code"": ""bool\nHandleActionDef(struct xkb_context *ctx, ActionsInfo *info,\n                const struct xkb_mod_set *mods, ExprDef *def,\n                union xkb_action *action)\n{\n    ExprDef *arg;\n    const char *str;\n    enum xkb_action_type handler_type;\n\n    if (def->expr.op != EXPR_ACTION_DECL) {\n        log_err(ctx, \""Expected an action definition, found %s\\n\"",\n                expr_op_type_to_string(def->expr.op));\n        return false;\n    }\n\n    str = xkb_atom_text(ctx, def->action.name);\n    if (!stringToAction(str, &handler_type)) {\n        log_err(ctx, \""Unknown action %s\\n\"", str);\n        return false;\n    }\n\n    /*\n     * Get the default values for this action type, as modified by\n     * statements such as:\n     *     latchMods.clearLocks = True;\n     */\n    *action = info->actions[handler_type];\n\n    /*\n     * Now change the action properties as specified for this\n     * particular instance, e.g. \""modifiers\"" and \""clearLocks\"" in:\n     *     SetMods(modifiers=Alt,clearLocks);\n     ..."", ""caller_start"": 776, ""file_path"": ""src/xkbcomp/action.c""}, {""call_line"": 636, ""call_code"": ""ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx)"", ""caller_code"": ""static bool\nHandleGlobalVar(CompatInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *ndx;\n    bool ret;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx))\n        ret = false;\n    else if (elem && istreq(elem, \""interpret\""))\n        ret = SetInterpField(info, &info->default_interp, field, ndx,\n                             stmt->value);\n    else if (elem && istreq(elem, \""indicator\""))\n        ret = SetLedMapField(info, &info->default_led, field, ndx,\n                             stmt->value);\n    else\n        ret = SetActionField(info->ctx, info->actions, &info->mods,\n                             elem, field, ndx, stmt->value);\n    return ret;\n}"", ""caller_start"": 629, ""file_path"": ""src/xkbcomp/compat.c""}, {""call_line"": 666, ""call_code"": ""ExprResolveLhs(info->ctx, def->name, &elem, &field, &arrayNdx)"", ""caller_code"": ""static bool\nHandleInterpBody(CompatInfo *info, VarDef *def, SymInterpInfo *si)\n{\n    bool ok = true;\n    const char *elem, *field;\n    ExprDef *arrayNdx;\n\n    for (; def; def = (VarDef *) def->common.next) {\n        if (def->name && def->name->expr.op == EXPR_FIELD_REF) {\n            log_err(info->ctx,\n                    \""Cannot set a global default value from within an interpret statement; \""\n                    \""Move statements to the global file scope\\n\"");\n            ok = false;\n            continue;\n        }\n\n        ok = ExprResolveLhs(info->ctx, def->name, &elem, &field, &arrayNdx);\n        if (!ok)\n            continue;\n\n        ok = SetInterpField(info, si, field, arrayNdx, def->value);\n    }\n\n    return ok;\n}"", ""caller_start"": 650, ""file_path"": ""src/xkbcomp/compat.c""}, {""call_line"": 727, ""call_code"": ""ExprResolveLhs(info->ctx, var->name, &elem, &field, &arrayNdx)"", ""caller_code"": ""static bool\nHandleLedMapDef(CompatInfo *info, LedMapDef *def, enum merge_mode merge)\n{\n    LedInfo ledi;\n    VarDef *var;\n    bool ok;\n\n    if (def->merge != MERGE_DEFAULT)\n        merge = def->merge;\n\n    ledi = info->default_led;\n    ledi.merge = merge;\n    ledi.led.name = def->name;\n\n    ok = true;\n    for (var = def->body; var != NULL; var = (VarDef *) var->common.next) {\n        const char *elem, *field;\n        ExprDef *arrayNdx;\n        if (!ExprResolveLhs(info->ctx, var->name, &elem, &field, &arrayNdx)) {\n            ok = false;\n            continue;\n        }\n\n        if (elem) {\n            log_err(info->ctx,\n                    \""Cannot set defaults for \\\""%s\\\"" element in indicator map; \""\n                    \""Assignment to %s.%s ignored\\n\"", elem, elem, field);\n            ok = false;\n        }\n        else {\n            ok = SetLedMapField(info, &ledi, field, arrayNdx, var->value) && ok;\n        }\n    }\n\n    if (ok)\n        return AddLedMap(info, &ledi, true);\n\n    return f..."", ""caller_start"": 709, ""file_path"": ""src/xkbcomp/compat.c""}]}, {""source"": ""code_info(file:expr.c, lines:100-200)"", ""result"": ""    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n\n    if (istreq(str, \""all\"")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \""none\"")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}\n\nbool\nExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \""Found constant of type %s where boolean was expected\\n\"",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \""true\"") ||\n                istreq(ident, \""yes\"") ||\n                istreq(ident, \""on\"")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \""false\"") ||\n                     istreq(ident, \""no\"") ||\n                     istreq(ident, \""off\"")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \""Identifier \\\""%s\\\"" of type boolean is unknown\\n\"", ident);\n        return false;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \""Default \\\""%s.%s\\\"" of type boolean is unknown\\n\"",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \""%s of boolean values not permitted\\n\"",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n\n    default:\n        log_wsgo(ctx, \""Unknown operator %d in ResolveBoolean\\n\"",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveKeyCode(struct xkb_context *ctx, const ExprDef *expr,\n                   xkb_keycode_t *kc)\n{\n    xkb_keycode_t leftRtrn, rightRtrn;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n""}, {""source"": ""code_info(file:action.c, lines:776-800)"", ""result"": ""bool\nHandleActionDef(struct xkb_context *ctx, ActionsInfo *info,\n                const struct xkb_mod_set *mods, ExprDef *def,\n                union xkb_action *action)\n{\n    ExprDef *arg;\n    const char *str;\n    enum xkb_action_type handler_type;\n\n    if (def->expr.op != EXPR_ACTION_DECL) {\n        log_err(ctx, \""Expected an action definition, found %s\\n\"",\n                expr_op_type_to_string(def->expr.op));\n        return false;\n    }\n\n    str = xkb_atom_text(ctx, def->action.name);\n    if (!stringToAction(str, &handler_type)) {\n        log_err(ctx, \""Unknown action %s\\n\"", str);\n        return false;\n    }\n\n    /*\n     * Get the default values for this action type, as modified by\n     * statements such as:\n     *     latchMods.clearLocks = True;\n     */\n""}, {""source"": ""code_info(file:compat.c, lines:629-650)"", ""result"": ""static bool\nHandleGlobalVar(CompatInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *ndx;\n    bool ret;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx))\n        ret = false;\n    else if (elem && istreq(elem, \""interpret\""))\n        ret = SetInterpField(info, &info->default_interp, field, ndx,\n                             stmt->value);\n    else if (elem && istreq(elem, \""indicator\""))\n        ret = SetLedMapField(info, &info->default_led, field, ndx,\n                             stmt->value);\n    else\n        ret = SetActionField(info->ctx, info->actions, &info->mods,\n                             elem, field, ndx, stmt->value);\n    return ret;\n}\n\nstatic bool\nHandleInterpBody(CompatInfo *info, VarDef *def, SymInterpInfo *si)\n""}, {""source"": ""func_info(file:action.c, func:SetActionField)"", ""result"": [{""code"": ""bool\nSetActionField(struct xkb_context *ctx, ActionsInfo *info,\n               struct xkb_mod_set *mods, const char *elem,\n               const char *field, ExprDef *array_ndx, ExprDef *value)\n{\n    enum xkb_action_type action;\n    enum action_field action_field;\n\n    if (!stringToAction(elem, &action))\n        return false;\n\n    if (!stringToField(field, &action_field)) {\n        log_err(ctx, \""\\\""%s\\\"" is not a legal field name\\n\"", field);\n        return false;\n    }\n\n    return handleAction[action](ctx, mods, &info->actions[action],\n                                action_field, array_ndx, value);\n}"", ""start_line"": 853, ""end_line"": 871, ""full_name"": ""SetActionField"", ""file_path"": ""src/xkbcomp/action.c""}]}, {""source"": ""func_info(file:compat.c, func:SetInterpField)"", ""result"": [{""code"": ""static bool\nSetInterpField(CompatInfo *info, SymInterpInfo *si, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    xkb_mod_index_t ndx;\n\n    if (istreq(field, \""action\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!HandleActionDef(info->ctx, info->actions, &info->mods,\n                             value, &si->interp.action))\n            return false;\n\n        si->defined |= SI_FIELD_ACTION;\n    }\n    else if (istreq(field, \""virtualmodifier\"") ||\n             istreq(field, \""virtualmod\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveMod(info->ctx, value, MOD_VIRT, &info->mods, &ndx))\n            return ReportSIBadType(info, si, field, \""virtual modifier\"");\n\n        si->interp.virtual_mod = ndx;\n        si->defined |= SI_FIELD_VIRTUAL_MOD;\n    }\n    else if (istreq(field, \""repeat\"")) {\n        bool set;\n\n        if (arrayNdx)\n            return ReportSINotArray(..."", ""start_line"": 464, ""end_line"": 528, ""full_name"": ""SetInterpField"", ""file_path"": ""src/xkbcomp/compat.c""}]}, {""source"": ""func_info(file:action.c, func:stringToField)"", ""result"": [{""code"": ""static bool\nstringToField(const char *str, enum action_field *field_rtrn)\n{\n    return LookupString(fieldStrings, str, field_rtrn);\n}"", ""start_line"": 176, ""end_line"": 180, ""full_name"": ""stringToField"", ""file_path"": ""src/xkbcomp/action.c""}]}, {""source"": ""code_info(file:action.c, lines:853-871)"", ""result"": ""bool\nSetActionField(struct xkb_context *ctx, ActionsInfo *info,\n               struct xkb_mod_set *mods, const char *elem,\n               const char *field, ExprDef *array_ndx, ExprDef *value)\n{\n    enum xkb_action_type action;\n    enum action_field action_field;\n\n    if (!stringToAction(elem, &action))\n        return false;\n\n    if (!stringToField(field, &action_field)) {\n        log_err(ctx, \""\\\""%s\\\"" is not a legal field name\\n\"", field);\n        return false;\n    }\n\n    return handleAction[action](ctx, mods, &info->actions[action],\n                                action_field, array_ndx, value);\n}\n""}, {""source"": ""code_info(file:compat.c, lines:464-528)"", ""result"": ""static bool\nSetInterpField(CompatInfo *info, SymInterpInfo *si, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    xkb_mod_index_t ndx;\n\n    if (istreq(field, \""action\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!HandleActionDef(info->ctx, info->actions, &info->mods,\n                             value, &si->interp.action))\n            return false;\n\n        si->defined |= SI_FIELD_ACTION;\n    }\n    else if (istreq(field, \""virtualmodifier\"") ||\n             istreq(field, \""virtualmod\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveMod(info->ctx, value, MOD_VIRT, &info->mods, &ndx))\n            return ReportSIBadType(info, si, field, \""virtual modifier\"");\n\n        si->interp.virtual_mod = ndx;\n        si->defined |= SI_FIELD_VIRTUAL_MOD;\n    }\n    else if (istreq(field, \""repeat\"")) {\n        bool set;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveBoolean(info->ctx, value, &set))\n            return ReportSIBadType(info, si, field, \""boolean\"");\n\n        si->interp.repeat = set;\n\n        si->defined |= SI_FIELD_AUTO_REPEAT;\n    }\n    else if (istreq(field, \""locking\"")) {\n        log_dbg(info->ctx,\n                \""The \\\""locking\\\"" field in symbol interpretation is unsupported; \""\n                \""Ignored\\n\"");\n    }\n    else if (istreq(field, \""usemodmap\"") ||\n             istreq(field, \""usemodmapmods\"")) {\n        unsigned int val;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveEnum(info->ctx, value, &val, useModMapValueNames))\n            return ReportSIBadType(info, si, field, \""level specification\"");\n\n        si->interp.level_one_only = val;\n        si->defined |= SI_FIELD_LEVEL_ONE_ONLY;\n    }\n    else {\n        return ReportBadField(info->ctx, \""symbol interpretation\"", field,\n                              siText(si, info));\n    }\n\n    return true;\n}\n\n""}, {""source"": ""func_info(func:LookupString)"", ""result"": [{""code"": ""bool\nLookupString(const LookupEntry tab[], const char *string,\n              unsigned int *value_rtrn)\n{\n    if (!string)\n        return false;\n\n    for (const LookupEntry *entry = tab; entry->name; entry++) {\n        if (istreq(entry->name, string)) {\n            *value_rtrn = entry->value;\n            return true;\n        }\n    }\n\n    return false;\n}"", ""start_line"": 30, ""end_line"": 45, ""full_name"": ""LookupString"", ""file_path"": ""src/text.c""}]}, {""source"": ""func_info(func:istreq)"", ""result"": [{""code"": ""static inline bool\nistreq(const char *s1, const char *s2)\n{\n    return istrcmp(s1, s2) == 0;\n}"", ""start_line"": 69, ""end_line"": 73, ""full_name"": ""istreq"", ""file_path"": ""src/utils.h""}]}]","src/xkbcomp/expr.c:43: *field_rtrn = xkb_atom_text(ctx, expr->ident.ident) may be NULL. Original code returns true, allowing callers to dereference *field_rtrn. Patch returns (*field_rtrn != NULL). Callers like HandleGlobalVar (compat.c:629) pass *field_rtrn to SetInterpField (compat.c:464-528), which uses istreq(field, 'action') (utils.h:69-73) without NULL checks, causing a NULL dereference.",0.95,./github/other_context/CVE-2018-15861
12,CVE-2018-17282,CWE-476,c_cpp,An issue was discovered in Exiv2 v0.26. The function Exiv2::DataValue::copy in value.cpp has a NULL pointer dereference.,https://github.com/Exiv2/exiv2/commit/670fb73dd5ee8acab90971c4878de29f9fc43a02,Fix #457,1,"[{""func_name"": ""TiffImage::readMetadata"", ""file_path"": ""src/tiffimage.cpp"", ""func_code"": ""void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Reading TIFF file \"" << io_->path() << \""\\n\"";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \""TIFF\"");\n        }\n        clearMetadata();\n\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n\n        // read profile from the metadata\n        Exiv2::ExifKey            key(\""Exif.Image.InterColorProfile\"");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n\n    }"", ""target"": 0}]","[{""func_name"": ""TiffImage::readMetadata"", ""file_path"": ""src/tiffimage.cpp"", ""func_code"": ""void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Reading TIFF file \"" << io_->path() << \""\\n\"";\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \""TIFF\"");\n        }\n        clearMetadata();\n\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n\n        // read profile from the metadata\n        Exiv2::ExifKey            key(\""Exif.Image.InterColorProfile\"");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end() ) {\n            long size = pos->count() * pos->typeSize();\n            if (size == 0) {\n                throw Error(kerFailedToReadImageData);\n            }\n            iccProfile_.alloc(size);\n            pos->copy(iccProfile_.pData_,bo);\n        }\n\n    }""}]","{""function"": 6, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(func:copy)"", ""result"": [{""code"": ""long ValueType<T>::copy(byte* buf, ByteOrder byteOrder) const\n    {\n        long offset = 0;\n        typename ValueList::const_iterator end = value_.end();\n        for (typename ValueList::const_iterator i = value_.begin(); i != end; ++i) {\n            offset += toData(buf + offset, *i, byteOrder);\n        }\n        return offset;\n    }"", ""start_line"": 1598, ""end_line"": 1606, ""full_name"": ""Exiv2.ValueType.copy:long(Exiv2.byte*,Exiv2.ByteOrder)<const>"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""long Exifdatum::copy(byte* buf, ByteOrder byteOrder) const\n    {\n        return value_.get() == 0 ? 0 : value_->copy(buf, byteOrder);\n    }"", ""start_line"": 355, ""end_line"": 358, ""full_name"": ""Exifdatum.copy:long(byte*,ByteOrder)<const>"", ""file_path"": ""src/exif.cpp""}, {""code"": ""DataBuf ExifThumbC::copy() const\n    {\n        Thumbnail::AutoPtr thumbnail = Thumbnail::create(exifData_);\n        if (thumbnail.get() == 0) return DataBuf();\n        return thumbnail->copy(exifData_);\n    }"", ""start_line"": 430, ""end_line"": 435, ""full_name"": ""ExifThumbC.copy:DataBuf()<const>"", ""file_path"": ""src/exif.cpp""}]}, {""source"": ""code_info(file:tiffimage.cpp, lines:200-210)"", ""result"": ""    void TiffImage::writeMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Writing TIFF file \"" << io_->path() << \""\\n\"";\n#endif\n        ByteOrder bo = byteOrder();\n        byte* pData = 0;\n        long size = 0;\n        IoCloser closer(*io_);\n        if (io_->open() == 0) {\n            // Ensure that this is the correct image type\n            if (isTiffType(*io_, false)) {\n""}, {""source"": ""value_info(file:tiffimage.cpp, value:iccProfile_)"", ""result"": {""value_trace"": [{""full_code"": ""iccProfile_ = iccProfile"", ""line"": 661, ""func_name"": ""Image.setIccProfile:void(Exiv2.DataBuf&,bool)""}], ""struct_var"": ""iccProfile_"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(file:value.hpp, func:toData)"", ""result"": [{""code"": ""inline long toData(byte* buf, uint16_t t, ByteOrder byteOrder)\n    {\n        return us2Data(buf, t, byteOrder);\n    }"", ""start_line"": 1439, ""end_line"": 1442, ""full_name"": ""toData:long(Exiv2.byte*,uint16_t,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""inline long toData(byte* buf, uint32_t t, ByteOrder byteOrder)\n    {\n        return ul2Data(buf, t, byteOrder);\n    }"", ""start_line"": 1448, ""end_line"": 1451, ""full_name"": ""toData:long(Exiv2.byte*,uint32_t,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""inline long toData(byte* buf, URational t, ByteOrder byteOrder)\n    {\n        return ur2Data(buf, t, byteOrder);\n    }"", ""start_line"": 1457, ""end_line"": 1460, ""full_name"": ""toData:long(Exiv2.byte*,Exiv2.URational,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/value.hpp""}]}, {""source"": ""func_info(func:us2Data)"", ""result"": [{""code"": ""long us2Data(byte* buf, uint16_t s, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            buf[0] = (byte) (s & 0x00ff);\n            buf[1] = (byte)((s & 0xff00) >> 8);\n        }\n        else {\n            buf[0] = (byte)((s & 0xff00) >> 8);\n            buf[1] = (byte) (s & 0x00ff);\n        }\n        return 2;\n    }"", ""start_line"": 394, ""end_line"": 405, ""full_name"": ""Exiv2.us2Data:long(Exiv2.byte*,uint16_t,Exiv2.ByteOrder)"", ""file_path"": ""src/types.cpp""}]}, {""source"": ""func_info(func:ul2Data)"", ""result"": [{""code"": ""long ul2Data(byte* buf, uint32_t l, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            buf[0] = (byte) (l & 0x000000ff);\n            buf[1] = (byte)((l & 0x0000ff00) >> 8);\n            buf[2] = (byte)((l & 0x00ff0000) >> 16);\n            buf[3] = (byte)((l & 0xff000000) >> 24);\n        }\n        else {\n            buf[0] = (byte)((l & 0xff000000) >> 24);\n            buf[1] = (byte)((l & 0x00ff0000) >> 16);\n            buf[2] = (byte)((l & 0x0000ff00) >> 8);\n            buf[3] = (byte) (l & 0x000000ff);\n        }\n        return 4;\n    }"", ""start_line"": 407, ""end_line"": 422, ""full_name"": ""Exiv2.ul2Data:long(Exiv2.byte*,uint32_t,Exiv2.ByteOrder)"", ""file_path"": ""src/types.cpp""}]}, {""source"": ""func_info(func:ur2Data)"", ""result"": [{""code"": ""long ur2Data(byte* buf, URational l, ByteOrder byteOrder)\n    {\n        long o = ul2Data(buf, l.first, byteOrder);\n        o += ul2Data(buf+o, l.second, byteOrder);\n        return o;\n    }"", ""start_line"": 424, ""end_line"": 429, ""full_name"": ""Exiv2.ur2Data:long(Exiv2.byte*,Exiv2.URational,Exiv2.ByteOrder)"", ""file_path"": ""src/types.cpp""}]}, {""source"": ""func_info(func:alloc)"", ""result"": [{""code"": ""void DataBuf::alloc(long size)\n    {\n        if (size > size_) {\n            delete[] pData_;\n            pData_ = 0;\n            size_ = 0;\n            pData_ = new byte[size];\n            size_ = size;\n        }\n    }"", ""start_line"": 160, ""end_line"": 169, ""full_name"": ""DataBuf.alloc:void(long)"", ""file_path"": ""src/types.cpp""}]}]","src/tiffimage.cpp:194-198: Zero-size allocation check prevents iccProfile_.pData_ from being NULL. Previously, if pos->count() * pos->typeSize() == 0, iccProfile_.alloc(0) would leave pData_ as NULL (src/types.cpp:160-169). The subsequent call to pos->copy(iccProfile_.pData_, bo) passed NULL to Exifdatum::copy (src/exif.cpp:355-358), which invoked ValueType<T>::copy (value.hpp:1598-1606). The loop in ValueType<T>::copy called toData(), which relied on us2Data/ul2Data (src/types.cpp:394-429) that directly dereferenced the NULL buffer (e.g., buf[0] = ...).",0.95,./github/other_context/CVE-2018-17282
13,CVE-2018-18873,CWE-476,c_cpp,An issue was discovered in JasPer 2.0.14. There is a NULL pointer dereference in the function ras_putdatastd in ras/ras_enc.c.,https://github.com/jasper-software/jasper/commit/12db8078ba17a8ffc5cc2429fb506988f0f11b44,"ras_enc: check components for RGB, fixes NULL pointer dereference\n\nFixes CVE-2018-18873\n\nCloses https://github.com/jasper-maint/jasper/issues/15\nCloses https://github.com/mdadams/jasper/issues/184",1,"[{""func_name"": ""ras_putdatastd"", ""file_path"": ""src/libjasper/ras/ras_enc.c"", ""func_code"": ""static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}"", ""target"": 0}]","[{""func_name"": ""ras_putdatastd"", ""file_path"": ""src/libjasper/ras/ras_enc.c"", ""func_code"": ""static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tif (RAS_ISRGB(hdr) && numcmpts < 3) {\n\t\t/* need 3 components for RGB */\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}""}]","{""value"": 2, ""code"": 2}","[{""source"": ""value_info(file:ras_enc.c, value:data)"", ""result"": {""value_trace"": [{""full_code"": ""*data[3]"", ""line"": 230, ""func_name"": ""ras_putdatastd""}], ""struct_var"": ""data"", ""struct_type"": ""jas_matrix_t**[3]"", ""struct_definition"": null}}, {""source"": ""code_info(file:ras_enc.c, lines:200-250)"", ""result"": ""\t}\n\n\treturn 0;\n}\n\nstatic int ras_putdata(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts)\n{\n\tint ret;\n\n\tswitch (hdr->type) {\n\tcase RAS_TYPE_STD:\n\t\tret = ras_putdatastd(out, hdr, image, numcmpts, cmpts);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n""}, {""source"": ""value_info(file:ras_enc.c, value:data)"", ""result"": {""value_trace"": [{""full_code"": ""*data[3]"", ""line"": 230, ""func_name"": ""ras_putdatastd""}], ""struct_var"": ""data"", ""struct_type"": ""jas_matrix_t**[3]"", ""struct_definition"": null}}, {""source"": ""code_info(file:ras_enc.c, lines:250-300)"", ""result"": ""\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n""}]","src/libjasper/ras/ras_enc.c:237-239 accesses 'data[i]' in a loop assuming 3 components. When RAS_ISRGB(hdr) is true and numcmpts < 3 (unvalidated pre-patch), data[0..2] is partially initialized (only i < numcmpts). src/libjasper/ras/ras_enc.c:250-300 dereferences data[0], data[1], data[2] during pixel processing. For i >= numcmpts, data[i] remains NULL, causing a dereference. Patch adds src/libjasper/ras/ras_enc.c:234-236 to return -1 in this case.",0.95,./github/other_context/CVE-2018-18873
14,CVE-2019-15695,"CWE-787, CWE-754",c_cpp,"TigerVNC version prior to 1.10.1 is vulnerable to stack buffer overflow, which could be triggered from CMsgReader::readSetCursor. This vulnerability occurs due to insufficient sanitization of PixelFormat. Since remote attacker can choose offset from start of the buffer to start writing his values, exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",https://github.com/CendioOssman/tigervnc/commit/05e28490873a861379c943bf616614b78b558b89,Handle pixel formats with odd shift values\n\nOur fast paths assume that each channel fits in to a separate byte.\nThat means the shift needs to be a multiple of 8. Start actually\nchecking this so that a client cannot trip us up and possibly cause\nincorrect code exection.\n\nIssue found by Pavel Cheremushkin from Kaspersky Lab.,1,"[{""func_name"": ""PixelFormat::is888"", ""file_path"": ""common/rfb/PixelFormat.cxx"", ""func_code"": ""bool PixelFormat::is888(void) const\n{\n  if (!trueColour)\n    return false;\n  if (bpp != 32)\n    return false;\n  if (depth != 24)\n    return false;\n  if (redMax != 255)\n    return false;\n  if (greenMax != 255)\n    return false;\n  if (blueMax != 255)\n    return false;\n\n  return true;\n}"", ""target"": 0}]","[{""func_name"": ""PixelFormat::is888"", ""file_path"": ""common/rfb/PixelFormat.cxx"", ""func_code"": ""bool PixelFormat::is888(void) const\n{\n  if (!trueColour)\n    return false;\n  if (bpp != 32)\n    return false;\n  if (depth != 24)\n    return false;\n  if (redMax != 255)\n    return false;\n  if (greenMax != 255)\n    return false;\n  if (blueMax != 255)\n    return false;\n  if ((redShift & 0x7) != 0)\n    return false;\n  if ((greenShift & 0x7) != 0)\n    return false;\n  if ((blueShift & 0x7) != 0)\n    return false;\n\n  return true;\n}""}]","{""caller"": 4, ""function"": 4, ""code"": 1}","[{""source"": ""caller_info(func:is888)"", ""result"": [{""call_line"": 234, ""call_code"": ""is888()"", ""caller_code"": ""void PixelFormat::bufferFromRGB(rdr::U8 *dst, const rdr::U8* src,\n                                int w, int stride, int h) const\n{\n  if (is888()) {\n    // Optimised common case\n    rdr::U8 *r, *g, *b, *x;\n\n    if (bigEndian) {\n      r = dst + (24 - redShift)/8;\n      g = dst + (24 - greenShift)/8;\n      b = dst + (24 - blueShift)/8;\n      x = dst + (24 - (48 - redShift - greenShift - blueShift))/8;\n    } else {\n      r = dst + redShift/8;\n      g = dst + greenShift/8;\n      b = dst + blueShift/8;\n      x = dst + (48 - redShift - greenShift - blueShift)/8;\n    }\n\n    int dstPad = (stride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *r = *(src++);\n        *g = *(src++);\n        *b = *(src++);\n        *x = 0;\n        r += 4;\n        g += 4;\n        b += 4;\n        x += 4;\n      }\n      r += dstPad;\n      g += dstPad;\n      b += dstPad;\n      x += dstPad;\n    }\n  } else {\n    // Generic code\n    int dstPad = (stride - w) * bpp/8;\n    while (h--) {\n      in..."", ""caller_start"": 231, ""file_path"": ""common/rfb/PixelFormat.cxx""}, {""call_line"": 301, ""call_code"": ""is888()"", ""caller_code"": ""void PixelFormat::rgbFromBuffer(rdr::U8* dst, const rdr::U8* src,\n                                int w, int stride, int h) const\n{\n  if (is888()) {\n    // Optimised common case\n    const rdr::U8 *r, *g, *b;\n\n    if (bigEndian) {\n      r = src + (24 - redShift)/8;\n      g = src + (24 - greenShift)/8;\n      b = src + (24 - blueShift)/8;\n    } else {\n      r = src + redShift/8;\n      g = src + greenShift/8;\n      b = src + blueShift/8;\n    }\n\n    int srcPad = (stride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *(dst++) = *r;\n        *(dst++) = *g;\n        *(dst++) = *b;\n        r += 4;\n        g += 4;\n        b += 4;\n      }\n      r += srcPad;\n      g += srcPad;\n      b += srcPad;\n    }\n  } else {\n    // Generic code\n    int srcPad = (stride - w) * bpp/8;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        Pixel p;\n        rdr::U8 r, g, b;\n\n        p = pixelFromBuffer(src);\n\n        rgbFromPixel(p, &r, &g, &b);\n\n        *(dst++) = r;\n       ..."", ""caller_start"": 298, ""file_path"": ""common/rfb/PixelFormat.cxx""}, {""call_line"": 381, ""call_code"": ""is888()"", ""caller_code"": ""void PixelFormat::bufferFromBuffer(rdr::U8* dst, const PixelFormat &srcPF,\n                                   const rdr::U8* src, int w, int h,\n                                   int dstStride, int srcStride) const\n{\n  if (equal(srcPF)) {\n    // Trivial case\n    while (h--) {\n      memcpy(dst, src, w * bpp/8);\n      dst += dstStride * bpp/8;\n      src += srcStride * srcPF.bpp/8;\n    }\n  } else if (is888() && srcPF.is888()) {\n    // Optimised common case A: byte shuffling (e.g. endian conversion)\n    rdr::U8 *d[4], *s[4];\n    int dstPad, srcPad;\n\n    if (bigEndian) {\n      s[0] = dst + (24 - redShift)/8;\n      s[1] = dst + (24 - greenShift)/8;\n      s[2] = dst + (24 - blueShift)/8;\n      s[3] = dst + (24 - (48 - redShift - greenShift - blueShift))/8;\n    } else {\n      s[0] = dst + redShift/8;\n      s[1] = dst + greenShift/8;\n      s[2] = dst + blueShift/8;\n      s[3] = dst + (48 - redShift - greenShift - blueShift)/8;\n    }\n\n    if (srcPF.bigEndian) {\n      d[(24 - srcPF.redShift)/8..."", ""caller_start"": 370, ""file_path"": ""common/rfb/PixelFormat.cxx""}]}, {""source"": ""func_info(file:CMsgReader.cxx, func:readSetCursor)"", ""result"": [{""code"": ""void CMsgReader::readSetCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\""Too big cursor\"");\n\n  int data_len = width * he"", ""start_line"": 382, ""end_line"": 421, ""full_name"": ""CMsgReader.readSetCursor:void(int,int,Point&)"", ""file_path"": ""common/rfb/CMsgReader.cxx""}]}, {""source"": ""code_info(file:CMsgReader.cxx, lines:382-421)"", ""result"": ""void CMsgReader::readSetCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\""Too big cursor\"");\n\n  int data_len = width * height * (handler->server.pf().bpp/8);\n  int mask_len = ((width+7)/8) * height;\n  rdr::U8Array data(data_len);\n  rdr::U8Array mask(mask_len);\n\n  int x, y;\n  rdr::U8Array rgba(width*height*4);\n  rdr::U8* in;\n  rdr::U8* out;\n\n  is->readBytes(data.buf, data_len);\n  is->readBytes(mask.buf, mask_len);\n\n  int maskBytesPerRow = (width+7)/8;\n  in = data.buf;\n  out = rgba.buf;\n  for (y = 0;y < height;y++) {\n    for (x = 0;x < width;x++) {\n      int byte = y * maskBytesPerRow + x / 8;\n      int bit = 7 - x % 8;\n\n      handler->server.pf().rgbFromBuffer(out, in, 1);\n\n      if (mask.buf[byte] & (1 << bit))\n        out[3] = 255;\n      else\n        out[3] = 0;\n\n      in += handler->server.pf().bpp/8;\n      out += 4;\n    }\n  }\n\n  handler->setCursor(width, height, hotspot, rgba.buf);\n}\n\n""}, {""source"": ""caller_info(file:Handler.cxx, func:pf)"", ""result"": [{""call_line"": 648, ""call_code"": ""server.pf()"", ""caller_code"": ""void CConnection::setPF(const PixelFormat& pf)\n{\n  if (server.pf().equal(pf) && !formatChange)\n    return;\n\n  nextPF = pf;\n  formatChange = true;\n}"", ""caller_start"": 646, ""file_path"": ""common/rfb/CConnection.cxx""}, {""call_line"": 387, ""call_code"": ""handler->server.pf()"", ""caller_code"": ""void CMsgReader::readSetCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\""Too big cursor\"");\n\n  int data_len = width * height * (handler->server.pf().bpp/8);\n  int mask_len = ((width+7)/8) * height;\n  rdr::U8Array data(data_len);\n  rdr::U8Array mask(mask_len);\n\n  int x, y;\n  rdr::U8Array rgba(width*height*4);\n  rdr::U8* in;\n  rdr::U8* out;\n\n  is->readBytes(data.buf, data_len);\n  is->readBytes(mask.buf, mask_len);\n\n  int maskBytesPerRow = (width+7)/8;\n  in = data.buf;\n  out = rgba.buf;\n  for (y = 0;y < height;y++) {\n    for (x = 0;x < width;x++) {\n      int byte = y * maskBytesPerRow + x / 8;\n      int bit = 7 - x % 8;\n\n      handler->server.pf().rgbFromBuffer(out, in, 1);\n\n      if (mask.buf[byte] & (1 << bit))\n        out[3] = 255;\n      else\n        out[3] = 0;\n\n      in += handler->server.pf().bpp/8;\n      out += 4;\n    }\n  }\n\n  handler->setCursor(width, height, hotspot, rgba.buf);\n}"", ""caller_start"": 382, ""file_path"": ""common/rfb/CMsgReader.cxx""}, {""call_line"": 408, ""call_code"": ""handler->server.pf()"", ""caller_code"": ""void CMsgReader::readSetCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\""Too big cursor\"");\n\n  int data_len = width * height * (handler->server.pf().bpp/8);\n  int mask_len = ((width+7)/8) * height;\n  rdr::U8Array data(data_len);\n  rdr::U8Array mask(mask_len);\n\n  int x, y;\n  rdr::U8Array rgba(width*height*4);\n  rdr::U8* in;\n  rdr::U8* out;\n\n  is->readBytes(data.buf, data_len);\n  is->readBytes(mask.buf, mask_len);\n\n  int maskBytesPerRow = (width+7)/8;\n  in = data.buf;\n  out = rgba.buf;\n  for (y = 0;y < height;y++) {\n    for (x = 0;x < width;x++) {\n      int byte = y * maskBytesPerRow + x / 8;\n      int bit = 7 - x % 8;\n\n      handler->server.pf().rgbFromBuffer(out, in, 1);\n\n      if (mask.buf[byte] & (1 << bit))\n        out[3] = 255;\n      else\n        out[3] = 0;\n\n      in += handler->server.pf().bpp/8;\n      out += 4;\n    }\n  }\n\n  handler->setCursor(width, height, hotspot, rgba.buf);\n}"", ""caller_start"": 382, ""file_path"": ""common/rfb/CMsgReader.cxx""}]}, {""source"": ""caller_info(file:CConnection.cxx, func:setPF)"", ""result"": [{""call_line"": 383, ""call_code"": ""server.setPF(pendingPF)"", ""caller_code"": ""void CConnection::endOfContinuousUpdates()\n{\n  CMsgHandler::endOfContinuousUpdates();\n\n  // We've gotten the marker for a format change, so make the pending\n  // one active\n  if (pendingPFChange) {\n    server.setPF(pendingPF);\n    pendingPFChange = false;\n\n    // We might have another change pending\n    if (formatChange)\n      requestNewUpdate();\n  }\n}"", ""caller_start"": 376, ""file_path"": ""common/rfb/CConnection.cxx""}, {""call_line"": 414, ""call_code"": ""server.setPF(pendingPF)"", ""caller_code"": ""void CConnection::serverInit(int width, int height,\n                             const PixelFormat& pf,\n                             const char* name)\n{\n  CMsgHandler::serverInit(width, height, pf, name);\n\n  state_ = RFBSTATE_NORMAL;\n  vlog.debug(\""initialisation done\"");\n\n  initDone();\n  assert(framebuffer != NULL);\n  assert(framebuffer->width() == server.width());\n  assert(framebuffer->height() == server.height());\n\n  // We want to make sure we call SetEncodings at least once\n  encodingChange = true;\n\n  requestNewUpdate();\n\n  // This initial update request is a bit of a corner case, so we need\n  // to help out setting the correct format here.\n  if (pendingPFChange) {\n    server.setPF(pendingPF);\n    pendingPFChange = false;\n  }\n}"", ""caller_start"": 392, ""file_path"": ""common/rfb/CConnection.cxx""}, {""call_line"": 447, ""call_code"": ""server.setPF(pendingPF)"", ""caller_code"": ""void CConnection::framebufferUpdateEnd()\n{\n  decoder.flush();\n\n  CMsgHandler::framebufferUpdateEnd();\n\n  // A format change has been scheduled and we are now past the update\n  // with the old format. Time to active the new one.\n  if (pendingPFChange && !continuousUpdates) {\n    server.setPF(pendingPF);\n    pendingPFChange = false;\n  }\n\n  if (firstUpdate) {\n    if (server.supportsContinuousUpdates) {\n      vlog.info(\""Enabling continuous updates\"");\n      continuousUpdates = true;\n      writer()->writeEnableContinuousUpdates(true, 0, 0,\n                                             server.width(),\n                                             server.height());\n    }\n\n    firstUpdate = false;\n  }\n}"", ""caller_start"": 438, ""file_path"": ""common/rfb/CConnection.cxx""}]}, {""source"": ""func_info(func:readSetPixelFormat)"", ""result"": [{""code"": ""void SMsgReader::readSetPixelFormat()\n{\n  is->skip(3);\n  PixelFormat pf;\n  pf.read(is);\n  handler->setPixelFormat(pf);\n}"", ""start_line"": 95, ""end_line"": 101, ""full_name"": ""SMsgReader.readSetPixelFormat:void()"", ""file_path"": ""common/rfb/SMsgReader.cxx""}]}, {""source"": ""caller_info(file:CMsgReader.cxx, func:readSetPixelFormat)"", ""result"": [{""call_line"": 60, ""call_code"": ""readSetPixelFormat()"", ""caller_code"": ""void SMsgReader::readMsg()\n{\n  int msgType = is->readU8();\n  switch (msgType) {\n  case msgTypeSetPixelFormat:\n    readSetPixelFormat();\n    break;\n  case msgTypeSetEncodings:\n    readSetEncodings();\n    break;\n  case msgTypeSetDesktopSize:\n    readSetDesktopSize();\n    break;\n  case msgTypeFramebufferUpdateRequest:\n    readFramebufferUpdateRequest();\n    break;\n  case msgTypeEnableContinuousUpdates:\n    readEnableContinuousUpdates();\n    break;\n  case msgTypeClientFence:\n    readFence();\n    break;\n  case msgTypeKeyEvent:\n    readKeyEvent();\n    break;\n  case msgTypePointerEvent:\n    readPointerEvent();\n    break;\n  case msgTypeClientCutText:\n    readClientCutText();\n    break;\n  case msgTypeQEMUClientMessage:\n    readQEMUMessage();\n    break;\n  default:\n    vlog.error(\""unknown message type %d\"", msgType);\n    throw Exception(\""unknown message type\"");\n  }\n}"", ""caller_start"": 55, ""file_path"": ""common/rfb/SMsgReader.cxx""}]}, {""source"": ""func_info(func:setPixelFormat)"", ""result"": [{""code"": ""void CMsgHandler::setPixelFormat(const PixelFormat& pf)\n{\n  server.setPF(pf);\n}"", ""start_line"": 55, ""end_line"": 58, ""full_name"": ""CMsgHandler.setPixelFormat:void(PixelFormat&)"", ""file_path"": ""common/rfb/CMsgHandler.cxx""}, {""code"": ""void SConnection::setPixelFormat(const PixelFormat& pf)\n{\n  SMsgHandler::setPixelFormat(pf);\n  readyForSetColourMapEntries = true;\n  if (!pf.trueColour)\n    writeFakeColourMap();\n}"", ""start_line"": 445, ""end_line"": 451, ""full_name"": ""SConnection.setPixelFormat:void(PixelFormat&)"", ""file_path"": ""common/rfb/SConnection.cxx""}, {""code"": ""void SMsgHandler::setPixelFormat(const PixelFormat& pf)\n{\n  client.setPF(pf);\n}"", ""start_line"": 38, ""end_line"": 41, ""full_name"": ""SMsgHandler.setPixelFormat:void(PixelFormat&)"", ""file_path"": ""common/rfb/SMsgHandler.cxx""}]}, {""source"": ""func_info(file:PixelFormat.cxx, func:read)"", ""result"": [{""code"": ""void PixelFormat::read(rdr::InStream* is)\n{\n  bpp = is->readU8();\n  depth = is->readU8();\n  bigEndian = is->readU8();\n  trueColour = is->readU8();\n  redMax = is->readU16();\n  greenMax = is->readU16();"", ""start_line"": 147, ""end_line"": 177, ""full_name"": ""PixelFormat.read:void(rdr.InStream*)"", ""file_path"": ""common/rfb/PixelFormat.cxx""}]}]","The vulnerability stems from unvalidated PixelFormat shift values (common/rfb/PixelFormat.cxx:207-213) in the optimized pixel processing paths (e.g., PixelFormat::rgbFromBuffer at common/rfb/PixelFormat.cxx:298). These shifts are set via client-provided data parsed in PixelFormat::read (common/rfb/PixelFormat.cxx:147-177), which reads redShift, greenShift, and blueShift directly from the input stream. When CMsgReader::readSetCursor (common/rfb/CMsgReader.cxx:382-421) uses the unsanitized shifts in rgbFromBuffer, incorrect pointer arithmetic leads to a stack buffer overflow. The patch adds checks to is888 to prevent this.",1.0,./github/other_context/CVE-2019-15695
15,CVE-2019-17177,"CWE-252, CWE-401",c_cpp,"libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a,Fixed #5645: realloc return handling,5,"[{""func_name"": ""region16_intersect_rect"", ""file_path"": ""libfreerdp/codec/region.c"", ""func_code"": ""BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* newItems;\n\tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n\tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t/* accumulate intersecting rectangles, the final region16_simplify_bands() will\n\t * do all the bad job to recreate correct rectangles\n\t */\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t/* Check if the existing newExtents is empty. If it is empty, use\n\t\t\t\t * new common directly. We do not need to check common rectangle\n\t\t\t\t * because the rectangles_intersection() ensures that it is not empty.\n\t\t\t\t */\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n\tif ((dst->data->size > 0) && (dst->data != &empty_region))\n\t\tfree(dst->data);\n\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}"", ""target"": 1}, {""func_name"": ""region16_simplify_bands"", ""file_path"": ""libfreerdp/codec/region.c"", ""func_code"": ""static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====>    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects < 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1->bottom == band2->top) && band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp < band2)\n\t\t\t{\n\t\t\t\ttmp->bottom = band2->bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tregion->data = realloc(region->data, allocSize);\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}\n\n\treturn TRUE;\n}"", ""target"": 1}, {""func_name"": ""region16_union_rect"", ""file_path"": ""libfreerdp/codec/region.c"", ""func_code"": ""BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}"", ""target"": 0}, {""func_name"": ""HuffmanTree_makeFromFrequencies"", ""file_path"": ""winpr/libwinpr/utils/lodepng/lodepng.c"", ""func_code"": ""static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}"", ""target"": 1}, {""func_name"": ""tr_esc_str"", ""file_path"": ""client/X11/generate_argument_docbook.c"", ""func_code"": ""LPSTR tr_esc_str(LPCSTR arg, bool format)\n{\n\tLPSTR tmp = NULL;\n\tsize_t cs = 0, x, ds, len;\n\tsize_t s;\n\n\tif (NULL == arg)\n\t\treturn NULL;\n\n\ts = strlen(arg);\n\n\t/* Find trailing whitespaces */\n\twhile ((s > 0) && isspace(arg[s - 1]))\n\t\ts--;\n\n\t/* Prepare a initial buffer with the size of the result string. */\n\tds = s + 1;\n\n\tif (s)\n\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\tif (NULL == tmp)\n\t{\n\t\tfprintf(stderr,  \""Could not allocate string buffer.\\n\"");\n\t\texit(-2);\n\t}\n\n\t/* Copy character for character and check, if it is necessary to escape. */\n\tmemset(tmp, 0, ds * sizeof(CHAR));\n\n\tfor (x = 0; x < s; x++)\n\t{\n\t\tswitch (arg[x])\n\t\t{\n\t\t\tcase '<':\n\t\t\t\tlen = format ? 13 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-3);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""<replaceable>\"", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""&lt;\"", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tlen = format ? 14 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-4);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""</replaceable>\"", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""&lt;\"", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\t\tds += 5;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-5);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 's';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '\""':\n\t\t\t\tds += 5;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-6);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'q';\n\t\t\t\ttmp[cs++] = 'u';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 't';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tds += 4;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-7);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'm';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttmp[cs++] = arg[x];\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Assure, the string is '\\0' terminated. */\n\t\ttmp[ds - 1] = '\\0';\n\t}\n\n\treturn tmp;\n}"", ""target"": 1}]","[{""func_name"": ""region16_intersect_rect"", ""file_path"": ""libfreerdp/codec/region.c"", ""func_code"": ""BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* data;\n\tREGION16_DATA* newItems;\n\tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n\tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t/* accumulate intersecting rectangles, the final region16_simplify_bands() will\n\t * do all the bad job to recreate correct rectangles\n\t */\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t/* Check if the existing newExtents is empty. If it is empty, use\n\t\t\t\t * new common directly. We do not need to check common rectangle\n\t\t\t\t * because the rectangles_intersection() ensures that it is not empty.\n\t\t\t\t */\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n\tif ((dst->data->size > 0) && (dst->data != &empty_region))\n\t\tfree(dst->data);\n\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}""}, {""func_name"": ""region16_simplify_bands"", ""file_path"": ""libfreerdp/codec/region.c"", ""func_code"": ""static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====>    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects < 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1->bottom == band2->top) && band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp < band2)\n\t\t\t{\n\t\t\t\ttmp->bottom = band2->bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tREGION16_DATA* data;\n\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tdata = realloc(region->data, allocSize);\n\t\tif (!data)\n\t\t\tfree(region->data);\n\t\tregion->data = data;\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}\n\n\treturn TRUE;\n}""}, {""func_name"": ""region16_union_rect"", ""file_path"": ""libfreerdp/codec/region.c"", ""func_code"": ""BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* data;\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tREGION16_DATA* tmpItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\ttmpItems = realloc(newItems, newItems->size);\n\tif (!tmpItems)\n\t\tfree(newItems);\n\tnewItems = tmpItems;\n\tdst->data = newItems;\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}""}, {""func_name"": ""HuffmanTree_makeFromFrequencies"", ""file_path"": ""winpr/libwinpr/utils/lodepng/lodepng.c"", ""func_code"": ""static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n\tunsigned* lengths;\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n\tif (!lengths)\n\t\tfree(tree->lengths);\n\ttree->lengths = lengths;\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}""}, {""func_name"": ""tr_esc_str"", ""file_path"": ""client/X11/generate_argument_docbook.c"", ""func_code"": ""LPSTR tr_esc_str(LPCSTR arg, bool format)\n{\n\tLPSTR tmp = NULL;\n\tLPSTR tmp2 = NULL;\n\tsize_t cs = 0, x, ds, len;\n\tsize_t s;\n\n\tif (NULL == arg)\n\t\treturn NULL;\n\n\ts = strlen(arg);\n\n\t/* Find trailing whitespaces */\n\twhile ((s > 0) && isspace(arg[s - 1]))\n\t\ts--;\n\n\t/* Prepare a initial buffer with the size of the result string. */\n\tds = s + 1;\n\n\tif (s)\n\t{\n\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\tif (!tmp2)\n\t\t\tfree(tmp);\n\t\ttmp = tmp2;\n\t}\n\n\tif (NULL == tmp)\n\t{\n\t\tfprintf(stderr,  \""Could not allocate string buffer.\\n\"");\n\t\texit(-2);\n\t}\n\n\t/* Copy character for character and check, if it is necessary to escape. */\n\tmemset(tmp, 0, ds * sizeof(CHAR));\n\n\tfor (x = 0; x < s; x++)\n\t{\n\t\tswitch (arg[x])\n\t\t{\n\t\t\tcase '<':\n\t\t\t\tlen = format ? 13 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-3);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""<replaceable>\"", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""&lt;\"", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tlen = format ? 14 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-4);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""</replaceable>\"", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \""&lt;\"", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\t\tds += 5;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-5);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 's';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '\""':\n\t\t\t\tds += 5;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-6);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'q';\n\t\t\t\ttmp[cs++] = 'u';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 't';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tds += 4;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \""Could not reallocate string buffer.\\n\"");\n\t\t\t\t\texit(-7);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'm';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttmp[cs++] = arg[x];\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Assure, the string is '\\0' terminated. */\n\t\ttmp[ds - 1] = '\\0';\n\t}\n\n\treturn tmp;\n}""}]","{""function"": 1, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(file:region.c, func:region16_union_rect)"", ""result"": [{""code"": ""BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that ..."", ""start_line"": 486, ""end_line"": 686, ""full_name"": ""region16_union_rect"", ""file_path"": ""libfreerdp/codec/region.c""}]}, {""source"": ""code_info(file:region.c, lines:487-680)"", ""result"": ""{\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n""}, {""source"": ""value_info(file:region.c, value:newItems)"", ""result"": {""value_trace"": [{""full_code"": ""* newItems = NULL"", ""line"": 491, ""func_name"": ""region16_union_rect""}, {""full_code"": ""newItems = allocateRegion((1 + region16_n_rects(src)) * 4)"", ""line"": 518, ""func_name"": ""region16_union_rect""}, {""full_code"": ""newItems = allocateRegion(nbRects)"", ""line"": 748, ""func_name"": ""region16_intersect_rect""}], ""struct_var"": ""newItems"", ""struct_type"": ""REGION16_DATA*"", ""struct_definition"": ""typedef struct _REGION16_DATA REGION16_DATA;""}}]","libfreerdp/codec/region.c:674-676: Original code assigned `dst->data = realloc(newItems, newItems->size);` without intermediate validation. If realloc failed, `newItems` (allocated at libfreerdp/codec/region.c:518) would be leaked because the original pointer was overwritten. The patch introduces `tmpItems` to hold realloc's return value, checks for NULL, and ensures `newItems` is freed on failure (libfreerdp/codec/region.c:676-680).",0.95,./github/other_context/CVE-2019-17177
16,CVE-2019-19270,"CWE-476, CWE-295",c_cpp,"An issue was discovered in tls_verify_crl in ProFTPD through 1.3.6b. Failure to check for the appropriate field of a CRL entry (checking twice for subject, rather than once for subject and once for issuer) prevents some valid CRLs from being taken into account, and can allow clients whose certificates have been revoked to proceed with a connection to the server.",https://github.com/proftpd/proftpd/commit/81cc5dce4fc0285629a1b08a07a109af10c208dd,"Issue #859, #861: Fix handling of CRL lookups by properly using issuer for\nlookups, and guarding against null pointers.",1,"[{""func_name"": ""tls_verify_crl"", ""file_path"": ""contrib/mod_tls.c"", ""func_code"": ""static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\""%s\"",\n    \""CRL store present, checking client certificate against configured CRLs\"");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: subject = '%s'\"", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: issuer = '%s'\"", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\""error initializing CRL store context: %s\"", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \""CA CRL: Issuer: \"");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \"", lastUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \"", nextUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\""%s\"", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\""invalid signature on CRL: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\""CRL has invalid nextUpdate field: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\""%s\"", \""CRL is expired, revoking all certificates until an \""\n          \""updated CRL is obtained\"");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\""certificate with serial number %ld (0x%lX) revoked per CRL \""\n            \""from issuer '%s'\"", serial, serial, cp ? cp : \""(ERROR)\"");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}"", ""target"": 0}]","[{""func_name"": ""tls_verify_crl"", ""file_path"": ""contrib/mod_tls.c"", ""func_code"": ""static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\""%s\"",\n    \""CRL store present, checking client certificate against configured CRLs\"");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: subject = '%s'\"", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: issuer = '%s'\"", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\""error initializing CRL store context: %s\"", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \""CA CRL: Issuer: \"");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \"", lastUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \"", nextUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\""%s\"", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\""invalid signature on CRL: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\""CRL has invalid nextUpdate field: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\""%s\"", \""CRL is expired, revoking all certificates until an \""\n          \""updated CRL is obtained\"");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, issuer);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, issuer);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n        if (revoked == NULL) {\n          continue;\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\""certificate with serial number %ld (0x%lX) revoked per CRL \""\n            \""from issuer '%s'\"", serial, serial, cp ? cp : \""(ERROR)\"");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}""}]","{""value"": 2, ""caller"": 1}","[{""source"": ""value_info(file:mod_tls.c, value:subject)"", ""result"": {""value_trace"": [{""full_code"": ""*subject = NULL"", ""line"": 9607, ""func_name"": ""tls_verify_crl""}, {""full_code"": ""subject = X509_get_subject_name(xs)"", ""line"": 9626, ""func_name"": ""tls_verify_crl""}], ""struct_var"": ""subject"", ""struct_type"": ""X509_NAME*"", ""struct_definition"": null}}, {""source"": ""value_info(file:mod_tls.c, value:issuer)"", ""result"": {""value_trace"": [{""full_code"": ""*issuer = NULL"", ""line"": 9607, ""func_name"": ""tls_verify_crl""}, {""full_code"": ""issuer = X509_get_issuer_name(xs)"", ""line"": 9630, ""func_name"": ""tls_verify_crl""}], ""struct_var"": ""issuer"", ""struct_type"": ""X509_NAME*"", ""struct_definition"": null}}, {""source"": ""caller_info(file:mod_tls.c, func:tls_verify_crl)"", ""result"": [{""call_line"": 9500, ""call_code"": ""tls_verify_crl(ok, ctx)"", ""caller_code"": ""static int tls_verify_cb(int ok, X509_STORE_CTX *ctx) {\n  config_rec *c;\n  int verify_err = 0;\n\n  /* We can configure the server to skip the peer's cert verification */\n  if (!(tls_flags & TLS_SESS_VERIFY_CLIENT_REQUIRED) &&\n      !(tls_flags & TLS_SESS_VERIFY_CLIENT_OPTIONAL)) {\n    return 1;\n  }\n\n  c = find_config(main_server->conf, CONF_PARAM, \""TLSVerifyOrder\"", FALSE);\n  if (c) {\n    register unsigned int i;\n\n    for (i = 0; i < c->argc; i++) {\n      char *mech = c->argv[i];\n\n      if (strncasecmp(mech, \""crl\"", 4) == 0) {\n        ok = tls_verify_crl(ok, ctx);\n        if (!ok) {\n          break;\n        }\n\n      } else if (strncasecmp(mech, \""ocsp\"", 5) == 0) {\n        ok = tls_verify_ocsp(ok, ctx);\n        if (!ok) {\n          break;\n        }\n      }\n    }\n\n  } else {\n    /* If no TLSVerifyOrder was specified, default to the old behavior of\n     * always checking CRLs, if configured, and not paying attention to\n     * any AIA attributes (i.e. no use of OCSP).\n     */\n    ok = tls_v..."", ""caller_start"": 9482, ""file_path"": ""contrib/mod_tls.c""}, {""call_line"": 9518, ""call_code"": ""tls_verify_crl(ok, ctx)"", ""caller_code"": ""static int tls_verify_cb(int ok, X509_STORE_CTX *ctx) {\n  config_rec *c;\n  int verify_err = 0;\n\n  /* We can configure the server to skip the peer's cert verification */\n  if (!(tls_flags & TLS_SESS_VERIFY_CLIENT_REQUIRED) &&\n      !(tls_flags & TLS_SESS_VERIFY_CLIENT_OPTIONAL)) {\n    return 1;\n  }\n\n  c = find_config(main_server->conf, CONF_PARAM, \""TLSVerifyOrder\"", FALSE);\n  if (c) {\n    register unsigned int i;\n\n    for (i = 0; i < c->argc; i++) {\n      char *mech = c->argv[i];\n\n      if (strncasecmp(mech, \""crl\"", 4) == 0) {\n        ok = tls_verify_crl(ok, ctx);\n        if (!ok) {\n          break;\n        }\n\n      } else if (strncasecmp(mech, \""ocsp\"", 5) == 0) {\n        ok = tls_verify_ocsp(ok, ctx);\n        if (!ok) {\n          break;\n        }\n      }\n    }\n\n  } else {\n    /* If no TLSVerifyOrder was specified, default to the old behavior of\n     * always checking CRLs, if configured, and not paying attention to\n     * any AIA attributes (i.e. no use of OCSP).\n     */\n    ok = tls_v..."", ""caller_start"": 9482, ""file_path"": ""contrib/mod_tls.c""}]}]","In contrib/mod_tls.c:tls_verify_crl(), the code incorrectly used 'subject = X509_get_subject_name(xs)' (line 9626) instead of 'issuer = X509_get_issuer_name(xs)' (line 9630) when calling X509_STORE_*_get1_crls (lines 9778-9779). This caused CRL lookups to filter by the certificate's subject name rather than its issuer name, ignoring valid CRLs issued by the correct CA. The patch replaces 'subject' with 'issuer' in the CRL lookup, ensuring revoked certificates are properly checked.",0.95,./github/other_context/CVE-2019-19270
17,CVE-2019-19924,CWE-755,c_cpp,"SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3,"When an error occurs while rewriting the parser tree for window functions\nin the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set,\nand make sure that this shuts down any subsequent code generation that might\ndepend on the transformations that were implemented.  This fixes a problem\ndiscovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",3,"[{""func_name"": ""vdbeVComment"", ""file_path"": ""src/vdbeaux.c"", ""func_code"": ""static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}"", ""target"": 0}, {""func_name"": ""sqlite3WindowRewrite"", ""file_path"": ""src/window.c"", ""func_code"": ""int sqlite3WindowRewrite(Parse *pParse, Select *p){\n  int rc = SQLITE_OK;\n  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    sqlite3 *db = pParse->db;\n    Select *pSub = 0;             /* The subquery */\n    SrcList *pSrc = p->pSrc;\n    Expr *pWhere = p->pWhere;\n    ExprList *pGroupBy = p->pGroupBy;\n    Expr *pHaving = p->pHaving;\n    ExprList *pSort = 0;\n\n    ExprList *pSublist = 0;       /* Expression list for sub-query */\n    Window *pMWin = p->pWin;      /* Master window object */\n    Window *pWin;                 /* Window object iterator */\n    Table *pTab;\n\n    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ){\n      return SQLITE_NOMEM;\n    }\n\n    p->pSrc = 0;\n    p->pWhere = 0;\n    p->pGroupBy = 0;\n    p->pHaving = 0;\n    p->selFlags &= ~SF_Aggregate;\n    p->selFlags |= SF_WinRewrite;\n\n    /* Create the ORDER BY clause for the sub-select. This is the concatenation\n    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it\n    ** redundant, remove the ORDER BY from the parent SELECT.  */\n    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);\n    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);\n    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){\n      int nSave = pSort->nExpr;\n      pSort->nExpr = p->pOrderBy->nExpr;\n      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        p->pOrderBy = 0;\n      }\n      pSort->nExpr = nSave;\n    }\n\n    /* Assign a cursor number for the ephemeral table used to buffer rows.\n    ** The OpenEphemeral instruction is coded later, after it is known how\n    ** many columns the table will have.  */\n    pMWin->iEphCsr = pParse->nTab++;\n    pParse->nTab += 3;\n\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);\n    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);\n\n    /* Append the PARTITION BY and ORDER BY expressions to the to the \n    ** sub-select expression list. They are required to figure out where \n    ** boundaries for partitions and sets of peer rows lie.  */\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);\n\n    /* Append the arguments passed to each window function to the\n    ** sub-select expression list. Also allocate two registers for each\n    ** window function - one for the accumulator, another for interim\n    ** results.  */\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      ExprList *pArgs = pWin->pOwner->x.pList;\n      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pWin->bExprArgs = 1;\n      }else{\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);\n      }\n      if( pWin->pFilter ){\n        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);\n        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);\n      }\n      pWin->regAccum = ++pParse->nMem;\n      pWin->regResult = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    }\n\n    /* If there is no ORDER BY or PARTITION BY clause, and the window\n    ** function accepts zero arguments, and there are no other columns\n    ** selected (e.g. \""SELECT row_number() OVER () FROM t1\""), it is possible\n    ** that pSublist is still NULL here. Add a constant expression here to \n    ** keep everything legal in this case. \n    */\n    if( pSublist==0 ){\n      pSublist = sqlite3ExprListAppend(pParse, 0, \n        sqlite3Expr(db, TK_INTEGER, \""0\"")\n      );\n    }\n\n    pSub = sqlite3SelectNew(\n        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0\n    );\n    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n    if( p->pSrc ){\n      Table *pTab2;\n      p->pSrc->a[0].pSelect = pSub;\n      sqlite3SrcListAssignCursors(pParse, p->pSrc);\n      pSub->selFlags |= SF_Expanded;\n      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);\n      if( pTab2==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        memcpy(pTab, pTab2, sizeof(Table));\n        pTab->tabFlags |= TF_Ephemeral;\n        p->pSrc->a[0].pTab = pTab;\n        pTab = pTab2;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);\n    }else{\n      sqlite3SelectDelete(db, pSub);\n    }\n    if( db->mallocFailed ) rc = SQLITE_NOMEM;\n    sqlite3DbFree(db, pTab);\n  }\n\n  return rc;\n}"", ""target"": 0}, {""func_name"": ""codeCompare"", ""file_path"": ""src/expr.c"", ""func_code"": ""static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}"", ""target"": 0}]","[{""func_name"": ""vdbeVComment"", ""file_path"": ""src/vdbeaux.c"", ""func_code"": ""static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed\n          || p->pParse->nErr>0 );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}""}, {""func_name"": ""sqlite3WindowRewrite"", ""file_path"": ""src/window.c"", ""func_code"": ""int sqlite3WindowRewrite(Parse *pParse, Select *p){\n  int rc = SQLITE_OK;\n  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    sqlite3 *db = pParse->db;\n    Select *pSub = 0;             /* The subquery */\n    SrcList *pSrc = p->pSrc;\n    Expr *pWhere = p->pWhere;\n    ExprList *pGroupBy = p->pGroupBy;\n    Expr *pHaving = p->pHaving;\n    ExprList *pSort = 0;\n\n    ExprList *pSublist = 0;       /* Expression list for sub-query */\n    Window *pMWin = p->pWin;      /* Master window object */\n    Window *pWin;                 /* Window object iterator */\n    Table *pTab;\n\n    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ){\n      return sqlite3ErrorToParser(db, SQLITE_NOMEM);\n    }\n\n    p->pSrc = 0;\n    p->pWhere = 0;\n    p->pGroupBy = 0;\n    p->pHaving = 0;\n    p->selFlags &= ~SF_Aggregate;\n    p->selFlags |= SF_WinRewrite;\n\n    /* Create the ORDER BY clause for the sub-select. This is the concatenation\n    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it\n    ** redundant, remove the ORDER BY from the parent SELECT.  */\n    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);\n    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);\n    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){\n      int nSave = pSort->nExpr;\n      pSort->nExpr = p->pOrderBy->nExpr;\n      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        p->pOrderBy = 0;\n      }\n      pSort->nExpr = nSave;\n    }\n\n    /* Assign a cursor number for the ephemeral table used to buffer rows.\n    ** The OpenEphemeral instruction is coded later, after it is known how\n    ** many columns the table will have.  */\n    pMWin->iEphCsr = pParse->nTab++;\n    pParse->nTab += 3;\n\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);\n    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);\n\n    /* Append the PARTITION BY and ORDER BY expressions to the to the \n    ** sub-select expression list. They are required to figure out where \n    ** boundaries for partitions and sets of peer rows lie.  */\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);\n\n    /* Append the arguments passed to each window function to the\n    ** sub-select expression list. Also allocate two registers for each\n    ** window function - one for the accumulator, another for interim\n    ** results.  */\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      ExprList *pArgs = pWin->pOwner->x.pList;\n      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pWin->bExprArgs = 1;\n      }else{\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);\n      }\n      if( pWin->pFilter ){\n        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);\n        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);\n      }\n      pWin->regAccum = ++pParse->nMem;\n      pWin->regResult = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    }\n\n    /* If there is no ORDER BY or PARTITION BY clause, and the window\n    ** function accepts zero arguments, and there are no other columns\n    ** selected (e.g. \""SELECT row_number() OVER () FROM t1\""), it is possible\n    ** that pSublist is still NULL here. Add a constant expression here to \n    ** keep everything legal in this case. \n    */\n    if( pSublist==0 ){\n      pSublist = sqlite3ExprListAppend(pParse, 0, \n        sqlite3Expr(db, TK_INTEGER, \""0\"")\n      );\n    }\n\n    pSub = sqlite3SelectNew(\n        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0\n    );\n    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n    if( p->pSrc ){\n      Table *pTab2;\n      p->pSrc->a[0].pSelect = pSub;\n      sqlite3SrcListAssignCursors(pParse, p->pSrc);\n      pSub->selFlags |= SF_Expanded;\n      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);\n      if( pTab2==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        memcpy(pTab, pTab2, sizeof(Table));\n        pTab->tabFlags |= TF_Ephemeral;\n        p->pSrc->a[0].pTab = pTab;\n        pTab = pTab2;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);\n    }else{\n      sqlite3SelectDelete(db, pSub);\n    }\n    if( db->mallocFailed ) rc = SQLITE_NOMEM;\n    sqlite3DbFree(db, pTab);\n  }\n\n  if( rc && pParse->nErr==0 ){\n    assert( pParse->db->mallocFailed );\n    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);\n  }\n  return rc;\n}""}, {""func_name"": ""codeCompare"", ""file_path"": ""src/expr.c"", ""func_code"": ""static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( pParse->nErr ) return 0;\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(func:sqlite3ErrorToParser)"", ""result"": [{""code"": ""int sqlite3ErrorToParser(sqlite3 *db, int errCode){\n  Parse *pParse;\n  if( db==0 || (pParse = db->pParse)==0 ) return errCode;\n  pParse->rc = errCode;\n  pParse->nErr++;\n  return errCode;\n}"", ""start_line"": 204, ""end_line"": 210, ""full_name"": ""sqlite3ErrorToParser"", ""file_path"": ""src/util.c""}]}, {""source"": ""code_info(file:window.c, lines:935-937)"", ""result"": ""    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ){\n      return SQLITE_NOMEM;\n    }\n""}]",src/window.c:935-937: Memory allocation failure returns SQLITE_NOMEM directly without setting pParse->nErr. src/window.c:1040-1044: Added check propagates errors to pParse->nErr via sqlite3ErrorToParser(). src/util.c:204-210: sqlite3ErrorToParser() increments pParse->nErr and sets return code. src/expr.c:377: Early return if pParse->nErr prevents invalid code generation. src/vdbeaux.c:1305-1307: Assertion updated to tolerate pParse->nErr>0.,0.95,./github/other_context/CVE-2019-19924
18,CVE-2016-8690,CWE-476,c_cpp,The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,https://github.com/jasper-software/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,"Fixed a sanitizer failure in the BMP codec.\nAlso, added a --debug-level command line option to the imginfo command\nfor debugging purposes.",3,"[{""func_name"": ""main"", ""file_path"": ""src/appl/imginfo.c"", ""func_code"": ""int main(int argc, char **argv)\n{\n\tint fmtid;\n\tint id;\n\tchar *infile;\n\tjas_stream_t *instream;\n\tjas_image_t *image;\n\tint width;\n\tint height;\n\tint depth;\n\tint numcmpts;\n\tint verbose;\n\tchar *fmtname;\n\n\tif (jas_init()) {\n\t\tabort();\n\t}\n\n\tcmdname = argv[0];\n\n\tinfile = 0;\n\tverbose = 0;\n\n\t/* Parse the command line options. */\n\twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n\t\tswitch (id) {\n\t\tcase OPT_VERBOSE:\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase OPT_VERSION:\n\t\t\tprintf(\""%s\\n\"", JAS_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase OPT_INFILE:\n\t\t\tinfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase OPT_HELP:\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Open the image file. */\n\tif (infile) {\n\t\t/* The image is to be read from a file. */\n\t\tif (!(instream = jas_stream_fopen(infile, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open input image file %s\\n\"", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\t/* The image is to be read from standard input. */\n\t\tif (!(instream = jas_stream_fdopen(0, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open standard input\\n\"");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif ((fmtid = jas_image_getfmt(instream)) < 0) {\n\t\tfprintf(stderr, \""unknown image format\\n\"");\n\t}\n\n\t/* Decode the image. */\n\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n\t\tfprintf(stderr, \""cannot load image\\n\"");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* Close the image file. */\n\tjas_stream_close(instream);\n\n\tnumcmpts = jas_image_numcmpts(image);\n\twidth = jas_image_cmptwidth(image, 0);\n\theight = jas_image_cmptheight(image, 0);\n\tdepth = jas_image_cmptprec(image, 0);\n\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n\t\tabort();\n\t}\n\tprintf(\""%s %d %d %d %d %ld\\n\"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n\n\tjas_image_destroy(image);\n\tjas_image_clearfmts();\n\n\treturn EXIT_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""bmp_decode"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n\t}\n\n\tjas_eprintf(\n\t  \""THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\""\n\t  \""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\""\n\t  \""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\""\n\t  \""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\""\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\""cannot get header\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\""cannot get info\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}"", ""target"": 1}, {""func_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (c << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""main"", ""file_path"": ""src/appl/imginfo.c"", ""func_code"": ""int main(int argc, char **argv)\n{\n\tint fmtid;\n\tint id;\n\tchar *infile;\n\tjas_stream_t *instream;\n\tjas_image_t *image;\n\tint width;\n\tint height;\n\tint depth;\n\tint numcmpts;\n\tint verbose;\n\tchar *fmtname;\n\tint debug;\n\n\tif (jas_init()) {\n\t\tabort();\n\t}\n\n\tcmdname = argv[0];\n\n\tinfile = 0;\n\tverbose = 0;\n\tdebug = 0;\n\n\t/* Parse the command line options. */\n\twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n\t\tswitch (id) {\n\t\tcase OPT_VERBOSE:\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase OPT_VERSION:\n\t\t\tprintf(\""%s\\n\"", JAS_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\tdebug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase OPT_INFILE:\n\t\t\tinfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase OPT_HELP:\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_setdbglevel(debug);\n\n\t/* Open the image file. */\n\tif (infile) {\n\t\t/* The image is to be read from a file. */\n\t\tif (!(instream = jas_stream_fopen(infile, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open input image file %s\\n\"", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\t/* The image is to be read from standard input. */\n\t\tif (!(instream = jas_stream_fdopen(0, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open standard input\\n\"");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif ((fmtid = jas_image_getfmt(instream)) < 0) {\n\t\tfprintf(stderr, \""unknown image format\\n\"");\n\t}\n\n\t/* Decode the image. */\n\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n\t\tjas_stream_close(instream);\n\t\tfprintf(stderr, \""cannot load image\\n\"");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* Close the image file. */\n\tjas_stream_close(instream);\n\n\tnumcmpts = jas_image_numcmpts(image);\n\twidth = jas_image_cmptwidth(image, 0);\n\theight = jas_image_cmptheight(image, 0);\n\tdepth = jas_image_cmptprec(image, 0);\n\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n\t\tabort();\n\t}\n\tprintf(\""%s %d %d %d %d %ld\\n\"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n\n\tjas_image_destroy(image);\n\tjas_image_clearfmts();\n\n\treturn EXIT_SUCCESS;\n}""}, {""func_name"": ""bmp_decode"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n\t}\n\n\tjas_eprintf(\n\t  \""THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\""\n\t  \""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\""\n\t  \""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\""\n\t  \""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\""\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\""cannot get header\\n\"");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\"",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\""cannot get info\\n\"");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\""BMP information: len %d; width %d; height %d; numplanes %d; \""\n\t  \""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \""\n\t  \""mincolors %d\\n\"", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}""}, {""func_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}""}]","{""function"": 4, ""query"": 1, ""value"": 1, ""code"": 1}","[{""source"": ""func_info(file:bmp_dec.c, func:bmp_getdata)"", ""result"": [{""code"": ""static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t..."", ""start_line"": 309, ""end_line"": 415, ""full_name"": ""bmp_getdata"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}, {""source"": ""func_info(file:bmp_dec.c, func:bmp_getint32)"", ""result"": [{""code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (c << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}"", ""start_line"": 434, ""end_line"": 453, ""full_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}, {""source"": ""query_info(query:cpg.call.name(\""bmp_getint32\"").file.name(\""src/libja...)"", ""result"": [""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>""]}, {""source"": ""value_info(file:bmp_dec.c, value:bmp_info_t)"", ""result"": {""value_trace"": [{""full_code"": ""bmp_info_t"", ""line"": 89, ""func_name"": null}, {""full_code"": ""typedef struct { int_fast32_t len; /* The length of the bitmap information header in bytes. */ int_fast32_t width; /* The width of the bitmap in pixels. */ int_fast32_t height; /* The height of the bitmap in pixels. */ int_fast8_t topdown; /* The bitmap data is specified in top-down order. */ int_fast16_t numplanes; /* The number of planes. This must be set to a value of one. */ int_fast16_t depth; /* The number of bits per pixel. */ int_fast32_t enctype; /* The type of compression used. */ int_fast32_t siz; /* The size of the image in bytes. */ int_fast32_t hres; /* The horizontal resolution in pixels/metre. */ int_fast32_t vres; /* The vertical resolution in pixels/metre. */ int_fast32_t numcolors; /* The number of color indices used by the bitmap. */ int_fast32_t mincolors; /* The number of color indices important for displaying the bitmap. */ bmp_palent_t *palents; /* The colors should be listed in order of importance. */ } bmp_info_t"", ""line"": 186, ""func_name"": null}], ""struct_var"": ""bmp_info_t"", ""struct_type"": ""bmp_info_t"", ""struct_definition"": ""typedef struct {\n\n\tint_fast32_t len;\n\t/* The length of the bitmap information header in bytes. */\n\n\tint_fast32_t width;\n\t/* The width of the bitmap in pixels. */\n\n\tint_fast32_t height;\n\t/* The height of the bitmap in pixels. */\n\n\tint_fast8_t topdown;\n\t/* The bitmap data is specified in top-down order. */\n\n\tint_fast16_t numplanes;\n\t/* The number of planes.  This must be set to a value of one. */\n\n\tint_fast16_t depth;\n\t/* The number of bits per pixel. */\n\n\tint_fast32_t enctype;\n\t/* The type of compression used. */\n\n\tint_fast32_t siz;\n\t/* The size of the image in bytes. */\n\n\tint_fast32_t hres;\n\t/* The horizontal resolution in pixels/metre. */\n\n\tint_fast32_t vres;\n\t/* The vertical resolution in pixels/metre. */\n\n\tint_fast32_t numcolors;\n\t/* The number of color indices used by the bitmap. */\n\n\tint_fast32_t mincolors;\n\t/* The number of color indices important for displaying the bitmap. */\n\n\tbmp_palent_t *palents;\n\t/* The colors should be listed in order of importance. */\n\n}""}}, {""source"": ""func_info(file:bmp_dec.c, func:bmp_getint32)"", ""result"": [{""code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (c << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}"", ""start_line"": 434, ""end_line"": 453, ""full_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}, {""source"": ""code_info(file:bmp_dec.c, lines:1-200)"", ""result"": ""/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \""User\"") obtaining a copy of this software and associated documentation\n * files (the \""Software\""), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\""HIGH\n * RISK ACTIVITIES\"").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Windows Bitmap File Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \""jasper/jas_types.h\""\n#include \""jasper/jas_stream.h\""\n#include \""jasper/jas_image.h\""\n#include \""jasper/jas_malloc.h\""\n\n#include \""bmp_cod.h\""\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr);\nstatic bmp_info_t *bmp_getinfo(jas_stream_t *in);\nstatic int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image);\nstatic int bmp_getint16(jas_stream_t *in, int_fast16_t *val);\nstatic int bmp_getint32(jas_stream_t *in, int_fast32_t *val);\nstatic int bmp_gobble(jas_stream_t *in, long n);\n\n/******************************************************************************\\\n* Interface functions.\n\\******************************************************************************/\n\njas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n\t}\n\n\tjas_eprintf(\n\t  \""THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\""\n\t  \""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\""\n\t  \""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\""\n\t  \""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\""\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\""cannot get header\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\""cannot get info\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}\n\nint bmp_validate(jas_stream_t *in)\n""}, {""source"": ""func_info(file:bmp_dec.c, func:bmp_getinfo)"", ""result"": [{""code"": ""static bmp_info_t *bmp_getinfo(jas_stream_t *in)\n{\n\tbmp_info_t *info;\n\tint i;\n\tbmp_palent_t *palent;\n\n\tif (!(info = bmp_info_create())) {\n\t\treturn 0;\n\t}\n\n\tif (bmp_getint32(in, &info->len) || info->len != 40 ||\n\t  bmp_getint32(in, &info->width) || bmp_getint32(in, &info->height) ||\n\t  bmp_getint16(in, &info->numplanes) ||\n\t  bmp_getint16(in, &info->depth) || bmp_getint32(in, &info->enctype) ||\n\t  bmp_getint32(in, &info->siz) ||\n\t  bmp_getint32(in, &info->hres) || bmp_getint32(in, &info->vres) ||\n\t  bmp_getint32(in, &info->numcolors) ||\n\t  bmp_getint32(in, &info->mincolors)) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0 ||\n\t  info->depth <= 0  || info->numcolors < 0 || info->mincolors < 0) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->enctype != BMP_ENC_RGB) {\n\t\tjas_eprintf(\""unsupported BMP encoding\\n..."", ""start_line"": 244, ""end_line"": 307, ""full_name"": ""bmp_getinfo"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}]","src/libjasper/bmp/bmp_dec.c:441-447: Improper handling of byte-to-32-bit integer conversion in `bmp_getint32` causes sign extension, leading to invalid `bmp_info_t` fields (e.g., `width`, `height`) during header parsing in `bmp_getinfo` (src/libjasper/bmp/bmp_dec.c:244-307). These invalid values are passed to `bmp_getdata` (src/libjasper/bmp/bmp_dec.c:309-415), which uses them in memory operations (e.g., `jas_matrix_create(1, info->width)`) to allocate matrices. If `info->width` is zero or invalid due to sign extension, `jas_matrix_create` returns NULL, and subsequent dereference of `cmpts[i]` in `bmp_getdata` causes a NULL pointer dereference.",0.95,./github/other_context/CVE-2016-8690
19,CVE-2017-17044,"CWE-755, CWE-835, CWE-754",c_cpp,An issue was discovered in Xen through 4.9.x allowing HVM guest OS users to cause a denial of service (infinite loop and host OS hang) by leveraging the mishandling of Populate on Demand (PoD) errors.,https://github.com/xen-project/xen/commit/a1c6c6768971ea387d7eba0803908ef0928b43ac,"x86/pod: prevent infinite loop when shattering large pages\n\nWhen populating pages, the PoD may need to split large ones using\np2m_set_entry and request the caller to retry (see ept_get_entry for\ninstance).\n\np2m_set_entry may fail to shatter if it is not possible to allocate\nmemory for the new page table. However, the error is not propagated\nresulting to the callers to retry infinitely the PoD.\n\nPrevent the infinite loop by return false when it is not possible to\nshatter the large mapping.\n\nThis is XSA-246.\n\nSigned-off-by: Julien Grall <julien.grall@linaro.org>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: George Dunlap <george.dunlap@citrix.com>",1,"[{""func_name"": ""p2m_pod_demand_populate"", ""file_path"": ""xen/arch/x86/mm/p2m-pod.c"", ""func_code"": ""bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                      p2m_populate_on_demand, p2m->default_access);\n        return true;\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                  p2m->default_access);\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\""%s: Dom%d out of PoD memory! (tot=%\""PRIu32\"" ents=%ld dom%d)\\n\"",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /* Remap this 2-meg region in singleton chunks */\n    /*\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    for ( i = 0; i < (1UL << order); i++ )\n        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,\n                      p2m_populate_on_demand, p2m->default_access);\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}"", ""target"": 0}]","[{""func_name"": ""p2m_pod_demand_populate"", ""file_path"": ""xen/arch/x86/mm/p2m-pod.c"", ""func_code"": ""bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                              p2m_populate_on_demand, p2m->default_access);\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                       p2m->default_access) )\n    {\n        p2m_pod_cache_add(p2m, p, order);\n        goto out_fail;\n    }\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\""%s: Dom%d out of PoD memory! (tot=%\""PRIu32\"" ents=%ld dom%d)\\n\"",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /*\n     * Remap this 2-meg region in singleton chunks. See the comment on the\n     * 1G page splitting path above for why a single call suffices.\n     *\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,\n                       p2m_populate_on_demand, p2m->default_access) )\n        return false;\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}""}]","{""function"": 2, ""caller"": 1, ""code"": 1}","[{""source"": ""func_info(file:p2m.c, func:p2m_set_entry)"", ""result"": [{""code"": ""int p2m_set_entry(struct p2m_domain *p2m, gfn_t gfn, mfn_t mfn,\n                  unsigned int page_order, p2m_type_t p2mt, p2m_access_t p2ma)\n{\n    struct domain *d = p2m->domain;\n    unsigned long todo = 1ul << page_order;\n    unsigned int order;\n    int set_rc, rc = 0;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n\n    while ( todo )\n    {\n        if ( hap_enabled(d) )\n        {\n            unsigned long fn_mask = !mfn_eq(mfn, INVALID_MFN) ? mfn_x(mfn) : 0;\n\n            fn_mask |= gfn_x(gfn) | todo;\n\n            order = (!(fn_mask & ((1ul << PAGE_ORDER_1G) - 1)) &&\n                     hap_has_1gb) ? PAGE_ORDER_1G :\n                    (!(fn_mask & ((1ul << PAGE_ORDER_2M) - 1)) &&\n                     hap_has_2mb) ? PAGE_ORDER_2M : PAGE_ORDER_4K;\n        }\n        else\n            order = 0;\n\n        set_rc = p2m->set_entry(p2m, gfn, mfn, order, p2mt, p2ma, -1);\n        if ( set_rc )\n            rc = set_rc;\n\n        gfn = gfn_add(gfn, 1ul << order);\n        if ( !mfn_eq(mfn, INVALID_..."", ""start_line"": 536, ""end_line"": 573, ""full_name"": ""p2m_set_entry<duplicate>0"", ""file_path"": ""xen/arch/x86/mm/p2m.c""}]}, {""source"": ""caller_info(func:p2m_pod_demand_populate)"", ""result"": [{""call_line"": 969, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, i * EPT_TABLE_ORDER)"", ""caller_code"": ""static mfn_t ept_get_entry(struct p2m_domain *p2m,\n                           gfn_t gfn_, p2m_type_t *t, p2m_access_t* a,\n                           p2m_query_t q, unsigned int *page_order,\n                           bool_t *sve)\n{\n    ept_entry_t *table =\n        map_domain_page(pagetable_get_mfn(p2m_get_pagetable(p2m)));\n    unsigned long gfn = gfn_x(gfn_);\n    unsigned long gfn_remainder = gfn;\n    ept_entry_t *ept_entry;\n    u32 index;\n    int i;\n    int ret = 0;\n    bool_t recalc = 0;\n    mfn_t mfn = INVALID_MFN;\n    struct ept_data *ept = &p2m->ept;\n\n    *t = p2m_mmio_dm;\n    *a = p2m_access_n;\n    if ( sve )\n        *sve = 1;\n\n    /* This pfn is higher than the highest the p2m map currently holds */\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        for ( i = ept->wl; i > 0; --i )\n            if ( (gfn & ~((1UL << (i * EPT_TABLE_ORDER)) - 1)) >\n                 p2m->max_mapped_pfn )\n                break;\n        goto out;\n    }\n\n    /* Should check if gfn obeys GAW here. */\n..."", ""caller_start"": 913, ""file_path"": ""xen/arch/x86/mm/p2m-ept.c""}, {""call_line"": 991, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, PAGE_ORDER_4K)"", ""caller_code"": ""static mfn_t ept_get_entry(struct p2m_domain *p2m,\n                           gfn_t gfn_, p2m_type_t *t, p2m_access_t* a,\n                           p2m_query_t q, unsigned int *page_order,\n                           bool_t *sve)\n{\n    ept_entry_t *table =\n        map_domain_page(pagetable_get_mfn(p2m_get_pagetable(p2m)));\n    unsigned long gfn = gfn_x(gfn_);\n    unsigned long gfn_remainder = gfn;\n    ept_entry_t *ept_entry;\n    u32 index;\n    int i;\n    int ret = 0;\n    bool_t recalc = 0;\n    mfn_t mfn = INVALID_MFN;\n    struct ept_data *ept = &p2m->ept;\n\n    *t = p2m_mmio_dm;\n    *a = p2m_access_n;\n    if ( sve )\n        *sve = 1;\n\n    /* This pfn is higher than the highest the p2m map currently holds */\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        for ( i = ept->wl; i > 0; --i )\n            if ( (gfn & ~((1UL << (i * EPT_TABLE_ORDER)) - 1)) >\n                 p2m->max_mapped_pfn )\n                break;\n        goto out;\n    }\n\n    /* Should check if gfn obeys GAW here. */\n..."", ""caller_start"": 913, ""file_path"": ""xen/arch/x86/mm/p2m-ept.c""}, {""call_line"": 805, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, PAGE_ORDER_1G)"", ""caller_code"": ""static mfn_t\np2m_pt_get_entry(struct p2m_domain *p2m, gfn_t gfn_,\n                 p2m_type_t *t, p2m_access_t *a, p2m_query_t q,\n                 unsigned int *page_order, bool_t *sve)\n{\n    mfn_t mfn;\n    unsigned long gfn = gfn_x(gfn_);\n    paddr_t addr = ((paddr_t)gfn) << PAGE_SHIFT;\n    l2_pgentry_t *l2e;\n    l1_pgentry_t *l1e;\n    unsigned int flags;\n    p2m_type_t l1t;\n    bool_t recalc;\n\n    ASSERT(paging_mode_translate(p2m->domain));\n\n    if ( sve )\n        *sve = 1;\n\n    /* XXX This is for compatibility with the old model, where anything not \n     * XXX marked as RAM was considered to be emulated MMIO space.\n     * XXX Once we start explicitly registering MMIO regions in the p2m \n     * XXX we will return p2m_invalid for unmapped gfns */\n    *t = p2m_mmio_dm;\n    /* Not implemented except with EPT */\n    *a = p2m_access_rwx; \n\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        /* This pfn is higher than the highest the p2m map currently holds */\n        if ( page_order )\n ..."", ""caller_start"": 734, ""file_path"": ""xen/arch/x86/mm/p2m-pt.c""}, {""call_line"": 847, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, PAGE_ORDER_2M)"", ""caller_code"": ""static mfn_t\np2m_pt_get_entry(struct p2m_domain *p2m, gfn_t gfn_,\n                 p2m_type_t *t, p2m_access_t *a, p2m_query_t q,\n                 unsigned int *page_order, bool_t *sve)\n{\n    mfn_t mfn;\n    unsigned long gfn = gfn_x(gfn_);\n    paddr_t addr = ((paddr_t)gfn) << PAGE_SHIFT;\n    l2_pgentry_t *l2e;\n    l1_pgentry_t *l1e;\n    unsigned int flags;\n    p2m_type_t l1t;\n    bool_t recalc;\n\n    ASSERT(paging_mode_translate(p2m->domain));\n\n    if ( sve )\n        *sve = 1;\n\n    /* XXX This is for compatibility with the old model, where anything not \n     * XXX marked as RAM was considered to be emulated MMIO space.\n     * XXX Once we start explicitly registering MMIO regions in the p2m \n     * XXX we will return p2m_invalid for unmapped gfns */\n    *t = p2m_mmio_dm;\n    /* Not implemented except with EPT */\n    *a = p2m_access_rwx; \n\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        /* This pfn is higher than the highest the p2m map currently holds */\n        if ( page_order )\n ..."", ""caller_start"": 734, ""file_path"": ""xen/arch/x86/mm/p2m-pt.c""}]}, {""source"": ""func_info(file:p2m.c, func:p2m_set_entry)"", ""result"": [{""code"": ""int p2m_set_entry(struct p2m_domain *p2m, gfn_t gfn, mfn_t mfn,\n                  unsigned int page_order, p2m_type_t p2mt, p2m_access_t p2ma)\n{\n    struct domain *d = p2m->domain;\n    unsigned long todo = 1ul << page_order;\n    unsigned int order;\n    int set_rc, rc = 0;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n\n    while ( todo )\n    {\n        if ( hap_enabled(d) )\n        {\n            unsigned long fn_mask = !mfn_eq(mfn, INVALID_MFN) ? mfn_x(mfn) : 0;\n\n            fn_mask |= gfn_x(gfn) | todo;\n\n            order = (!(fn_mask & ((1ul << PAGE_ORDER_1G) - 1)) &&\n                     hap_has_1gb) ? PAGE_ORDER_1G :\n                    (!(fn_mask & ((1ul << PAGE_ORDER_2M) - 1)) &&\n                     hap_has_2mb) ? PAGE_ORDER_2M : PAGE_ORDER_4K;\n        }\n        else\n            order = 0;\n\n        set_rc = p2m->set_entry(p2m, gfn, mfn, order, p2mt, p2ma, -1);\n        if ( set_rc )\n            rc = set_rc;\n\n        gfn = gfn_add(gfn, 1ul << order);\n        if ( !mfn_eq(mfn, INVALID_..."", ""start_line"": 536, ""end_line"": 573, ""full_name"": ""p2m_set_entry<duplicate>0"", ""file_path"": ""xen/arch/x86/mm/p2m.c""}]}, {""source"": ""code_info(file:p2m.c, lines:574-600)"", ""result"": ""\nmfn_t p2m_alloc_ptp(struct p2m_domain *p2m, unsigned int level)\n{\n    struct page_info *pg;\n\n    ASSERT(p2m);\n    ASSERT(p2m->domain);\n    ASSERT(p2m->domain->arch.paging.alloc_page);\n    pg = p2m->domain->arch.paging.alloc_page(p2m->domain);\n    if ( !pg )\n        return INVALID_MFN;\n\n    page_list_add_tail(pg, &p2m->pages);\n    BUILD_BUG_ON(PGT_l1_page_table * 2 != PGT_l2_page_table);\n    BUILD_BUG_ON(PGT_l1_page_table * 3 != PGT_l3_page_table);\n    BUILD_BUG_ON(PGT_l1_page_table * 4 != PGT_l4_page_table);\n    pg->u.inuse.type_info = (PGT_l1_page_table * level) | 1 | PGT_validated;\n\n    return page_to_mfn(pg);\n}\n\nvoid p2m_free_ptp(struct p2m_domain *p2m, struct page_info *pg)\n{\n    ASSERT(pg);\n    ASSERT(p2m);\n    ASSERT(p2m->domain);\n    ASSERT(p2m->domain->arch.paging.free_page);\n\n""}]","xen/arch/x86/mm/p2m-pod.c:1114-1117: p2m_pod_demand_populate returns true regardless of p2m_set_entry's success/failure. p2m_set_entry (xen/arch/x86/mm/p2m.c:536-573) returns non-zero on failure (e.g., memory allocation errors during page table splitting). Callers like ept_get_entry (xen/arch/x86/mm/p2m-ept.c:969, 991) retry on failure, leading to infinite loops. The patch returns false on p2m_set_entry failure, aborting retries.",0.95,./github/other_context/CVE-2017-17044
20,CVE-2018-13301,CWE-476,c_cpp,"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,"avcodec/mpeg4videodec: Check read profile before setting it\n\nFixes: null pointer dereference\nFixes: ffmpeg_crash_7.avi\n\nFound-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",2,"[{""func_name"": ""mpeg4_decode_profile_level"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n{\n\n    s->avctx->profile = get_bits(gb, 4);\n    s->avctx->level   = get_bits(gb, 4);\n\n    // for Simple profile, level 0\n    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n        s->avctx->level = 0;\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""ff_mpeg4_decode_picture_header"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\""WV1F\"") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\""QMP4\"")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \""frame skip %d\\n\"", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \""startcode: %3X \"", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Start\"");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Layer Start\"");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FGS bp start\"");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq Start\"");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq End\"");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""User Data\"");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Group of VOP start\"");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Session Error\"");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Start\"");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Plane start\"");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \""slice start\"");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \""extension start\"");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \""fgs start\"");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object start\"");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object Plane start\"");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object start\"");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object Plane start\"");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Still Texture Object start\"");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Spatial Layer start\"");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture SNR Layer start\"");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Tile start\"");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Shape Layer start\"");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""stuffing start\"");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""reserved\"");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""System start\"");\n            av_log(s->avctx, AV_LOG_DEBUG, \"" at %d\\n\"", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Ignoring multiple VOL headers\\n\"");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Missing VOL header\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}"", ""target"": 0}]","[{""func_name"": ""mpeg4_decode_profile_level"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n{\n\n    *profile = get_bits(gb, 4);\n    *level   = get_bits(gb, 4);\n\n    // for Simple profile, level 0\n    if (*profile == 0 && *level == 8) {\n        *level = 0;\n    }\n\n    return 0;\n}""}, {""func_name"": ""ff_mpeg4_decode_picture_header"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\""WV1F\"") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\""QMP4\"")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \""frame skip %d\\n\"", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \""startcode: %3X \"", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Start\"");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Layer Start\"");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FGS bp start\"");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq Start\"");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq End\"");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""User Data\"");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Group of VOP start\"");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Session Error\"");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Start\"");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Plane start\"");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \""slice start\"");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \""extension start\"");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \""fgs start\"");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object start\"");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object Plane start\"");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object start\"");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object Plane start\"");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Still Texture Object start\"");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Spatial Layer start\"");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture SNR Layer start\"");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Tile start\"");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Shape Layer start\"");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""stuffing start\"");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""reserved\"");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""System start\"");\n            av_log(s->avctx, AV_LOG_DEBUG, \"" at %d\\n\"", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Ignoring multiple VOL headers\\n\"");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \""Mixes studio and non studio profile\\n\"");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Missing VOL header\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}""}]",{},[],"libavcodec/mpeg4videodec.c:1984-1987 previously wrote unvalidated profile/level values directly to s->avctx without checking their validity. The patch (libavcodec/mpeg4videodec.c:3212-3245) now validates these values in local variables before assignment, preventing NULL dereference when s->avctx is accessed with invalid state.",0.95,./github/other_context/CVE-2018-13301
21,CVE-2018-17961,CWE-209,c_cpp,Artifex Ghostscript 9.25 and earlier allows attackers to bypass a sandbox protection mechanism via vectors involving errorhandler setup. NOTE: this issue exists because of an incomplete fix for CVE-2018-17183.,https://github.com/ArtifexSoftware/ghostpdl/commit/a6807394bd94b708be24758287b606154daaaed9,"For hidden operators, pass a name object to error handler.\n\nIn normal operation, Postscript error handlers are passed the object which\ntriggered the error: this is invariably an operator object.\n\nThe issue arises when an error is triggered by an operator which is for internal\nuse only, and that operator is then passed to the error handler, meaning it\nbecomes visible to the error handler code.\n\nBy converting to a name object, the error message is still valid, but we no\nlonger expose internal use only operators.\n\nThe change in gs_dps1.ps is related to the above: previously an error in\nscheck would throw an error against .gcheck, but as .gcheck is now a hidden\noperator, it resulted in a name object being passed to the error handler. As\nscheck is a 'real' operator, it's better to use the real operator, rather than\nthe name of an internal, hidden one.",1,"[{""func_name"": ""gs_call_interp"", ""file_path"": ""psi/interp.c"", ""func_code"": ""static int\ngs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,\n               int *pexit_code, ref * perror_object)\n{\n    ref *epref = pref;\n    ref doref;\n    ref *perrordict;\n    ref error_name;\n    int code, ccode;\n    ref saref;\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal;\n\n    *pexit_code = 0;\n    *gc_signal = 0;\n    ialloc_reset_requested(idmemory);\nagain:\n    /* Avoid a dangling error object that might get traced by a future GC. */\n    make_null(perror_object);\n    o_stack.requested = e_stack.requested = d_stack.requested = 0;\n    while (*gc_signal) { /* Some routine below triggered a GC. */\n        gs_gc_root_t epref_root;\n\n        *gc_signal = 0;\n        /* Make sure that doref will get relocated properly if */\n        /* a garbage collection happens with epref == &doref. */\n        gs_register_ref_root(imemory_system, &epref_root,\n                             (void **)&epref, \""gs_call_interp(epref)\"");\n        code = interp_reclaim(pi_ctx_p, -1);\n        i_ctx_p = *pi_ctx_p;\n        gs_unregister_root(imemory_system, &epref_root,\n                           \""gs_call_interp(epref)\"");\n        if (code < 0)\n            return code;\n    }\n    code = interp(pi_ctx_p, epref, perror_object);\n    i_ctx_p = *pi_ctx_p;\n    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {\n        *perror_object = i_ctx_p->error_object;\n        make_t(&i_ctx_p->error_object, t__invalid);\n    }\n    /* Prevent a dangling reference to the GC signal in ticks_left */\n    /* in the frame of interp, but be prepared to do a GC if */\n    /* an allocation in this routine asks for it. */\n    *gc_signal = 0;\n    set_gc_signal(i_ctx_p, 1);\n    if (esp < esbot)            /* popped guard entry */\n        esp = esbot;\n    switch (code) {\n        case gs_error_Fatal:\n            *pexit_code = 255;\n            return code;\n        case gs_error_Quit:\n            *perror_object = osp[-1];\n            *pexit_code = code = osp->value.intval;\n            osp -= 2;\n            return\n                (code == 0 ? gs_error_Quit :\n                 code < 0 && code > -100 ? code : gs_error_Fatal);\n        case gs_error_InterpreterExit:\n            return 0;\n        case gs_error_ExecStackUnderflow:\n/****** WRONG -- must keep mark blocks intact ******/\n            ref_stack_pop_block(&e_stack);\n            doref = *perror_object;\n            epref = &doref;\n            goto again;\n        case gs_error_VMreclaim:\n            /* Do the GC and continue. */\n            /* We ignore the return value here, if it fails here\n             * we'll call it again having jumped to the \""again\"" label.\n             * Where, assuming it fails again, we'll handle the error.\n             */\n            (void)interp_reclaim(pi_ctx_p,\n                                  (osp->value.intval == 2 ?\n                                   avm_global : avm_local));\n            i_ctx_p = *pi_ctx_p;\n            make_oper(&doref, 0, zpop);\n            epref = &doref;\n            goto again;\n        case gs_error_NeedInput:\n        case gs_error_interrupt:\n            return code;\n    }\n    /* Adjust osp in case of operand stack underflow */\n    if (osp < osbot - 1)\n        osp = osbot - 1;\n    /* We have to handle stack over/underflow specially, because */\n    /* we might be able to recover by adding or removing a block. */\n    switch (code) {\n        case gs_error_dictstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_dstack, which does a ref_stack_extend, */\n            /* so if` we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            /* Skip system dictionaries for CET 20-02-02 */\n            ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_pop_to(&d_stack, min_dstack_size);\n            dict_set_top();\n            *++osp = saref;\n            break;\n        case gs_error_dictstackunderflow:\n            if (ref_stack_pop_block(&d_stack) >= 0) {\n                dict_set_top();\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n        case gs_error_execstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_estack, which does a ref_stack_extend, */\n            /* so if we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            {\n                uint count = ref_stack_count(&e_stack);\n                uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM;\n\n                if (count > limit) {\n                    /*\n                     * If there is an e-stack mark within MIN_BLOCK_ESTACK of\n                     * the new top, cut the stack back to remove the mark.\n                     */\n                    int skip = count - limit;\n                    int i;\n\n                    for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) {\n                        const ref *ep = ref_stack_index(&e_stack, i);\n\n                        if (r_has_type_attrs(ep, t_null, a_executable)) {\n                            skip = i + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(i_ctx_p, skip);\n                }\n            }\n            *++osp = saref;\n            break;\n        case gs_error_stackoverflow:\n            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */\n                /* it might be a procedure being pushed as a */\n                /* literal.  We check for this case specially. */\n                doref = *perror_object;\n                if (r_is_proc(&doref)) {\n                    *++osp = doref;\n                    make_null_proc(&doref);\n                }\n                epref = &doref;\n                goto again;\n            }\n            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_clear(&o_stack);\n            *++osp = saref;\n            break;\n        case gs_error_stackunderflow:\n            if (ref_stack_pop_block(&o_stack) >= 0) {\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n    }\n    if (user_errors < 0)\n        return code;\n    if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n        return code;            /* out-of-range error code! */\n\n    /*  We refer to gserrordict first, which is not accessible to Postcript jobs\n     *  If we're running with SAFERERRORS all the handlers are copied to gserrordict\n     *  so we'll always find the default one. If not SAFERERRORS, only gs specific\n     *  errors are in gserrordict.\n     */\n    if (dict_find_string(systemdict, \""gserrordict\"", &perrordict) <= 0 ||\n        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n         (dict_find_string(systemdict, \""errordict\"", &perrordict) <= 0 ||\n          dict_find(perrordict, &error_name, &epref) <= 0))\n        )\n        return code;            /* error name not in errordict??? */\n\n    doref = *epref;\n    epref = &doref;\n    /* Push the error object on the operand stack if appropriate. */\n    if (!GS_ERROR_IS_INTERRUPT(code)) {\n        /* Replace the error object if within an oparray or .errorexec. */\n        osp++;\n        if (osp >= ostop) {\n            *pexit_code = gs_error_Fatal;\n            return_error(gs_error_Fatal);\n        }\n        *osp = *perror_object;\n        errorexec_find(i_ctx_p, osp);\n        /* If using SAFER, hand a name object to the error handler, rather than the executable\n         * object/operator itself.\n         */\n        if (i_ctx_p->LockFilePermissions) {\n            code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n            if (code < 0) {\n                const char *unknownstr = \""--unknown--\"";\n                rlen = strlen(unknownstr);\n                memcpy(buf, unknownstr, rlen);\n            }\n            else {\n                buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n                rlen += 4;\n            }\n            code = name_ref(imemory, buf, rlen, osp, 1);\n            if (code < 0)\n                make_null(osp);\n        }\n    }\n    goto again;\n}"", ""target"": 0}]","[{""func_name"": ""gs_call_interp"", ""file_path"": ""psi/interp.c"", ""func_code"": ""static int\ngs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,\n               int *pexit_code, ref * perror_object)\n{\n    ref *epref = pref;\n    ref doref;\n    ref *perrordict;\n    ref error_name;\n    int code, ccode;\n    ref saref;\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal;\n\n    *pexit_code = 0;\n    *gc_signal = 0;\n    ialloc_reset_requested(idmemory);\nagain:\n    /* Avoid a dangling error object that might get traced by a future GC. */\n    make_null(perror_object);\n    o_stack.requested = e_stack.requested = d_stack.requested = 0;\n    while (*gc_signal) { /* Some routine below triggered a GC. */\n        gs_gc_root_t epref_root;\n\n        *gc_signal = 0;\n        /* Make sure that doref will get relocated properly if */\n        /* a garbage collection happens with epref == &doref. */\n        gs_register_ref_root(imemory_system, &epref_root,\n                             (void **)&epref, \""gs_call_interp(epref)\"");\n        code = interp_reclaim(pi_ctx_p, -1);\n        i_ctx_p = *pi_ctx_p;\n        gs_unregister_root(imemory_system, &epref_root,\n                           \""gs_call_interp(epref)\"");\n        if (code < 0)\n            return code;\n    }\n    code = interp(pi_ctx_p, epref, perror_object);\n    i_ctx_p = *pi_ctx_p;\n    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {\n        *perror_object = i_ctx_p->error_object;\n        make_t(&i_ctx_p->error_object, t__invalid);\n    }\n    /* Prevent a dangling reference to the GC signal in ticks_left */\n    /* in the frame of interp, but be prepared to do a GC if */\n    /* an allocation in this routine asks for it. */\n    *gc_signal = 0;\n    set_gc_signal(i_ctx_p, 1);\n    if (esp < esbot)            /* popped guard entry */\n        esp = esbot;\n    switch (code) {\n        case gs_error_Fatal:\n            *pexit_code = 255;\n            return code;\n        case gs_error_Quit:\n            *perror_object = osp[-1];\n            *pexit_code = code = osp->value.intval;\n            osp -= 2;\n            return\n                (code == 0 ? gs_error_Quit :\n                 code < 0 && code > -100 ? code : gs_error_Fatal);\n        case gs_error_InterpreterExit:\n            return 0;\n        case gs_error_ExecStackUnderflow:\n/****** WRONG -- must keep mark blocks intact ******/\n            ref_stack_pop_block(&e_stack);\n            doref = *perror_object;\n            epref = &doref;\n            goto again;\n        case gs_error_VMreclaim:\n            /* Do the GC and continue. */\n            /* We ignore the return value here, if it fails here\n             * we'll call it again having jumped to the \""again\"" label.\n             * Where, assuming it fails again, we'll handle the error.\n             */\n            (void)interp_reclaim(pi_ctx_p,\n                                  (osp->value.intval == 2 ?\n                                   avm_global : avm_local));\n            i_ctx_p = *pi_ctx_p;\n            make_oper(&doref, 0, zpop);\n            epref = &doref;\n            goto again;\n        case gs_error_NeedInput:\n        case gs_error_interrupt:\n            return code;\n    }\n    /* Adjust osp in case of operand stack underflow */\n    if (osp < osbot - 1)\n        osp = osbot - 1;\n    /* We have to handle stack over/underflow specially, because */\n    /* we might be able to recover by adding or removing a block. */\n    switch (code) {\n        case gs_error_dictstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_dstack, which does a ref_stack_extend, */\n            /* so if` we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            /* Skip system dictionaries for CET 20-02-02 */\n            ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_pop_to(&d_stack, min_dstack_size);\n            dict_set_top();\n            *++osp = saref;\n            break;\n        case gs_error_dictstackunderflow:\n            if (ref_stack_pop_block(&d_stack) >= 0) {\n                dict_set_top();\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n        case gs_error_execstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_estack, which does a ref_stack_extend, */\n            /* so if we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            {\n                uint count = ref_stack_count(&e_stack);\n                uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM;\n\n                if (count > limit) {\n                    /*\n                     * If there is an e-stack mark within MIN_BLOCK_ESTACK of\n                     * the new top, cut the stack back to remove the mark.\n                     */\n                    int skip = count - limit;\n                    int i;\n\n                    for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) {\n                        const ref *ep = ref_stack_index(&e_stack, i);\n\n                        if (r_has_type_attrs(ep, t_null, a_executable)) {\n                            skip = i + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(i_ctx_p, skip);\n                }\n            }\n            *++osp = saref;\n            break;\n        case gs_error_stackoverflow:\n            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */\n                /* it might be a procedure being pushed as a */\n                /* literal.  We check for this case specially. */\n                doref = *perror_object;\n                if (r_is_proc(&doref)) {\n                    *++osp = doref;\n                    make_null_proc(&doref);\n                }\n                epref = &doref;\n                goto again;\n            }\n            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_clear(&o_stack);\n            *++osp = saref;\n            break;\n        case gs_error_stackunderflow:\n            if (ref_stack_pop_block(&o_stack) >= 0) {\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n    }\n    if (user_errors < 0)\n        return code;\n    if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n        return code;            /* out-of-range error code! */\n\n    /*  We refer to gserrordict first, which is not accessible to Postcript jobs\n     *  If we're running with SAFERERRORS all the handlers are copied to gserrordict\n     *  so we'll always find the default one. If not SAFERERRORS, only gs specific\n     *  errors are in gserrordict.\n     */\n    if (dict_find_string(systemdict, \""gserrordict\"", &perrordict) <= 0 ||\n        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n         (dict_find_string(systemdict, \""errordict\"", &perrordict) <= 0 ||\n          dict_find(perrordict, &error_name, &epref) <= 0))\n        )\n        return code;            /* error name not in errordict??? */\n\n    doref = *epref;\n    epref = &doref;\n    /* Push the error object on the operand stack if appropriate. */\n    if (!GS_ERROR_IS_INTERRUPT(code)) {\n        byte buf[260], *bufptr;\n        uint rlen;\n        /* Replace the error object if within an oparray or .errorexec. */\n        osp++;\n        if (osp >= ostop) {\n            *pexit_code = gs_error_Fatal;\n            return_error(gs_error_Fatal);\n        }\n        *osp = *perror_object;\n        errorexec_find(i_ctx_p, osp);\n\n        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {\n            code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n            if (code < 0) {\n                const char *unknownstr = \""--unknown--\"";\n                rlen = strlen(unknownstr);\n                memcpy(buf, unknownstr, rlen);\n                bufptr = buf;\n            }\n            else {\n                ref *tobj;\n                bufptr[rlen] = '\\0';\n                /* Only pass a name object if the operator doesn't exist in systemdict\n                 * i.e. it's an internal operator we have hidden\n                 */\n                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);\n                if (code < 0) {\n                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n                    rlen += 4;\n                    bufptr = buf;\n                }\n                else {\n                    bufptr = NULL;\n                }\n            }\n            if (bufptr) {\n                code = name_ref(imemory, buf, rlen, osp, 1);\n                if (code < 0)\n                    make_null(osp);\n            }\n        }\n    }\n    goto again;\n}""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(func:dict_find_string)"", ""result"": [{""code"": ""int\ndict_find_string(const ref * pdref, const char *kstr, ref ** ppvalue)\n{\n    int code;\n    ref kname;\n    if ( pdref != 0 ) {\n        dict *pdict = pdref->value.pdict;\n\n        if ((code = name_ref(dict_mem(pdict),\n                             (const byte *)kstr, strlen(kstr), &kname, -1)) < 0)\n            return code;\n        code = dict_find(pdref, &kname, ppvalue);\n        if (code == gs_error_dictfull)\n            return_error(gs_error_undefined);\n        return code;\n    }\n    return 0;\n}"", ""start_line"": 419, ""end_line"": 436, ""full_name"": ""dict_find_string"", ""file_path"": ""psi/idict.c""}]}, {""source"": ""value_info(file:interp.c, value:systemdict)"", ""result"": {""value_trace"": [{""full_code"": ""*systemdict = *ref_stack_index(&d_stack, ref_stack_count(&d_stack) - 1)"", ""line"": 171, ""func_name"": ""gs_vmreclaim""}], ""struct_var"": ""systemdict"", ""struct_type"": null, ""struct_definition"": null}}]","psi/interp.c:689-690: Check if `osp` is a string/name. If not, proceed to conversion logic. psi/interp.c:698-700: `dict_find_string()` is called on `systemdict` to check if the operator exists in the system dictionary. psi/idict.c:419-436: `dict_find_string()` converts the string to a name and searches the dictionary. If not found, returns an error code. psi/interp.c:704-706: If `dict_find_string()` returns an error (operator not in `systemdict`), the operator is converted to a name with a prefix (e.g., `--unknown--`).",0.95,./github/other_context/CVE-2018-17961
22,CVE-2018-5801,CWE-476,c_cpp,"An error within the ""LibRaw::unpack()"" function (src/libraw_cxx.cpp) in LibRaw versions prior to 0.18.7 can be exploited to trigger a NULL pointer dereference.",https://github.com/LibRaw/LibRaw/commit/0df5490b985c419de008d32168650bff17128914,SA79000 advisory fix,21,"[{""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}"", ""target"": 0}, {""func_name"": ""foveon_sd_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf = 0;\n  int pred[3], row, col, bit = -1, c, i;\n\n  read_shorts((ushort *)diff, 1024);\n  if (!load_flags)\n    foveon_decoder(1024, 0);\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model + 2) < 14)\n      get4();\n    for (col = bit = 0; col < width; col++)\n    {\n      if (load_flags)\n      {\n        bitbuf = get4();\n        FORC3 pred[2 - c] += diff[bitbuf >> c * 10 & 0x3ff];\n      }\n      else\n        FORC3\n        {\n          for (dindex = first_decode; dindex->branch[0];)\n          {\n            if ((bit = (bit - 1) & 31) == 31)\n              for (i = 0; i < 4; i++)\n                bitbuf = (bitbuf << 8) + fgetc(ifp);\n            dindex = dindex->branch[bitbuf >> bit & 1];\n          }\n          pred[c] += diff[dindex->leaf];\n          if (pred[c] >> 16 && ~pred[c] >> 16)\n            derror();\n        }\n      FORC3 image[row * width + col][c] = pred[c];\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }"", ""target"": 0}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }"", ""target"": 0}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}"", ""target"": 0}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}"", ""target"": 0}, {""func_name"": ""foveon_dp_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek(ifp, 8, SEEK_CUR);\n  foveon_huff(huff);\n  roff[0] = 48;\n  FORC3 roff[c + 1] = -(-(roff[c] + get4()) & -16);\n  FORC3\n  {\n    fseek(ifp, data_offset + roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        image[row * width + col][c] = hpred[col & 1];\n      }\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}"", ""target"": 0}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }"", ""target"": 0}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}"", ""target"": 0}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}"", ""target"": 0}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }"", ""target"": 0}, {""func_name"": ""LibRaw::unpack"", ""file_path"": ""src/libraw_cxx.cpp"", ""func_code"": ""int LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      libraw_internal_data.internal_data.meta_data = (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n      merror(libraw_internal_data.internal_data.meta_data, \""LibRaw::unpack()\"");\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost && imgdata.idata.raw_count == 1 && valid_for_dngsdk() &&\n        load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      int rr = try_dngsdk();\n    }\n#endif\n\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \""Magic\"", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (!strncasecmp(imgdata.idata.make, \""Olympus\"", 7) &&\n          ((imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model, \""SH-2\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""SH-3\"", 4) || !strncasecmp(imgdata.idata.model, \""TG-4\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""TG-5\"", 4)))\n        rawspeed_enabled = 0;\n\n      if (!strncasecmp(imgdata.idata.make, \""Canon\"", 5) && !strcasecmp(imgdata.idata.model, \""EOS 6D Mark II\""))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make, \""Nikon\"", 5) &&\n          (!strncasecmp(imgdata.idata.model, \""E\"", 1) || !strncasecmp(imgdata.idata.model, \""COOLPIX B\"", 9)))\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (O.use_rawspeed && rawspeed_enabled &&\n          !(is_sraw() &&\n            (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n      {\n        int rr = try_rawspeed();\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      else if (imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n      {\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (!(imgdata.idata.filters || P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}"", ""target"": 0}]","[{""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}""}, {""func_name"": ""foveon_sd_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_sd_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf = 0;\n  int pred[3], row, col, bit = -1, c, i;\n\n  read_shorts((ushort *)diff, 1024);\n  if (!load_flags)\n    foveon_decoder(1024, 0);\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model + 2) < 14)\n      get4();\n    for (col = bit = 0; col < width; col++)\n    {\n      if (load_flags)\n      {\n        bitbuf = get4();\n        FORC3 pred[2 - c] += diff[bitbuf >> c * 10 & 0x3ff];\n      }\n      else\n        FORC3\n        {\n          for (dindex = first_decode; dindex->branch[0];)\n          {\n            if ((bit = (bit - 1) & 31) == 31)\n              for (i = 0; i < 4; i++)\n                bitbuf = (bitbuf << 8) + fgetc(ifp);\n            dindex = dindex->branch[bitbuf >> bit & 1];\n          }\n          pred[c] += diff[dindex->leaf];\n          if (pred[c] >> 16 && ~pred[c] >> 16)\n            derror();\n        }\n      FORC3 image[row * width + col][c] = pred[c];\n    }\n  }\n}""}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}""}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }""}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }""}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}""}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}""}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}""}, {""func_name"": ""foveon_dp_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_dp_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek(ifp, 8, SEEK_CUR);\n  foveon_huff(huff);\n  roff[0] = 48;\n  FORC3 roff[c + 1] = -(-(roff[c] + get4()) & -16);\n  FORC3\n  {\n    fseek(ifp, data_offset + roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        image[row * width + col][c] = hpred[col & 1];\n      }\n    }\n  }\n}""}, {""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}""}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}""}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }""}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}""}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}""}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}""}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }""}, {""func_name"": ""LibRaw::unpack"", ""file_path"": ""src/libraw_cxx.cpp"", ""func_code"": ""int LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      libraw_internal_data.internal_data.meta_data = (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n      merror(libraw_internal_data.internal_data.meta_data, \""LibRaw::unpack()\"");\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost && imgdata.idata.raw_count == 1 && valid_for_dngsdk() &&\n        load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      int rr = try_dngsdk();\n    }\n#endif\n\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \""Magic\"", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (!strncasecmp(imgdata.idata.make, \""Olympus\"", 7) &&\n          ((imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model, \""SH-2\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""SH-3\"", 4) || !strncasecmp(imgdata.idata.model, \""TG-4\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""TG-5\"", 4)))\n        rawspeed_enabled = 0;\n\n      if (!strncasecmp(imgdata.idata.make, \""Canon\"", 5) && !strcasecmp(imgdata.idata.model, \""EOS 6D Mark II\""))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make, \""Nikon\"", 5) &&\n          (!strncasecmp(imgdata.idata.model, \""E\"", 1) || !strncasecmp(imgdata.idata.model, \""COOLPIX B\"", 9)))\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (O.use_rawspeed && rawspeed_enabled &&\n          !(is_sraw() &&\n            (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n      {\n        int rr = try_rawspeed();\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      else if (imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n      {\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(unsigned(MAX(S.width,S.raw_width)) * unsigned(MAX(S.height,S.raw_height)), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (!(imgdata.idata.filters || P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}""}]","{""code"": 1, ""value"": 1, ""caller"": 1}","[{""source"": ""code_info(file:libraw_cxx.cpp, lines:2780-2810)"", ""result"": ""        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = m_save;\n""}, {""source"": ""value_info(file:libraw_cxx.cpp, value:imgdata.image)"", ""result"": {""value_trace"": [{""full_code"": ""imgdata.image = NULL"", ""line"": 574, ""func_name"": ""LibRaw.recycle:void()""}, {""full_code"": ""imgdata.image = 0"", ""line"": 2679, ""func_name"": ""LibRaw.unpack:int(void)""}, {""full_code"": ""imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image))"", ""line"": 2795, ""func_name"": ""LibRaw.unpack:int(void)""}, {""full_code"": ""imgdata.image = 0"", ""line"": 2821, ""func_name"": ""LibRaw.unpack:int(void)""}], ""struct_var"": ""imgdata"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:libraw_cxx.cpp, func:unpack)"", ""result"": [{""call_line"": 105, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int ac, char *av[])\n{\n  int i, ret;\n  int autoscale = 0, black_subtraction = 1, use_gamma = 0;\n  char outfn[1024];\n\n  LibRaw RawProcessor;\n  if (ac < 2)\n  {\n  usage:\n    printf(\""4channels - LibRaw %s sample. %d cameras supported\\n\""\n           \""Usage: %s [-s N] [-g] [-A] [-B] [-N] raw-files....\\n\""\n           \""\\t-s N - select Nth image in file (default=0)\\n\""\n           \""\\t-g - use gamma correction with gamma 2.2 (not precise,use for visual inspection only)\\n\""\n           \""\\t-A - autoscaling (by integer factor)\\n\""\n           \""\\t-B - no black subtraction\\n\"",\n           LibRaw::version(), LibRaw::cameraCount(), av[0]);\n    return 0;\n  }\n\n#define P1 RawProcessor.imgdata.idata\n#define S RawProcessor.imgdata.sizes\n#define C RawProcessor.imgdata.color\n#define T RawProcessor.imgdata.thumbnail\n#define P2 RawProcessor.imgdata.other\n#define OUT RawProcessor.imgdata.params\n\n  OUT.output_bps = 16;\n  OUT.output_tiff = 1;\n  OUT.user_flip = 0;\n  OUT.no_auto_bright = 1;\n  OUT.half_size = 1;\n\n ..."", ""caller_start"": 36, ""file_path"": ""samples/4channels.cpp""}, {""call_line"": 576, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int argc, char *argv[])\n{\n  if (argc == 1)\n    usage(argv[0]);\n\n  LibRaw RawProcessor;\n  int i, arg, c, ret;\n  char opm, opt, *cp, *sp;\n  int use_bigfile = 0, use_timing = 0, use_mem = 0;\n#ifdef USE_DNGSDK\n  dng_host *dnghost = NULL;\n#endif\n#ifndef WIN32\n  int msize = 0, use_mmap = 0;\n\n#endif\n  void *iobuffer = 0;\n#ifdef OUT\n#undef OUT\n#endif\n\n#define OUT RawProcessor.imgdata.params\n\n  argv[argc] = (char *)\""\"";\n  for (arg = 1; (((opm = argv[arg][0]) - 2) | 2) == '+';)\n  {\n    char *optstr = argv[arg];\n    opt = argv[arg++][1];\n    if ((cp = strchr(sp = (char *)\""cnbrkStqmHABCgU\"", opt)) != 0)\n      for (i = 0; i < \""111411111144221\""[cp - sp] - '0'; i++)\n        if (!isdigit(argv[arg + i][0]) && !optstr[2])\n        {\n          fprintf(stderr, \""Non-numeric argument to \\\""-%c\\\""\\n\"", opt);\n          return 1;\n        }\n    if (!strchr(\""ftdeam\"", opt) && argv[arg - 1][2])\n      fprintf(stderr, \""Unknown option \\\""%s\\\"".\\n\"", argv[arg - 1]);\n    switch (opt)\n    {\n    case 'v':\n      verbos..."", ""caller_start"": 184, ""file_path"": ""samples/dcraw_emu.cpp""}, {""call_line"": 146, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int ac, char *av[])\n{\n  int i, ret, output_thumbs = 0;\n\n  // don't use fixed size buffers in real apps!\n\n  LibRaw RawProcessor;\n\n  if (ac < 2)\n  {\n    printf(\""mem_image - LibRaw sample, to illustrate work for memory buffers. Emulates dcraw [-4] [-1] [-e] [-h]\\n\""\n           \""Usage: %s [-D] [-T] [-v] [-e] raw-files....\\n\""\n           \""\\t-6 - output 16-bit PPM\\n\""\n           \""\\t-4 - linear 16-bit data\\n\""\n           \""\\t-e - extract thumbnails (same as dcraw -e in separate run)\\n\"",\n           \""\\t-h - use half_size\\n\"");\n    return 0;\n  }\n\n  putenv((char *)\""TZ=UTC\""); // dcraw compatibility, affects TIFF datestamp field\n\n#define P1 RawProcessor.imgdata.idata\n#define S RawProcessor.imgdata.sizes\n#define C RawProcessor.imgdata.color\n#define T RawProcessor.imgdata.thumbnail\n#define P2 RawProcessor.imgdata.other\n#define OUT RawProcessor.imgdata.params\n\n  for (i = 1; i < ac; i++)\n  {\n    if (av[i][0] == '-')\n    {\n      if (av[i][1] == '6' && av[i][2] == 0)\n        OUT.output_bps = 16;\n  ..."", ""caller_start"": 94, ""file_path"": ""samples/mem_image.cpp""}, {""call_line"": 86, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int ac, char *av[])\n{\n  int i, ret;\n\n  LibRaw RawProcessor;\n  if (ac < 2)\n  {\n    printf(\""multirender_test - LibRaw %s sample. Performs 4 different renderings of one file\\n\""\n           \"" %d cameras supported\\n\""\n           \""Usage: %s raw-files....\\n\"",\n           LibRaw::version(), LibRaw::cameraCount(), av[0]);\n    return 0;\n  }\n\n  for (i = 1; i < ac; i++)\n  {\n\n    printf(\""Processing file %s\\n\"", av[i]);\n\n    if ((ret = RawProcessor.open_file(av[i])) != LIBRAW_SUCCESS)\n    {\n      fprintf(stderr, \""Cannot open_file %s: %s\\n\"", av[i], libraw_strerror(ret));\n      continue; // no recycle b/c open file will recycle itself\n    }\n\n    if ((ret = RawProcessor.unpack()) != LIBRAW_SUCCESS)\n    {\n      fprintf(stderr, \""Cannot unpack %s: %s\\n\"", av[i], libraw_strerror(ret));\n      continue;\n    }\n    process_once(RawProcessor, 0, 0, 0, 1, -1, av[i]); // default flip\n    process_once(RawProcessor, 1, 0, 1, 2, -1, av[i]);\n    process_once(RawProcessor, 1, 1, 0, 3, -1, av[i]); // default fli..."", ""caller_start"": 61, ""file_path"": ""samples/multirender_test.cpp""}]}]","src/libraw_cxx.cpp:2793 (incorrect allocation size calculation in LibRaw::unpack() using S.raw_width * S.raw_height). If S.raw_width or S.raw_height is zero, calloc returns NULL. This NULL 'imgdata.image' is later dereferenced in functions like 'kodak_rgb_load_raw' (internal/dcraw_common.cpp:4069) without checks, causing a NULL pointer dereference.",0.95,./github/other_context/CVE-2018-5801
23,CVE-2018-9132,CWE-476,c_cpp,libming 0.4.8 has a NULL pointer dereference in the getInt function of the decompile.c file. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted swf file.,https://github.com/libming/libming/commit/dc65ba0497f4c5ca58be2018e2816e72baf63634,"decompile: Fix null pointer dereference in getInt\n\nWhen getInt is passed a PUSH_REGISTER parameter, it retrieves the\ncontent of this register and returns the value contained by this\nregister as an int. When this register is empty, we call getInt with\na NULL pointer and a null pointer dereference occurs.\n\nIn this patch we first make sure that regs[act->p.RegisterNumber] is\nnot NULL before doing anything with it.\n\nFixes #133 (CVE-2018-9132).",1,"[{""func_name"": ""getInt"", ""file_path"": ""util/decompile.c"", ""func_code"": ""static int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\treturn getInt(regs[act->p.RegisterNumber]);\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\""  Can't get int for type: %d\\n\"", act->Type);\n\t}\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""getInt"", ""file_path"": ""util/decompile.c"", ""func_code"": ""static int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\tif (regs[act->p.RegisterNumber])\n\t\t{\n\t\t\treturn getInt(regs[act->p.RegisterNumber]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSWF_warn(\""WARNING: retrieving undefined register values.\\n\"");\n\t\t\tbreak;\n\t\t}\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\""  Can't get int for type: %d\\n\"", act->Type);\n\t}\n\treturn 0;\n}""}]","{""value"": 5, ""code"": 3, ""function"": 2}","[{""source"": ""value_info(file:decompile.c, value:regs)"", ""result"": {""value_trace"": [{""full_code"": ""regs[0]=var"", ""line"": 1583, ""func_name"": ""decompileINCR_DECR""}, {""full_code"": ""regs[sact->Register] = data"", ""line"": 1639, ""func_name"": ""decompileSTOREREGISTER""}, {""full_code"": ""regs[0]=newVar3(getName(obj),\"".\"",getName(var))"", ""line"": 1776, ""func_name"": ""decompileSETMEMBER""}, {""full_code"": ""regs[sact->CatchRegister] = newVar(t)"", ""line"": 2722, ""func_name"": ""decompileTRY""}, {""full_code"": ""regs[sact->CatchRegister]=rsave"", ""line"": 2729, ""func_name"": ""decompileTRY""}], ""struct_var"": ""regs"", ""struct_type"": ""SWF_ACTIONPUSHPARAM*[256]"", ""struct_definition"": null}}, {""source"": ""value_info(file:decompile.c, value:act)"", ""result"": {""value_trace"": [{""full_code"": ""act = (SWF_ACTIONGOTOFRAME *)action"", ""line"": 931, ""func_name"": ""parseSWF_ACTIONRECORD""}, {""full_code"": ""act = (SWF_ACTIONGETURL *)action"", ""line"": 937, ""func_name"": ""parseSWF_ACTIONRECORD""}, {""full_code"": ""act = (SWF_ACTIONWAITFORFRAME *)action"", ""line"": 944, ""func_name"": ""parseSWF_ACTIONRECORD""}], ""struct_var"": ""act"", ""struct_type"": ""SWF_ACTIONGOTOFRAME*"", ""struct_definition"": ""struct SWF_ACTIONGOTOFRAME {\n\tUI8\tActionCode;\n\tUI16\tLength;\n\tUI32\tOffset;\n\tWORD\tFrame;\n}\n\nstruct SWF_ACTIONGOTOFRAME""}}, {""source"": ""code_info(file:decompile.c, lines:450-500)"", ""result"": ""\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\""WARNING: retrieving constants not present in the pool.\\n\"");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\""this\"");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\""\"");\n\n\treturn t;\n}\n\nstatic int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\treturn getInt(regs[act->p.RegisterNumber]);\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\""  Can't get int for type: %d\\n\"", act->Type);\n\t}\n\treturn 0;\n}\n\nstatic char *\ngetProperty(Property prop)\n{\n\tswitch(prop)\n\t{\n\tcase SWF_SETPROPERTY_X: \treturn(\""_x\""); break;\n\tcase SWF_SETPROPERTY_Y:\n""}, {""source"": ""func_info(func:parseSWF_ACTIONRECORD)"", ""result"": [{""code"": ""int\nparseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)\n{\n\tint thisaction = *thisactionp;\n\tSWF_ACTION *action = &(actions[thisaction]);\n\n\t//fprintf(stderr,\""ACTION[%d] Offset %d\\n\"", thisaction, fileOffset );\n\n\taction->SWF_ACTIONRECORD.Offset = fileOffset; /* remember where it came from */\n\tif( (action->SWF_ACTIONRECORD.ActionCode = readUInt8(f)) == SWFACTION_END )\n\t\treturn 0;\n\t/*\n\t * Actions without the high bit set take no additional\n\t * arguments, so we are done for these types.\n\t */\n\tif( !(action->SWF_ACTIONRECORD.ActionCode&0x80) ) {\n\t\taction->SWF_ACTIONRECORD.Length = 1; /* Fill in the size for later use */\n\t\treturn 1;\n\t}\n\n\taction->SWF_ACTIONRECORD.Length = 0; /* make valgrind happy */\n\t/*\n\t * Actions with the high bit set take additional\n\t * arguments, so we have to parse each one uniquely.\n\t */\n\tswitch( action->SWF_ACTIONRECORD.ActionCode ) {\n\t\t/* v3 actions */\n\tcase SWFACTION_GOTOFRAME:\n\t\t{\n\t\tACT_BEGIN(SWF_ACTIONGOTOFRAME)\n\t\tact->Frame = readUInt16(f);\n\t\tbr..."", ""start_line"": 902, ""end_line"": 1285, ""full_name"": ""parseSWF_ACTIONRECORD"", ""file_path"": ""util/parser.c""}]}, {""source"": ""code_info(file:decompile.c, lines:1-200)"", ""result"": ""/****************************************************************************\n *\n *  Copyright (C) 2006,2007 A.Kleine\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n ****************************************************************************/\n\n#define _GNU_SOURCE 1\n\n//#define DEBUGSTACK\n#define DECOMP_SWITCH\n// #define DEBUGSWITCH\n\n//#define STATEMENT_CLASS  \n//  I have uncommented some buggy class recognition stuff in decompileIF()\n//  to make work simple code lines like:  \""if(!a) trace(a);\""   - ak, November 2006\n\n//  To do: add some free()-calls for allocated blocks\n\n#include <assert.h>\n\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#include \""read.h\""\n#include \""action.h\""\n#include \""swftypes.h\""\n#include \""../src/blocks/error.h\""\n#include \""vasprintf.h\""\n\n\nstatic char **pool;\nstatic unsigned short poolcounter;\nstruct SWF_ACTIONPUSHPARAM *regs[256];\n\nstatic char *getName(struct SWF_ACTIONPUSHPARAM *act);\n\nstatic int offseoloop;\t// offset wherever a break can jump to (loops and switch)\n\nstatic void\ndumpRegs()\n{\nint i;\nfor(i=0;i<6;i++)\n\tif( regs[i] )\n\t\tprintf(\""reg[%d] %s\\n\"", i, getName(regs[i]));\n}\n\n/*\n * Start Package \n *\n * A package to build up a string that can be returned to the caller\n * ak/2006: Extended for temporary swichting to a 2nd buffer\n */\n#define USE_LIB 1\n\nstatic int strsize=0;\nstatic int strmaxsize=0;\nstatic char *dcstr=NULL;\nstatic char *dcptr=NULL;\n\n#define DCSTRSIZE 40960\n#define PARAM_STRSIZE 512\nvoid\ndcinit()\n{\n\tstrsize = 1; // We start with empty string, i.e. \\0\n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}\n\nvoid\ndcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n\n}\n\nvoid\ndcputs(const char *s)\n{\n\tint len=strlen(s);\n\tdcchkstr(len);\n\tstrcat(dcptr,s);\n\tdcptr+=len;\n\tstrsize+=len;\n}\n\nvoid\ndcputchar(char c)\n{\n\tdcchkstr(1);\n\n\t*dcptr++=c;\n\t*dcptr='\\000';\n\tstrsize++;\n}\n\nint\ndcprintf(char *format, ...)\n{\n\tchar *s;\n\tsize_t size;\n\tint ret;\n\n\tva_list args;\n\tva_start(args,format);\n\tret = vasprintf(&s,format,args);\n\tdcputs(s);\n\tsize=strlen(s);\n\tfree(s);\n\treturn size;\n}\n\nchar *\ndcgetstr()\n{\n\tchar *ret;\n\tret = dcstr;\n\tdcstr=NULL;\n\tstrmaxsize=0;\n\treturn ret;\n}\n\nstruct strbufinfo\n{\n\tint size;\n\tint maxsize;\n\tchar *str;\n\tchar *ptr;\n};\n\n\nstatic struct strbufinfo setTempString(void)\n{\n\tstruct strbufinfo current;\n\tcurrent.size=strsize;\n\tcurrent.maxsize=strmaxsize;\n\tcurrent.str=dcstr;\n\tcurrent.ptr=dcptr;\n\tdcinit();\n\treturn current;\n}\n\nstatic void setOrigString(struct strbufinfo old)\n{\n\tfree(dcstr);\t\t\t\t/* not needed anymore */\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n}\n\n// a variant of setOrigString()\n// but for further usage of 2nd buffer\n//\nstatic char *\nswitchToOrigString(struct strbufinfo old)\n{\n\tchar *tmp=dcstr;\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n\treturn tmp;\n}\n\n#if USE_LIB\n#define puts(s) dcputs(s)\n#define putchar(c) dcputchar(c)\n#define printf dcprintf\n#endif\n\n#define INDENT { int ii=gIndent; while(--ii>=0) { putchar(' '); putchar(' '); } }\n\n/* String used for terminating lines (see println) */\nstatic const char* newlinestring = \""\\\\\\n\"";\n\n/* Set the newline character. By default it is an escaped NL. */\nvoid\n""}, {""source"": ""value_info(file:decompile.c, value:act->p.RegisterNumber)"", ""result"": {""value_trace"": [{""full_code"": ""act->p.RegisterNumber"", ""line"": 329, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 330, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 331, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 333, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 338, ""func_name"": ""getString""}], ""struct_var"": ""act"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:parser.c, lines:1-200)"", ""result"": ""/****************************************************************************\n *\n *  Copyright (C) 2005-2006 \""Stuart R. Anderson\"" <anderson@netsweng.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n ****************************************************************************/\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/param.h>\n#include \""blocks/blocktypes.h\""\n#include \""abctypes.h\""\n#include \""action.h\""\n#include \""decompile.h\""\n#include \""parser.h\""\n#include \""read.h\""\n#include \""blocks/error.h\""\n\nextern struct Movie m;\nextern SWF_Parserstruct *blockParse (FILE *f, int length, SWFBlocktype header);\nconst char *blockName (SWFBlocktype header);\nvoid silentSkipBytes(FILE *f, int length);\n\n#define PAR_BEGIN(block) \t\t\t\t\t\t\\\n\tstruct block *parserrec; \t\t\t\t\t\\\n\tSWF_Parserstruct *pstruct; \t\t\t\t\t\\\n\tpstruct = calloc(1, sizeof(SWF_Parserstruct)); \t\t\t\\\n\tpstruct->length = length;\t\t\t\t\t\\\n\tpstruct->offset = fileOffset - ( (length >= 63 ) ? 6 : 2) ;\t\\\n\tparserrec= (struct block *)pstruct; \t\t\t\t\\\n\n#define PAR_END \\\n\treturn (SWF_Parserstruct *)parserrec;\n\n#define SKIP \\\n\tprintf(\""skipping %i bytes\\n\"", length); \\\n        readBytes(f, length);\n\n/* Parse Basic Flash types */\n\nvoid\nparseSWF_RGB (FILE * f, struct SWF_RGBA *rgb)\n{\n  rgb->red = readUInt8 (f);\n  rgb->green = readUInt8 (f);\n  rgb->blue = readUInt8 (f);\n  rgb->alpha = 255;\n}\n\nvoid\nparseSWF_RGBA (FILE * f, struct SWF_RGBA *rgb)\n{\n  rgb->red = readUInt8 (f);\n  rgb->green = readUInt8 (f);\n  rgb->blue = readUInt8 (f);\n  rgb->alpha = readUInt8 (f);\n}\n\nvoid\nparseSWF_RECT (FILE * f, struct SWF_RECT *rect)\n{\n  byteAlign ();\n\n  rect->Nbits = readBits (f, 5);\n  rect->Xmin = readSBits (f, rect->Nbits);\n  rect->Xmax = readSBits (f, rect->Nbits);\n  rect->Ymin = readSBits (f, rect->Nbits);\n  rect->Ymax = readSBits (f, rect->Nbits);\n}\n\nvoid\nparseSWF_MATRIX (FILE * f, struct SWF_MATRIX *matrix)\n{\n  byteAlign ();\n\n  matrix->HasScale = readBits (f, 1);\n  if (matrix->HasScale)\n    {\n      matrix->NScaleBits = readBits (f, 5);\n      matrix->ScaleX = (float) readSBits (f, matrix->NScaleBits) / 0x10000;\n      matrix->ScaleY = (float) readSBits (f, matrix->NScaleBits) / 0x10000;\n    }\n  matrix->HasRotate = readBits (f, 1);\n  if (matrix->HasRotate)\n    {\n      matrix->NRotateBits = readBits (f, 5);\n      matrix->RotateSkew0 =\n\t(float) readSBits (f, matrix->NRotateBits) / 0x10000;\n      matrix->RotateSkew1 =\n\t(float) readSBits (f, matrix->NRotateBits) / 0x10000;\n    }\n  matrix->NTranslateBits = readBits (f, 5);\n  matrix->TranslateX = readSBits (f, matrix->NTranslateBits);\n  matrix->TranslateY = readSBits (f, matrix->NTranslateBits);\n  byteAlign();\n}\n\nvoid \nparseSWF_FILTERLIST(FILE *f, SWF_FILTERLIST *list);\n\nint\nparseSWF_BUTTONRECORD (FILE * f, struct SWF_BUTTONRECORD *brec, int level)\n{\n  byteAlign ();\n\n  brec->ButtonReserved = readBits (f, 2);\n  brec->ButtonHasBlendMode = readBits(f, 1);\n  brec->ButtonHasFilterList = readBits(f, 1);\n  brec->ButtonStateHitTest = readBits (f, 1);\n  brec->ButtonStateDown = readBits (f, 1);\n  brec->ButtonStateOver = readBits (f, 1);\n  brec->ButtonStateUp = readBits (f, 1);\n  if( brec->ButtonStateHitTest == 0 &&\n      brec->ButtonStateDown == 0 &&\n      brec->ButtonStateOver == 0 &&\n      brec->ButtonStateUp == 0 &&\n      brec->ButtonHasBlendMode == 0 && \n      brec->ButtonHasFilterList == 0 &&\n      brec->ButtonReserved == 0)\n\t  return 0;  // CharacterEndFlag \n  brec->CharacterId = readUInt16 (f);\n  brec->PlaceDepth = readUInt16 (f);\n  parseSWF_MATRIX (f, &brec->PlaceMatrix);\n  if( level > 1 )\n  \tparseSWF_CXFORMWITHALPHA (f, &brec->ColorTransform);\n  if ( brec->ButtonHasFilterList )\n\tparseSWF_FILTERLIST(f, &brec->FilterList);\n  if ( brec->ButtonHasBlendMode )\n\tbrec->BlendMode = readUInt8(f);\n  return 1;\n}\n\nint\nparseSWF_BUTTONCONDACTION (FILE * f, struct SWF_BUTTONCONDACTION *bcarec, int end)\n{\n  int actionEnd, start;\n  byteAlign ();\n\n  start = fileOffset;\n  bcarec->CondActionSize = readUInt16 (f);\n  bcarec->CondIdleToOverDown = readBits (f, 1);\n  bcarec->CondOutDownToIdle = readBits (f, 1);\n  bcarec->CondOutDownToOverDown = readBits (f, 1);\n  bcarec->CondOverDownToOutDown = readBits (f, 1);\n  bcarec->CondOverDownToOverUp = readBits (f, 1);\n  bcarec->CondOverUpToOverDown = readBits (f, 1);\n  bcarec->CondOverUpToIdle = readBits (f, 1);\n  bcarec->CondIdleToOverUp = readBits (f, 1);\n  bcarec->CondKeyPress = readBits (f, 7);\n  bcarec->CondOverDownToIdle = readBits (f, 1);\n\n  bcarec->Actions =\n    (SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));\n  bcarec->numActions = 0;\n  while ( parseSWF_ACTIONRECORD (f, &(bcarec->numActions), bcarec->Actions) ) {\n      bcarec->Actions = (SWF_ACTION *) realloc (bcarec->Actions,\n\t\t\t\t\t\t\t (++bcarec->\n\t\t\t\t\t\t\t  numActions +\n\t\t\t\t\t\t\t  1) *\n\t\t\t\t\t\t\t sizeof\n\t\t\t\t\t\t\t (SWF_ACTION));\n    }\n\n  if(bcarec->CondActionSize > 0)\n\tactionEnd = start + bcarec->CondActionSize;\n  else\n\tactionEnd = end;\n\n  if(fileOffset >= actionEnd)\n  {\n\tSWF_warn(\""parseSWF_BUTTONCONDACTION: expected actionEnd flag\\n\"");\n  \treturn bcarec->CondActionSize;\n  }\n\n  /* read end action flag only there are realy action records\n   * if there are no actionrecords parseSWF_ACTIONRECORD did already\n   * read end action\n   */\n  if(bcarec->numActions > 0)\n    readUInt8(f);\n  return bcarec->CondActionSize;\n}\n\nvoid\nparseSWF_CXFORM (FILE * f, struct SWF_CXFORM *cxform)\n{\n""}, {""source"": ""value_info(file:decompile.c, value:SWF_ACTIONPUSHPARAM)"", ""result"": {""value_trace"": [{""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 750, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 716, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 624, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 581, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 567, ""func_name"": null}], ""struct_var"": ""SWF_ACTIONPUSHPARAM"", ""struct_type"": ""SWF_ACTIONPUSHPARAM"", ""struct_definition"": ""struct SWF_ACTIONPUSHPARAM\n\nstruct SWF_ACTIONPUSHPARAM\n\nstruct SWF_ACTIONPUSHPARAM {\n\tUI8\tActionCode;\n\tUI16\tLength;\n\tUI32\tOffset;\n\tUI8\tType;\n\tunion {\n\t\tSTRING\tString;\n\t\tFLOAT\tFloat;\n\t\tint\tRegisterNumber;\n\t\tint\tBoolean;\n\t\tDOUBLE\tDouble;\n\t\tSI32\tInteger;\n\t\tUI8\tConstant8;\n\t\tUI16\tConstant16;\n\t} p;\n}\n\nstruct SWF_ACTIONPUSHPARAM""}}, {""source"": ""func_info(file:parser.c, func:parseSWF_ACTIONRECORD)"", ""result"": [{""code"": ""int\nparseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)\n{\n\tint thisaction = *thisactionp;\n\tSWF_ACTION *action = &(actions[thisaction]);\n\n\t//fprintf(stderr,\""ACTION[%d] Offset %d\\n\"", thisaction, fileOffset );\n\n\taction->SWF_ACTIONRECORD.Offset = fileOffset; /* remember where it came from */\n\tif( (action->SWF_ACTIONRECORD.ActionCode = readUInt8(f)) == SWFACTION_END )\n\t\treturn 0;\n\t/*\n\t * Actions without the high bit set take no additional\n\t * arguments, so we are done for these types.\n\t */\n\tif( !(action->SWF_ACTIONRECORD.ActionCode&0x80) ) {\n\t\taction->SWF_ACTIONRECORD.Length = 1; /* Fill in the size for later use */\n\t\treturn 1;\n\t}\n\n\taction->SWF_ACTIONRECORD.Length = 0; /* make valgrind happy */\n\t/*\n\t * Actions with the high bit set take additional\n\t * arguments, so we have to parse each one uniquely.\n\t */\n\tswitch( action->SWF_ACTIONRECORD.ActionCode ) {\n\t\t/* v3 actions */\n\tcase SWFACTION_GOTOFRAME:\n\t\t{\n\t\tACT_BEGIN(SWF_ACTIONGOTOFRAME)\n\t\tact->Frame = readUInt16(f);\n\t\tbr..."", ""start_line"": 902, ""end_line"": 1285, ""full_name"": ""parseSWF_ACTIONRECORD"", ""file_path"": ""util/parser.c""}]}, {""source"": ""value_info(file:parser.c, value:RegisterNumber)"", ""result"": {""value_trace"": [{""full_code"": ""param->p.RegisterNumber = readUInt8(f)"", ""line"": 987, ""func_name"": ""parseSWF_ACTIONRECORD""}], ""struct_var"": ""RegisterNumber"", ""struct_type"": null, ""struct_definition"": null}}]","util/decompile.c: getInt() dereferences 'regs[act->p.RegisterNumber]' without a NULL check in the PUSH_REGISTER case (line 482). 'regs' is a SWF_ACTIONPUSHPARAM*[256] array initialized in decompileSTOREREGISTER (util/decompile.c:1639) and decompileTRY (util/decompile.c:2722). 'act->p.RegisterNumber' is set via readUInt8(f) in parseSWF_ACTIONRECORD (util/parser.c:987), which directly parses SWF input. If a PUSH_REGISTER action specifies an uninitialized register index, 'regs[RegisterNumber]' is NULL, causing a dereference.",0.95,./github/other_context/CVE-2018-9132
24,CVE-2016-9438,CWE-476,c_cpp,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,https://github.com/tats/w3m/commit/010b68580dc50ce183df11cc79721936ab5c4f25,Prevent segfault with malformed input_alt\n\nBug-Debian: https://github.com/tats/w3m/issues/18,1,"[{""func_name"": ""flushline"", ""file_path"": ""file.c"", ""func_code"": ""void\nflushline(struct html_feed_environ *h_env, struct readbuffer *obuf, int indent,\n\t  int force, int width)\n{\n    TextLineList *buf = h_env->buf;\n    FILE *f = h_env->f;\n    Str line = obuf->line, pass = NULL;\n    char *hidden_anchor = NULL, *hidden_img = NULL, *hidden_bold = NULL,\n\t*hidden_under = NULL, *hidden_italic = NULL, *hidden_strike = NULL,\n\t*hidden_ins = NULL, *hidden_input = NULL, *hidden = NULL;\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *df = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(df, \""flushline(%s,%d,%d,%d)\\n\"", obuf->line->ptr, indent, force,\n\t\twidth);\n\tif (buf) {\n\t    TextLineListItem *p;\n\t    for (p = buf->first; p; p = p->next) {\n\t\tfprintf(df, \""buf=\\\""%s\\\""\\n\"", p->ptr->line->ptr);\n\t    }\n\t}\n\tfclose(df);\n    }\n#endif\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && Strlastchar(line) == ' ') {\n\tStrshrink(line, 1);\n\tobuf->pos--;\n    }\n\n    append_tags(obuf);\n\n    if (obuf->anchor.url)\n\thidden = hidden_anchor = has_hidden_link(obuf, HTML_A);\n    if (obuf->img_alt) {\n\tif ((hidden_img = has_hidden_link(obuf, HTML_IMG_ALT)) != NULL) {\n\t    if (!hidden || hidden_img < hidden)\n\t\thidden = hidden_img;\n\t}\n    }\n    if (obuf->input_alt.in) {\n\tif ((hidden_input = has_hidden_link(obuf, HTML_INPUT_ALT)) != NULL) {\n\t    if (!hidden || hidden_input < hidden)\n\t\thidden = hidden_input;\n\t}\n    }\n    if (obuf->in_bold) {\n\tif ((hidden_bold = has_hidden_link(obuf, HTML_B)) != NULL) {\n\t    if (!hidden || hidden_bold < hidden)\n\t\thidden = hidden_bold;\n\t}\n    }\n    if (obuf->in_italic) {\n\tif ((hidden_italic = has_hidden_link(obuf, HTML_I)) != NULL) {\n\t    if (!hidden || hidden_italic < hidden)\n\t\thidden = hidden_italic;\n\t}\n    }\n    if (obuf->in_under) {\n\tif ((hidden_under = has_hidden_link(obuf, HTML_U)) != NULL) {\n\t    if (!hidden || hidden_under < hidden)\n\t\thidden = hidden_under;\n\t}\n    }\n    if (obuf->in_strike) {\n\tif ((hidden_strike = has_hidden_link(obuf, HTML_S)) != NULL) {\n\t    if (!hidden || hidden_strike < hidden)\n\t\thidden = hidden_strike;\n\t}\n    }\n    if (obuf->in_ins) {\n\tif ((hidden_ins = has_hidden_link(obuf, HTML_INS)) != NULL) {\n\t    if (!hidden || hidden_ins < hidden)\n\t\thidden = hidden_ins;\n\t}\n    }\n    if (hidden) {\n\tpass = Strnew_charp(hidden);\n\tStrshrink(line, line->ptr + line->length - hidden);\n    }\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && obuf->pos > width) {\n\tchar *tp = &line->ptr[obuf->bp.len - obuf->bp.tlen];\n\tchar *ep = &line->ptr[line->length];\n\n\tif (obuf->bp.pos == obuf->pos && tp <= ep &&\n\t    tp > line->ptr && tp[-1] == ' ') {\n\t    bcopy(tp, tp - 1, ep - tp + 1);\n\t    line->length--;\n\t    obuf->pos--;\n\t}\n    }\n\n    if (obuf->anchor.url && !hidden_anchor)\n\tStrcat_charp(line, \""</a>\"");\n    if (obuf->img_alt && !hidden_img)\n\tStrcat_charp(line, \""</img_alt>\"");\n    if (obuf->input_alt.in && !hidden_input)\n\tStrcat_charp(line, \""</input_alt>\"");\n    if (obuf->in_bold && !hidden_bold)\n\tStrcat_charp(line, \""</b>\"");\n    if (obuf->in_italic && !hidden_italic)\n\tStrcat_charp(line, \""</i>\"");\n    if (obuf->in_under && !hidden_under)\n\tStrcat_charp(line, \""</u>\"");\n    if (obuf->in_strike && !hidden_strike)\n\tStrcat_charp(line, \""</s>\"");\n    if (obuf->in_ins && !hidden_ins)\n\tStrcat_charp(line, \""</ins>\"");\n\n    if (obuf->top_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->top_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n\n    if (force == 1 || obuf->flag & RB_NFLUSHED) {\n\tTextLine *lbuf = newTextLine(line, obuf->pos);\n\tif (RB_GET_ALIGN(obuf) == RB_CENTER) {\n\t    align(lbuf, width, ALIGN_CENTER);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_RIGHT) {\n\t    align(lbuf, width, ALIGN_RIGHT);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_LEFT && obuf->flag & RB_INTABLE) {\n\t    align(lbuf, width, ALIGN_LEFT);\n\t}\n#ifdef FORMAT_NICE\n\telse if (obuf->flag & RB_FILL) {\n\t    char *p;\n\t    int rest, rrest;\n\t    int nspace, d, i;\n\n\t    rest = width - get_Str_strwidth(line);\n\t    if (rest > 1) {\n\t\tnspace = 0;\n\t\tfor (p = line->ptr + indent; *p; p++) {\n\t\t    if (*p == ' ')\n\t\t\tnspace++;\n\t\t}\n\t\tif (nspace > 0) {\n\t\t    int indent_here = 0;\n\t\t    d = rest / nspace;\n\t\t    p = line->ptr;\n\t\t    while (IS_SPACE(*p)) {\n\t\t\tp++;\n\t\t\tindent_here++;\n\t\t    }\n\t\t    rrest = rest - d * nspace;\n\t\t    line = Strnew_size(width + 1);\n\t\t    for (i = 0; i < indent_here; i++)\n\t\t\tStrcat_char(line, ' ');\n\t\t    for (; *p; p++) {\n\t\t\tStrcat_char(line, *p);\n\t\t\tif (*p == ' ') {\n\t\t\t    for (i = 0; i < d; i++)\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t    if (rrest > 0) {\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t\trrest--;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    lbuf = newTextLine(line, width);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* FORMAT_NICE */\n#ifdef TABLE_DEBUG\n\tif (w3m_debug) {\n\t    FILE *f = fopen(\""zzzproc1\"", \""a\"");\n\t    fprintf(f, \""pos=%d,%d, maxlimit=%d\\n\"",\n\t\t    visible_length(lbuf->line->ptr), lbuf->pos,\n\t\t    h_env->maxlimit);\n\t    fclose(f);\n\t}\n#endif\n\tif (lbuf->pos > h_env->maxlimit)\n\t    h_env->maxlimit = lbuf->pos;\n\tif (buf)\n\t    pushTextLine(buf, lbuf);\n\telse if (f) {\n\t    Strfputs(Str_conv_to_halfdump(lbuf->line), f);\n\t    fputc('\\n', f);\n\t}\n\tif (obuf->flag & RB_SPECIAL || obuf->flag & RB_NFLUSHED)\n\t    h_env->blank_lines = 0;\n\telse\n\t    h_env->blank_lines++;\n    }\n    else {\n\tchar *p = line->ptr, *q;\n\tStr tmp = Strnew(), tmp2 = Strnew();\n\n#define APPEND(str) \\\n\tif (buf) \\\n\t    appendTextLine(buf,(str),0); \\\n\telse if (f) \\\n\t    Strfputs((str),f)\n\n\twhile (*p) {\n\t    q = p;\n\t    if (sloppy_parse_line(&p)) {\n\t\tStrcat_charp_n(tmp, q, p - q);\n\t\tif (force == 2) {\n\t\t    APPEND(tmp);\n\t\t}\n\t\telse\n\t\t    Strcat(tmp2, tmp);\n\t\tStrclear(tmp);\n\t    }\n\t}\n\tif (force == 2) {\n\t    if (pass) {\n\t\tAPPEND(pass);\n\t    }\n\t    pass = NULL;\n\t}\n\telse {\n\t    if (pass)\n\t\tStrcat(tmp2, pass);\n\t    pass = tmp2;\n\t}\n    }\n\n    if (obuf->bottom_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->bottom_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n    if (obuf->top_margin < 0 || obuf->bottom_margin < 0)\n\treturn;\n\n    obuf->line = Strnew_size(256);\n    obuf->pos = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->bp.init_flag = 1;\n    obuf->flag &= ~RB_NFLUSHED;\n    set_breakpoint(obuf, 0);\n    obuf->prev_ctype = PC_ASCII;\n    link_stack = NULL;\n    fillline(obuf, indent);\n    if (pass)\n\tpassthrough(obuf, pass->ptr, 0);\n    if (!hidden_anchor && obuf->anchor.url) {\n\tStr tmp;\n\tif (obuf->anchor.hseq > 0)\n\t    obuf->anchor.hseq = -obuf->anchor.hseq;\n\ttmp = Sprintf(\""<A HSEQ=\\\""%d\\\"" HREF=\\\""\"", obuf->anchor.hseq);\n\tStrcat_charp(tmp, html_quote(obuf->anchor.url));\n\tif (obuf->anchor.target) {\n\t    Strcat_charp(tmp, \""\\\"" TARGET=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.target));\n\t}\n\tif (obuf->anchor.referer) {\n\t    Strcat_charp(tmp, \""\\\"" REFERER=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.referer));\n\t}\n\tif (obuf->anchor.title) {\n\t    Strcat_charp(tmp, \""\\\"" TITLE=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.title));\n\t}\n\tif (obuf->anchor.accesskey) {\n\t    char *c = html_quote_char(obuf->anchor.accesskey);\n\t    Strcat_charp(tmp, \""\\\"" ACCESSKEY=\\\""\"");\n\t    if (c)\n\t\tStrcat_charp(tmp, c);\n\t    else\n\t\tStrcat_char(tmp, obuf->anchor.accesskey);\n\t}\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_A);\n    }\n    if (!hidden_img && obuf->img_alt) {\n\tStr tmp = Strnew_charp(\""<IMG_ALT SRC=\\\""\"");\n\tStrcat_charp(tmp, html_quote(obuf->img_alt->ptr));\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_IMG_ALT);\n    }\n    if (!hidden_input && obuf->input_alt.in) {\n\tStr tmp;\n\tif (obuf->input_alt.hseq > 0)\n\t    obuf->input_alt.hseq = - obuf->input_alt.hseq;\n\ttmp = Sprintf(\""<INPUT_ALT hseq=\\\""%d\\\"" fid=\\\""%d\\\"" name=\\\""%s\\\"" type=\\\""%s\\\"" value=\\\""%s\\\"">\"",\n\t\t     obuf->input_alt.hseq,\n\t\t     obuf->input_alt.fid,\n\t\t     obuf->input_alt.name->ptr,\n\t\t     obuf->input_alt.type->ptr,\n\t\t     obuf->input_alt.value->ptr);\n\tpush_tag(obuf, tmp->ptr, HTML_INPUT_ALT);\n    }\n    if (!hidden_bold && obuf->in_bold)\n\tpush_tag(obuf, \""<B>\"", HTML_B);\n    if (!hidden_italic && obuf->in_italic)\n\tpush_tag(obuf, \""<I>\"", HTML_I);\n    if (!hidden_under && obuf->in_under)\n\tpush_tag(obuf, \""<U>\"", HTML_U);\n    if (!hidden_strike && obuf->in_strike)\n\tpush_tag(obuf, \""<S>\"", HTML_S);\n    if (!hidden_ins && obuf->in_ins)\n\tpush_tag(obuf, \""<INS>\"", HTML_INS);\n}"", ""target"": 0}]","[{""func_name"": ""flushline"", ""file_path"": ""file.c"", ""func_code"": ""void\nflushline(struct html_feed_environ *h_env, struct readbuffer *obuf, int indent,\n\t  int force, int width)\n{\n    TextLineList *buf = h_env->buf;\n    FILE *f = h_env->f;\n    Str line = obuf->line, pass = NULL;\n    char *hidden_anchor = NULL, *hidden_img = NULL, *hidden_bold = NULL,\n\t*hidden_under = NULL, *hidden_italic = NULL, *hidden_strike = NULL,\n\t*hidden_ins = NULL, *hidden_input = NULL, *hidden = NULL;\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *df = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(df, \""flushline(%s,%d,%d,%d)\\n\"", obuf->line->ptr, indent, force,\n\t\twidth);\n\tif (buf) {\n\t    TextLineListItem *p;\n\t    for (p = buf->first; p; p = p->next) {\n\t\tfprintf(df, \""buf=\\\""%s\\\""\\n\"", p->ptr->line->ptr);\n\t    }\n\t}\n\tfclose(df);\n    }\n#endif\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && Strlastchar(line) == ' ') {\n\tStrshrink(line, 1);\n\tobuf->pos--;\n    }\n\n    append_tags(obuf);\n\n    if (obuf->anchor.url)\n\thidden = hidden_anchor = has_hidden_link(obuf, HTML_A);\n    if (obuf->img_alt) {\n\tif ((hidden_img = has_hidden_link(obuf, HTML_IMG_ALT)) != NULL) {\n\t    if (!hidden || hidden_img < hidden)\n\t\thidden = hidden_img;\n\t}\n    }\n    if (obuf->input_alt.in) {\n\tif ((hidden_input = has_hidden_link(obuf, HTML_INPUT_ALT)) != NULL) {\n\t    if (!hidden || hidden_input < hidden)\n\t\thidden = hidden_input;\n\t}\n    }\n    if (obuf->in_bold) {\n\tif ((hidden_bold = has_hidden_link(obuf, HTML_B)) != NULL) {\n\t    if (!hidden || hidden_bold < hidden)\n\t\thidden = hidden_bold;\n\t}\n    }\n    if (obuf->in_italic) {\n\tif ((hidden_italic = has_hidden_link(obuf, HTML_I)) != NULL) {\n\t    if (!hidden || hidden_italic < hidden)\n\t\thidden = hidden_italic;\n\t}\n    }\n    if (obuf->in_under) {\n\tif ((hidden_under = has_hidden_link(obuf, HTML_U)) != NULL) {\n\t    if (!hidden || hidden_under < hidden)\n\t\thidden = hidden_under;\n\t}\n    }\n    if (obuf->in_strike) {\n\tif ((hidden_strike = has_hidden_link(obuf, HTML_S)) != NULL) {\n\t    if (!hidden || hidden_strike < hidden)\n\t\thidden = hidden_strike;\n\t}\n    }\n    if (obuf->in_ins) {\n\tif ((hidden_ins = has_hidden_link(obuf, HTML_INS)) != NULL) {\n\t    if (!hidden || hidden_ins < hidden)\n\t\thidden = hidden_ins;\n\t}\n    }\n    if (hidden) {\n\tpass = Strnew_charp(hidden);\n\tStrshrink(line, line->ptr + line->length - hidden);\n    }\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && obuf->pos > width) {\n\tchar *tp = &line->ptr[obuf->bp.len - obuf->bp.tlen];\n\tchar *ep = &line->ptr[line->length];\n\n\tif (obuf->bp.pos == obuf->pos && tp <= ep &&\n\t    tp > line->ptr && tp[-1] == ' ') {\n\t    bcopy(tp, tp - 1, ep - tp + 1);\n\t    line->length--;\n\t    obuf->pos--;\n\t}\n    }\n\n    if (obuf->anchor.url && !hidden_anchor)\n\tStrcat_charp(line, \""</a>\"");\n    if (obuf->img_alt && !hidden_img)\n\tStrcat_charp(line, \""</img_alt>\"");\n    if (obuf->input_alt.in && !hidden_input)\n\tStrcat_charp(line, \""</input_alt>\"");\n    if (obuf->in_bold && !hidden_bold)\n\tStrcat_charp(line, \""</b>\"");\n    if (obuf->in_italic && !hidden_italic)\n\tStrcat_charp(line, \""</i>\"");\n    if (obuf->in_under && !hidden_under)\n\tStrcat_charp(line, \""</u>\"");\n    if (obuf->in_strike && !hidden_strike)\n\tStrcat_charp(line, \""</s>\"");\n    if (obuf->in_ins && !hidden_ins)\n\tStrcat_charp(line, \""</ins>\"");\n\n    if (obuf->top_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->top_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n\n    if (force == 1 || obuf->flag & RB_NFLUSHED) {\n\tTextLine *lbuf = newTextLine(line, obuf->pos);\n\tif (RB_GET_ALIGN(obuf) == RB_CENTER) {\n\t    align(lbuf, width, ALIGN_CENTER);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_RIGHT) {\n\t    align(lbuf, width, ALIGN_RIGHT);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_LEFT && obuf->flag & RB_INTABLE) {\n\t    align(lbuf, width, ALIGN_LEFT);\n\t}\n#ifdef FORMAT_NICE\n\telse if (obuf->flag & RB_FILL) {\n\t    char *p;\n\t    int rest, rrest;\n\t    int nspace, d, i;\n\n\t    rest = width - get_Str_strwidth(line);\n\t    if (rest > 1) {\n\t\tnspace = 0;\n\t\tfor (p = line->ptr + indent; *p; p++) {\n\t\t    if (*p == ' ')\n\t\t\tnspace++;\n\t\t}\n\t\tif (nspace > 0) {\n\t\t    int indent_here = 0;\n\t\t    d = rest / nspace;\n\t\t    p = line->ptr;\n\t\t    while (IS_SPACE(*p)) {\n\t\t\tp++;\n\t\t\tindent_here++;\n\t\t    }\n\t\t    rrest = rest - d * nspace;\n\t\t    line = Strnew_size(width + 1);\n\t\t    for (i = 0; i < indent_here; i++)\n\t\t\tStrcat_char(line, ' ');\n\t\t    for (; *p; p++) {\n\t\t\tStrcat_char(line, *p);\n\t\t\tif (*p == ' ') {\n\t\t\t    for (i = 0; i < d; i++)\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t    if (rrest > 0) {\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t\trrest--;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    lbuf = newTextLine(line, width);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* FORMAT_NICE */\n#ifdef TABLE_DEBUG\n\tif (w3m_debug) {\n\t    FILE *f = fopen(\""zzzproc1\"", \""a\"");\n\t    fprintf(f, \""pos=%d,%d, maxlimit=%d\\n\"",\n\t\t    visible_length(lbuf->line->ptr), lbuf->pos,\n\t\t    h_env->maxlimit);\n\t    fclose(f);\n\t}\n#endif\n\tif (lbuf->pos > h_env->maxlimit)\n\t    h_env->maxlimit = lbuf->pos;\n\tif (buf)\n\t    pushTextLine(buf, lbuf);\n\telse if (f) {\n\t    Strfputs(Str_conv_to_halfdump(lbuf->line), f);\n\t    fputc('\\n', f);\n\t}\n\tif (obuf->flag & RB_SPECIAL || obuf->flag & RB_NFLUSHED)\n\t    h_env->blank_lines = 0;\n\telse\n\t    h_env->blank_lines++;\n    }\n    else {\n\tchar *p = line->ptr, *q;\n\tStr tmp = Strnew(), tmp2 = Strnew();\n\n#define APPEND(str) \\\n\tif (buf) \\\n\t    appendTextLine(buf,(str),0); \\\n\telse if (f) \\\n\t    Strfputs((str),f)\n\n\twhile (*p) {\n\t    q = p;\n\t    if (sloppy_parse_line(&p)) {\n\t\tStrcat_charp_n(tmp, q, p - q);\n\t\tif (force == 2) {\n\t\t    APPEND(tmp);\n\t\t}\n\t\telse\n\t\t    Strcat(tmp2, tmp);\n\t\tStrclear(tmp);\n\t    }\n\t}\n\tif (force == 2) {\n\t    if (pass) {\n\t\tAPPEND(pass);\n\t    }\n\t    pass = NULL;\n\t}\n\telse {\n\t    if (pass)\n\t\tStrcat(tmp2, pass);\n\t    pass = tmp2;\n\t}\n    }\n\n    if (obuf->bottom_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->bottom_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n    if (obuf->top_margin < 0 || obuf->bottom_margin < 0)\n\treturn;\n\n    obuf->line = Strnew_size(256);\n    obuf->pos = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->bp.init_flag = 1;\n    obuf->flag &= ~RB_NFLUSHED;\n    set_breakpoint(obuf, 0);\n    obuf->prev_ctype = PC_ASCII;\n    link_stack = NULL;\n    fillline(obuf, indent);\n    if (pass)\n\tpassthrough(obuf, pass->ptr, 0);\n    if (!hidden_anchor && obuf->anchor.url) {\n\tStr tmp;\n\tif (obuf->anchor.hseq > 0)\n\t    obuf->anchor.hseq = -obuf->anchor.hseq;\n\ttmp = Sprintf(\""<A HSEQ=\\\""%d\\\"" HREF=\\\""\"", obuf->anchor.hseq);\n\tStrcat_charp(tmp, html_quote(obuf->anchor.url));\n\tif (obuf->anchor.target) {\n\t    Strcat_charp(tmp, \""\\\"" TARGET=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.target));\n\t}\n\tif (obuf->anchor.referer) {\n\t    Strcat_charp(tmp, \""\\\"" REFERER=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.referer));\n\t}\n\tif (obuf->anchor.title) {\n\t    Strcat_charp(tmp, \""\\\"" TITLE=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.title));\n\t}\n\tif (obuf->anchor.accesskey) {\n\t    char *c = html_quote_char(obuf->anchor.accesskey);\n\t    Strcat_charp(tmp, \""\\\"" ACCESSKEY=\\\""\"");\n\t    if (c)\n\t\tStrcat_charp(tmp, c);\n\t    else\n\t\tStrcat_char(tmp, obuf->anchor.accesskey);\n\t}\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_A);\n    }\n    if (!hidden_img && obuf->img_alt) {\n\tStr tmp = Strnew_charp(\""<IMG_ALT SRC=\\\""\"");\n\tStrcat_charp(tmp, html_quote(obuf->img_alt->ptr));\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_IMG_ALT);\n    }\n    if (!hidden_input && obuf->input_alt.in) {\n\tStr tmp;\n\tif (obuf->input_alt.hseq > 0)\n\t    obuf->input_alt.hseq = - obuf->input_alt.hseq;\n\ttmp = Sprintf(\""<INPUT_ALT hseq=\\\""%d\\\"" fid=\\\""%d\\\"" name=\\\""%s\\\"" type=\\\""%s\\\"" value=\\\""%s\\\"">\"",\n\t\t     obuf->input_alt.hseq,\n\t\t     obuf->input_alt.fid,\n\t\t     obuf->input_alt.name ? obuf->input_alt.name->ptr : \""\"",\n\t\t     obuf->input_alt.type ? obuf->input_alt.type->ptr : \""\"",\n\t\t     obuf->input_alt.value ? obuf->input_alt.value->ptr : \""\"");\n\tpush_tag(obuf, tmp->ptr, HTML_INPUT_ALT);\n    }\n    if (!hidden_bold && obuf->in_bold)\n\tpush_tag(obuf, \""<B>\"", HTML_B);\n    if (!hidden_italic && obuf->in_italic)\n\tpush_tag(obuf, \""<I>\"", HTML_I);\n    if (!hidden_under && obuf->in_under)\n\tpush_tag(obuf, \""<U>\"", HTML_U);\n    if (!hidden_strike && obuf->in_strike)\n\tpush_tag(obuf, \""<S>\"", HTML_S);\n    if (!hidden_ins && obuf->in_ins)\n\tpush_tag(obuf, \""<INS>\"", HTML_INS);\n}""}]","{""value"": 2, ""function"": 1, ""query"": 3}","[{""source"": ""value_info(file:file.c, value:obuf->input_alt)"", ""result"": {""value_trace"": [{""full_code"": ""obuf->input_alt = obuf->bp.input_alt"", ""line"": 2476, ""func_name"": ""back_to_breakpoint""}], ""struct_var"": ""obuf"", ""struct_type"": ""readbuffer*"", ""struct_definition"": ""struct readbuffer {\n    Str line;\n    Lineprop cprop;\n    short pos;\n    Str prevchar;\n    long flag;\n    long flag_stack[RB_STACK_SIZE];\n    int flag_sp;\n    int status;\n    unsigned char end_tag;\n    short table_level;\n    short nobr_level;\n    Anchor anchor;\n    Str img_alt;\n    struct input_alt_attr input_alt;\n    char fontstat[FONTSTAT_SIZE];\n    char fontstat_stack[FONT_STACK_SIZE][FONTSTAT_SIZE];\n    int fontstat_sp;\n    Lineprop prev_ctype;\n    Breakpoint bp;\n    struct cmdtable *tag_stack[TAG_STACK_SIZE];\n    int tag_sp;\n    short top_margin;\n    short bottom_margin;\n}\n\nstruct readbuffer""}}, {""source"": ""value_info(value:input_alt)"", ""result"": {""value_trace"": [{""full_code"": ""obuf->bp.input_alt = obuf->input_alt"", ""line"": 2458, ""func_name"": ""set_breakpoint""}, {""full_code"": ""obuf->input_alt = obuf->bp.input_alt"", ""line"": 2476, ""func_name"": ""back_to_breakpoint""}, {""full_code"": ""obuf->input_alt.hseq = - obuf->input_alt.hseq"", ""line"": 3024, ""func_name"": ""flushline""}, {""full_code"": ""obuf->input_alt.hseq = hseq"", ""line"": 4952, ""func_name"": ""HTMLtagproc1""}, {""full_code"": ""obuf->input_alt.fid = i"", ""line"": 4955, ""func_name"": ""HTMLtagproc1""}], ""struct_var"": ""input_alt"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:HTMLtagproc1)"", ""result"": [{""code"": ""int\nHTMLtagproc1(struct parsed_tag *tag, struct html_feed_environ *h_env)\n{\n    char *p, *q, *r;\n    int i, w, x, y, z, count, width;\n    struct readbuffer *obuf = h_env->obuf;\n    struct environment *envs = h_env->envs;\n    Str tmp;\n    int hseq;\n    int cmd;\n#ifdef ID_EXT\n    char *id = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\n    cmd = tag->tagid;\n\n    if (obuf->flag & RB_PRE) {\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\tcase HTML_N_NOBR:\n\tcase HTML_PRE_INT:\n\tcase HTML_N_PRE_INT:\n\t    return 1;\n\t}\n    }\n\n    switch (cmd) {\n    case HTML_B:\n\tobuf->in_bold++;\n\tif (obuf->in_bold > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_B:\n\tif (obuf->in_bold == 1 && close_effect0(obuf, HTML_B))\n\t    obuf->in_bold = 0;\n\tif (obuf->in_bold > 0) {\n\t    obuf->in_bold--;\n\t    if (obuf->in_bold == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_I:\n\tobuf->in_italic++;\n\tif (obuf->in_italic > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_I:\n\tif (obuf->in_italic == 1 && close_effect0(obuf, HTML_I))\n\t    obuf->in_italic = 0;\n\tif (obuf->in_italic > 0) {\n\t    obuf->in_italic--;\n\t    if (obuf->in_italic == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_U:\n\tobuf->in_under++;\n\tif (obuf->in_under > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_U:\n\tif (obuf->in_under == 1 && close_effect0(obuf, HTML_U))\n\t    obuf->in_under = 0;\n\tif (obuf->in_under > 0) {\n\t    obuf->in_under--;\n\t    if (obuf->in_under == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_EM:\n\tHTMLlineproc1(\""<i>\"", h_env);\n\treturn 1;\n    case HTML_N_EM:\n\tHTMLlineproc1(\""</i>\"", h_env);\n\treturn 1;\n    case HTML_STRONG:\n\tHTMLlineproc1(\""<b>\"", h_env);\n\treturn 1;\n    case HTML_N_STRONG:\n\tHTMLlineproc1(\""</b>\"", h_env);\n\treturn 1;\n    case HTML_Q:\n\tHTMLlineproc1(\""`\"", h_env);\n\treturn 1;\n    case HTML_N_Q:\n\tHTMLlineproc1(\""'\"", h_env);\n\treturn 1;\n    case HTML_P:\n    case HTML_N_P:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\tif (cmd == HTML_P) {\n\t    set_alignment(obuf, tag);\n\t    obuf->flag |= RB_P;\n\t}\n\treturn 1;\n    case HTML_BR:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\th_env->blank_lines = 0;\n\treturn 1;\n    case HTML_H:\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P))) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tHTMLlineproc1(\""<b>\"", h_env);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_H:\n\tHTMLlineproc1(\""</b>\"", h_env);\n\tif (!(obuf->flag & RB_PREMODE)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\tclose_anchor(h_env, obuf);\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_UL:\n    case HTML_OL:\n    case HTML_BLQ:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_BLQ))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (cmd == HTML_UL || cmd == HTML_OL) {\n\t    if (parsedtag_get_value(tag, ATTR_START, &count)) {\n\t\tenvs[h_env->envc].count = count - 1;\n\t    }\n\t}\n\tif (cmd == HTML_OL) {\n\t    envs[h_env->envc].type = '1';\n\t    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t\tenvs[h_env->envc].type = (int)*p;\n\t    }\n\t}\n\tif (cmd == HTML_UL)\n\t    envs[h_env->envc].type = ul_type(tag, 0);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 1;\n    case HTML_N_UL:\n    case HTML_N_OL:\n    case HTML_N_DL:\n    case HTML_N_BLQ:\n\tCLOSE_DT;\n\tCLOSE_A;\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf, envs[h_env->envc - 1].indent, 0,\n\t\t      h_env->limit);\n\t    POP_ENV;\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ)) {\n\t\tdo_blankline(h_env, obuf,\n\t\t\t     envs[h_env->envc].indent,\n\t\t\t     INDENT_INCR, h_env->limit);\n\t\tobuf->flag |= RB_IGNORE_P;\n\t    }\n\t}\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_DL:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (parsedtag_exists(tag, ATTR_COMPACT))\n\t    envs[h_env->envc].env = HTML_DL_COMPACT;\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_LI:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (h_env->envc > 0) {\n\t    Str num;\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t    envs[h_env->envc].count++;\n\t    if (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t\tcount = atoi(p);\n\t\tif (count > 0)\n\t\t    envs[h_env->envc].count = count;\n\t\telse\n\t\t    envs[h_env->envc].count = 0;\n\t    }\n\t    switch (envs[h_env->envc].env) {\n\t    case HTML_UL:\n\t\tenvs[h_env->envc].type = ul_type(tag, envs[h_env->envc].type);\n\t\tfor (i = 0; i < INDENT_INCR - 3; i++)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\ttmp = Strnew();\n\t\tswitch (envs[h_env->envc].type) {\n\t\tcase 'd':\n\t\t    push_symbol(tmp, UL_SYMBOL_DISC, symbol_width, 1);\n\t\t    break;\n\t\tcase 'c':\n\t\t    push_symbol(tmp, UL_SYMBOL_CIRCLE, symbol_width, 1);\n\t\t    break;\n\t\tcase 's':\n\t\t    push_symbol(tmp, UL_SYMBOL_SQUARE, symbol_width, 1);\n\t\t    break;\n\t\tdefault:\n\t\t    push_symbol(tmp,\n\t\t\t\tUL_SYMBOL((h_env->envc_real -\n\t\t\t\t\t   1) % MAX_UL_LEVEL), symbol_width,\n\t\t\t\t1);\n\t\t    break;\n\t\t}\n\t\tif (symbol_width == 1)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tpush_str(obuf, symbol_width, tmp, PC_ASCII);\n\t\tpush_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    case HTML_OL:\n\t\tif (parsedtag_get_value(tag, ATTR_TYPE, &p))\n\t\t    envs[h_env->envc].type = (int)*p;\n\t\tswitch ((envs[h_env->envc].count > 0)? envs[h_env->envc].type: '1') {\n\t\tcase 'i':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'I':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tcase 'a':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'A':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tdefault:\n\t\t    num = Sprintf(\""%d\"", envs[h_env->envc].count);\n\t\t    break;\n\t\t}\n\t\tif (INDENT_INCR >= 4)\n\t\t    Strcat_charp(num, \"". \"");\n\t\telse\n\t\t    Strcat_char(num, '.');\n\t\tpush_spaces(obuf, 1, INDENT_INCR - num->length);\n\t\tpush_str(obuf, num->length, num, PC_ASCII);\n\t\tif (INDENT_INCR >= 4)\n\t\t    set_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    default:\n\t\tpush_spaces(obuf, 1, INDENT_INCR);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    flushline(h_env, obuf, 0, 0, h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DT:\n\tCLOSE_A;\n\tif (h_env->envc == 0 ||\n\t    (h_env->envc_real < h_env->nenv &&\n\t     envs[h_env->envc].env != HTML_DL &&\n\t     envs[h_env->envc].env != HTML_DL_COMPACT)) {\n\t    PUSH_ENV(HTML_DL);\n\t}\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t}\n\tif (!(obuf->flag & RB_IN_DT)) {\n\t    HTMLlineproc1(\""<b>\"", h_env);\n\t    obuf->flag |= RB_IN_DT;\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DD:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (envs[h_env->envc].env == HTML_DL_COMPACT) {\n\t    if (obuf->pos > envs[h_env->envc].indent)\n\t\tflushline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t  h_env->limit);\n\t    else\n\t\tpush_spaces(obuf, 1, envs[h_env->envc].indent - obuf->pos);\n\t}\n\telse\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t/* obuf->flag |= RB_IGNORE_P; */\n\treturn 1;\n    case HTML_TITLE:\n\tclose_anchor(h_env, obuf);\n\tprocess_title(tag);\n\tobuf->flag |= RB_TITLE;\n\tobuf->end_tag = HTML_N_TITLE;\n\treturn 1;\n    case HTML_N_TITLE:\n\tif (!(obuf->flag & RB_TITLE))\n\t    return 1;\n\tobuf->flag &= ~RB_TITLE;\n\tobuf->end_tag = 0;\n\ttmp = process_n_title(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_TITLE_ALT:\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    h_env->title = html_unquote(p);\n\treturn 0;\n    case HTML_FRAMESET:\n\tPUSH_ENV(cmd);\n\tpush_charp(obuf, 9, \""--FRAME--\"", PC_ASCII);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_N_FRAMESET:\n\tif (h_env->envc > 0) {\n\t    POP_ENV;\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\treturn 0;\n    case HTML_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= (RB_NOFRAMES | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag &= ~RB_NOFRAMES;\n\treturn 1;\n    case HTML_FRAME:\n\tq = r = NULL;\n\tparsedtag_get_value(tag, ATTR_SRC, &q);\n\tparsedtag_get_value(tag, ATTR_NAME, &r);\n\tif (q) {\n\t    q = html_quote(q);\n\t    push_tag(obuf, Sprintf(\""<a hseq=\\\""%d\\\"" href=\\\""%s\\\"">\"",\n\t\t\t\t   cur_hseq++, q)->ptr, HTML_A);\n\t    if (r)\n\t\tq = html_quote(r);\n\t    push_charp(obuf, get_strwidth(q), q, PC_ASCII);\n\t    push_tag(obuf, \""</a>\"", HTML_N_A);\n\t}\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_HR:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_hr(tag, h_env->limit, envs[h_env->envc].indent);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\tset_space_to_prevchar(obuf->prevchar);\n\treturn 1;\n    case HTML_PRE:\n\tx = parsedtag_exists(tag, ATTR_FOR_TABLE);\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!x)\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\telse\n\t    fillline(obuf, envs[h_env->envc].indent);\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_PRE:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t    h_env->blank_lines++;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_PRE_INT:\n\ti = obuf->line->length;\n\tappend_tags(obuf);\n\tif (!(obuf->flag & RB_SPECIAL)) {\n\t    set_breakpoint(obuf, obuf->line->length - i);\n\t}\n\tobuf->flag |= RB_PRE_INT;\n\treturn 0;\n    case HTML_N_PRE_INT:\n\tpush_tag(obuf, \""</pre_int>\"", HTML_N_PRE_INT);\n\tobuf->flag &= ~RB_PRE_INT;\n\tif (!(obuf->flag & RB_SPECIAL) && obuf->pos > obuf->bp.pos) {\n\t    set_prevchar(obuf->prevchar, \""\"", 0);\n\t    obuf->prev_ctype = PC_CTRL;\n\t}\n\treturn 1;\n    case HTML_NOBR:\n\tobuf->flag |= RB_NOBR;\n\tobuf->nobr_level++;\n\treturn 0;\n    case HTML_N_NOBR:\n\tif (obuf->nobr_level > 0)\n\t    obuf->nobr_level--;\n\tif (obuf->nobr_level == 0)\n\t    obuf->flag &= ~RB_NOBR;\n\treturn 0;\n    case HTML_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\treturn 1;\n    case HTML_N_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\treturn 1;\n    case HTML_LISTING:\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PLAIN | RB_IGNORE_P);\n\tswitch (cmd) {\n\tcase HTML_LISTING:\n\t    obuf->end_tag = HTML_N_LISTING;\n\t    break;\n\tcase HTML_XMP:\n\t    obuf->end_tag = HTML_N_XMP;\n\t    break;\n\tcase HTML_PLAINTEXT:\n\t    obuf->end_tag = MAX_HTMLTAG;\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_LISTING:\n    case HTML_N_XMP:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PLAIN;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_SCRIPT:\n\tobuf->flag |= RB_SCRIPT;\n\tobuf->end_tag = HTML_N_SCRIPT;\n\treturn 1;\n    case HTML_STYLE:\n\tobuf->flag |= RB_STYLE;\n\tobuf->end_tag = HTML_N_STYLE;\n\treturn 1;\n    case HTML_N_SCRIPT:\n\tobuf->flag &= ~RB_SCRIPT;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_N_STYLE:\n\tobuf->flag &= ~RB_STYLE;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_A:\n\tif (obuf->anchor.url)\n\t    close_anchor(h_env, obuf);\n\n\thseq = 0;\n\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p))\n\t    obuf->anchor.url = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TARGET, &p))\n\t    obuf->anchor.target = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_REFERER, &p))\n\t    obuf->anchor.referer = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    obuf->anchor.title = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_ACCESSKEY, &p))\n\t    obuf->anchor.accesskey = (unsigned char)*p;\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq))\n\t    obuf->anchor.hseq = hseq;\n\n\tif (hseq == 0 && obuf->anchor.url) {\n\t    obuf->anchor.hseq = cur_hseq;\n\t    tmp = process_anchor(tag, h_env->tagbuf->ptr);\n\t    push_tag(obuf, tmp->ptr, HTML_A);\n\t    if (displayLinkNumber)\n\t\tHTMLlineproc1(getLinkNumberStr(-1)->ptr, h_env);\n\t    return 1;\n\t}\n\treturn 0;\n    case HTML_N_A:\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_IMG:\n\ttmp = process_img(tag, h_env->limit);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_IMG_ALT:\n\tif (parsedtag_get_value(tag, ATTR_SRC, &p))\n\t    obuf->img_alt = Strnew_charp(p);\n#ifdef USE_IMAGE\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n#endif\n\treturn 0;\n    case HTML_N_IMG_ALT:\n\tif (obuf->img_alt) {\n\t    if (!close_effect0(obuf, HTML_IMG_ALT))\n\t\tpush_tag(obuf, \""</img_alt>\"", HTML_N_IMG_ALT);\n\t    obuf->img_alt = NULL;\n\t}\n\treturn 1;\n    case HTML_INPUT_ALT:\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq)) {\n\t    obuf->input_alt.hseq = hseq;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_FID, &i)) {\n\t    obuf->input_alt.fid = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t    obuf->input_alt.type = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t    obuf->input_alt.value = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_NAME, &p)) {\n\t    obuf->input_alt.name = Strnew_charp(p);\n\t}\n\tobuf->input_alt.in = 1;\n\treturn 0;\n    case HTML_N_INPUT_ALT:\n\tif (obuf->input_alt.in) {\n\t    if (!close_effect0(obuf, HTML_INPUT_ALT))\n\t\tpush_tag(obuf, \""</input_alt>\"", HTML_N_INPUT_ALT);\n\t    obuf->input_alt.hseq = 0;\n\t    obuf->input_alt.fid = -1;\n\t    obuf->input_alt.in = 0;\n\t    obuf->input_alt.type = NULL;\n\t    obuf->input_alt.name = NULL;\n\t    obuf->input_alt.value = NULL;\n\t}\n\treturn 1;\n    case HTML_TABLE:\n\tclose_anchor(h_env, obuf);\n\tobuf->table_level++;\n\tif (obuf->table_level >= MAX_TABLE)\n\t    break;\n\tw = BORDER_NONE;\n\t/* x: cellspacing, y: cellpadding */\n\tx = 2;\n\ty = 1;\n\tz = 0;\n\twidth = 0;\n\tif (parsedtag_exists(tag, ATTR_BORDER)) {\n\t    if (parsedtag_get_value(tag, ATTR_BORDER, &w)) {\n\t\tif (w > 2)\n\t\t    w = BORDER_THICK;\n\t\telse if (w < 0) {\t/* weird */\n\t\t    w = BORDER_THIN;\n\t\t}\n\t    }\n\t    else\n\t\tw = BORDER_THIN;\n\t}\n\tif (DisplayBorders && w == BORDER_NONE)\n\t    w = BORDER_THIN;\n\tif (parsedtag_get_value(tag, ATTR_WIDTH, &i)) {\n\t    if (obuf->table_level == 0)\n\t\twidth = REAL_WIDTH(i, h_env->limit - envs[h_env->envc].indent);\n\t    else\n\t\twidth = RELATIVE_WIDTH(i);\n\t}\n\tif (parsedtag_exists(tag, ATTR_HBORDER))\n\t    w = BORDER_NOWIN;\n#define MAX_CELLSPACING 1000\n#define MAX_CELLPADDING 1000\n#define MAX_VSPACE 1000\n\tparsedtag_get_value(tag, ATTR_CELLSPACING, &x);\n\tparsedtag_get_value(tag, ATTR_CELLPADDING, &y);\n\tparsedtag_get_value(tag, ATTR_VSPACE, &z);\n\tif (x > MAX_CELLSPACING)\n\t    x = MAX_CELLSPACING;\n\tif (y > MAX_CELLPADDING)\n\t    y = MAX_CELLPADDING;\n\tif (z > MAX_VSPACE)\n\t    z = MAX_VSPACE;\n#ifdef ID_EXT\n\tparsedtag_get_value(tag, ATTR_ID, &id);\n#endif\t\t\t\t/* ID_EXT */\n\ttables[obuf->table_level] = begin_table(w, x, y, z);\n#ifdef ID_EXT\n\tif (id != NULL)\n\t    tables[obuf->table_level]->id = Strnew_charp(id);\n#endif\t\t\t\t/* ID_EXT */\n\ttable_mode[obuf->table_level].pre_mode = 0;\n\ttable_mode[obuf->table_level].indent_level = 0;\n\ttable_mode[obuf->table_level].nobr_level = 0;\n\ttable_mode[obuf->table_level].caption = 0;\n\ttable_mode[obuf->table_level].end_tag = 0;\t/* HTML_UNKNOWN */\n#ifndef TABLE_EXPAND\n\ttables[obuf->table_level]->total_width = width;\n#else\n\ttables[obuf->table_level]->real_width = width;\n\ttables[obuf->table_level]->total_width = 0;\n#endif\n\treturn 1;\n    case HTML_N_TABLE:\n\t/* should be processed in HTMLlineproc() */\n\treturn 1;\n    case HTML_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P)))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_SAVE_FLAG(obuf);\n\tRB_SET_ALIGN(obuf, RB_CENTER);\n\treturn 1;\n    case HTML_N_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_PREMODE))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV_INT:\n\tCLOSE_P;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV_INT:\n\tCLOSE_P;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_FORM:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\ttmp = process_form(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_N_FORM:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= RB_IGNORE_P;\n\tprocess_n_form();\n\treturn 1;\n    case HTML_INPUT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_input(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_BUTTON:\n       tmp = process_button(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_N_BUTTON:\n       tmp = process_n_button();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_SELECT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_select(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INSELECT;\n\tobuf->end_tag = HTML_N_SELECT;\n\treturn 1;\n    case HTML_N_SELECT:\n\tobuf->flag &= ~RB_INSELECT;\n\tobuf->end_tag = 0;\n\ttmp = process_n_select();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_OPTION:\n\t/* nothing */\n\treturn 1;\n    case HTML_TEXTAREA:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_textarea(tag, h_env->limit);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INTXTA;\n\tobuf->end_tag = HTML_N_TEXTAREA;\n\treturn 1;\n    case HTML_N_TEXTAREA:\n\tobuf->flag &= ~RB_INTXTA;\n\tobuf->end_tag = 0;\n\ttmp = process_n_textarea();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_ISINDEX:\n\tp = \""\"";\n\tq = \""!CURRENT_URL!\"";\n\tparsedtag_get_value(tag, ATTR_PROMPT, &p);\n\tparsedtag_get_value(tag, ATTR_ACTION, &q);\n\ttmp = Strnew_m_charp(\""<form method=get action=\\\""\"",\n\t\t\t     html_quote(q),\n\t\t\t     \""\\\"">\"",\n\t\t\t     html_quote(p),\n\t\t\t     \""<input type=text name=\\\""\\\"" accept></form>\"",\n\t\t\t     NULL);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_META:\n\tp = q = r = NULL;\n\tparsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);\n\tparsedtag_get_value(tag, ATTR_CONTENT, &q);\n#ifdef USE_M17N\n\tparsedtag_get_value(tag, ATTR_CHARSET, &r);\n\tif (r) {\n\t    /* <meta charset=\""\""> */\n\t    SKIP_BLANKS(r);\n\t    meta_charset = wc_guess_charset(r, 0);\n\t}\n\telse\n\tif (p && q && !strcasecmp(p, \""Content-Type\"") &&\n\t    (q = strcasestr(q, \""charset\"")) != NULL) {\n\t    q += 7;\n\t    SKIP_BLANKS(q);\n\t    if (*q == '=') {\n\t\tq++;\n\t\tSKIP_BLANKS(q);\n\t\tmeta_charset = wc_guess_charset(q, 0);\n\t    }\n\t}\n\telse\n#endif\n\tif (p && q && !strcasecmp(p, \""refresh\"")) {\n\t    int refresh_interval;\n\t    tmp = NULL;\n\t    refresh_interval = getMetaRefreshParam(q, &tmp);\n\t    if (tmp) {\n\t\tq = html_quote(tmp->ptr);\n\t\ttmp = Sprintf(\""Refresh (%d sec) <a href=\\\""%s\\\"">%s</a>\"",\n\t\t\t      refresh_interval, q, q);\n\t    }\n\t    else if (refresh_interval > 0)\n\t\ttmp = Sprintf(\""Refresh (%d sec)\"", refresh_interval);\n\t    if (tmp) {\n\t\tHTMLlineproc1(tmp->ptr, h_env);\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t\tif (!is_redisplay &&\n\t\t    !((obuf->flag & RB_NOFRAMES) && RenderFrame)) {\n\t\t    tag->need_reconstruct = TRUE;\n\t\t    return 0;\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_BASE:\n#if defined(USE_M17N) || defined(USE_IMAGE)\n\tp = NULL;\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t    cur_baseURL = New(ParsedURL);\n\t    parseURL(p, cur_baseURL, NULL);\n\t}\n#endif\n    case HTML_MAP:\n    case HTML_N_MAP:\n    case HTML_AREA:\n\treturn 0;\n    case HTML_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>[DEL:</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \""<s>\"", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>:DEL]</U>\"", h_env);\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \""</s>\"", HTML_N_S);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>[S:</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \""<s>\"", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>:S]</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \""</s>\"", HTML_N_S);\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>[INS:</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_ins++;\n\t    if (obuf->in_ins == 1) {\n\t\tpush_tag(obuf, \""<ins>\"", HTML_INS);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>:INS]</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_ins == 0)\n\t\treturn 1;\n\t    if (obuf->in_ins == 1 && close_effect0(obuf, HTML_INS))\n\t\tobuf->in_ins = 0;\n\t    if (obuf->in_ins > 0) {\n\t\tobuf->in_ins--;\n\t\tif (obuf->in_ins == 0) {\n\t\t    push_tag(obuf, \""</ins>\"", HTML_N_INS);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_SUP:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\""^\"", h_env);\n\treturn 1;\n    case HTML_N_SUP:\n\treturn 1;\n    case HTML_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\""[\"", h_env);\n\treturn 1;\n    case HTML_N_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\""]\"", h_env);\n\treturn 1;\n    case HTML_FONT:\n    case HTML_N_FONT:\n    case HTML_NOP:\n\treturn 1;\n    case HTML_BGSOUND:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<A HREF=\\\""%s\\\"">bgsound(%s)</A>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_EMBED:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<A HREF=\\\""%s\\\"">embed(%s)</A>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_APPLET:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_ARCHIVE, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<A HREF=\\\""%s\\\"">applet archive(%s)</A>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_BODY:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_BACKGROUND, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<IMG SRC=\\\""%s\\\"" ALT=\\\""bg image(%s)\\\""><BR>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n    case HTML_N_HEAD:\n\tif (obuf->flag & RB_TITLE)\n\t    HTMLlineproc1(\""</title>\"", h_env);\n    case HTML_HEAD:\n    case HTML_N_BODY:\n\treturn 1;\n    default:\n\t/* obuf->prevchar = '\\0'; */\n\treturn 0;\n    }\n    /* not reached */\n    return 0;\n}\n"", ""start_line"": 4399, ""end_line"": 5396, ""full_name"": ""HTMLtagproc1"", ""file_path"": ""file.c""}]}, {""source"": ""query_info(query:cpg.call.code(\""obuf->input_alt.name\"").l)"", ""result"": [{""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 3028, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 8, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 4964, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 4976, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 6926, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 6969, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": 1}]}, {""source"": ""query_info(query:cpg.call.code(\""obuf->input_alt.type\"").l)"", ""result"": [{""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 3029, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 8, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 4958, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 4975, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 6925, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 6968, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": 1}]}, {""source"": ""query_info(query:cpg.call.code(\""obuf->input_alt.value\"").l)"", ""result"": [{""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 3030, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 8, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 4961, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 4977, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 6927, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 6970, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": 1}]}]","file.c:3026-3032: Dereference of obuf->input_alt.name->ptr, obuf->input_alt.type->ptr, and obuf->input_alt.value->ptr without null checks. obuf->input_alt is sourced from obuf->bp.input_alt (file.c:2476), which is set via obuf->input_alt in set_breakpoint() (file.c:2458). HTMLtagproc1() (file.c:4952-4977) populates input_alt.name, input_alt.type, and input_alt.value during parsing of <input_alt> tags using parsedtag_get_value(). If attributes are missing, these fields remain NULL, leading to a segfault in flushline().",0.95,./github/other_context/CVE-2016-9438
25,CVE-2017-14532,CWE-476,c_cpp,ImageMagick 7.0.7-0 has a NULL Pointer Dereference in TIFFIgnoreTags in coders/tiff.c.,https://github.com/ImageMagick/ImageMagick/commit/c55fb18c3f78445d100a378ab8b3c0acd53c6590,https://github.com/ImageMagick/ImageMagick/issues/719,1,"[{""func_name"": ""TIFFIgnoreTags"", ""file_path"": ""coders/tiff.c"", ""func_code"": ""static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\""tiff:ignore-tags\"");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}"", ""target"": 0}]","[{""func_name"": ""TIFFIgnoreTags"", ""file_path"": ""coders/tiff.c"", ""func_code"": ""static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\""tiff:ignore-tags\"");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}""}]","{""function"": 2}","[{""source"": ""func_info(func:AcquireQuantumMemory)"", ""result"": [{""code"": ""void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}"", ""start_line"": 530, ""end_line"": 539, ""full_name"": ""AcquireQuantumMemory"", ""file_path"": ""magick/memory.c""}]}, {""source"": ""func_info(file:memory.c, func:AcquireMagickMemory)"", ""result"": [{""code"": ""MagickExport void *AcquireMagickMemory(const size_t size)\n{\n  register void\n    *memory;\n\n#if !defined(MAGICKCORE_ANONYMOUS_MEMORY_SUPPORT)\n  memory=memory_methods.acquire_memory_handler(size == 0 ? 1UL : size);\n#else\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  if (free_segments == (DataSegmentInfo *) NULL)\n    {\n      LockSemaphoreInfo(memory_semaphore);\n      if (free_segments == (DataSegmentInfo *) NULL)\n        {\n          register ssize_t\n            i;\n\n          assert(2*sizeof(size_t) > (size_t) (~SizeMask));\n          (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n          memory_pool.allocation=SegmentSize;\n          memory_pool.blocks[MaxBlocks]=(void *) (-1);\n          for (i=0; i < MaxSegments; i++)\n          {\n            if (i != 0)\n              memory_pool.segment_pool[i].previous=\n                (&memory_pool.segment_pool[i-1]);\n            if (i != (MaxSegments-1))\n              memory_pool.segment_pool[i].next=(&memory_pool.segment_pool[i+1]);\n          }\n          free_segments=(&memory_pool.segment_pool[0]);\n        }\n      UnlockSemaphoreInfo(memory_semaphore);\n    }\n  LockSemaphoreInfo(memory_semaphore);\n  memory=AcquireBlock(size == 0 ? 1UL : size);\n  if (memory == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) != MagickFalse)\n        memory=AcquireBlock(size == 0 ? 1UL : size);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return(memory);\n}\n"", ""start_line"": 459, ""end_line"": 503, ""full_name"": ""AcquireMagickMemory"", ""file_path"": ""magick/memory.c""}]}]","coders/tiff.c:2221-2223: 'ignore' pointer allocated via AcquireQuantumMemory() without NULL check. If AcquireQuantumMemory (magick/memory.c:530-539) returns NULL (due to HeapOverflowSanityCheck failure or AcquireMagickMemory failure), ResetMagickMemory() is called on a NULL pointer. AcquireMagickMemory (magick/memory.c:459-503) returns NULL when memory allocation (via acquire_memory_handler or AcquireBlock) fails, confirming the failure condition.",0.95,./github/other_context/CVE-2017-14532
26,CVE-2019-12108,CWE-476,c_cpp,A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for int_port.,https://github.com/miniupnp/miniupnp/commit/13585f15c7f7dc28bbbba1661efb280d530d114c,GetOutboundPinholeTimeout: check args,2,"[{""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \""Invalid Args\"");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}"", ""target"": 1}, {""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}"", ""target"": 0}]","[{""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\tif (!int_port || !rem_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \""Invalid Args\"");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}""}, {""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \""Invalid Args\"");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}""}]","{""function"": 4, ""value"": 2, ""code"": 4, ""caller"": 3}","[{""source"": ""func_info(func:GetValueFromNameValueList)"", ""result"": [{""code"": ""char *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}"", ""start_line"": 138, ""end_line"": 152, ""full_name"": ""GetValueFromNameValueList"", ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""code"": ""char *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}"", ""start_line"": 138, ""end_line"": 152, ""full_name"": ""GetValueFromNameValueList<duplicate>0"", ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}, {""code"": ""char *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}"", ""start_line"": 137, ""end_line"": 151, ""full_name"": ""GetValueFromNameValueList<duplicate>1"", ""file_path"": ""miniupnpc/upnpreplyparse.c""}]}, {""source"": ""value_info(file:upnpsoap.c, value:data)"", ""result"": {""value_trace"": [{""full_code"": ""data = ++p->xml"", ""line"": 155, ""func_name"": ""parseelt""}, {""full_code"": ""data = p->xml"", ""line"": 168, ""func_name"": ""parseelt""}, {""full_code"": ""* data = (struct NameValueParserData *)d"", ""line"": 18, ""func_name"": ""NameValueParserStartElt""}, {""full_code"": ""* data = (struct NameValueParserData *)d"", ""line"": 31, ""func_name"": ""NameValueParserEndElt""}, {""full_code"": ""* data = (struct NameValueParserData *)d"", ""line"": 76, ""func_name"": ""NameValueParserGetData""}], ""struct_var"": ""data"", ""struct_type"": ""ifdata"", ""struct_definition"": ""struct ifdata {\n\tunsigned long opackets;\n\tunsigned long ipackets;\n\tunsigned long obytes;\n\tunsigned long ibytes;\n\tunsigned long baudrate;\n}""}}, {""source"": ""func_info(func:NameValueParserStartElt)"", ""result"": [{""code"": ""static void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}"", ""start_line"": 15, ""end_line"": 26, ""full_name"": ""NameValueParserStartElt"", ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}"", ""start_line"": 15, ""end_line"": 26, ""full_name"": ""NameValueParserStartElt<duplicate>0"", ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}"", ""start_line"": 16, ""end_line"": 27, ""full_name"": ""NameValueParserStartElt<duplicate>1"", ""file_path"": ""miniupnpc/upnpreplyparse.c""}]}, {""source"": ""func_info(func:NameValueParserEndElt)"", ""result"": [{""code"": ""static void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \""NewPortListing\"") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: error allocating memory\"",\n\t\t\t        \""NameValueParserEndElt\"");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}"", ""start_line"": 28, ""end_line"": 71, ""full_name"": ""NameValueParserEndElt"", ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \""NewPortListing\"") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: error allocating memory\"",\n\t\t\t        \""NameValueParserEndElt\"");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}"", ""start_line"": 28, ""end_line"": 71, ""full_name"": ""NameValueParserEndElt<duplicate>0"", ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserEndElt(void * d, const char * name, int namelen)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)namelen;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \""NewPortListing\"") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: error allocating memory\"",\n\t\t\t        \""NameValueParserEndElt\"");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}"", ""start_line"": 29, ""end_line"": 72, ""full_name"": ""NameValueParserEndElt<duplicate>1"", ""file_path"": ""miniupnpc/upnpreplyparse.c""}]}, {""source"": ""value_info(file:upnpsoap.c, value:NameValueParserData)"", ""result"": {""value_trace"": [{""full_code"": ""struct NameValueParserData"", ""line"": 108, ""func_name"": null}], ""struct_var"": ""NameValueParserData"", ""struct_type"": ""NameValueParserData"", ""struct_definition"": ""struct NameValueParserData\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}\n\nstruct NameValueParserData\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}""}}, {""source"": ""func_info(func:parseelt)"", ""result"": [{""code"": ""static void parseelt(struct xmlparser * p)\n{\n\tint i;\n\tconst char * elementname;\n\twhile(p->xml < (p->xmlend - 1))\n\t{\n\t\tif((p->xml + 4) <= p->xmlend && (0 == memcmp(p->xml, \""<!--\"", 4)))\n\t\t{\n\t\t\tp->xml += 3;\n\t\t\t/* ignore comments */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tp->xml++;\n\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile(memcmp(p->xml, \""-->\"", 3) != 0);\n\t\t\tp->xml += 3;\n\t\t}\n\t\telse if((p->xml)[0]=='<' && (p->xml)[1]!='?')\n\t\t{\n\t\t\ti = 0; elementname = ++p->xml;\n\t\t\twhile( !IS_WHITE_SPACE(*p->xml)\n\t\t\t\t  && (*p->xml!='>') && (*p->xml!='/')\n\t\t\t\t )\n\t\t\t{\n\t\t\t\ti++; p->xml++;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\t/* to ignore namespace : */\n\t\t\t\tif(*p->xml==':')\n\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\telementname = ++p->xml;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>0)\n\t\t\t{\n\t\t\t\tif(p->starteltfunc)\n\t\t\t\t\tp->starteltfunc(p->data, elementname, i);\n\t\t\t\tif(parseatt(p))\n\t\t\t\t\treturn;\n\t\t\t\tif(*p->xml!='/')\n\t\t\t\t{\n\t\t\t\t\tconst char * data;\n\t\t\t\t\ti = 0; data = ++p->xml;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t\twhile( IS_WHITE_SPACE(*p->xml) )\n\t\t\t\t\t{\n\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(memcmp(p->xml, \""<![CDATA[\"", 9) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* CDATA handling */\n\t\t\t\t\t\tp->xml += 9;\n\t\t\t\t\t\tdata = p->xml;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile(memcmp(p->xml, \""]]>\"", 3) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc)\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp->xml++;\n\t\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 1) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc && *(p->xml + 1) == '/')\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(*p->xml == '/')\n\t\t\t{\n\t\t\t\ti = 0; elementname = ++p->xml;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\twhile((*p->xml != '>'))\n\t\t\t\t{\n\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(p->endeltfunc)\n\t\t\t\t\tp->endeltfunc(p->data, elementname, i);\n\t\t\t\tp->xml++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->xml++;\n\t\t}\n\t}\n}\n"", ""start_line"": 110, ""end_line"": 219, ""full_name"": ""parseelt"", ""file_path"": ""miniupnpc-async/minixml.c""}, {""code"": ""static void parseelt(struct xmlparser * p)\n{\n\tint i;\n\tconst char * elementname;\n\twhile(p->xml < (p->xmlend - 1))\n\t{\n\t\tif((p->xml + 4) <= p->xmlend && (0 == memcmp(p->xml, \""<!--\"", 4)))\n\t\t{\n\t\t\tp->xml += 3;\n\t\t\t/* ignore comments */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tp->xml++;\n\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile(memcmp(p->xml, \""-->\"", 3) != 0);\n\t\t\tp->xml += 3;\n\t\t}\n\t\telse if((p->xml)[0]=='<' && (p->xml)[1]!='?')\n\t\t{\n\t\t\ti = 0; elementname = ++p->xml;\n\t\t\twhile( !IS_WHITE_SPACE(*p->xml)\n\t\t\t\t  && (*p->xml!='>') && (*p->xml!='/')\n\t\t\t\t )\n\t\t\t{\n\t\t\t\ti++; p->xml++;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\t/* to ignore namespace : */\n\t\t\t\tif(*p->xml==':')\n\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\telementname = ++p->xml;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>0)\n\t\t\t{\n\t\t\t\tif(p->starteltfunc)\n\t\t\t\t\tp->starteltfunc(p->data, elementname, i);\n\t\t\t\tif(parseatt(p))\n\t\t\t\t\treturn;\n\t\t\t\tif(*p->xml!='/')\n\t\t\t\t{\n\t\t\t\t\tconst char * data;\n\t\t\t\t\ti = 0; data = ++p->xml;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t\twhile( IS_WHITE_SPACE(*p->xml) )\n\t\t\t\t\t{\n\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(memcmp(p->xml, \""<![CDATA[\"", 9) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* CDATA handling */\n\t\t\t\t\t\tp->xml += 9;\n\t\t\t\t\t\tdata = p->xml;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile(memcmp(p->xml, \""]]>\"", 3) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc)\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp->xml++;\n\t\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 1) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc && *(p->xml + 1) == '/')\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(*p->xml == '/')\n\t\t\t{\n\t\t\t\ti = 0; elementname = ++p->xml;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\twhile((*p->xml != '>'))\n\t\t\t\t{\n\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(p->endeltfunc)\n\t\t\t\t\tp->endeltfunc(p->data, elementname, i);\n\t\t\t\tp->xml++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->xml++;\n\t\t}\n\t}\n}\n"", ""start_line"": 110, ""end_line"": 219, ""full_name"": ""parseelt<duplicate>0"", ""file_path"": ""miniupnpc-libevent/minixml.c""}, {""code"": ""static void parseelt(struct xmlparser * p)\n{\n\tint i;\n\tconst char * elementname;\n\twhile(p->xml < (p->xmlend - 1))\n\t{\n\t\tif((p->xml + 4) <= p->xmlend && (0 == memcmp(p->xml, \""<!--\"", 4)))\n\t\t{\n\t\t\tp->xml += 3;\n\t\t\t/* ignore comments */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tp->xml++;\n\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile(memcmp(p->xml, \""-->\"", 3) != 0);\n\t\t\tp->xml += 3;\n\t\t}\n\t\telse if((p->xml)[0]=='<' && (p->xml)[1]!='?')\n\t\t{\n\t\t\ti = 0; elementname = ++p->xml;\n\t\t\twhile( !IS_WHITE_SPACE(*p->xml)\n\t\t\t\t  && (*p->xml!='>') && (*p->xml!='/')\n\t\t\t\t )\n\t\t\t{\n\t\t\t\ti++; p->xml++;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\t/* to ignore namespace : */\n\t\t\t\tif(*p->xml==':')\n\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\telementname = ++p->xml;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>0)\n\t\t\t{\n\t\t\t\tif(p->starteltfunc)\n\t\t\t\t\tp->starteltfunc(p->data, elementname, i);\n\t\t\t\tif(parseatt(p))\n\t\t\t\t\treturn;\n\t\t\t\tif(*p->xml!='/')\n\t\t\t\t{\n\t\t\t\t\tconst char * data;\n\t\t\t\t\ti = 0; data = ++p->xml;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t\twhile( IS_WHITE_SPACE(*p->xml) )\n\t\t\t\t\t{\n\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t/* CDATA are at least 9 + 3 characters long : <![CDATA[ ]]> */\n\t\t\t\t\tif((p->xmlend >= (p->xml + (9 + 3))) && (memcmp(p->xml, \""<![CDATA[\"", 9) == 0))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* CDATA handling */\n\t\t\t\t\t\tp->xml += 9;\n\t\t\t\t\t\tdata = p->xml;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile(memcmp(p->xml, \""]]>\"", 3) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc)\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp->xml++;\n\t\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 1) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc && *(p->xml + 1) == '/')\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(*p->xml == '/')\n\t\t\t{\n\t\t\t\ti = 0; elementname = ++p->xml;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\twhile((*p->xml != '>'))\n\t\t\t\t{\n\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(p->endeltfunc)\n\t\t\t\t\tp->endeltfunc(p->data, elementname, i);\n\t\t\t\tp->xml++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->xml++;\n\t\t}\n\t}\n}\n"", ""start_line"": 111, ""end_line"": 221, ""full_name"": ""parseelt<duplicate>1"", ""file_path"": ""miniupnpc/minixml.c""}]}, {""source"": ""code_info(file:upnpsoap.c, lines:150-170)"", ""result"": ""\t/* TotalBytesReceived\n\t * This variable represents the cumulative counter for total number of\n\t * bytes received downstream across all connection service instances on\n\t * WANDevice. The count rolls over to 0 after it reaching the maximum\n\t * value (2^32)-1. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\"" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ibytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ibytes, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalPacketsSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n""}, {""source"": ""code_info(file:upnpsoap.c, lines:140-160)"", ""result"": ""\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<NewTotalBytesReceived>%lu</NewTotalBytesReceived>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\t/* TotalBytesReceived\n\t * This variable represents the cumulative counter for total number of\n\t * bytes received downstream across all connection service instances on\n\t * WANDevice. The count rolls over to 0 after it reaching the maximum\n\t * value (2^32)-1. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\"" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ibytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ibytes, action);\n#endif /* UPNP_STRICT */\n""}, {""source"": ""caller_info(file:upnpsoap.c, func:parseelt)"", ""result"": [{""call_line"": 226, ""call_code"": ""parseelt(parser)"", ""caller_code"": ""void parsexml(struct xmlparser * parser)\n{\n\tparser->xml = parser->xmlstart;\n\tparser->xmlend = parser->xmlstart + parser->xmlsize;\n\tparseelt(parser);\n}"", ""caller_start"": 222, ""file_path"": ""miniupnpc-async/minixml.c""}]}, {""source"": ""caller_info(file:upnpsoap.c, func:parsexml)"", ""result"": [{""call_line"": 618, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static int upnpc_get_response(upnpc_device_t * p)\n{\n\tssize_t n;\n\tssize_t count;\n\tchar buffer[2048];\n\tif(p->http_response_content_length > 0) {\n\t\tcount = p->http_response_content_length\n\t\t      + p->http_response_end_of_headers\n\t\t      - p->http_response_received;\n\t\tif(count > (ssize_t)sizeof(buffer)) count = sizeof(buffer);\n\t} else {\n\t\tcount = sizeof(buffer);\n\t}\n\tdebug_printf(\""recv(..., %d)\\n\"", (int)count);\n\tn = recv(p->http_socket, buffer, count, 0/* flags */);\n\tif(n < 0) {\n\t\tif(errno == EINTR || WOULDBLOCK(errno))\n\t\t\treturn 0;\t/* try again later */\n\t\tPRINT_SOCKET_ERROR(\""read\"");\n\t\tp->state = EDevError;\n\t\treturn -1;\n\t} else if(n == 0) {\n\t\t/* receiving finished */\n\t\tdebug_printf(\""%.*s\\n\"", p->http_response_received, p->http_response);\n\t\tclose(p->http_socket);\n\t\tp->http_socket = -1;\n\t\t/* parse */\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t\t/* TODO : decode chunked transfer-encoding */\n\t\t/* parse xml */\n\t\tif(p->state == EDevGetDescResponse) {\n\t\t\tstruct IGDdatas igd;\n\t\t\tstruct xmlparser parser;\n\t\t\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\t\t\tmemset(&parser, 0, sizeof(struct xmlparser));\n\t\t\tparser.xmlstart = p->http_response + p->http_response_end_of_headers;\n\t\t\tparser.xmlsize = p->http_response_received - p->http_response_end_of_headers;\n\t\t\tparser.data = &igd;\n\t\t\tparser.starteltfunc = IGDstartelt;\n\t\t\tparser.endeltfunc = IGDendelt;\n\t\t\tparser.datafunc = IGDdata;\n\t\t\tparsexml(&parser);\n#ifdef DEBUG\n\t\t\tprintIGD(&igd);\n#endif /* DEBUG */\n\t\t\tp->control_conn_url = build_url_string(igd.urlbase, p->root_desc_location, igd.first.controlurl);\n\t\t\tp->control_cif_url = build_url_string(igd.urlbase, p->root_desc_location, igd.CIF.controlurl);\n\t\t\tdebug_printf(\""control_conn_url='%s'\\n\"", p->control_conn_url);\n\t\t\tdebug_printf(\""control_cif_url='%s'\\n\"", p->control_cif_url);\n\t\t} else {\n\t\t\tClearNameValueList(&p->soap_response_data);\n\t\t\tParseNameValue(p->http_response + p->http_response_end_of_headers,\n\t\t\t               p->http_response_received - p->http_response_end_of_headers,\n\t\t\t               &p->soap_response_data);\n\t\t}\n\t\tfree(p->http_response);\n\t\tp->http_response = NULL;\n\t\tp->http_response_received = 0;\n\t\tp->http_response_end_of_headers = 0;\n\t\tp->state = EDevReady;\n\t} else {\n\t\t/* receiving in progress */\n\t\tdebug_printf(\""received %d bytes:\\n%.*s\\n\"", (int)n, (int)n, buffer);\n\t\tif(p->http_response == NULL) {\n\t\t\tp->http_response = malloc(n);\n\t\t\tif(p->http_response == NULL) {\n\t\t\t\tdebug_printf(\""failed to malloc %d bytes\\n\"", (int)n);\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response_received = n;\n\t\t\tmemcpy(p->http_response, buffer, n);\n\t\t} else {\n\t\t\tchar * tmp = realloc(p->http_response, p->http_response_received + n);\n\t\t\tif(tmp == NULL) {\n\t\t\t\tdebug_printf(\""failed to realloc %d bytes\\n\"", (int)(p->http_response_received + n));\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response = tmp;\n\t\t\tmemcpy(p->http_response + p->http_response_received, buffer, n);\n\t\t\tp->http_response_received += n;\n\t\t}\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t}\n\treturn 0;\n}\n"", ""caller_start"": 575, ""file_path"": ""miniupnpc-async/miniupnpc-async.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""call_line"": 398, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static void upnpc_desc_received(struct evhttp_request * req, void * pvoid)\n{\n\tsize_t len;\n\tunsigned char * data;\n\tstruct evbuffer * input_buffer;\n\tstruct IGDdatas igd;\n\tstruct xmlparser parser;\n\tupnpc_device_t * d = (upnpc_device_t *)pvoid;\n\n\tif(req == NULL) {\n\t\tdebug_printf(\""%s(%p, %p) NULL argument !\\n\"", __func__, req, pvoid);\n\t\treturn;\n\t}\n\tinput_buffer = evhttp_request_get_input_buffer(req);\n\tlen = evbuffer_get_length(input_buffer);\n\tdata = evbuffer_pullup(input_buffer, len);\n\tdebug_printf(\""%s %d (%d bytes)\\n\"", __func__, evhttp_request_get_response_code(req), (int)len);\n\tif(evhttp_request_get_response_code(req) != HTTP_OK) {\n\t\td->parent->ready_cb(evhttp_request_get_response_code(req), d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tif(data == NULL) {\n\t\td->parent->ready_cb(UPNPC_ERR_ROOT_DESC_ERROR, d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tdebug_printf(\""%.*s\\n\"", (int)len, (char *)data);\n\n\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\tmemset(&parser, 0, sizeof(struct xmlparser));\n\tparser.xmlstart = (char *)data;\n\tparser.xmlsize = len;\n\tparser.data = &igd;\n\tparser.starteltfunc = IGDstartelt;\n\tparser.endeltfunc = IGDendelt;\n\tparser.datafunc = IGDdata;\n\tparsexml(&parser);\n#ifdef DEBUG\n\tprintIGD(&igd);\n#endif /* DEBUG */\n\td->control_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.controlurl);\n\td->event_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.eventsuburl);\n\td->conn_service_type = strdup(igd.first.servicetype);\n\td->control_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.controlurl);\n\td->event_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.eventsuburl);\n\td->cif_service_type = strdup(igd.CIF.servicetype);\n\tdebug_printf(\""control_conn_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_conn_url, d->conn_service_type);\n\tdebug_printf(\""event_conn_url='%s'\\n\"", d->event_conn_url);\n\tdebug_printf(\""control_cif_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_cif_url, d->cif_service_type);\n\n\tif((d->cif_service_type == NULL)\n\t  || (d->cif_service_type[0] == '\\0')\n\t  || (!COMPARE(d->cif_service_type, \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:\""))) {\n\t\td->parent->ready_cb(UPNPC_ERR_NOT_IGD, d->parent, d, d->parent->cb_data);\n\t} else {\n\t\td->state |= UPNPC_DEVICE_GETSTATUS;\n\t\tupnpc_get_status_info(d);\n\t}\n}\n"", ""caller_start"": 363, ""file_path"": ""miniupnpc-libevent/miniupnpc-libevent.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}]}, {""source"": ""code_info(file:upnpsoap.c, lines:100-120)"", ""result"": ""\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* maximum value for a UPNP ui4 type variable */\n#define UPNP_UI4_MAX (4294967295ul)\n\nstatic void\nGetTotalBytesSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<NewTotalBytesSent>%lu</NewTotalBytesSent>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n""}, {""source"": ""caller_info(file:upnpsoap.c, func:parsexml)"", ""result"": [{""call_line"": 618, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static int upnpc_get_response(upnpc_device_t * p)\n{\n\tssize_t n;\n\tssize_t count;\n\tchar buffer[2048];\n\tif(p->http_response_content_length > 0) {\n\t\tcount = p->http_response_content_length\n\t\t      + p->http_response_end_of_headers\n\t\t      - p->http_response_received;\n\t\tif(count > (ssize_t)sizeof(buffer)) count = sizeof(buffer);\n\t} else {\n\t\tcount = sizeof(buffer);\n\t}\n\tdebug_printf(\""recv(..., %d)\\n\"", (int)count);\n\tn = recv(p->http_socket, buffer, count, 0/* flags */);\n\tif(n < 0) {\n\t\tif(errno == EINTR || WOULDBLOCK(errno))\n\t\t\treturn 0;\t/* try again later */\n\t\tPRINT_SOCKET_ERROR(\""read\"");\n\t\tp->state = EDevError;\n\t\treturn -1;\n\t} else if(n == 0) {\n\t\t/* receiving finished */\n\t\tdebug_printf(\""%.*s\\n\"", p->http_response_received, p->http_response);\n\t\tclose(p->http_socket);\n\t\tp->http_socket = -1;\n\t\t/* parse */\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t\t/* TODO : decode chunked transfer-encoding */\n\t\t/* parse xml */\n\t\tif(p->state == EDevGetDescResponse) {\n\t\t\tstruct IGDdatas igd;\n\t\t\tstruct xmlparser parser;\n\t\t\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\t\t\tmemset(&parser, 0, sizeof(struct xmlparser));\n\t\t\tparser.xmlstart = p->http_response + p->http_response_end_of_headers;\n\t\t\tparser.xmlsize = p->http_response_received - p->http_response_end_of_headers;\n\t\t\tparser.data = &igd;\n\t\t\tparser.starteltfunc = IGDstartelt;\n\t\t\tparser.endeltfunc = IGDendelt;\n\t\t\tparser.datafunc = IGDdata;\n\t\t\tparsexml(&parser);\n#ifdef DEBUG\n\t\t\tprintIGD(&igd);\n#endif /* DEBUG */\n\t\t\tp->control_conn_url = build_url_string(igd.urlbase, p->root_desc_location, igd.first.controlurl);\n\t\t\tp->control_cif_url = build_url_string(igd.urlbase, p->root_desc_location, igd.CIF.controlurl);\n\t\t\tdebug_printf(\""control_conn_url='%s'\\n\"", p->control_conn_url);\n\t\t\tdebug_printf(\""control_cif_url='%s'\\n\"", p->control_cif_url);\n\t\t} else {\n\t\t\tClearNameValueList(&p->soap_response_data);\n\t\t\tParseNameValue(p->http_response + p->http_response_end_of_headers,\n\t\t\t               p->http_response_received - p->http_response_end_of_headers,\n\t\t\t               &p->soap_response_data);\n\t\t}\n\t\tfree(p->http_response);\n\t\tp->http_response = NULL;\n\t\tp->http_response_received = 0;\n\t\tp->http_response_end_of_headers = 0;\n\t\tp->state = EDevReady;\n\t} else {\n\t\t/* receiving in progress */\n\t\tdebug_printf(\""received %d bytes:\\n%.*s\\n\"", (int)n, (int)n, buffer);\n\t\tif(p->http_response == NULL) {\n\t\t\tp->http_response = malloc(n);\n\t\t\tif(p->http_response == NULL) {\n\t\t\t\tdebug_printf(\""failed to malloc %d bytes\\n\"", (int)n);\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response_received = n;\n\t\t\tmemcpy(p->http_response, buffer, n);\n\t\t} else {\n\t\t\tchar * tmp = realloc(p->http_response, p->http_response_received + n);\n\t\t\tif(tmp == NULL) {\n\t\t\t\tdebug_printf(\""failed to realloc %d bytes\\n\"", (int)(p->http_response_received + n));\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response = tmp;\n\t\t\tmemcpy(p->http_response + p->http_response_received, buffer, n);\n\t\t\tp->http_response_received += n;\n\t\t}\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t}\n\treturn 0;\n}\n"", ""caller_start"": 575, ""file_path"": ""miniupnpc-async/miniupnpc-async.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""call_line"": 398, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static void upnpc_desc_received(struct evhttp_request * req, void * pvoid)\n{\n\tsize_t len;\n\tunsigned char * data;\n\tstruct evbuffer * input_buffer;\n\tstruct IGDdatas igd;\n\tstruct xmlparser parser;\n\tupnpc_device_t * d = (upnpc_device_t *)pvoid;\n\n\tif(req == NULL) {\n\t\tdebug_printf(\""%s(%p, %p) NULL argument !\\n\"", __func__, req, pvoid);\n\t\treturn;\n\t}\n\tinput_buffer = evhttp_request_get_input_buffer(req);\n\tlen = evbuffer_get_length(input_buffer);\n\tdata = evbuffer_pullup(input_buffer, len);\n\tdebug_printf(\""%s %d (%d bytes)\\n\"", __func__, evhttp_request_get_response_code(req), (int)len);\n\tif(evhttp_request_get_response_code(req) != HTTP_OK) {\n\t\td->parent->ready_cb(evhttp_request_get_response_code(req), d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tif(data == NULL) {\n\t\td->parent->ready_cb(UPNPC_ERR_ROOT_DESC_ERROR, d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tdebug_printf(\""%.*s\\n\"", (int)len, (char *)data);\n\n\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\tmemset(&parser, 0, sizeof(struct xmlparser));\n\tparser.xmlstart = (char *)data;\n\tparser.xmlsize = len;\n\tparser.data = &igd;\n\tparser.starteltfunc = IGDstartelt;\n\tparser.endeltfunc = IGDendelt;\n\tparser.datafunc = IGDdata;\n\tparsexml(&parser);\n#ifdef DEBUG\n\tprintIGD(&igd);\n#endif /* DEBUG */\n\td->control_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.controlurl);\n\td->event_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.eventsuburl);\n\td->conn_service_type = strdup(igd.first.servicetype);\n\td->control_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.controlurl);\n\td->event_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.eventsuburl);\n\td->cif_service_type = strdup(igd.CIF.servicetype);\n\tdebug_printf(\""control_conn_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_conn_url, d->conn_service_type);\n\tdebug_printf(\""event_conn_url='%s'\\n\"", d->event_conn_url);\n\tdebug_printf(\""control_cif_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_cif_url, d->cif_service_type);\n\n\tif((d->cif_service_type == NULL)\n\t  || (d->cif_service_type[0] == '\\0')\n\t  || (!COMPARE(d->cif_service_type, \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:\""))) {\n\t\td->parent->ready_cb(UPNPC_ERR_NOT_IGD, d->parent, d, d->parent->cb_data);\n\t} else {\n\t\td->state |= UPNPC_DEVICE_GETSTATUS;\n\t\tupnpc_get_status_info(d);\n\t}\n}\n"", ""caller_start"": 363, ""file_path"": ""miniupnpc-libevent/miniupnpc-libevent.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}]}, {""source"": ""code_info(file:upnpsoap.c, lines:100-120)"", ""result"": ""\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* maximum value for a UPNP ui4 type variable */\n#define UPNP_UI4_MAX (4294967295ul)\n\nstatic void\nGetTotalBytesSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<NewTotalBytesSent>%lu</NewTotalBytesSent>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n""}]","The vulnerability arises from the absence of NULL checks for int_port, ext_port, and protocol in GetOutboundPinholeTimeout (miniupnpd/upnpsoap.c:1853). These variables are assigned via GetValueFromNameValueList(&data, ""InternalPort""), GetValueFromNameValueList(&data, ""RemotePort""), and GetValueFromNameValueList(&data, ""Protocol"") (miniupnpd/upnpsoap.c:1851). GetValueFromNameValueList (miniupnpc/upnpreplyparse.c:138-152) returns NULL if the requested key is missing from the NameValueParserData structure. The 'data' structure (miniupnpd/upnpsoap.c:108) is populated during XML parsing of SOAP requests by NameValueParserStartElt (miniupnpc/upnpreplyparse.c:15-26) and NameValueParserEndElt (miniupnpc/upnpreplyparse.c:28-71), which extract parameters into a linked list of NameValue entries. If required parameters are absent, GetValueFromNameValueList returns NULL, leading to a dereference in atoi(). The patch (miniupnpd/upnpsoap.c:1851-1857) adds explicit NULL checks to prevent this.",0.95,./github/other_context/CVE-2019-12108
27,CVE-2019-18798,"CWE-476, CWE-125",c_cpp,LibSass before 3.6.3 allows a heap-based buffer over-read in Sass::weaveParents in ast_sel_weave.cpp.,https://github.com/sass/libsass/commit/0b721e0f37fc69ab197ec956a923e036e3b05ca6,Fix out of boundary vector access\n\nFixes https://github.com/sass/libsass/issues/2999,3,"[{""func_name"": ""weaveParents"", ""file_path"": ""src/ast_sel_weave.cpp"", ""func_code"": ""std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      groups1.erase(groups1.begin());\n      groups2.erase(groups2.begin());\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }"", ""target"": 0}, {""func_name"": ""Parser::parseCompoundSelector"", ""file_path"": ""src/parser_selectors.cpp"", ""func_code"": ""CompoundSelectorObj Parser::parseCompoundSelector()\n  {\n    // init an empty compound selector wrapper\n    CompoundSelectorObj seq = SASS_MEMORY_NEW(CompoundSelector, pstate);\n\n    // skip initial white-space\n    lex < block_comment >();\n    advanceToNextToken();\n\n    if (lex< exactly<'&'> >(false))\n    {\n      // ToDo: check the conditions and try to simplify flag passing\n      if (!allow_parent) error(\""Parent selectors aren't allowed here.\"");\n      // Create and append a new parent selector object\n      seq->hasRealParent(true);\n    }\n\n    // parse list\n    while (true)\n    {\n      // remove all block comments\n      // leaves trailing white-space\n      lex < block_comment >();\n      // parse parent selector\n      if (lex< exactly<'&'> >(false))\n      {\n        // parent selector only allowed at start\n        // upcoming Sass may allow also trailing\n        ParserState state(pstate);\n        SimpleSelectorObj prev = (*seq)[seq->length()-1];\n        std::string sel(prev->to_string({ NESTED, 5 }));\n        std::string found(\""&\"");\n        if (lex < identifier >()) { found += std::string(lexed); }\n        // ToDo: parser should throw parser exceptions\n        error(\""Invalid CSS after \\\""\"" + sel + \""\\\"": expected \\\""{\\\"", was \\\""\"" + found + \""\\\""\\n\\n\""\n          \""\\\""\"" + found + \""\\\"" may only be used at the beginning of a compound selector.\"", state);\n      }\n      // parse functional\n      else if (match < re_functional >())\n        {\n          seq->append(parse_simple_selector());\n        }\n\n      // parse type selector\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      // peek for abort conditions\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      // otherwise parse another simple selector\n      else {\n        SimpleSelectorObj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    // EO while true\n\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->hasPostLineBreak(peek_newline());\n    }\n\n    // We may have set hasRealParent\n    if (seq && seq->empty() && !seq->hasRealParent()) return {};\n\n    return seq;\n  }"", ""target"": 0}, {""func_name"": ""Eval::operator()"", ""file_path"": ""src/eval.cpp"", ""func_code"": ""Expression* Eval::operator()(Binary_Expression* b_in)\n  {\n\n    Expression_Obj lhs = b_in->left();\n    Expression_Obj rhs = b_in->right();\n    enum Sass_OP op_type = b_in->optype();\n\n    if (op_type == Sass_OP::AND) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (!*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n    else if (op_type == Sass_OP::OR) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n\n    // Evaluate variables as early o\n    while (Variable* l_v = Cast<Variable>(lhs)) {\n      lhs = operator()(l_v);\n    }\n    while (Variable* r_v = Cast<Variable>(rhs)) {\n      rhs = operator()(r_v);\n    }\n\n    Binary_Expression_Obj b = b_in;\n\n    // Evaluate sub-expressions early on\n    while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) {\n      if (!force && l_b->is_delayed()) break;\n      lhs = operator()(l_b);\n    }\n    while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) {\n      if (!force && r_b->is_delayed()) break;\n      rhs = operator()(r_b);\n    }\n\n    // don't eval delayed expressions (the '/' when used as a separator)\n    if (!force && op_type == Sass_OP::DIV && b->is_delayed()) {\n      b->right(b->right()->perform(this));\n      b->left(b->left()->perform(this));\n      return b.detach();\n    }\n\n    // specific types we know are final\n    // handle them early to avoid overhead\n    if (Number* l_n = Cast<Number>(lhs)) {\n      // lhs is number and rhs is number\n      if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is number and rhs is color\n      // Todo: allow to work with HSLA colors\n      else if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n    else if (Color* l_col = Cast<Color>(lhs)) {\n      Color_RGBA_Obj l_c = l_col->toRGBA();\n      // lhs is color and rhs is color\n      if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is color and rhs is number\n      else if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n\n    String_Schema_Obj ret_schema;\n\n    // only the last item will be used to eval the binary expression\n    if (String_Schema* s_l = Cast<String_Schema>(b->left())) {\n      if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), s_l->last(), b->right());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // unverified\n        for (size_t i = 0; i < s_l->length() - 1; ++i) {\n          ret_schema->append(Cast<PreValue>(s_l->at(i)->perform(this)));\n        }\n        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));\n        return ret_schema->perform(this);\n      }\n    }\n    if (String_Schema* s_r = Cast<String_Schema>(b->right())) {\n\n      if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), b->left(), s_r->first());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // verified\n        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));\n        for (size_t i = 1; i < s_r->length(); ++i) {\n          ret_schema->append(Cast<PreValue>(s_r->at(i)->perform(this)));\n        }\n        return ret_schema->perform(this);\n      }\n    }\n\n    // fully evaluate their values\n    if (op_type == Sass_OP::EQ ||\n        op_type == Sass_OP::NEQ ||\n        op_type == Sass_OP::GT ||\n        op_type == Sass_OP::GTE ||\n        op_type == Sass_OP::LT ||\n        op_type == Sass_OP::LTE)\n    {\n      LOCAL_FLAG(force, true);\n      lhs->is_expanded(false);\n      lhs->set_delayed(false);\n      lhs = lhs->perform(this);\n      rhs->is_expanded(false);\n      rhs->set_delayed(false);\n      rhs = rhs->perform(this);\n    }\n    else {\n      lhs = lhs->perform(this);\n    }\n\n    // not a logical connective, so go ahead and eval the rhs\n    rhs = rhs->perform(this);\n    AST_Node_Obj lu = lhs;\n    AST_Node_Obj ru = rhs;\n\n    Expression::Type l_type;\n    Expression::Type r_type;\n\n    // Is one of the operands an interpolant?\n    String_Schema_Obj s1 = Cast<String_Schema>(b->left());\n    String_Schema_Obj s2 = Cast<String_Schema>(b->right());\n    Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left());\n    Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right());\n\n    bool schema_op = false;\n\n    bool force_delay = (s2 && s2->is_left_interpolant()) ||\n                       (s1 && s1->is_right_interpolant()) ||\n                       (b1 && b1->is_right_interpolant()) ||\n                       (b2 && b2->is_left_interpolant());\n\n    if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay)\n    {\n      if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB ||\n          op_type == Sass_OP::EQ) {\n        // If possible upgrade LHS to a number (for number to string compare)\n        if (String_Constant* str = Cast<String_Constant>(lhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) {\n            lhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n        // If possible upgrade RHS to a number (for string to number compare)\n        if (String_Constant* str = Cast<String_Constant>(rhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) {\n            rhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n      }\n\n      To_Value to_value(ctx);\n      Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n      Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n\n      if (force_delay) {\n        std::string str(\""\"");\n        str += v_l->to_string(options());\n        if (b->op().ws_before) str += \"" \"";\n        str += b->separator();\n        if (b->op().ws_after) str += \"" \"";\n        str += v_r->to_string(options());\n        String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str);\n        val->is_interpolant(b->left()->has_interpolant());\n        return val;\n      }\n    }\n\n    // see if it's a relational expression\n    try {\n      switch(op_type) {\n        case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs));\n        case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs));\n        case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs));\n        case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs));\n        case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs));\n        case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs));\n        default: break;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    l_type = lhs->concrete_type();\n    r_type = rhs->concrete_type();\n\n    // ToDo: throw error in op functions\n    // ToDo: then catch and re-throw them\n    Expression_Obj rv;\n    try {\n      ParserState pstate(b->pstate());\n      if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) {\n        Number* l_n = Cast<Number>(lhs);\n        Number* r_n = Cast<Number>(rhs);\n        l_n->reduce(); r_n->reduce();\n        rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) {\n        Number* l_n = Cast<Number>(lhs);\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Number* r_n = Cast<Number>(rhs);\n        rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::COLOR) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate);\n      }\n      else {\n        To_Value to_value(ctx);\n        // this will leak if perform does not return a value!\n        Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n        Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n        bool interpolant = b->is_right_interpolant() ||\n                           b->is_left_interpolant() ||\n                           b->is_interpolant();\n        if (op_type == Sass_OP::SUB) interpolant = false;\n        // if (op_type == Sass_OP::DIV) interpolant = true;\n        // check for type violations\n        if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_l->pstate()));\n          throw Exception::InvalidValue(traces, *v_l);\n        }\n        if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_r->pstate()));\n          throw Exception::InvalidValue(traces, *v_r);\n        }\n        Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant); // pass true to compress\n        if (String_Constant* str = Cast<String_Constant>(ex))\n        {\n          if (str->concrete_type() == Expression::STRING)\n          {\n            String_Constant* lstr = Cast<String_Constant>(lhs);\n            String_Constant* rstr = Cast<String_Constant>(rhs);\n            if (op_type != Sass_OP::SUB) {\n              if (String_Constant* org = lstr ? lstr : rstr)\n              { str->quote_mark(org->quote_mark()); }\n            }\n          }\n        }\n        ex->is_interpolant(b->is_interpolant());\n        rv = ex;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      // throw Exception::Base(b->pstate(), err.what());\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    if (rv) {\n      if (schema_op) {\n        // XXX: this is never hit via spec tests\n        (*s2)[0] = rv;\n        rv = s2->perform(this);\n      }\n    }\n\n    return rv.detach();\n\n  }"", ""target"": 0}]","[{""func_name"": ""weaveParents"", ""file_path"": ""src/ast_sel_weave.cpp"", ""func_code"": ""std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      if (!groups1.empty()) {\n        groups1.erase(groups1.begin());\n      }\n      if (!groups2.empty()) {\n        groups2.erase(groups2.begin());\n      }\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }""}, {""func_name"": ""Parser::parseCompoundSelector"", ""file_path"": ""src/parser_selectors.cpp"", ""func_code"": ""CompoundSelectorObj Parser::parseCompoundSelector()\n  {\n    // init an empty compound selector wrapper\n    CompoundSelectorObj seq = SASS_MEMORY_NEW(CompoundSelector, pstate);\n\n    // skip initial white-space\n    lex < block_comment >();\n    advanceToNextToken();\n\n    if (lex< exactly<'&'> >(false))\n    {\n      // ToDo: check the conditions and try to simplify flag passing\n      if (!allow_parent) error(\""Parent selectors aren't allowed here.\"");\n      // Create and append a new parent selector object\n      seq->hasRealParent(true);\n    }\n\n    // parse list\n    while (true)\n    {\n      // remove all block comments\n      // leaves trailing white-space\n      lex < block_comment >();\n      // parse parent selector\n      if (lex< exactly<'&'> >(false))\n      {\n        // parent selector only allowed at start\n        // upcoming Sass may allow also trailing\n        ParserState state(pstate);\n        std::string found(\""&\"");\n        if (lex < identifier >()) {\n          found += std::string(lexed);\n        }\n        std::string sel(seq->hasRealParent() ? \""&\"" : \""\"");\n        if (!seq->empty()) { sel = seq->last()->to_string({ NESTED, 5 }); }\n        // ToDo: parser should throw parser exceptions\n        error(\""Invalid CSS after \\\""\"" + sel + \""\\\"": expected \\\""{\\\"", was \\\""\"" + found + \""\\\""\\n\\n\""\n          \""\\\""\"" + found + \""\\\"" may only be used at the beginning of a compound selector.\"", state);\n      }\n      // parse functional\n      else if (match < re_functional >())\n        {\n          seq->append(parse_simple_selector());\n        }\n\n      // parse type selector\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      // peek for abort conditions\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      // otherwise parse another simple selector\n      else {\n        SimpleSelectorObj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    // EO while true\n\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->hasPostLineBreak(peek_newline());\n    }\n\n    // We may have set hasRealParent\n    if (seq && seq->empty() && !seq->hasRealParent()) return {};\n\n    return seq;\n  }""}, {""func_name"": ""Eval::operator()"", ""file_path"": ""src/eval.cpp"", ""func_code"": ""Expression* Eval::operator()(Binary_Expression* b_in)\n  {\n\n    Expression_Obj lhs = b_in->left();\n    Expression_Obj rhs = b_in->right();\n    enum Sass_OP op_type = b_in->optype();\n\n    if (op_type == Sass_OP::AND) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (!*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n    else if (op_type == Sass_OP::OR) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n\n    // Evaluate variables as early o\n    while (Variable* l_v = Cast<Variable>(lhs)) {\n      lhs = operator()(l_v);\n    }\n    while (Variable* r_v = Cast<Variable>(rhs)) {\n      rhs = operator()(r_v);\n    }\n\n    Binary_Expression_Obj b = b_in;\n\n    // Evaluate sub-expressions early on\n    while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) {\n      if (!force && l_b->is_delayed()) break;\n      lhs = operator()(l_b);\n    }\n    while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) {\n      if (!force && r_b->is_delayed()) break;\n      rhs = operator()(r_b);\n    }\n\n    // don't eval delayed expressions (the '/' when used as a separator)\n    if (!force && op_type == Sass_OP::DIV && b->is_delayed()) {\n      b->right(b->right()->perform(this));\n      b->left(b->left()->perform(this));\n      return b.detach();\n    }\n\n    // specific types we know are final\n    // handle them early to avoid overhead\n    if (Number* l_n = Cast<Number>(lhs)) {\n      // lhs is number and rhs is number\n      if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is number and rhs is color\n      // Todo: allow to work with HSLA colors\n      else if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n    else if (Color* l_col = Cast<Color>(lhs)) {\n      Color_RGBA_Obj l_c = l_col->toRGBA();\n      // lhs is color and rhs is color\n      if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is color and rhs is number\n      else if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n\n    String_Schema_Obj ret_schema;\n\n    // only the last item will be used to eval the binary expression\n    if (String_Schema* s_l = Cast<String_Schema>(b->left())) {\n      if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), s_l->last(), b->right());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // unverified\n        for (size_t i = 0; i < s_l->length() - 1; ++i) {\n          ret_schema->append(s_l->at(i)->perform(this));\n        }\n        ret_schema->append(bin_ex->perform(this));\n        return ret_schema->perform(this);\n      }\n    }\n    if (String_Schema* s_r = Cast<String_Schema>(b->right())) {\n\n      if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), b->left(), s_r->first());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // verified\n        ret_schema->append(bin_ex->perform(this));\n        for (size_t i = 1; i < s_r->length(); ++i) {\n          ret_schema->append(s_r->at(i)->perform(this));\n        }\n        return ret_schema->perform(this);\n      }\n    }\n\n    // fully evaluate their values\n    if (op_type == Sass_OP::EQ ||\n        op_type == Sass_OP::NEQ ||\n        op_type == Sass_OP::GT ||\n        op_type == Sass_OP::GTE ||\n        op_type == Sass_OP::LT ||\n        op_type == Sass_OP::LTE)\n    {\n      LOCAL_FLAG(force, true);\n      lhs->is_expanded(false);\n      lhs->set_delayed(false);\n      lhs = lhs->perform(this);\n      rhs->is_expanded(false);\n      rhs->set_delayed(false);\n      rhs = rhs->perform(this);\n    }\n    else {\n      lhs = lhs->perform(this);\n    }\n\n    // not a logical connective, so go ahead and eval the rhs\n    rhs = rhs->perform(this);\n    AST_Node_Obj lu = lhs;\n    AST_Node_Obj ru = rhs;\n\n    Expression::Type l_type;\n    Expression::Type r_type;\n\n    // Is one of the operands an interpolant?\n    String_Schema_Obj s1 = Cast<String_Schema>(b->left());\n    String_Schema_Obj s2 = Cast<String_Schema>(b->right());\n    Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left());\n    Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right());\n\n    bool schema_op = false;\n\n    bool force_delay = (s2 && s2->is_left_interpolant()) ||\n                       (s1 && s1->is_right_interpolant()) ||\n                       (b1 && b1->is_right_interpolant()) ||\n                       (b2 && b2->is_left_interpolant());\n\n    if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay)\n    {\n      if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB ||\n          op_type == Sass_OP::EQ) {\n        // If possible upgrade LHS to a number (for number to string compare)\n        if (String_Constant* str = Cast<String_Constant>(lhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) {\n            lhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n        // If possible upgrade RHS to a number (for string to number compare)\n        if (String_Constant* str = Cast<String_Constant>(rhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) {\n            rhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n      }\n\n      To_Value to_value(ctx);\n      Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n      Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n\n      if (force_delay) {\n        std::string str(\""\"");\n        str += v_l->to_string(options());\n        if (b->op().ws_before) str += \"" \"";\n        str += b->separator();\n        if (b->op().ws_after) str += \"" \"";\n        str += v_r->to_string(options());\n        String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str);\n        val->is_interpolant(b->left()->has_interpolant());\n        return val;\n      }\n    }\n\n    // see if it's a relational expression\n    try {\n      switch(op_type) {\n        case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs));\n        case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs));\n        case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs));\n        case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs));\n        case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs));\n        case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs));\n        default: break;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    l_type = lhs->concrete_type();\n    r_type = rhs->concrete_type();\n\n    // ToDo: throw error in op functions\n    // ToDo: then catch and re-throw them\n    Expression_Obj rv;\n    try {\n      ParserState pstate(b->pstate());\n      if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) {\n        Number* l_n = Cast<Number>(lhs);\n        Number* r_n = Cast<Number>(rhs);\n        l_n->reduce(); r_n->reduce();\n        rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) {\n        Number* l_n = Cast<Number>(lhs);\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Number* r_n = Cast<Number>(rhs);\n        rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::COLOR) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate);\n      }\n      else {\n        To_Value to_value(ctx);\n        // this will leak if perform does not return a value!\n        Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n        Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n        bool interpolant = b->is_right_interpolant() ||\n                           b->is_left_interpolant() ||\n                           b->is_interpolant();\n        if (op_type == Sass_OP::SUB) interpolant = false;\n        // if (op_type == Sass_OP::DIV) interpolant = true;\n        // check for type violations\n        if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_l->pstate()));\n          throw Exception::InvalidValue(traces, *v_l);\n        }\n        if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_r->pstate()));\n          throw Exception::InvalidValue(traces, *v_r);\n        }\n        Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant); // pass true to compress\n        if (String_Constant* str = Cast<String_Constant>(ex))\n        {\n          if (str->concrete_type() == Expression::STRING)\n          {\n            String_Constant* lstr = Cast<String_Constant>(lhs);\n            String_Constant* rstr = Cast<String_Constant>(rhs);\n            if (op_type != Sass_OP::SUB) {\n              if (String_Constant* org = lstr ? lstr : rstr)\n              { str->quote_mark(org->quote_mark()); }\n            }\n          }\n        }\n        ex->is_interpolant(b->is_interpolant());\n        rv = ex;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      // throw Exception::Base(b->pstate(), err.what());\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    if (rv) {\n      if (schema_op) {\n        // XXX: this is never hit via spec tests\n        (*s2)[0] = rv;\n        rv = s2->perform(this);\n      }\n    }\n\n    return rv.detach();\n\n  }""}]","{""function"": 4, ""code"": 1, ""value"": 2, ""caller"": 1}","[{""source"": ""func_info(file:ast_sel_weave.cpp, func:weaveParents)"", ""result"": [{""code"": ""  std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      groups1.erase(groups1.begin());\n      groups2.erase(groups2.begin());\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }\n"", ""start_line"": 522, ""end_line"": 606, ""full_name"": ""Sass.weaveParents:vector(std.vector,std.vector)"", ""file_path"": ""src/ast_sel_weave.cpp""}]}, {""source"": ""code_info(file:ast_sel_weave.cpp, lines:550-576)"", ""result"": ""    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n""}, {""source"": ""value_info(file:ast_sel_weave.cpp, value:groups1)"", ""result"": {""value_trace"": [{""full_code"": ""std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1)"", ""line"": 553, ""func_name"": ""Sass.weaveParents:vector(std.vector,std.vector)""}], ""struct_var"": ""groups1"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:ast_sel_weave.cpp, value:groups2)"", ""result"": {""value_trace"": [{""full_code"": ""std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2)"", ""line"": 554, ""func_name"": ""Sass.weaveParents:vector(std.vector,std.vector)""}], ""struct_var"": ""groups2"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(func:last)"", ""result"": [{""code"": ""T& last()               { return elements_.back(); }"", ""start_line"": 229, ""end_line"": 229, ""full_name"": ""Sass.Vectorized.last:ANY()"", ""file_path"": ""src/ast.hpp""}, {""code"": ""const T& last() const   { return elements_.back(); }"", ""start_line"": 231, ""end_line"": 231, ""full_name"": ""Sass.Vectorized.last:ANY()<const>"", ""file_path"": ""src/ast.hpp""}]}, {""source"": ""func_info(file:ast_sel_weave.cpp, func:groupSelectors)"", ""result"": [{""code"": ""std::vector<std::vector<SelectorComponentObj>> groupSelectors(\n    const std::vector<SelectorComponentObj>& components)\n  {\n    bool lastWasCompound = false;\n    std::vector<SelectorComponentObj> group;\n    std::vector<std::vector<SelectorComponentObj>> groups;\n    for (size_t i = 0; i < components.size(); i += 1) {\n      if (CompoundSelector* compound = components[i]->getCompound()) {\n        if (lastWasCompound) {\n          groups.push_back(group);\n          group.clear();\n        }\n        group.push_back(compound);\n        lastWasCompound = true;\n      }\n      else if (SelectorCombinator* combinator = components[i]->getCombinator()) {\n        group.push_back(combinator);\n        lastWasCompound = false;\n      }\n    }\n    if (!group.empty()) {\n      groups.push_back(group);\n    }\n    return groups;\n  }"", ""start_line"": 213, ""end_line"": 237, ""full_name"": ""Sass.groupSelectors:vector(std.vector&)"", ""file_path"": ""src/ast_sel_weave.cpp""}]}, {""source"": ""func_info(file:ast_sel_weave.cpp, func:weaveParents)"", ""result"": [{""code"": ""  std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      groups1.erase(groups1.begin());\n      groups2.erase(groups2.begin());\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }\n"", ""start_line"": 522, ""end_line"": 606, ""full_name"": ""Sass.weaveParents:vector(std.vector,std.vector)"", ""file_path"": ""src/ast_sel_weave.cpp""}]}, {""source"": ""caller_info(file:ast_sel_weave.cpp, func:weaveParents)"", ""result"": [{""call_line"": 494, ""call_code"": ""weaveParents(prefix, parents)"", ""caller_code"": ""  std::vector<std::vector<SelectorComponentObj>> weave(\n    const std::vector<std::vector<SelectorComponentObj>>& complexes) {\n\n    std::vector<std::vector<SelectorComponentObj>> prefixes;\n\n    prefixes.push_back(complexes.at(0));\n\n    for (size_t i = 1; i < complexes.size(); i += 1) {\n\n      if (complexes[i].empty()) {\n        continue;\n      }\n      const std::vector<SelectorComponentObj>& complex = complexes[i];\n      SelectorComponent* target = complex.back();\n      if (complex.size() == 1) {\n        for (auto& prefix : prefixes) {\n          prefix.push_back(target);\n        }\n        continue;\n      }\n\n      std::vector<SelectorComponentObj> parents(complex);\n\n      parents.pop_back();\n\n      std::vector<std::vector<SelectorComponentObj>> newPrefixes;\n      for (std::vector<SelectorComponentObj> prefix : prefixes) {\n        std::vector<std::vector<SelectorComponentObj>>\n          parentPrefixes = weaveParents(prefix, parents);\n        if (parentPrefixes.empty()) continue;\n        for (auto& parentPrefix : parentPrefixes) {\n          parentPrefix.push_back(target);\n          newPrefixes.push_back(parentPrefix);\n        }\n      }\n      prefixes = newPrefixes;\n\n    }\n    return prefixes;\n\n  }\n"", ""caller_start"": 466, ""file_path"": ""src/ast_sel_weave.cpp""}]}]",src/ast_sel_weave.cpp:577-578 (groups1/groups2 erase without empty check) → src/ast_sel_weave.cpp:553-554 (groups1/groups2 initialized via groupSelectors(queue1/queue2)) → src/ast_sel_weave.cpp:213-237 (groupSelectors returns empty if input components are empty) → src/ast_sel_weave.cpp:494 (weaveParents called with potentially empty queues from weave function).,0.95,./github/other_context/CVE-2019-18798
28,CVE-2019-20163,"CWE-416, CWE-476",c_cpp,An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There is a NULL pointer dereference in the function gf_odf_avc_cfg_write_bs() in odf/descriptors.c.,https://github.com/gpac/gpac/commit/5250afecbc770c8f26829e9566d5b226a3c5fa80,"fix some memory issues:\n\nfixes #1330, #1331, #1332, #1333, #1335, #1338",4,"[{""func_name"": ""ilst_item_Read"", ""file_path"": ""src/isomedia/box_code_apple.c"", ""func_code"": ""GF_Err ilst_item_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && ptr->size < a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\"", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del((GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID)\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\telse {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tptr->data->type = 0;\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""tenc_Read"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err tenc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\n\tgf_bs_read_u8(bs); //reserved\n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); //reserved\n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tptr->Per_Sample_IV_Size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, (char *) ptr->KID, 16);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\n\tif ((ptr->isProtected == 1) && !ptr->Per_Sample_IV_Size) {\n\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tISOM_DECREASE_SIZE(ptr, (1 + ptr->constant_IV_size) );\n\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count, sample_number;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, sample_number, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", sample_number, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tif (trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] Failed to parse SENC box, invalid SAI size\\n\"" ));\n\t\t\t\t\t\t\treturn GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""gf_odf_avc_cfg_write_bs"", ""file_path"": ""src/odf/descriptors.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_odf_avc_cfg_write_bs(GF_AVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCProfileIndication , 8);\n\t\tgf_bs_write_int(bs, cfg->profile_compatibility, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCLevelIndication, 8);\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, 0x7, 3);\n\t\tgf_bs_write_int(bs, count, 5);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->pictureParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tif (gf_avc_is_rext_profile(cfg->AVCProfileIndication)) {\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth - 8, 3);\n\t\t}\n\t\tcount = cfg->sequenceParameterSetExtensions ? gf_list_count(cfg->sequenceParameterSetExtensions) : 0;\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}]","[{""func_name"": ""ilst_item_Read"", ""file_path"": ""src/isomedia/box_code_apple.c"", ""func_code"": ""GF_Err ilst_item_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && a && ptr->size < a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\"", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (!a) e = GF_ISOM_INVALID_FILE;\n\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del((GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID)\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\telse {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tptr->data->type = 0;\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""tenc_Read"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err tenc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\n\tgf_bs_read_u8(bs); //reserved\n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); //reserved\n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tptr->Per_Sample_IV_Size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, (char *) ptr->KID, 16);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\n\tif ((ptr->isProtected == 1) && !ptr->Per_Sample_IV_Size) {\n\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\tif (ptr->constant_IV_size > sizeof(ptr->constant_IV))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tgf_bs_read_data(bs, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tISOM_DECREASE_SIZE(ptr, (1 + ptr->constant_IV_size) );\n\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count, sample_number;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, sample_number, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", sample_number, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tif (trak && trak->moov && trak->moov->mov && trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] Failed to parse SENC box, invalid SAI size\\n\"" ));\n\t\t\t\t\t\t\treturn GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}""}, {""func_name"": ""gf_odf_avc_cfg_write_bs"", ""file_path"": ""src/odf/descriptors.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_odf_avc_cfg_write_bs(GF_AVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tif (!cfg) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCProfileIndication , 8);\n\t\tgf_bs_write_int(bs, cfg->profile_compatibility, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCLevelIndication, 8);\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, 0x7, 3);\n\t\tgf_bs_write_int(bs, count, 5);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->pictureParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tif (gf_avc_is_rext_profile(cfg->AVCProfileIndication)) {\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth - 8, 3);\n\t\t}\n\t\tcount = cfg->sequenceParameterSetExtensions ? gf_list_count(cfg->sequenceParameterSetExtensions) : 0;\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}""}]","{""caller"": 2, ""value"": 1}","[{""source"": ""caller_info(file:descriptors.c, func:gf_odf_avc_cfg_write_bs)"", ""result"": [{""call_line"": 631, ""call_code"": ""gf_odf_avc_cfg_write_bs(cfg, bs)"", ""caller_code"": ""GF_Err gf_odf_avc_cfg_write(GF_AVCConfig *cfg, char **outData, u32 *outSize)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_avc_cfg_write_bs(cfg, bs);\n\t*outSize = 0;\n\t*outData = NULL;\n\tgf_bs_get_content(bs, outData, outSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}"", ""caller_start"": 628, ""file_path"": ""src/odf/descriptors.c""}, {""call_line"": 351, ""call_code"": ""gf_odf_avc_cfg_write_bs(avcc->config, item_bs)"", ""caller_code"": ""GF_Err gf_isom_extract_meta_item_extended(GF_ISOFile *file, Bool root_meta, u32 track_num, u32 item_id, const char *dump_file_name, char **out_data, u32 *out_size, const char **out_mime, Bool use_annex_b)\n{\n\tGF_BitStream *item_bs;\n\tchar szPath[1024];\n\tGF_ItemExtentEntry *extent_entry;\n\tFILE *resource = NULL;\n\tu32 i, count;\n\tGF_ItemLocationEntry *location_entry;\n\tu32 item_num;\n\tu32 item_type = 0;\n\tu32 nalu_size_length = 0;\n\tu64 idat_offset = 0;\n\tchar *item_name = NULL;\n\n\tGF_MetaBox *meta = gf_isom_get_meta(file, root_meta, track_num);\n\tif (!meta || !meta->item_infos || !meta->item_locations) return GF_BAD_PARAM;\n\n\tif (out_mime) *out_mime = NULL;\n\n\titem_num = gf_isom_get_meta_item_by_id(file, root_meta, track_num, item_id);\n\tif (item_num) {\n\t\tGF_ItemInfoEntryBox *item_entry = (GF_ItemInfoEntryBox *)gf_list_get(meta->item_infos->item_infos, item_num-1);\n\t\titem_name = item_entry->item_name;\n\t\tif (out_mime) *out_mime = item_entry->content_type;\n\n\t\titem_type = item_entry->item_type;\n\t}\n\n\tlocation_entry = NULL;\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tlocation_entry = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\tif (location_entry->item_ID == item_id) break;\n\t\tlocation_entry = NULL;\n\t}\n\n\t// switch (item_type) {\n\t// case GF_ISOM_SUBTYPE_HVC1:\n\t// case GF_ISOM_SUBTYPE_AVC_H264:\n\t// case GF_ISOM_SUBTYPE_JPEG:\n\t// \tbreak;\n\t// default:\n\t// \tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\""[IsoMedia] Extracting item type %s not supported\\n\"", gf_4cc_to_str(item_type) ));\n\t// \treturn GF_NOT_SUPPORTED;\n\t// }\n\n\tif (!location_entry) return GF_BAD_PARAM;\n\n\t/* offsets are expressed from the start of the idat box instead of the start of the file */\n\tif (location_entry->construction_method == 1) {\n\t\tint found = 0;\n\n\t\tcount = gf_list_count(meta->other_boxes);\n\t\tfor (i = 0; i <count; i++) {\n\t\t\tGF_Box *a = (GF_Box *)gf_list_get(meta->other_boxes, i);\n\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_IDAT) {\n\n\t\t\t\tGF_MediaDataBox *p = (GF_MediaDataBox *)a;\n\t\t\t\tidat_offset = p->bsOffset;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[IsoMedia] Item %d references an inexistant idat box\\n\"", item_num));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\t/* when construction_method==1, data_reference_index is ignored */\n\t/*FIXME*/\n\telse if (location_entry->data_reference_index) {\n\t\tchar *item_url = NULL, *item_urn = NULL;\n\t\tGF_Box *a = (GF_Box *)gf_list_get(meta->file_locations->dref->other_boxes, location_entry->data_reference_index-1);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_URL) {\n\t\t\titem_url = ((GF_DataEntryURLBox*)a)->location;\n\t\t} else if (a->type==GF_ISOM_BOX_TYPE_URN) {\n\t\t\titem_url = ((GF_DataEntryURNBox*)a)->location;\n\t\t\titem_urn = ((GF_DataEntryURNBox*)a)->nameURN;\n\t\t}\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\""[IsoMedia] Item already outside the ISO file at URL: %s, URN: %s\\n\"", (item_url?item_url:\""N/A\""), (item_urn?item_urn:\""N/A\"") ));\n\t\treturn GF_OK;\n\t}\n\n\t/*don't extract self-reference item*/\n\tcount = gf_list_count(location_entry->extent_entries);\n\tif (!location_entry->base_offset && (count==1)) {\n\t\textent_entry = (GF_ItemExtentEntry *)gf_list_get(location_entry->extent_entries, 0);\n\t\tif (!extent_entry->extent_length\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t        && !extent_entry->original_extent_offset\n#endif\n\t\t   ) return GF_BAD_PARAM;\n\t}\n\n\titem_bs = NULL;\n\n\n\tif (out_data) {\n\t\titem_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t} else if (dump_file_name) {\n\t\tstrcpy(szPath, dump_file_name);\n\t\tresource = gf_fopen(szPath, \""wb\"");\n\t\titem_bs = gf_bs_from_file(resource, GF_BITSTREAM_WRITE);\n\t} else {\n\t\tif (item_name && strlen(item_name) > 0) strcpy(szPath, item_name);\n\t\telse sprintf(szPath, \""item_id%02d\"", item_id);\n\t\tresource = gf_fopen(szPath, \""wb\"");\n\t\titem_bs = gf_bs_from_file(resource, GF_BITSTREAM_WRITE);\n\t}\n\n\tif ((item_type == GF_ISOM_SUBTYPE_HVC1) || (item_type == GF_ISOM_SUBTYPE_AVC_H264) ) {\n\t\tu32 i, count, j, c2;\n\t\tGF_HEVCConfigurationBox *hvcc = NULL;\n\t\tGF_AVCConfigurationBox *avcc = NULL;\n\t\tif (! meta->item_props) return GF_NON_COMPLIANT_BITSTREAM;\n\t\tif (! meta->item_props->property_container) return GF_NON_COMPLIANT_BITSTREAM;\n\t\tif (! meta->item_props->property_association) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tcount = gf_list_count(meta->item_props->property_association->entries);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ItemPropertyAssociationEntry *e = gf_list_get(meta->item_props->property_association->entries, i);\n\t\t\tif (e->item_id!=item_id) continue;\n\t\t\tc2 = gf_list_count(e->property_index);\n\t\t\tfor (j=0; j<c2; j++) {\n\t\t\t\tu32 *idx = gf_list_get(e->property_index, j);\n\t\t\t\tif (! (*idx) ) continue;\n\t\t\t\thvcc = gf_list_get(meta->item_props->property_container->other_boxes, (*idx) - 1);\n\t\t\t\tif (!hvcc) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tif (hvcc->type == GF_ISOM_BOX_TYPE_HVCC) break;\n\t\t\t\tif (hvcc->type == GF_ISOM_BOX_TYPE_AVCC) {\n\t\t\t\t\tavcc = (GF_AVCConfigurationBox *) hvcc;\n\t\t\t\t\thvcc = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avcc || hvcc) break;\n\t\t}\n\t\tif (hvcc) {\n\t\t\tif (! hvcc->config) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Missing HEVC config in hvcC\\n\""));\n\t\t\t} else {\n\t\t\t\tif (use_annex_b) {\n\t\t\t\t\thvcc->config->write_annex_b = GF_TRUE;\n\t\t\t\t\tgf_odf_hevc_cfg_write_bs(hvcc->config, item_bs);\n\t\t\t\t\thvcc->config->write_annex_b = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tnalu_size_length = hvcc->config->nal_unit_size;\n\t\t\t}\n\t\t} else if (avcc) {\n\t\t\tif (! avcc->config) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Missing AVC config in avcC\\n\""));\n\t\t\t} else {\n\t\t\t\tif (use_annex_b) {\n\t\t\t\t\tavcc->config->write_annex_b = GF_TRUE;\n\t\t\t\t\tgf_odf_avc_cfg_write_bs(avcc->config, item_bs);\n\t\t\t\t\tavcc->config->write_annex_b = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tnalu_size_length = avcc->config->nal_unit_size;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tchar buf_cache[4096];\n\t\tu64 remain;\n\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_list_get(location_entry->extent_entries, i);\n\t\tgf_bs_seek(file->movieFileMap->bs, idat_offset + location_entry->base_offset + extent_entry->extent_offset);\n\n\t\tremain = extent_entry->extent_length;\n\t\twhile (remain) {\n\t\t\tif (nalu_size_length) {\n\t\t\t\tu32 nal_size = gf_bs_read_int(file->movieFileMap->bs, 8*nalu_size_length);\n\t\t\t\tassert(remain>nalu_size_length);\n\n\t\t\t\tif (use_annex_b)\n\t\t\t\t\tgf_bs_write_u32(item_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(item_bs, nal_size, 8*nalu_size_length);\n\n\t\t\t\tremain -= nalu_size_length + nal_size;\n\t\t\t\twhile (nal_size) {\n\t\t\t\t\tu32 cache_size = (nal_size>4096) ? 4096 : (u32) nal_size;\n\n\t\t\t\t\tgf_bs_read_data(file->movieFileMap->bs, buf_cache, cache_size);\n\t\t\t\t\tgf_bs_write_data(item_bs, buf_cache, cache_size);\n\t\t\t\t\tnal_size -= cache_size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 cache_size = (remain>4096) ? 4096 : (u32) remain;\n\t\t\t\tgf_bs_read_data(file->movieFileMap->bs, buf_cache, cache_size);\n\t\t\t\tgf_bs_write_data(item_bs, buf_cache, cache_size);\n\t\t\t\tremain -= cache_size;\n\t\t\t}\n\t\t}\n\t}\n\tif (out_data) {\n\t\tgf_bs_get_content(item_bs, out_data, out_size);\n\t}\n\tif (resource) {\n\t\tgf_fclose(resource);\n\t}\n\tgf_bs_del(item_bs);\n\treturn GF_OK;\n}\n"", ""caller_start"": 195, ""file_path"": ""src/isomedia/meta.c""}]}, {""source"": ""caller_info(file:descriptors.c, func:gf_odf_avc_cfg_write)"", ""result"": [{""call_line"": 260, ""call_code"": ""gf_odf_avc_cfg_write(cfg, &dsi_data, &dsi_data_size)"", ""caller_code"": ""static GF_Err VTBDec_InitDecoder(VTBDec *ctx)\n{\n\tCFMutableDictionaryRef dec_dsi, dec_type;\n\tCFMutableDictionaryRef dsi;\n\tVTDecompressionOutputCallbackRecord cbacks;\n    CFDictionaryRef buffer_attribs;\n    OSStatus status;\n\tOSType kColorSpace;\n\t\n\tCFDataRef data = NULL;\n\tchar *dsi_data=NULL;\n\tu32 dsi_data_size=0;\n\t\n    dec_dsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\n//\tkColorSpace = kCVPixelFormatType_420YpCbCr8Planar;\n//\tctx->pix_fmt = GF_PIXEL_YV12;\n\n\tkColorSpace = kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange;\n\tctx->pix_fmt = GF_PIXEL_NV12;\n\t\n\tswitch (ctx->esd->decoderConfig->objectTypeIndication) {\n    case GPAC_OTI_VIDEO_AVC :\n\t\tif (gf_list_count(ctx->SPSs) && gf_list_count(ctx->PPSs)) {\n\t\t\ts32 idx;\n\t\t\tu32 i;\n\t\t\tGF_AVCConfig *cfg;\n\t\t\tGF_AVCConfigSlot *sps = NULL;\n\t\t\tGF_AVCConfigSlot *pps = NULL;\n\n\t\t\tfor (i=0; i<gf_list_count(ctx->SPSs); i++) {\n\t\t\t\tsps = gf_list_get(ctx->SPSs, i);\n\t\t\t\tif (ctx->active_sps<0) ctx->active_sps = sps->id;\n\n\t\t\t\tif (sps->id==ctx->active_sps) break;\n\t\t\t\tsps = NULL;\n\t\t\t}\n\t\t\tif (!sps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tfor (i=0; i<gf_list_count(ctx->PPSs); i++) {\n\t\t\t\tpps = gf_list_get(ctx->PPSs, i);\n\t\t\t\tif (ctx->active_pps<0) ctx->active_pps = pps->id;\n\n\t\t\t\tif (pps->id==ctx->active_pps) break;\n\t\t\t\tpps = NULL;\n\t\t\t}\n\t\t\tif (!pps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tctx->reconfig_needed = GF_FALSE;\n\t\t\t\n\t\t\tctx->vtb_type = kCMVideoCodecType_H264;\n\n\t\t\tidx = ctx->active_sps;\n\t\t\tctx->width = ctx->avc.sps[idx].width;\n\t\t\tctx->height = ctx->avc.sps[idx].height;\n\t\t\tif (ctx->avc.sps[idx].vui.par_num && ctx->avc.sps[idx].vui.par_den) {\n\t\t\t\tctx->pixel_ar = ctx->avc.sps[idx].vui.par_num;\n\t\t\t\tctx->pixel_ar <<= 16;\n\t\t\t\tctx->pixel_ar |= ctx->avc.sps[idx].vui.par_den;\n\t\t\t}\n\t\t\tctx->chroma_format = ctx->avc.sps[idx].chroma_format;\n\t\t\tctx->luma_bit_depth = 8 + ctx->avc.sps[idx].luma_bit_depth_m8;\n\t\t\tctx->chroma_bit_depth = 8 + ctx->avc.sps[idx].chroma_bit_depth_m8;\n\t\t\n\t\t\tswitch (ctx->chroma_format) {\n\t\t\tcase 2:\n\t\t\t\t//422 decoding doesn't seem supported ...\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422_10;\n\t\t\t\t} else {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444_10;\n\t\t\t\t} else {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YV12_10;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//always rewrite with cirrent sps and pps\n\t\t\tcfg = gf_odf_avc_cfg_new();\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_compatibility = ctx->avc.sps[idx].prof_compat;\n\t\t\tcfg->AVCProfileIndication = ctx->avc.sps[idx].profile_idc;\n\t\t\tcfg->AVCLevelIndication = ctx->avc.sps[idx].level_idc;\n\t\t\tcfg->chroma_format = ctx->avc.sps[idx].chroma_format;\n\t\t\tcfg->luma_bit_depth = 8 + ctx->avc.sps[idx].luma_bit_depth_m8;\n\t\t\tcfg->chroma_bit_depth = 8 + ctx->avc.sps[idx].chroma_bit_depth_m8;\n\t\t\tcfg->nal_unit_size = 4;\n\t\t\t\t\n\t\t\tgf_list_add(cfg->sequenceParameterSets, sps);\n\t\t\t//we send all PPS\n\t\t\tgf_list_del(cfg->pictureParameterSets);\n\t\t\tcfg->pictureParameterSets = ctx->PPSs;\n\n\t\t\tgf_odf_avc_cfg_write(cfg, &dsi_data, &dsi_data_size);\n\t\t\tgf_list_reset(cfg->sequenceParameterSets);\n\t\t\tcfg->pictureParameterSets = NULL;\n\t\t\tgf_odf_avc_cfg_del((cfg));\n\t\t\t\n\t\t\tdsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\t\tdata = CFDataCreate(kCFAllocatorDefault, (const UInt8*)dsi_data, dsi_data_size);\n\t\t\tif (data) {\n\t\t\t\tCFDictionarySetValue(dsi, CFSTR(\""avcC\""), data);\n\t\t\t\tCFDictionarySetValue(dec_dsi, kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, dsi);\n\t\t\t\tCFRelease(data);\n\t\t\t}\n\t\t\tCFRelease(dsi);\n\t\t\n\t\t\tgf_free(dsi_data);\n\t\t}\n        break;\n\n    case GPAC_OTI_VIDEO_HEVC:\n\t\tif (gf_list_count(ctx->SPSs) && gf_list_count(ctx->PPSs) && gf_list_count(ctx->VPSs)) {\n\t\t\ts32 idx;\n\t\t\tu32 i;\n\t\t\tGF_HEVCConfig *cfg;\n\t\t\tGF_HEVCParamArray *vpsa = NULL;\n\t\t\tGF_HEVCParamArray *spsa = NULL;\n\t\t\tGF_HEVCParamArray *ppsa = NULL;\n\t\t\tGF_AVCConfigSlot *vps = NULL;\n\t\t\tGF_AVCConfigSlot *sps = NULL;\n\t\t\tGF_AVCConfigSlot *pps = NULL;\n\n\t\t\tfor (i=0; i<gf_list_count(ctx->VPSs); i++) {\n\t\t\t\tvps = gf_list_get(ctx->VPSs, i);\n\t\t\t\tif (ctx->active_vps<0) ctx->active_vps = vps->id;\n\n\t\t\t\tif (vps->id==ctx->active_vps) break;\n\t\t\t\tvps = NULL;\n\t\t\t}\n\t\t\tif (!vps) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\t\tfor (i=0; i<gf_list_count(ctx->SPSs); i++) {\n\t\t\t\tsps = gf_list_get(ctx->SPSs, i);\n\t\t\t\tif (ctx->active_sps<0) ctx->active_sps = sps->id;\n\n\t\t\t\tif (sps->id==ctx->active_sps) break;\n\t\t\t\tsps = NULL;\n\t\t\t}\n\t\t\tif (!sps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tfor (i=0; i<gf_list_count(ctx->PPSs); i++) {\n\t\t\t\tpps = gf_list_get(ctx->PPSs, i);\n\t\t\t\tif (ctx->active_pps<0) ctx->active_pps = pps->id;\n\n\t\t\t\tif (pps->id==ctx->active_pps) break;\n\t\t\t\tpps = NULL;\n\t\t\t}\n\t\t\tif (!pps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tctx->reconfig_needed = GF_FALSE;\n\n\t\t\tctx->vtb_type = kCMVideoCodecType_HEVC;\n\n\t\t\tidx = ctx->active_sps;\n\t\t\tctx->width = ctx->hevc.sps[idx].width;\n\t\t\tctx->height = ctx->hevc.sps[idx].height;\n\t\t\tif (ctx->hevc.sps[idx].aspect_ratio_info_present_flag && ctx->hevc.sps[idx].sar_width && ctx->hevc.sps[idx].sar_height) {\n\t\t\t\tctx->pixel_ar = ctx->hevc.sps[idx].sar_width;\n\t\t\t\tctx->pixel_ar <<= 16;\n\t\t\t\tctx->pixel_ar |= ctx->hevc.sps[idx].sar_height;\n\t\t\t}\n\t\t\tctx->chroma_format = ctx->hevc.sps[idx].chroma_format_idc;\n\t\t\tctx->luma_bit_depth = ctx->hevc.sps[idx].bit_depth_luma;\n\t\t\tctx->chroma_bit_depth = ctx->hevc.sps[idx].bit_depth_chroma;\n\n\t\t\tswitch (ctx->chroma_format) {\n\t\t\tcase 2:\n#ifndef GPAC_IPHONE\n\t\t\t\t//422 decoding doesn't seem supported ...\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422_10;\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n#ifndef GPAC_IPHONE\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444_10;\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//we disable support for 10bit output on ios and old OSX, defaulting back to 8 bits\n#if !defined(GPAC_IPHONE) && defined(AVAILABLE_MAC_OS_X_VERSION_10_13_AND_LATER)\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_NV12_10;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//always rewrite with cirrent sps and pps\n\t\t\tcfg = gf_odf_hevc_cfg_new();\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_space = ctx->hevc.sps[idx].ptl.profile_space;\n\t\t\tcfg->tier_flag = ctx->hevc.sps[idx].ptl.tier_flag;\n\t\t\tcfg->profile_idc = ctx->hevc.sps[idx].ptl.profile_idc;\n\t\t\tcfg->general_profile_compatibility_flags = ctx->hevc.sps[idx].ptl.profile_compatibility_flag;\n\t\t\tcfg->progressive_source_flag = ctx->hevc.sps[idx].ptl.general_progressive_source_flag;\n\t\t\tcfg->interlaced_source_flag = ctx->hevc.sps[idx].ptl.general_interlaced_source_flag;\n\t\t\tcfg->non_packed_constraint_flag = ctx->hevc.sps[idx].ptl.general_non_packed_constraint_flag;\n\t\t\tcfg->frame_only_constraint_flag = ctx->hevc.sps[idx].ptl.general_frame_only_constraint_flag;\n\n\t\t\tcfg->constraint_indicator_flags = ctx->hevc.sps[idx].ptl.general_reserved_44bits;\n\t\t\tcfg->level_idc = ctx->hevc.sps[idx].ptl.level_idc;\n\n\t\t\tcfg->luma_bit_depth = ctx->hevc.sps[idx].bit_depth_luma;\n\t\t\tcfg->chroma_bit_depth = ctx->hevc.sps[idx].bit_depth_chroma;\n\t\t\tcfg->chromaFormat = ctx->hevc.sps[idx].chroma_format_idc;\n\t\t\tcfg->complete_representation = GF_TRUE;\n\n\t\t\tcfg->nal_unit_size = 4;\n\n\t\t\tGF_SAFEALLOC(vpsa, GF_HEVCParamArray);\n\t\t\tvpsa->array_completeness = 1;\n\t\t\tvpsa->type = GF_HEVC_NALU_VID_PARAM;\n\t\t\tvpsa->nalus = gf_list_new();\n\t\t\tgf_list_add(vpsa->nalus, vps);\n\t\t\tgf_list_add(cfg->param_array, vpsa);\n\n\t\t\tGF_SAFEALLOC(spsa, GF_HEVCParamArray);\n\t\t\tspsa->array_completeness = 1;\n\t\t\tspsa->type = GF_HEVC_NALU_SEQ_PARAM;\n\t\t\tspsa->nalus = gf_list_new();\n\t\t\tgf_list_add(spsa->nalus, sps);\n\t\t\tgf_list_add(cfg->param_array, spsa);\n\n\t\t\tGF_SAFEALLOC(ppsa, GF_HEVCParamArray);\n\t\t\tppsa->array_completeness = 1;\n\t\t\tppsa->type = GF_HEVC_NALU_PIC_PARAM;\n\t\t\t//we send all PPS\n\t\t\tppsa->nalus = ctx->PPSs;\n\n\t\t\tgf_list_add(cfg->param_array, ppsa);\n\n\t\t\tgf_odf_hevc_cfg_write(cfg, &dsi_data, &dsi_data_size);\n\t\t\tgf_list_reset(vpsa->nalus);\n\t\t\tgf_list_reset(spsa->nalus);\n\t\t\tppsa->nalus = NULL;\n\t\t\tgf_odf_hevc_cfg_del(cfg);\n\n\t\t\tdsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\t\tdata = CFDataCreate(kCFAllocatorDefault, (const UInt8*)dsi_data, dsi_data_size);\n\t\t\tif (data) {\n\t\t\t\tCFDictionarySetValue(dsi, CFSTR(\""hvcC\""), data);\n\t\t\t\tCFDictionarySetValue(dec_dsi, kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, dsi);\n\t\t\t\tCFRelease(data);\n\t\t\t}\n\t\t\tCFRelease(dsi);\n\n\t\t\tgf_free(dsi_data);\n\t\t}\n        break;\n\n\tcase GPAC_OTI_VIDEO_MPEG2_SIMPLE:\n\tcase GPAC_OTI_VIDEO_MPEG2_MAIN:\n\tcase GPAC_OTI_VIDEO_MPEG2_SNR:\n\tcase GPAC_OTI_VIDEO_MPEG2_SPATIAL:\n\tcase GPAC_OTI_VIDEO_MPEG2_HIGH:\n\tcase GPAC_OTI_VIDEO_MPEG2_422:\n        ctx->vtb_type = kCMVideoCodecType_MPEG2Video;\n\t\tif (!ctx->width || !ctx->height) {\n\t\t\tctx->init_mpeg12 = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->init_mpeg12 = GF_FALSE;\n        break;\n\t\t\n\tcase GPAC_OTI_VIDEO_MPEG1:\n\t\tctx->vtb_type = kCMVideoCodecType_MPEG1Video;\n\t\tif (!ctx->width || !ctx->height) {\n\t\t\tctx->init_mpeg12 = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->init_mpeg12 = GF_FALSE;\n\t\tbreak;\n    case GPAC_OTI_VIDEO_MPEG4_PART2 :\n\t{\n\t\tBool reset_dsi = GF_FALSE;\n\t\tctx->vtb_type = kCMVideoCodecType_MPEG4Video;\n\t\tif (!ctx->esd->decoderConfig->decoderSpecificInfo) {\n\t\t\tctx->esd->decoderConfig->decoderSpecificInfo = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\t}\n\n\t\tif (!ctx->esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\treset_dsi = GF_TRUE;\n\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->data = ctx->vosh;\n\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->dataLength = ctx->vosh_size;\n\t\t}\n\t\t\n\t\tif (ctx->esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tGF_M4VDecSpecInfo vcfg;\n\t\t\tGF_BitStream *bs;\n\t\t\t\n\t\t\tgf_m4v_get_config(ctx->esd->decoderConfig->decoderSpecificInfo->data, ctx->esd->decoderConfig->decoderSpecificInfo->dataLength, &vcfg);\n\t\t\tctx->width = vcfg.width;\n\t\t\tctx->height = vcfg.height;\n\t\t\tif (ctx->esd->slConfig) {\n\t\t\t\tctx->esd->slConfig->predefined  = 2;\n\t\t\t}\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\tgf_odf_desc_write_bs((GF_Descriptor *) ctx->esd, bs);\n\t\t\tgf_bs_get_content(bs, &dsi_data, &dsi_data_size);\n\t\t\tgf_bs_del(bs);\n\t\t\t\n\t\t\tdsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\t\tdata = CFDataCreate(kCFAllocatorDefault, (const UInt8*) dsi_data, dsi_data_size);\n\t\t\tgf_free(dsi_data);\n\t\t\t\n\t\t\tif (data) {\n\t\t\t\tCFDictionarySetValue(dsi, CFSTR(\""esds\""), data);\n\t\t\t\tCFDictionarySetValue(dec_dsi, kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, dsi);\n\t\t\t\tCFRelease(data);\n\t\t\t}\n\t\t\tCFRelease(dsi);\n\t\t\t\n\t\t\tif (reset_dsi) {\n\t\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t\t}\n\t\t\tctx->skip_mpeg4_vosh = GF_FALSE;\n\t\t} else {\n\t\t\tctx->skip_mpeg4_vosh = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n        break;\n    }\n\tcase GPAC_OTI_MEDIA_GENERIC:\n\t\tif (ctx->esd->decoderConfig->decoderSpecificInfo && ctx->esd->decoderConfig->decoderSpecificInfo->dataLength) {\n\t\t\tchar *dsi = ctx->esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\tif (ctx->esd->decoderConfig->decoderSpecificInfo->dataLength<8) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tif (strnicmp(dsi, \""s263\"", 4)) return GF_NOT_SUPPORTED;\n\t\t\t\n\t\t\tctx->width = ((u8) dsi[4]); ctx->width<<=8; ctx->width |= ((u8) dsi[5]);\n\t\t\tctx->height = ((u8) dsi[6]); ctx->height<<=8; ctx->height |= ((u8) dsi[7]);\n\t\t\tctx->vtb_type = kCMVideoCodecType_H263;\n\t\t}\n\t\tbreak;\n\t\t\n\tdefault :\n\t\treturn GF_NOT_SUPPORTED;\n    }\n\n\tif (! ctx->width || !ctx->height) return GF_NOT_SUPPORTED;\n\n    status = CMVideoFormatDescriptionCreate(kCFAllocatorDefault, ctx->vtb_type, ctx->width, ctx->height, dec_dsi, &ctx->fmt_desc);\n\n    if (!ctx->fmt_desc) {\n\t\tif (dec_dsi) CFRelease(dec_dsi);\n        return GF_NON_COMPLIANT_BITSTREAM;\n    }\n\tbuffer_attribs = VTBDec_CreateBufferAttributes(ctx, kColorSpace);\n\t\n\tcbacks.decompressionOutputCallback = VTBDec_on_frame;\n    cbacks.decompressionOutputRefCon   = ctx;\n\n    dec_type = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n    CFDictionarySetValue(dec_type, kVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder, kCFBooleanTrue);\n\tctx->is_hardware = GF_TRUE;\n\n    status = VTDecompressionSessionCreate(NULL, ctx->fmt_desc, dec_type, buffer_attribs, &cbacks, &ctx->vtb_session);\n\t//if HW decoder not available, try soft one\n\tif (status) {\n\t\tstatus = VTDecompressionSessionCreate(NULL, ctx->fmt_desc, NULL, buffer_attribs, &cbacks, &ctx->vtb_session);\n\t\tctx->is_hardware = GF_FALSE;\n\t}\n\t\n\tif (dec_dsi)\n\t\tCFRelease(dec_dsi);\n\tif (dec_type)\n\t\tCFRelease(dec_type);\n    if (buffer_attribs)\n        CFRelease(buffer_attribs);\n\n    switch (status) {\n    case kVTVideoDecoderNotAvailableNowErr:\n    case kVTVideoDecoderUnsupportedDataFormatErr:\n        return GF_NOT_SUPPORTED;\n    case kVTVideoDecoderMalfunctionErr:\n        return GF_IO_ERR;\n    case kVTVideoDecoderBadDataErr :\n        return GF_BAD_PARAM;\n\n\tcase kVTPixelTransferNotSupportedErr:\n\tcase kVTCouldNotFindVideoDecoderErr:\n\t\treturn GF_NOT_SUPPORTED;\n    case 0:\n        break;\n    default:\n        return GF_SERVICE_ERROR;\n    }\n\t\n\t//good to go !\n\tif (ctx->pix_fmt == GF_PIXEL_YUV422) {\n\t\tctx->out_size = ctx->width*ctx->height*2;\n\t} else if (ctx->pix_fmt == GF_PIXEL_YUV444) {\n\t\tctx->out_size = ctx->width*ctx->height*3;\n\t} else {\n\t\t// (ctx->pix_fmt == GF_PIXEL_YV12)\n\t\tctx->out_size = ctx->width*ctx->height*3/2;\n\t}\n\tif (ctx->luma_bit_depth>8) {\n\t\tctx->out_size *= 2;\n\t}\n\tctx->frame_size_changed = GF_TRUE;\n\treturn GF_OK;\n}\n"", ""caller_start"": 155, ""file_path"": ""modules/vtb_decode/vtb_decode.c""}, {""call_line"": 1564, ""call_code"": ""gf_odf_avc_cfg_write(avcc, &rtp->sl_map.config, &rtp->sl_map.configSize)"", ""caller_code"": ""static GF_Err gf_rtp_payt_setup(GF_RTPDepacketizer *rtp, GF_RTPMap *map, GF_SDPMedia *media)\n{\n\tu32 i, j;\n\tGF_SDP_FMTP *fmtp;\n\n\t/*reset sl map*/\n\tmemset(&rtp->sl_map, 0, sizeof(GP_RTPSLMap));\n\n\tif (!stricmp(map->payload_name, \""enc-mpeg4-generic\"")) rtp->flags |= GF_RTP_HAS_ISMACRYP;\n\n\n\t/*then process all FMTPs*/\n\ti=0;\n\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\tGF_X_Attribute *att;\n\t\t//we work with only one PayloadType for now\n\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\tj=0;\n\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\t\t\tpayt_set_param(rtp, att->Name, att->Value);\n\t\t}\n\t}\n\n\tswitch (rtp->payt) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_LATM:\n\t{\n\t\tu32 AudioMuxVersion, AllStreamsSameTime, numSubFrames, numPrograms, numLayers, ch_cfg;\n\t\tGF_M4ADecSpecInfo cfg;\n\t\tchar *latm_dsi = rtp->sl_map.config;\n\t\tGF_BitStream *bs = gf_bs_new(latm_dsi, rtp->sl_map.configSize, GF_BITSTREAM_READ);\n\t\tAudioMuxVersion = gf_bs_read_int(bs, 1);\n\t\tAllStreamsSameTime = gf_bs_read_int(bs, 1);\n\t\tnumSubFrames = gf_bs_read_int(bs, 6);\n\t\tnumPrograms = gf_bs_read_int(bs, 4);\n\t\tnumLayers = gf_bs_read_int(bs, 3);\n\n\t\tif (AudioMuxVersion || !AllStreamsSameTime || numSubFrames || numPrograms || numLayers) {\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tmemset(&cfg, 0, sizeof(cfg));\n\t\tcfg.base_object_type = gf_bs_read_int(bs, 5);\n\t\tcfg.base_sr_index = gf_bs_read_int(bs, 4);\n\t\tif (cfg.base_sr_index == 0x0F) {\n\t\t\tcfg.base_sr = gf_bs_read_int(bs, 24);\n\t\t} else {\n\t\t\tcfg.base_sr = GF_M4ASampleRates[cfg.base_sr_index];\n\t\t}\n\t\tch_cfg = gf_bs_read_int(bs, 4);\n\t\tif (cfg.base_object_type==5 || cfg.base_object_type==29) {\n\t\t\tif (cfg.base_object_type==29) {\n\t\t\t\tcfg.has_ps = 1;\n\t\t\t\tcfg.nb_chan = 1;\n\t\t\t}\n\t\t\tcfg.has_sbr = 1;\n\t\t\tcfg.sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\t\tif (cfg.sbr_sr_index == 0x0F) {\n\t\t\t\tcfg.sbr_sr = gf_bs_read_int(bs, 24);\n\t\t\t} else {\n\t\t\t\tcfg.sbr_sr = GF_M4ASampleRates[cfg.sbr_sr_index];\n\t\t\t}\n\t\t\tcfg.sbr_object_type = gf_bs_read_int(bs, 5);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_free(rtp->sl_map.config);\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t/*write as regular AAC*/\n\t\tgf_bs_write_int(bs, cfg.base_object_type, 5);\n\t\tgf_bs_write_int(bs, cfg.base_sr_index, 4);\n\n\t\tgf_bs_write_int(bs, ch_cfg, 4);\n\t\tgf_bs_align(bs);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_bs_del(bs);\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_latm;\n\t}\n\tbreak;\n#endif\n\tcase GF_RTP_PAYT_MPEG4:\n\t\t/*mark if AU header is present*/\n\t\trtp->sl_map.auh_first_min_len = 0;\n\t\tif (rtp->flags & GF_RTP_HAS_ISMACRYP) {\n\t\t\tif (!rtp->isma_scheme) rtp->isma_scheme = GF_ISOM_ISMACRYP_SCHEME;\n\t\t\tif (!rtp->sl_map.IV_length) rtp->sl_map.IV_length = 4;\n\n\t\t\tif (rtp->flags & GF_RTP_ISMA_SEL_ENC) rtp->sl_map.auh_first_min_len += 8;\n\t\t\telse rtp->sl_map.auh_first_min_len += 8*(rtp->sl_map.IV_length + rtp->sl_map.KI_length);\n\t\t}\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.CTSDeltaLength;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.DTSDeltaLength;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.SizeLength;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.RandomAccessIndication;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.StreamStateIndication;\n\t\trtp->sl_map.auh_min_len = rtp->sl_map.auh_first_min_len;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.IndexLength;\n\t\trtp->sl_map.auh_min_len += rtp->sl_map.IndexDeltaLength;\n\t\t/*RFC3016 flags*/\n\t\tif (!stricmp(map->payload_name, \""MP4V-ES\"")) {\n\t\t\trtp->sl_map.StreamType = GF_STREAM_VISUAL;\n\t\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_MPEG4_PART2;\n\t\t}\n\t\telse if (!strnicmp(map->payload_name, \""AAC\"", 3)) {\n\t\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\t\t}\n\t\telse if (!stricmp(map->payload_name, \""MP4A-LATM\"")) {\n\t\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\t\t}\n\t\t/*MPEG-4 video, check RAPs if not indicated*/\n\t\tif ((rtp->sl_map.StreamType == GF_STREAM_VISUAL) && (rtp->sl_map.ObjectTypeIndication == GPAC_OTI_VIDEO_MPEG4_PART2) && !rtp->sl_map.RandomAccessIndication) {\n\t\t\trtp->flags |= GF_RTP_M4V_CHECK_RAP;\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif ((rtp->sl_map.ObjectTypeIndication == GPAC_OTI_AUDIO_AAC_MPEG4) && !rtp->sl_map.config) {\n\t\t\tGF_M4ADecSpecInfo cfg;\n\t\t\tGF_RTPMap*map = (GF_RTPMap*)gf_list_get(media->RTPMaps, 0);\n\n\t\t\tmemset(&cfg, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\tcfg.audioPL = rtp->sl_map.PL_ID;\n\t\t\tcfg.nb_chan = map->AudioChannels;\n\t\t\tcfg.nb_chan = 1;\n\t\t\tcfg.base_sr = map->ClockRate/2;\n\t\t\tcfg.sbr_sr = map->ClockRate;\n\t\t\tcfg.base_object_type = GF_M4A_AAC_LC;\n\t\t\tcfg.base_object_type = 5;\n\t\t\tcfg.sbr_object_type = GF_M4A_AAC_MAIN;\n\t\t\tgf_m4a_write_config(&cfg, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\t}\n#endif\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_mpeg4;\n\t\tbreak;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_MPEG12_AUDIO:\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_MPEG2_PART3;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_mpeg12_audio;\n\t\tbreak;\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\tcase GF_RTP_PAYT_MPEG12_VIDEO:\n\t\t/*we signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\trtp->sl_map.StreamType = GF_STREAM_VISUAL;\n\t\t/*FIXME: how to differentiate MPEG1 from MPEG2 video before any frame is received??*/\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_MPEG1;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_mpeg12_video;\n\t\tbreak;\n\tcase GF_RTP_PAYT_AMR:\n\tcase GF_RTP_PAYT_AMR_WB:\n\t{\n\t\tGF_BitStream *bs;\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t/*create DSI*/\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (rtp->payt == GF_RTP_PAYT_AMR) {\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_SUBTYPE_3GP_AMR);\n\t\t\tgf_bs_write_u32(bs, 8000);\n\t\t\tgf_bs_write_u16(bs, 1);\n\t\t\tgf_bs_write_u16(bs, 160);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_SUBTYPE_3GP_AMR_WB);\n\t\t\tgf_bs_write_u32(bs, 16000);\n\t\t\tgf_bs_write_u16(bs, 1);\n\t\t\tgf_bs_write_u16(bs, 320);\n\t\t}\n\t\tgf_bs_write_u8(bs, 16);\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_bs_del(bs);\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_amr;\n\t}\n\tbreak;\n\tcase GF_RTP_PAYT_H263:\n\t{\n\t\tu32 x, y, w, h;\n\t\tGF_X_Attribute *att;\n\t\tGF_BitStream *bs;\n\t\tx = y = w = h = 0;\n\t\tj=0;\n\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(media->Attributes, &j))) {\n\t\t\tif (stricmp(att->Name, \""cliprect\"")) continue;\n\t\t\t/*only get the display area*/\n\t\t\tsscanf(att->Value, \""%u,%u,%u,%u\"", &y, &x, &h, &w);\n\t\t}\n\n\t\trtp->sl_map.StreamType = GF_STREAM_VISUAL;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t/*create DSI*/\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, GF_ISOM_SUBTYPE_H263);\n\t\tgf_bs_write_u16(bs, w);\n\t\tgf_bs_write_u16(bs, h);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_bs_del(bs);\n\t\t/*we signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_h263;\n\t}\n\tbreak;\n\tcase GF_RTP_PAYT_3GPP_TEXT:\n\t{\n\t\tchar *tx3g, *a_tx3g;\n\t\tGF_BitStream *bs;\n\t\tu32 nb_desc;\n\t\tGF_SDP_FMTP *fmtp;\n\t\tGF_TextConfig tcfg;\n\t\tmemset(&tcfg, 0, sizeof(GF_TextConfig));\n\t\ttcfg.tag = GF_ODF_TEXT_CFG_TAG;\n\t\ttcfg.Base3GPPFormat = 0x10;\n\t\ttcfg.MPEGExtendedFormat = 0x10;\n\t\ttcfg.profileLevel = 0x10;\n\t\ttcfg.timescale = map->ClockRate;\n\t\ttcfg.sampleDescriptionFlags = 1;\n\t\ttx3g = NULL;\n\n\t\ti=0;\n\t\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\t\tGF_X_Attribute *att;\n\t\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\t\tj=0;\n\t\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\n\t\t\t\tif (!stricmp(att->Name, \""width\"")) tcfg.text_width = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""height\"")) tcfg.text_height = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""tx\"")) tcfg.horiz_offset = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""ty\"")) tcfg.vert_offset = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""layer\"")) tcfg.layer = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""max-w\"")) tcfg.video_width = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""max-h\"")) tcfg.video_height = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""tx3g\"")) tx3g = att->Value;\n\t\t\t}\n\t\t}\n\t\tif (!tx3g) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u8(bs, tcfg.Base3GPPFormat);\n\t\tgf_bs_write_u8(bs, tcfg.MPEGExtendedFormat); /*MPEGExtendedFormat*/\n\t\tgf_bs_write_u8(bs, tcfg.profileLevel); /*profileLevel*/\n\t\tgf_bs_write_u24(bs, tcfg.timescale);\n\t\tgf_bs_write_int(bs, 0, 1);\t/*no alt formats*/\n\t\tgf_bs_write_int(bs, tcfg.sampleDescriptionFlags, 2);\n\t\tgf_bs_write_int(bs, 1, 1);\t/*we will write sample desc*/\n\t\tgf_bs_write_int(bs, 1, 1);\t/*video info*/\n\t\tgf_bs_write_int(bs, 0, 3);\t/*reserved, spec doesn't say the values*/\n\t\tgf_bs_write_u8(bs, tcfg.layer);\n\t\tgf_bs_write_u16(bs, tcfg.text_width);\n\t\tgf_bs_write_u16(bs, tcfg.text_height);\n\t\t/*get all tx3g (comma separated)*/\n\t\tnb_desc = 1;\n\t\ta_tx3g = tx3g;\n\t\twhile ((a_tx3g = strchr(a_tx3g, ',')) ) {\n\t\t\ta_tx3g ++;\n\t\t\tnb_desc ++;\n\t\t}\n\t\ta_tx3g = tx3g;\n\t\tgf_bs_write_u8(bs, nb_desc);\n\t\tnb_desc = 1;\n\t\twhile (1) {\n\t\t\tchar *next_tx3g, szOut[1000];\n\t\t\tu32 len, s_len;\n\t\t\tnext_tx3g = strchr(a_tx3g, ',');\n\t\t\tif (next_tx3g) s_len = (u32) (next_tx3g - a_tx3g - 1);\n\t\t\telse s_len = (u32) strlen(a_tx3g);\n\n\t\t\tlen = gf_base64_decode(a_tx3g, s_len, szOut, 1000);\n\t\t\tnb_desc++;\n\t\t\tgf_bs_write_data(bs, szOut, len);\n\t\t\tif (!next_tx3g) break;\n\t\t\ta_tx3g = strchr(a_tx3g, ',');\n\t\t\tif (!a_tx3g) break;\n\t\t\ta_tx3g += 1;\n\t\t\twhile (a_tx3g[0] == ' ') a_tx3g += 1;\n\t\t}\n\n\t\t/*write video cfg*/\n\t\tgf_bs_write_u16(bs, tcfg.video_width);\n\t\tgf_bs_write_u16(bs, tcfg.video_height);\n\t\tgf_bs_write_u16(bs, tcfg.horiz_offset);\n\t\tgf_bs_write_u16(bs, tcfg.vert_offset);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\trtp->sl_map.StreamType = GF_STREAM_TEXT;\n\t\trtp->sl_map.ObjectTypeIndication = 0x08;\n\t\tgf_bs_del(bs);\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_ttxt;\n\t}\n\tbreak;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_H264_AVC:\n\tcase GF_RTP_PAYT_H264_SVC:\n\t{\n\t\tGF_SDP_FMTP *fmtp;\n\t\tGF_AVCConfig *avcc = gf_odf_avc_cfg_new();\n\t\tavcc->AVCProfileIndication = (rtp->sl_map.PL_ID>>16) & 0xFF;\n\t\tavcc->profile_compatibility = (rtp->sl_map.PL_ID>>8) & 0xFF;\n\t\tavcc->AVCLevelIndication = rtp->sl_map.PL_ID & 0xFF;\n\t\tavcc->configurationVersion = 1;\n\t\tavcc->nal_unit_size = 4;\n\t\trtp->sl_map.StreamType = 4;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\t\t/*we will signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*rewrite sps and pps*/\n\t\ti=0;\n\t\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\t\tGF_X_Attribute *att;\n\t\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\t\tj=0;\n\t\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\t\t\t\tchar *nal_ptr, *sep;\n\t\t\t\tif (stricmp(att->Name, \""sprop-parameter-sets\"")) continue;\n\n\t\t\t\tnal_ptr = att->Value;\n\t\t\t\twhile (nal_ptr) {\n\t\t\t\t\tu32 nalt, b64size, ret;\n\t\t\t\t\tchar *b64_d;\n\n\t\t\t\t\tsep = strchr(nal_ptr, ',');\n\t\t\t\t\tif (sep) sep[0] = 0;\n\n\t\t\t\t\tb64size = (u32) strlen(nal_ptr);\n\t\t\t\t\tb64_d = (char*)gf_malloc(sizeof(char)*b64size);\n\t\t\t\t\tret = gf_base64_decode(nal_ptr, b64size, b64_d, b64size);\n\t\t\t\t\tb64_d[ret] = 0;\n\n\t\t\t\t\tnalt = b64_d[0] & 0x1F;\n\t\t\t\t\tif (/*SPS*/(nalt==0x07) || /*PPS*/(nalt==0x08) || /*SSPS*/(nalt==0x0F)) {\n\t\t\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\t\t\t\tsl->size = ret;\n\t\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\t\tmemcpy(sl->data, b64_d, sizeof(char)*sl->size);\n\t\t\t\t\t\tif (nalt==0x07 || nalt==0x0F) {\n\t\t\t\t\t\t\tgf_list_add(avcc->sequenceParameterSets, sl);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_add(avcc->pictureParameterSets, sl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_free(b64_d);\n\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = ',';\n\t\t\t\t\t\tnal_ptr = sep+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gf_list_count(avcc->sequenceParameterSets) && gf_list_count(avcc->pictureParameterSets)) {\n\t\t\tgf_odf_avc_cfg_write(avcc, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\t} else {\n\t\t\trtp->flags |= GF_RTP_AVC_USE_ANNEX_B;\n\t\t}\n\t\tgf_odf_avc_cfg_del(avcc);\n\t}\n\t\t/*assign depacketizer*/\n\trtp->depacketize = gf_rtp_parse_h264;\n\tbreak;\n\tcase GF_RTP_PAYT_HEVC:\n\tcase GF_RTP_PAYT_LHVC:\n#ifndef GPAC_DISABLE_HEVC\n\t{\n\t\tGF_SDP_FMTP *fmtp;\n\t\tGF_HEVCConfig *hevcc = gf_odf_hevc_cfg_new();\n\t\thevcc->configurationVersion = 1;\n\t\thevcc->nal_unit_size = 4;\n\t\trtp->sl_map.StreamType = 4;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_HEVC;\n\t\t/*we will signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\ti=0;\n\t\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\t\tGF_X_Attribute *att;\n\t\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\t\tj=0;\n\t\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\t\t\t\tchar *nal_ptr, *sep;\n\t\t\t\tGF_HEVCParamArray *ar;\n\t\t\t\tif (!stricmp(att->Name, \""sprop-vps\"")) {\n\t\t\t\t\tGF_SAFEALLOC(ar, GF_HEVCParamArray);\n\t\t\t\t\tif (!ar) return GF_OUT_OF_MEM;\n\t\t\t\t\tar->nalus = gf_list_new();\n\t\t\t\t\tar->type = GF_HEVC_NALU_VID_PARAM;\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(att->Name, \""sprop-sps\"")) {\n\t\t\t\t\tGF_SAFEALLOC(ar, GF_HEVCParamArray);\n\t\t\t\t\tif (!ar) return GF_OUT_OF_MEM;\n\t\t\t\t\tar->nalus = gf_list_new();\n\t\t\t\t\tar->type = GF_HEVC_NALU_SEQ_PARAM;\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(att->Name, \""sprop-pps\"")) {\n\t\t\t\t\tGF_SAFEALLOC(ar, GF_HEVCParamArray);\n\t\t\t\t\tif (!ar) return GF_OUT_OF_MEM;\n\t\t\t\t\tar->nalus = gf_list_new();\n\t\t\t\t\tar->type = GF_HEVC_NALU_PIC_PARAM;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t\tnal_ptr = att->Value;\n\t\t\t\twhile (nal_ptr) {\n\t\t\t\t\tu32 b64size, ret;\n\t\t\t\t\tchar *b64_d;\n\t\t\t\t\tGF_AVCConfigSlot *sl;\n\n\t\t\t\t\tsep = strchr(nal_ptr, ',');\n\t\t\t\t\tif (sep) sep[0] = 0;\n\n\t\t\t\t\tb64size = (u32) strlen(nal_ptr);\n\t\t\t\t\tb64_d = (char*)gf_malloc(sizeof(char)*b64size);\n\t\t\t\t\tret = gf_base64_decode(nal_ptr, b64size, b64_d, b64size);\n\t\t\t\t\tb64_d[ret] = 0;\n\n\t\t\t\t\tsl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\t\t\tsl->size = ret;\n\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\tmemcpy(sl->data, b64_d, sizeof(char)*sl->size);\n\t\t\t\t\tgf_list_add(ar->nalus, sl);\n\n\t\t\t\t\tgf_free(b64_d);\n\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = ',';\n\t\t\t\t\t\tnal_ptr = sep+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!hevcc->param_array) hevcc->param_array = gf_list_new();\n\t\t\t\tgf_list_add(hevcc->param_array, ar);\n\t\t\t}\n\t\t}\n\t\tgf_odf_hevc_cfg_write(hevcc, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_odf_hevc_cfg_del(hevcc);\n\t}\n\trtp->depacketize = gf_rtp_parse_hevc;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\tbreak;\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\t/*todo - rewrite DIMS config*/\n\tcase GF_RTP_PAYT_3GPP_DIMS:\n\t\trtp->sl_map.StreamType = GF_STREAM_SCENE;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_SCENE_DIMS;\n\t\t/*we will signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*we map DIMS CTR to AU seq num, hence 3 bits*/\n\t\trtp->sl_map.StreamStateIndication = 3;\n\t\trtp->sl_map.IndexLength = 3;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_3gpp_dims;\n\t\tbreak;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_AC3:\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = 0xA5;\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_ac3;\n\t\tbreak;\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\treturn GF_OK;\n}\n"", ""caller_start"": 1203, ""file_path"": ""src/ietf/rtp_depacketizer.c""}, {""call_line"": 1047, ""call_code"": ""gf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength)"", ""caller_code"": ""void AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_AVCConfig *avcc, *svcc, *mvcc;\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (avc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(avc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tavcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tsvcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tmvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n"", ""caller_start"": 1001, ""file_path"": ""src/isomedia/avc_ext.c""}, {""call_line"": 1055, ""call_code"": ""gf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength)"", ""caller_code"": ""void AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_AVCConfig *avcc, *svcc, *mvcc;\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (avc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(avc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tavcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tsvcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tmvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n"", ""caller_start"": 1001, ""file_path"": ""src/isomedia/avc_ext.c""}]}, {""source"": ""value_info(file:meta.c, value:avcc)"", ""result"": {""value_trace"": [{""full_code"": ""*avcc = NULL"", ""line"": 310, ""func_name"": ""gf_isom_extract_meta_item_extended""}, {""full_code"": ""avcc = (GF_AVCConfigurationBox *) hvcc"", ""line"": 327, ""func_name"": ""gf_isom_extract_meta_item_extended""}], ""struct_var"": ""avcc"", ""struct_type"": ""GF_AVCConfigurationBox*"", ""struct_definition"": ""typedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AVCConfig *config;\n}""}}]","src/odf/descriptors.c:567: Dereference of 'cfg' without a NULL check. Patch added a check at src/odf/descriptors.c:565. Trigger occurs when 'cfg' is NULL, which can be caused by: \n1. Direct calls to gf_odf_avc_cfg_write() with unvalidated 'cfg' (e.g., src/isomedia/meta.c:351, where avcc is cast from hvcc without NULL check: src/isomedia/meta.c:327). \n2. Callers like src/ietf/rtp_depacketizer.c:1564 and src/isomedia/avc_ext.c:1055, where avcc->config is used without ensuring avcc is non-NULL. \nOriginal vulnerability arises when 'hvcc' is NULL in meta.c:327, leading to avcc->config being NULL and passed to gf_odf_avc_cfg_write_bs().",0.95,./github/other_context/CVE-2019-20163
29,CVE-2019-7153,CWE-476,c_cpp,"A NULL pointer dereference was discovered in wasm::WasmBinaryBuilder::processFunctions() in wasm/wasm-binary.cpp (when calling wasm::WasmBinaryBuilder::getFunctionIndexName) in Binaryen 1.38.22. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by wasm-opt.",https://github.com/WebAssembly/binaryen/commit/e63c4a7d04c145dafaf4b09de5f9f5de69cee8ef,More misc ASAN fixes (#1882)\n\n* fix buffer overflow in simple_ast.h printing.\r\n* check wasm binary format reading of function export indexes for errors.\r\n* check if s-expr format imports have a non-empty module and base.\r\n\r\nFixes #1876\r\nFixes #1877\r\nFixes #1879,5,"[{""func_name"": ""printAst"", ""file_path"": ""src/emscripten-optimizer/simple_ast.h"", ""func_code"": ""void printAst() {\n    print(ast);\n    buffer[used] = 0;\n  }"", ""target"": 0}, {""func_name"": ""WasmBinaryBuilder::processFunctions"", ""file_path"": ""src/wasm/wasm-binary.cpp"", ""func_code"": ""void WasmBinaryBuilder::processFunctions() {\n  for (auto* func : functions) {\n    wasm.addFunction(func);\n  }\n\n  // now that we have names for each function, apply things\n\n  if (startIndex != static_cast<Index>(-1)) {\n    wasm.start = getFunctionIndexName(startIndex);\n  }\n\n  for (auto* curr : exportOrder) {\n    auto index = exportIndexes[curr];\n    switch (curr->kind) {\n      case ExternalKind::Function: {\n        curr->value = getFunctionIndexName(index);\n        break;\n      }\n      case ExternalKind::Table: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Memory: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Global: curr->value = getGlobalName(index); break;\n      default: throwError(\""bad export kind\"");\n    }\n    wasm.addExport(curr);\n  }\n\n  for (auto& iter : functionCalls) {\n    size_t index = iter.first;\n    auto& calls = iter.second;\n    for (auto* call : calls) {\n      call->target = getFunctionIndexName(index);\n    }\n  }\n\n  for (auto& pair : functionTable) {\n    auto i = pair.first;\n    auto& indexes = pair.second;\n    for (auto j : indexes) {\n      wasm.table.segments[i].data.push_back(getFunctionIndexName(j));\n    }\n  }\n\n  // Everything now has its proper name.\n\n  wasm.updateMaps();\n}"", ""target"": 0}, {""func_name"": ""SExpressionWasmBuilder::parseGlobal"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseGlobal(Element& s, bool preParseImport) {\n  std::unique_ptr<Global> global = make_unique<Global>();\n  size_t i = 1;\n  if (s[i]->dollared() && !(s[i]->isStr() && isType(s[i]->str()))) {\n    global->name = s[i++]->str();\n  } else {\n    global->name = Name::fromInt(globalCounter);\n  }\n  globalCounter++;\n  globalNames.push_back(global->name);\n  bool mutable_ = false;\n  Type type = none;\n  bool exported = false;\n  Name importModule, importBase;\n  while (i < s.size() && s[i]->isList()) {\n    auto& inner = *s[i];\n    if (inner[0]->str() == EXPORT) {\n      auto ex = make_unique<Export>();\n      ex->name = inner[1]->str();\n      ex->value = global->name;\n      ex->kind = ExternalKind::Global;\n      if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n      wasm.addExport(ex.release());\n      exported = true;\n      i++;\n    } else if (inner[0]->str() == IMPORT) {\n      importModule = inner[1]->str();\n      importBase = inner[2]->str();\n      i++;\n    } else if (inner[0]->str() == MUT) {\n      mutable_ = true;\n      type = stringToType(inner[1]->str());\n      i++;\n    } else {\n      break;\n    }\n  }\n  if (exported && mutable_) throw ParseException(\""cannot export a mutable global\"", s.line, s.col);\n  if (type == none) {\n    type = stringToType(s[i++]->str());\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!preParseImport) throw ParseException(\""!preParseImport in global\"");\n    auto im = make_unique<Global>();\n    im->name = global->name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    im->mutable_ = mutable_;\n    if (wasm.getGlobalOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addGlobal(im.release());\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in global\"");\n  global->type = type;\n  if (i < s.size()) {\n    global->init = parseExpression(s[i++]);\n  } else {\n    throw ParseException(\""global without init\"", s.line, s.col);\n  }\n  global->mutable_ = mutable_;\n  if (i != s.size()) throw ParseException(\""extra import elements\"");\n  if (wasm.getGlobalOrNull(global->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n  wasm.addGlobal(global.release());\n}"", ""target"": 0}, {""func_name"": ""SExpressionWasmBuilder::parseImport"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseImport(Element& s) {\n  size_t i = 1;\n  bool newStyle = s.size() == 4 && s[3]->isList(); // (import \""env\"" \""STACKTOP\"" (global $stackTop i32))\n  auto kind = ExternalKind::Invalid;\n  if (newStyle) {\n    if ((*s[3])[0]->str() == FUNC) {\n      kind = ExternalKind::Function;\n    } else if ((*s[3])[0]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n      if (wasm.memory.exists) throw ParseException(\""more than one memory\"");\n      wasm.memory.exists = true;\n    } else if ((*s[3])[0]->str() == TABLE) {\n      kind = ExternalKind::Table;\n      if (wasm.table.exists) throw ParseException(\""more than one table\"");\n      wasm.table.exists = true;\n    } else if ((*s[3])[0]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      newStyle = false; // either (param..) or (result..)\n    }\n  }\n  Index newStyleInner = 1;\n  Name name;\n  if (s.size() > 3 && s[3]->isStr()) {\n    name = s[i++]->str();\n  } else if (newStyle && newStyleInner < s[3]->size() && (*s[3])[newStyleInner]->dollared()) {\n    name = (*s[3])[newStyleInner++]->str();\n  }\n  if (!name.is()) {\n    if (kind == ExternalKind::Function) {\n      name = Name(\""import$function$\"" + std::to_string(functionCounter++));\n      functionNames.push_back(name);\n    } else if (kind == ExternalKind::Global) {\n      name = Name(\""import$global\"" + std::to_string(globalCounter++));\n      globalNames.push_back(name);\n    } else if (kind == ExternalKind::Memory) {\n      name = Name(\""import$memory$\"" + std::to_string(0));\n    } else if (kind == ExternalKind::Table) {\n      name = Name(\""import$table$\"" + std::to_string(0));\n    } else {\n      throw ParseException(\""invalid import\"");\n    }\n  }\n  if (!s[i]->quoted()) {\n    if (s[i]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n    } else if (s[i]->str() == TABLE) {\n      kind = ExternalKind::Table;\n    } else if (s[i]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      throw ParseException(\""invalid ext import\"");\n    }\n    i++;\n  } else if (!newStyle) {\n    kind = ExternalKind::Function;\n  }\n  auto module = s[i++]->str();\n  if (!s[i]->isStr()) throw ParseException(\""no name for import\"");\n  auto base = s[i++]->str();\n  // parse internals\n  Element& inner = newStyle ? *s[3] : s;\n  Index j = newStyle ? newStyleInner : i;\n  if (kind == ExternalKind::Function) {\n    std::unique_ptr<FunctionType> type = make_unique<FunctionType>();\n    if (inner.size() > j) {\n      Element& params = *inner[j];\n      IString id = params[0]->str();\n      if (id == PARAM) {\n        for (size_t k = 1; k < params.size(); k++) {\n          type->params.push_back(stringToType(params[k]->str()));\n        }\n      } else if (id == RESULT) {\n        type->result = stringToType(params[1]->str());\n      } else if (id == TYPE) {\n        IString name = params[1]->str();\n        if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""bad function type for import\"");\n        *type = *wasm.getFunctionType(name);\n      } else {\n        throw ParseException(\""bad import element\"");\n      }\n      if (inner.size() > j+1) {\n        Element& result = *inner[j+1];\n        if (result[0]->str() != RESULT) throw ParseException(\""expected result\"");\n        type->result = stringToType(result[1]->str());\n      }\n    }\n    auto func = make_unique<Function>();\n    func->name = name;\n    func->module = module;\n    func->base = base;\n    auto* functionType = ensureFunctionType(getSig(type.get()), &wasm);\n    func->type = functionType->name;\n    FunctionTypeUtils::fillFunction(func.get(), functionType);\n    functionTypes[name] = func->result;\n    wasm.addFunction(func.release());\n  } else if (kind == ExternalKind::Global) {\n    Type type;\n    bool mutable_ = false;\n    if (inner[j]->isStr()) {\n      type = stringToType(inner[j]->str());\n    } else {\n      auto& inner2 = *inner[j];\n      if (inner2[0]->str() != MUT) throw ParseException(\""expected mut\"");\n      type = stringToType(inner2[1]->str());\n      mutable_ = true;\n    }\n    auto global = make_unique<Global>();\n    global->name = name;\n    global->module = module;\n    global->base = base;\n    global->type = type;\n    global->mutable_ = mutable_;\n    wasm.addGlobal(global.release());\n  } else if (kind == ExternalKind::Table) {\n    wasm.table.module = module;\n    wasm.table.base = base;\n    if (j < inner.size() - 1) {\n      wasm.table.initial = getCheckedAddress(inner[j++], \""excessive table init size\"");\n    }\n    if (j < inner.size() - 1) {\n      wasm.table.max = getCheckedAddress(inner[j++], \""excessive table max size\"");\n    } else {\n      wasm.table.max = Table::kUnlimitedSize;\n    }\n    // ends with the table element type\n  } else if (kind == ExternalKind::Memory) {\n    wasm.memory.module = module;\n    wasm.memory.base = base;\n    if (inner[j]->isList()) {\n      auto& limits = *inner[j];\n      if (!(limits[0]->isStr() && limits[0]->str() == \""shared\"")) throw ParseException(\""bad memory limit declaration\"");\n      wasm.memory.shared = true;\n      parseMemoryLimits(limits, 1);\n    } else {\n      parseMemoryLimits(inner, j);\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""SExpressionWasmBuilder::parseFunction"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseFunction(Element& s, bool preParseImport) {\n  size_t i = 1;\n  Name name, exportName;\n  i = parseFunctionNames(s, name, exportName);\n  if (!preParseImport) {\n    if (!name.is()) {\n      // unnamed, use an index\n      name = Name::fromInt(functionCounter);\n    }\n    functionCounter++;\n  } else {\n    // just preparsing, functionCounter was incremented by preParseFunctionType\n    if (!name.is()) {\n      // unnamed, use an index\n      name = functionNames[functionCounter - 1];\n    }\n  }\n  if (exportName.is()) {\n    auto ex = make_unique<Export>();\n    ex->name = exportName;\n    ex->value = name;\n    ex->kind = ExternalKind::Function;\n    if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n    wasm.addExport(ex.release());\n  }\n  Expression* body = nullptr;\n  localIndex = 0;\n  otherIndex = 0;\n  brokeToAutoBlock = false;\n  std::vector<NameType> typeParams; // we may have both params and a type. store the type info here\n  std::vector<NameType> params;\n  std::vector<NameType> vars;\n  Type result = none;\n  Name type;\n  Block* autoBlock = nullptr; // we may need to add a block for the very top level\n  Name importModule, importBase;\n  auto makeFunction = [&]() {\n    currFunction = std::unique_ptr<Function>(Builder(wasm).makeFunction(\n        name,\n        std::move(params),\n        result,\n        std::move(vars)\n    ));\n  };\n  auto ensureAutoBlock = [&]() {\n    if (!autoBlock) {\n      autoBlock = allocator.alloc<Block>();\n      autoBlock->list.push_back(body);\n      body = autoBlock;\n    }\n  };\n  for (;i < s.size(); i++) {\n    Element& curr = *s[i];\n    IString id = curr[0]->str();\n    if (id == PARAM || id == LOCAL) {\n      size_t j = 1;\n      while (j < curr.size()) {\n        IString name;\n        Type type = none;\n        if (!curr[j]->dollared()) { // dollared input symbols cannot be types\n          type = stringToType(curr[j]->str(), true);\n        }\n        if (type != none) {\n          // a type, so an unnamed parameter\n          name = Name::fromInt(localIndex);\n        } else {\n          name = curr[j]->str();\n          type = stringToType(curr[j+1]->str());\n          j++;\n        }\n        j++;\n        if (id == PARAM) {\n          params.emplace_back(name, type);\n        } else {\n          vars.emplace_back(name, type);\n        }\n        localIndex++;\n        currLocalTypes[name] = type;\n      }\n    } else if (id == RESULT) {\n      if (curr.size() > 2) throw ParseException(\""invalid result arity\"", curr.line, curr.col);\n      result = stringToType(curr[1]->str());\n    } else if (id == TYPE) {\n      Name name = getFunctionTypeName(*curr[1]);\n      type = name;\n      if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""unknown function type\"");\n      FunctionType* type = wasm.getFunctionType(name);\n      result = type->result;\n      for (size_t j = 0; j < type->params.size(); j++) {\n        IString name = Name::fromInt(j);\n        Type currType = type->params[j];\n        typeParams.emplace_back(name, currType);\n        currLocalTypes[name] = currType;\n      }\n    } else if (id == IMPORT) {\n      importModule = curr[1]->str();\n      importBase = curr[2]->str();\n    } else {\n      // body\n      if (typeParams.size() > 0 && params.size() == 0) {\n        params = typeParams;\n      }\n      if (!currFunction) makeFunction();\n      Expression* ex = parseExpression(curr);\n      if (!body) {\n        body = ex;\n      } else {\n        ensureAutoBlock();\n        autoBlock->list.push_back(ex);\n      }\n    }\n  }\n  // see https://github.com/WebAssembly/spec/pull/301\n  if (type.isNull()) {\n    // if no function type name provided, then we generated one\n    auto functionType = make_unique<FunctionType>(sigToFunctionType(getSigFromStructs(result, params)));\n    for (auto& existing : wasm.functionTypes) {\n      if (existing->structuralComparison(*functionType)) {\n        type = existing->name;\n        break;\n      }\n    }\n    if (!type.is()) throw ParseException(\""no function type [internal error?]\"", s.line, s.col);\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!preParseImport) throw ParseException(\""!preParseImport in func\"");\n    auto im = make_unique<Function>();\n    im->name = name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    FunctionTypeUtils::fillFunction(im.get(), wasm.getFunctionType(type));\n    functionTypes[name] = im->result;\n    if (wasm.getFunctionOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addFunction(im.release());\n    if (currFunction) throw ParseException(\""import module inside function dec\"");\n    currLocalTypes.clear();\n    nameMapper.clear();\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in func\"");\n  if (brokeToAutoBlock) {\n    ensureAutoBlock();\n    autoBlock->name = FAKE_RETURN;\n  }\n  if (autoBlock) {\n    autoBlock->finalize(result);\n  }\n  if (!currFunction) {\n    makeFunction();\n    body = allocator.alloc<Nop>();\n  }\n  if (currFunction->result != result) throw ParseException(\""bad func declaration\"", s.line, s.col);\n  currFunction->body = body;\n  currFunction->type = type;\n  if (s.startLoc) {\n    currFunction->prologLocation.insert(getDebugLocation(*s.startLoc));\n  }\n  if (s.endLoc) {\n    currFunction->epilogLocation.insert(getDebugLocation(*s.endLoc));\n  }\n  if (wasm.getFunctionOrNull(currFunction->name)) throw ParseException(\""duplicate function\"", s.line, s.col);\n  wasm.addFunction(currFunction.release());\n  currLocalTypes.clear();\n  nameMapper.clear();\n}"", ""target"": 0}]","[{""func_name"": ""printAst"", ""file_path"": ""src/emscripten-optimizer/simple_ast.h"", ""func_code"": ""void printAst() {\n    print(ast);\n    ensure(1);\n    buffer[used] = 0;\n  }""}, {""func_name"": ""WasmBinaryBuilder::processFunctions"", ""file_path"": ""src/wasm/wasm-binary.cpp"", ""func_code"": ""void WasmBinaryBuilder::processFunctions() {\n  for (auto* func : functions) {\n    wasm.addFunction(func);\n  }\n\n  // now that we have names for each function, apply things\n\n  if (startIndex != static_cast<Index>(-1)) {\n    wasm.start = getFunctionIndexName(startIndex);\n  }\n\n  for (auto* curr : exportOrder) {\n    auto index = exportIndexes[curr];\n    switch (curr->kind) {\n      case ExternalKind::Function: {\n        if (index >= wasm.functions.size()) {\n          throwError(\""bad function export index\"");\n        }\n        curr->value = getFunctionIndexName(index);\n        break;\n      }\n      case ExternalKind::Table: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Memory: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Global: curr->value = getGlobalName(index); break;\n      default: throwError(\""bad export kind\"");\n    }\n    wasm.addExport(curr);\n  }\n\n  for (auto& iter : functionCalls) {\n    size_t index = iter.first;\n    auto& calls = iter.second;\n    for (auto* call : calls) {\n      call->target = getFunctionIndexName(index);\n    }\n  }\n\n  for (auto& pair : functionTable) {\n    auto i = pair.first;\n    auto& indexes = pair.second;\n    for (auto j : indexes) {\n      wasm.table.segments[i].data.push_back(getFunctionIndexName(j));\n    }\n  }\n\n  // Everything now has its proper name.\n\n  wasm.updateMaps();\n}""}, {""func_name"": ""SExpressionWasmBuilder::parseGlobal"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseGlobal(Element& s, bool preParseImport) {\n  std::unique_ptr<Global> global = make_unique<Global>();\n  size_t i = 1;\n  if (s[i]->dollared() && !(s[i]->isStr() && isType(s[i]->str()))) {\n    global->name = s[i++]->str();\n  } else {\n    global->name = Name::fromInt(globalCounter);\n  }\n  globalCounter++;\n  globalNames.push_back(global->name);\n  bool mutable_ = false;\n  Type type = none;\n  bool exported = false;\n  Name importModule, importBase;\n  while (i < s.size() && s[i]->isList()) {\n    auto& inner = *s[i];\n    if (inner[0]->str() == EXPORT) {\n      auto ex = make_unique<Export>();\n      ex->name = inner[1]->str();\n      ex->value = global->name;\n      ex->kind = ExternalKind::Global;\n      if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n      wasm.addExport(ex.release());\n      exported = true;\n      i++;\n    } else if (inner[0]->str() == IMPORT) {\n      importModule = inner[1]->str();\n      importBase = inner[2]->str();\n      i++;\n    } else if (inner[0]->str() == MUT) {\n      mutable_ = true;\n      type = stringToType(inner[1]->str());\n      i++;\n    } else {\n      break;\n    }\n  }\n  if (exported && mutable_) throw ParseException(\""cannot export a mutable global\"", s.line, s.col);\n  if (type == none) {\n    type = stringToType(s[i++]->str());\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!importBase.size()) throw ParseException(\""module but no base for import\"");\n    if (!preParseImport) throw ParseException(\""!preParseImport in global\"");\n    auto im = make_unique<Global>();\n    im->name = global->name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    im->mutable_ = mutable_;\n    if (wasm.getGlobalOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addGlobal(im.release());\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in global\"");\n  global->type = type;\n  if (i < s.size()) {\n    global->init = parseExpression(s[i++]);\n  } else {\n    throw ParseException(\""global without init\"", s.line, s.col);\n  }\n  global->mutable_ = mutable_;\n  if (i != s.size()) throw ParseException(\""extra import elements\"");\n  if (wasm.getGlobalOrNull(global->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n  wasm.addGlobal(global.release());\n}""}, {""func_name"": ""SExpressionWasmBuilder::parseImport"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseImport(Element& s) {\n  size_t i = 1;\n  bool newStyle = s.size() == 4 && s[3]->isList(); // (import \""env\"" \""STACKTOP\"" (global $stackTop i32))\n  auto kind = ExternalKind::Invalid;\n  if (newStyle) {\n    if ((*s[3])[0]->str() == FUNC) {\n      kind = ExternalKind::Function;\n    } else if ((*s[3])[0]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n      if (wasm.memory.exists) throw ParseException(\""more than one memory\"");\n      wasm.memory.exists = true;\n    } else if ((*s[3])[0]->str() == TABLE) {\n      kind = ExternalKind::Table;\n      if (wasm.table.exists) throw ParseException(\""more than one table\"");\n      wasm.table.exists = true;\n    } else if ((*s[3])[0]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      newStyle = false; // either (param..) or (result..)\n    }\n  }\n  Index newStyleInner = 1;\n  Name name;\n  if (s.size() > 3 && s[3]->isStr()) {\n    name = s[i++]->str();\n  } else if (newStyle && newStyleInner < s[3]->size() && (*s[3])[newStyleInner]->dollared()) {\n    name = (*s[3])[newStyleInner++]->str();\n  }\n  if (!name.is()) {\n    if (kind == ExternalKind::Function) {\n      name = Name(\""import$function$\"" + std::to_string(functionCounter++));\n      functionNames.push_back(name);\n    } else if (kind == ExternalKind::Global) {\n      name = Name(\""import$global\"" + std::to_string(globalCounter++));\n      globalNames.push_back(name);\n    } else if (kind == ExternalKind::Memory) {\n      name = Name(\""import$memory$\"" + std::to_string(0));\n    } else if (kind == ExternalKind::Table) {\n      name = Name(\""import$table$\"" + std::to_string(0));\n    } else {\n      throw ParseException(\""invalid import\"");\n    }\n  }\n  if (!s[i]->quoted()) {\n    if (s[i]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n    } else if (s[i]->str() == TABLE) {\n      kind = ExternalKind::Table;\n    } else if (s[i]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      throw ParseException(\""invalid ext import\"");\n    }\n    i++;\n  } else if (!newStyle) {\n    kind = ExternalKind::Function;\n  }\n  auto module = s[i++]->str();\n  if (!s[i]->isStr()) throw ParseException(\""no name for import\"");\n  auto base = s[i++]->str();\n  if (!module.size() || !base.size()) throw ParseException(\""imports must have module and base\"");\n  // parse internals\n  Element& inner = newStyle ? *s[3] : s;\n  Index j = newStyle ? newStyleInner : i;\n  if (kind == ExternalKind::Function) {\n    std::unique_ptr<FunctionType> type = make_unique<FunctionType>();\n    if (inner.size() > j) {\n      Element& params = *inner[j];\n      IString id = params[0]->str();\n      if (id == PARAM) {\n        for (size_t k = 1; k < params.size(); k++) {\n          type->params.push_back(stringToType(params[k]->str()));\n        }\n      } else if (id == RESULT) {\n        type->result = stringToType(params[1]->str());\n      } else if (id == TYPE) {\n        IString name = params[1]->str();\n        if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""bad function type for import\"");\n        *type = *wasm.getFunctionType(name);\n      } else {\n        throw ParseException(\""bad import element\"");\n      }\n      if (inner.size() > j+1) {\n        Element& result = *inner[j+1];\n        if (result[0]->str() != RESULT) throw ParseException(\""expected result\"");\n        type->result = stringToType(result[1]->str());\n      }\n    }\n    auto func = make_unique<Function>();\n    func->name = name;\n    func->module = module;\n    func->base = base;\n    auto* functionType = ensureFunctionType(getSig(type.get()), &wasm);\n    func->type = functionType->name;\n    FunctionTypeUtils::fillFunction(func.get(), functionType);\n    functionTypes[name] = func->result;\n    wasm.addFunction(func.release());\n  } else if (kind == ExternalKind::Global) {\n    Type type;\n    bool mutable_ = false;\n    if (inner[j]->isStr()) {\n      type = stringToType(inner[j]->str());\n    } else {\n      auto& inner2 = *inner[j];\n      if (inner2[0]->str() != MUT) throw ParseException(\""expected mut\"");\n      type = stringToType(inner2[1]->str());\n      mutable_ = true;\n    }\n    auto global = make_unique<Global>();\n    global->name = name;\n    global->module = module;\n    global->base = base;\n    global->type = type;\n    global->mutable_ = mutable_;\n    wasm.addGlobal(global.release());\n  } else if (kind == ExternalKind::Table) {\n    wasm.table.module = module;\n    wasm.table.base = base;\n    if (j < inner.size() - 1) {\n      wasm.table.initial = getCheckedAddress(inner[j++], \""excessive table init size\"");\n    }\n    if (j < inner.size() - 1) {\n      wasm.table.max = getCheckedAddress(inner[j++], \""excessive table max size\"");\n    } else {\n      wasm.table.max = Table::kUnlimitedSize;\n    }\n    // ends with the table element type\n  } else if (kind == ExternalKind::Memory) {\n    wasm.memory.module = module;\n    wasm.memory.base = base;\n    if (inner[j]->isList()) {\n      auto& limits = *inner[j];\n      if (!(limits[0]->isStr() && limits[0]->str() == \""shared\"")) throw ParseException(\""bad memory limit declaration\"");\n      wasm.memory.shared = true;\n      parseMemoryLimits(limits, 1);\n    } else {\n      parseMemoryLimits(inner, j);\n    }\n  }\n}""}, {""func_name"": ""SExpressionWasmBuilder::parseFunction"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseFunction(Element& s, bool preParseImport) {\n  size_t i = 1;\n  Name name, exportName;\n  i = parseFunctionNames(s, name, exportName);\n  if (!preParseImport) {\n    if (!name.is()) {\n      // unnamed, use an index\n      name = Name::fromInt(functionCounter);\n    }\n    functionCounter++;\n  } else {\n    // just preparsing, functionCounter was incremented by preParseFunctionType\n    if (!name.is()) {\n      // unnamed, use an index\n      name = functionNames[functionCounter - 1];\n    }\n  }\n  if (exportName.is()) {\n    auto ex = make_unique<Export>();\n    ex->name = exportName;\n    ex->value = name;\n    ex->kind = ExternalKind::Function;\n    if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n    wasm.addExport(ex.release());\n  }\n  Expression* body = nullptr;\n  localIndex = 0;\n  otherIndex = 0;\n  brokeToAutoBlock = false;\n  std::vector<NameType> typeParams; // we may have both params and a type. store the type info here\n  std::vector<NameType> params;\n  std::vector<NameType> vars;\n  Type result = none;\n  Name type;\n  Block* autoBlock = nullptr; // we may need to add a block for the very top level\n  Name importModule, importBase;\n  auto makeFunction = [&]() {\n    currFunction = std::unique_ptr<Function>(Builder(wasm).makeFunction(\n        name,\n        std::move(params),\n        result,\n        std::move(vars)\n    ));\n  };\n  auto ensureAutoBlock = [&]() {\n    if (!autoBlock) {\n      autoBlock = allocator.alloc<Block>();\n      autoBlock->list.push_back(body);\n      body = autoBlock;\n    }\n  };\n  for (;i < s.size(); i++) {\n    Element& curr = *s[i];\n    IString id = curr[0]->str();\n    if (id == PARAM || id == LOCAL) {\n      size_t j = 1;\n      while (j < curr.size()) {\n        IString name;\n        Type type = none;\n        if (!curr[j]->dollared()) { // dollared input symbols cannot be types\n          type = stringToType(curr[j]->str(), true);\n        }\n        if (type != none) {\n          // a type, so an unnamed parameter\n          name = Name::fromInt(localIndex);\n        } else {\n          name = curr[j]->str();\n          type = stringToType(curr[j+1]->str());\n          j++;\n        }\n        j++;\n        if (id == PARAM) {\n          params.emplace_back(name, type);\n        } else {\n          vars.emplace_back(name, type);\n        }\n        localIndex++;\n        currLocalTypes[name] = type;\n      }\n    } else if (id == RESULT) {\n      if (curr.size() > 2) throw ParseException(\""invalid result arity\"", curr.line, curr.col);\n      result = stringToType(curr[1]->str());\n    } else if (id == TYPE) {\n      Name name = getFunctionTypeName(*curr[1]);\n      type = name;\n      if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""unknown function type\"");\n      FunctionType* type = wasm.getFunctionType(name);\n      result = type->result;\n      for (size_t j = 0; j < type->params.size(); j++) {\n        IString name = Name::fromInt(j);\n        Type currType = type->params[j];\n        typeParams.emplace_back(name, currType);\n        currLocalTypes[name] = currType;\n      }\n    } else if (id == IMPORT) {\n      importModule = curr[1]->str();\n      importBase = curr[2]->str();\n    } else {\n      // body\n      if (typeParams.size() > 0 && params.size() == 0) {\n        params = typeParams;\n      }\n      if (!currFunction) makeFunction();\n      Expression* ex = parseExpression(curr);\n      if (!body) {\n        body = ex;\n      } else {\n        ensureAutoBlock();\n        autoBlock->list.push_back(ex);\n      }\n    }\n  }\n  // see https://github.com/WebAssembly/spec/pull/301\n  if (type.isNull()) {\n    // if no function type name provided, then we generated one\n    auto functionType = make_unique<FunctionType>(sigToFunctionType(getSigFromStructs(result, params)));\n    for (auto& existing : wasm.functionTypes) {\n      if (existing->structuralComparison(*functionType)) {\n        type = existing->name;\n        break;\n      }\n    }\n    if (!type.is()) throw ParseException(\""no function type [internal error?]\"", s.line, s.col);\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!importBase.size()) throw ParseException(\""module but no base for import\"");\n    if (!preParseImport) throw ParseException(\""!preParseImport in func\"");\n    auto im = make_unique<Function>();\n    im->name = name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    FunctionTypeUtils::fillFunction(im.get(), wasm.getFunctionType(type));\n    functionTypes[name] = im->result;\n    if (wasm.getFunctionOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addFunction(im.release());\n    if (currFunction) throw ParseException(\""import module inside function dec\"");\n    currLocalTypes.clear();\n    nameMapper.clear();\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in func\"");\n  if (brokeToAutoBlock) {\n    ensureAutoBlock();\n    autoBlock->name = FAKE_RETURN;\n  }\n  if (autoBlock) {\n    autoBlock->finalize(result);\n  }\n  if (!currFunction) {\n    makeFunction();\n    body = allocator.alloc<Nop>();\n  }\n  if (currFunction->result != result) throw ParseException(\""bad func declaration\"", s.line, s.col);\n  currFunction->body = body;\n  currFunction->type = type;\n  if (s.startLoc) {\n    currFunction->prologLocation.insert(getDebugLocation(*s.startLoc));\n  }\n  if (s.endLoc) {\n    currFunction->epilogLocation.insert(getDebugLocation(*s.endLoc));\n  }\n  if (wasm.getFunctionOrNull(currFunction->name)) throw ParseException(\""duplicate function\"", s.line, s.col);\n  wasm.addFunction(currFunction.release());\n  currLocalTypes.clear();\n  nameMapper.clear();\n}""}]","{""code"": 2, ""value"": 1, ""function"": 1}","[{""source"": ""code_info(file:wasm-binary.cpp, lines:1490-1510)"", ""result"": ""  return mappedGlobals[index];\n}\n\nvoid WasmBinaryBuilder::processFunctions() {\n  for (auto* func : functions) {\n    wasm.addFunction(func);\n  }\n\n  // now that we have names for each function, apply things\n\n  if (startIndex != static_cast<Index>(-1)) {\n    wasm.start = getFunctionIndexName(startIndex);\n  }\n\n  for (auto* curr : exportOrder) {\n    auto index = exportIndexes[curr];\n    switch (curr->kind) {\n      case ExternalKind::Function: {\n        curr->value = getFunctionIndexName(index);\n        break;\n      }\n      case ExternalKind::Table: curr->value = Name::fromInt(0); break;\n""}, {""source"": ""value_info(file:wasm-binary.cpp, value:exportIndexes)"", ""result"": {""value_trace"": [{""full_code"": ""exportIndexes[curr] = index"", ""line"": 1160, ""func_name"": ""wasm.WasmBinaryBuilder.readExports:void()""}], ""struct_var"": ""exportIndexes"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:wasm-binary.cpp, lines:1150-1170)"", ""result"": ""  for (size_t i = 0; i < num; i++) {\n    if (debug) std::cerr << \""read one\"" << std::endl;\n    auto curr = new Export;\n    curr->name = getInlineString();\n    if (names.count(curr->name) > 0) {\n      throwError(\""duplicate export name\"");\n    }\n    names.insert(curr->name);\n    curr->kind = (ExternalKind)getU32LEB();\n    auto index = getU32LEB();\n    exportIndexes[curr] = index;\n    exportOrder.push_back(curr);\n  }\n}\n\nstatic int32_t readBase64VLQ(std::istream& in) {\n  uint32_t value = 0;\n  uint32_t shift = 0;\n  while (1) {\n    auto ch = in.get();\n    if (ch == EOF)\n      throw MapParseException(\""unexpected EOF in the middle of VLQ\"");\n""}, {""source"": ""func_info(file:wasm-binary.cpp, func:getU32LEB)"", ""result"": [{""code"": ""uint32_t WasmBinaryBuilder::getU32LEB() {\n  if (debug) std::cerr << \""<==\"" << std::endl;\n  U32LEB ret;\n  ret.read([&]() {\n      return getInt8();\n    });\n  if (debug) std::cerr << \""getU32LEB: \"" << ret.value << \"" ==>\"" << std::endl;\n  return ret.value;\n}"", ""start_line"": 800, ""end_line"": 808, ""full_name"": ""wasm.WasmBinaryBuilder.getU32LEB:uint32_t()"", ""file_path"": ""src/wasm/wasm-binary.cpp""}]}]","The vulnerability arises from unvalidated index values read during WebAssembly export parsing. Specifically:\n1. Export indexes are read via `getU32LEB()` (wasm-binary.cpp:1160) without bounds checking against `wasm.functions.size()`.\n2. These indexes are stored in `exportIndexes` and later used in `processFunctions()` (wasm-binary.cpp:1506) to call `getFunctionIndexName()`, causing a NULL dereference if out-of-bounds.\n3. The patch added a bounds check in `processFunctions()` but did not address input validation during parsing.",0.95,./github/other_context/CVE-2019-7153
30,CVE-2020-14396,CWE-476,c_cpp,An issue was discovered in LibVNCServer before 0.9.13. libvncclient/tls_openssl.c has a NULL pointer dereference.,https://github.com/LibVNC/libvncserver/commit/33441d90a506d5f3ae9388f2752901227e430553,libvncclient/tls_openssl: do not deref a NULL pointer\n\nHappens in anonTLS mode where cred is NULL.\n\nre #347,1,"[{""func_name"": ""open_ssl_connection"", ""file_path"": ""libvncclient/tls_openssl.c"", ""func_code"": ""static SSL *\nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\""Could not create new SSL context.\\n\"");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\""Failed to load CA certificate from %s.\\n\"",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\""Using default paths for certificate verification.\\n\"");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\""CRLs could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\""Client certificate could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\""Client private key could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\""Client certificate and private key do not match.\\n\"");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\""Could not set server name for verification.\\n\"");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\""Could not create a new SSL session.\\n\"");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \""ALL\"");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}"", ""target"": 0}]","[{""func_name"": ""open_ssl_connection"", ""file_path"": ""libvncclient/tls_openssl.c"", ""func_code"": ""static SSL *\nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\""Could not create new SSL context.\\n\"");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    verify_crls = cred->x509Credential.x509CrlVerifyMode;\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\""Failed to load CA certificate from %s.\\n\"",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\""Using default paths for certificate verification.\\n\"");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\""CRLs could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\""Client certificate could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\""Client private key could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\""Client certificate and private key do not match.\\n\"");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\""Could not set server name for verification.\\n\"");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\""Could not create a new SSL session.\\n\"");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \""ALL\"");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}""}]","{""value"": 2, ""code"": 1}","[{""source"": ""value_info(file:tls_openssl.c, value:anonTLS)"", ""result"": {""value_trace"": [{""full_code"": ""anonTLS = TRUE"", ""line"": 577, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}, {""full_code"": ""anonTLS = FALSE"", ""line"": 580, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}], ""struct_var"": ""anonTLS"", ""struct_type"": ""rfbBool"", ""struct_definition"": ""static rfbBool\n\nstatic rfbBool\n\nstatic rfbBool\n\nstatic rfbBool\n\nstatic rfbBool\n\ntypedef int8_t rfbBool;\n\ntypedef int8_t rfbBool;""}}, {""source"": ""value_info(file:tls_openssl.c, value:cred)"", ""result"": {""value_trace"": [{""full_code"": ""*cred = NULL"", ""line"": 528, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}, {""full_code"": ""cred = client->GetCredential(client, rfbCredentialTypeX509)"", ""line"": 593, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}], ""struct_var"": ""cred"", ""struct_type"": ""rfbCredential*"", ""struct_definition"": ""typedef union _rfbCredential\n{\n  /** X509 (VeNCrypt) */\n  struct\n  {\n    char *x509CACertFile;\n    char *x509CACrlFile;\n    char *x509ClientCertFile;\n    char *x509ClientKeyFile;\n    uint8_t x509CrlVerifyMode; /* Only required for OpenSSL - see meanings below */\n  } x509Credential;\n  /** Plain (VeNCrypt), MSLogon (UltraVNC) */\n  struct\n  {\n    char *username;\n    char *password;\n  } userCredential;\n} rfbCredential;""}}, {""source"": ""code_info(file:tls_openssl.c, lines:577-593)"", ""result"": ""      anonTLS = TRUE;\n      break;\n    default:\n      anonTLS = FALSE;\n      break;\n  }\n\n  /* Get X509 Credentials if it's not anonymous */\n  if (!anonTLS)\n  {\n\n    if (!client->GetCredential)\n    {\n      rfbClientLog(\""GetCredential callback is not set.\\n\"");\n      return FALSE;\n    }\n    cred = client->GetCredential(client, rfbCredentialTypeX509);\n    if (!cred)\n""}]","libvncclient/tls_openssl.c:269-282: Original code dereferences 'cred->x509Credential.x509CrlVerifyMode' outside the 'if (!anonTLS)' block. When 'anonTLS' is TRUE (set in HandleVeNCryptAuth:577/580), 'cred' remains NULL (initialized to NULL in tls_openssl.c:528) and is not reassigned (confirmed in HandleVeNCryptAuth:577-593, where 'cred = client->GetCredential(...)' is skipped in 'anonTLS' mode). This leads to a NULL pointer dereference. The patch moves the dereference inside the 'if (!anonTLS)' block (line 282), preventing the issue.",0.95,./github/other_context/CVE-2020-14396
31,CVE-2020-16295,CWE-476,c_cpp,A null pointer dereference vulnerability in clj_media_size() in devices/gdevclj.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.,https://github.com/ArtifexSoftware/ghostpdl/commit/2c2dc335c212750e0fb8ae157063bc06cafa8d3e,"Color Laserjet device - properly check params\n\nBug #701796 ""Segmentation fault at devices/gdevclj.c:269 in clj_media_size""\n\nThe test in clj_media_size() as incorrect, it didn't signal an error if\nthere was no HWResolution in the param list. This left the parameter\n'fres' undefined leading to a potential invalid memory read, or a\ndivide-by-zero error.\n\nThis commit returns an error if we get a param list with no HWResolution\nI'm not absolutely certain if this is correct, but at least signalling\nan error is better than a seg fault.",1,"[{""func_name"": ""clj_media_size"", ""file_path"": ""devices/gdevclj.c"", ""func_code"": ""static int\nclj_media_size(float mediasize[2], gs_param_list *plist)\n{\n    gs_param_float_array fres;\n    gs_param_float_array fsize;\n    gs_param_int_array hwsize;\n    int have_pagesize = 0;\n\n    if ( (param_read_float_array(plist, \""HWResolution\"", &fres) == 0) &&\n          !is_supported_resolution(fres.data) )\n        return_error(gs_error_rangecheck);\n\n    if ( (param_read_float_array(plist, \""PageSize\"", &fsize) == 0) ||\n         (param_read_float_array(plist, \"".MediaSize\"", &fsize) == 0) ) {\n        mediasize[0] = fsize.data[0];\n        mediasize[1] = fsize.data[1];\n        have_pagesize = 1;\n    }\n\n    if (param_read_int_array(plist, \""HWSize\"", &hwsize) == 0) {\n        mediasize[0] = ((float)hwsize.data[0]) * 72 / fres.data[0];\n        mediasize[1] = ((float)hwsize.data[1]) * 72 / fres.data[1];\n        have_pagesize = 1;\n    }\n\n    return have_pagesize;\n}"", ""target"": 0}]","[{""func_name"": ""clj_media_size"", ""file_path"": ""devices/gdevclj.c"", ""func_code"": ""static int\nclj_media_size(float mediasize[2], gs_param_list *plist)\n{\n    gs_param_float_array fres;\n    gs_param_float_array fsize;\n    gs_param_int_array hwsize;\n    int have_pagesize = 0;\n\n    if ( param_read_float_array(plist, \""HWResolution\"", &fres) != 0 ||\n          !is_supported_resolution(fres.data) )\n        return_error(gs_error_rangecheck);\n\n    if ( (param_read_float_array(plist, \""PageSize\"", &fsize) == 0) ||\n         (param_read_float_array(plist, \"".MediaSize\"", &fsize) == 0) ) {\n        mediasize[0] = fsize.data[0];\n        mediasize[1] = fsize.data[1];\n        have_pagesize = 1;\n    }\n\n    if (param_read_int_array(plist, \""HWSize\"", &hwsize) == 0) {\n        mediasize[0] = ((float)hwsize.data[0]) * 72 / fres.data[0];\n        mediasize[1] = ((float)hwsize.data[1]) * 72 / fres.data[1];\n        have_pagesize = 1;\n    }\n\n    return have_pagesize;\n}""}]","{""function"": 1, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(func:param_read_float_array)"", ""result"": [{""code"": ""int\nparam_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                       gs_param_float_array * pvalue)\n{\n    RETURN_READ_TYPED(fa, gs_param_type_float_array);\n}"", ""start_line"": 346, ""end_line"": 351, ""full_name"": ""param_read_float_array"", ""file_path"": ""base/gsparam.c""}]}, {""source"": ""code_info(file:gdevclj.c, lines:255-269)"", ""result"": ""    int have_pagesize = 0;\n\n    if ( (param_read_float_array(plist, \""HWResolution\"", &fres) == 0) &&\n          !is_supported_resolution(fres.data) )\n        return_error(gs_error_rangecheck);\n\n    if ( (param_read_float_array(plist, \""PageSize\"", &fsize) == 0) ||\n         (param_read_float_array(plist, \"".MediaSize\"", &fsize) == 0) ) {\n        mediasize[0] = fsize.data[0];\n        mediasize[1] = fsize.data[1];\n        have_pagesize = 1;\n    }\n\n    if (param_read_int_array(plist, \""HWSize\"", &hwsize) == 0) {\n        mediasize[0] = ((float)hwsize.data[0]) * 72 / fres.data[0];\n        mediasize[1] = ((float)hwsize.data[1]) * 72 / fres.data[1];\n""}, {""source"": ""value_info(file:gdevclj.c, value:fres)"", ""result"": {""value_trace"": [{""full_code"": ""pfres->FontType = ftype"", ""line"": 410, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->count = chars_count"", ""line"": 411, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->Widths = widths"", ""line"": 412, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->used = used"", ""line"": 413, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->write_contents = write_contents"", ""line"": 414, ""func_name"": ""font_resource_alloc""}], ""struct_var"": ""fres"", ""struct_type"": ""gs_param_float_array"", ""struct_definition"": ""typedef _param_array_struct(gs_param_float_array_s, float) gs_param_float_array;""}}]","The 'clj_media_size' function in 'devices/gdevclj.c' (lines 255-269) fails to handle the case where 'HWResolution' is missing from the parameter list. The 'param_read_float_array' function (base/gsparam.c:346-351) returns a non-zero error code when 'HWResolution' is absent, leaving 'fres' (a 'gs_param_float_array') uninitialized. Subsequent code uses 'fres.data' in calculations (e.g., '72 / fres.data[0]'), leading to an invalid memory read or divide-by-zero. The patch corrects this by returning an error when 'HWResolution' is missing.",0.95,./github/other_context/CVE-2020-16295
32,CVE-2020-16306,CWE-476,c_cpp,A null pointer dereference vulnerability in devices/gdevtsep.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted postscript file. This is fixed in v9.51.,https://github.com/ArtifexSoftware/ghostpdl/commit/aadb53eb834b3def3ef68d78865ff87a68901804,"Tiffsep and Tiffsep1 - abort on multi-page input wtithout %d OutputFile\n\nBug #701821 ""Segmentation fault at tiff//libtiff/tif_dirinfo.c:513 in TIFFFindField""\n\nThe tiffsep and tiffsep1 only set 'code' to an error when an attempt is\nmade to write a second output file without using %d in the OutputFile\nspecification.\n\nThis causes problems later when attempting to process the files. The\ndevices should exit without trying to further process the pages under\nthese conditions and this commit returns immediately on error.\n\nThe other devices like this already return immediately on error, it\nlooks like the code here was copied between  devices without realising\nthat the tiffsep and tiffsep1 devices didn't exit when the error\ncondition was set.",2,"[{""func_name"": ""tiffsep1_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep1_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep1_device * const tfdev = (tiffsep1_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, code = 0, code1 = 0;\n    short map_comp_to_sep[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n\n        gs_free_object(pdev->memory, compname, \""tiffsep_print_page(compname)\"");\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n    for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n        int sep_num = map_comp_to_sep[comp_num];\n\n        code = create_separation_file_name((tiffsep_device *)tfdev, name,\n                                        gp_file_name_sizeof, sep_num, true);\n        if (code < 0) {\n            goto done;\n        }\n\n        /* Open the separation file, if not already open */\n        if (tfdev->sep_file[comp_num] == NULL) {\n            code = gs_add_outputfile_control_path(tfdev->memory, name);\n            if (code < 0) {\n                goto done;\n            }\n            code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n            if (code < 0) {\n                goto done;\n            }\n            tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                                                    tfdev->sep_file[comp_num],\n                                                    tfdev->BigEndian, tfdev->UseBigTIFF);\n            if (!tfdev->tiff[comp_num]) {\n                code = gs_note_error(gs_error_ioerror);\n                goto done;\n            }\n        }\n\n        pdev->color_info.depth = 8;     /* Create files for 8 bit gray */\n        pdev->color_info.num_components = 1;\n        code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], 1, 0, tfdev->write_datetime);\n        tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], 1, tfdev->Compression, tfdev->MaxStripSize);\n        pdev->color_info.depth = save_depth;\n        pdev->color_info.num_components = save_numcomps;\n        if (code < 0) {\n            goto done;\n        }\n\n    }   /* end initialization of separation files */\n\n\n    {   /* Get the expanded contone line, halftone and write out the dithered separations */\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS];\n        int width = tfdev->width;\n        int raster_plane = bitmap_raster(width * 8);\n        int dithered_raster = ((7 + width) / 8) + ARCH_SIZEOF_LONG;\n        int pixel, y;\n        gs_get_bits_params_t params;\n        gs_int_rect rect;\n        /* the dithered_line is assumed to be 32-bit aligned by the alloc */\n        uint32_t *dithered_line = (uint32_t *)gs_alloc_bytes(pdev->memory, dithered_raster,\n                                \""tiffsep1_print_page\"");\n\n        memset(planes, 0, sizeof(*planes) * GS_CLIENT_COLOR_MAX_COMPONENTS);\n\n        /* Return planar data */\n        params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n             GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n             GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n        params.x_offset = 0;\n        params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n        code = 0;\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                            \""tiffsep1_print_page\"");\n            if (planes[comp_num] == NULL) {\n                code = gs_error_VMerror;\n                break;\n            }\n        }\n\n        if (code < 0 || dithered_line == NULL) {\n            code = gs_note_error(gs_error_VMerror);\n            goto cleanup;\n        }\n\n        for (comp_num = 0; comp_num < num_comp; comp_num++ )\n            TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n\n        rect.p.x = 0;\n        rect.q.x = pdev->width;\n        /* Loop for the lines */\n        for (y = 0; y < pdev->height; ++y) {\n            rect.p.y = y;\n            rect.q.y = y + 1;\n            /* We have to reset the pointers since get_bits_rect will have moved them */\n            for (comp_num = 0; comp_num < num_comp; comp_num++)\n                params.data[comp_num] = planes[comp_num];\n            code = (*dev_proc(pdev, get_bits_rectangle))((gx_device *)pdev, &rect, &params, NULL);\n            if (code < 0)\n                break;\n\n            /* Dither the separation and write it out */\n            for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n\n/***** #define SKIP_HALFTONING_FOR_TIMING *****/ /* uncomment for timing test */\n#ifndef SKIP_HALFTONING_FOR_TIMING\n\n                /*\n                 * Define 32-bit writes by default. Testing shows that while this is more\n                 * complex code, it runs measurably and consistently faster than the more\n                 * obvious 8-bit code. The 8-bit code is kept to help future optimization\n                 * efforts determine what affects tight loop optimization. Subtracting the\n                 * time when halftoning is skipped shows that the 32-bit halftoning is\n                 * 27% faster.\n                 */\n#define USE_32_BIT_WRITES\n                byte *thresh_line_base = tfdev->thresholds[comp_num].dstart +\n                                    ((y % tfdev->thresholds[comp_num].dheight) *\n                                        tfdev->thresholds[comp_num].dwidth) ;\n                byte *thresh_ptr = thresh_line_base;\n                byte *thresh_limit = thresh_ptr + tfdev->thresholds[comp_num].dwidth;\n                byte *src = params.data[comp_num];\n#ifdef USE_32_BIT_WRITES\n                uint32_t *dest = dithered_line;\n                uint32_t val = 0;\n                const uint32_t *mask = &bit_order[0];\n#else   /* example 8-bit code */\n                byte *dest = dithered_line;\n                byte val = 0;\n                byte mask = 0x80;\n#endif /* USE_32_BIT_WRITES */\n\n                for (pixel = 0; pixel < width; pixel++, src++) {\n#ifdef USE_32_BIT_WRITES\n                    if (*src < *thresh_ptr++)\n                        val |= *mask;\n                    if (++mask == &(bit_order[32])) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = &bit_order[0];\n                    }\n#else   /* example 8-bit code */\n                    if (*src < *thresh_ptr++)\n                        val |= mask;\n                    mask >>= 1;\n                    if (mask == 0) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = 0x80;\n                    }\n#endif /* USE_32_BIT_WRITES */\n                    if (thresh_ptr >= thresh_limit)\n                        thresh_ptr = thresh_line_base;\n                } /* end src pixel loop - collect last bits if any */\n                /* the following relies on their being enough 'pad' in dithered_line */\n#ifdef USE_32_BIT_WRITES\n                if (mask != &bit_order[0]) {\n                    *dest = val;\n                }\n#else   /* example 8-bit code */\n                if (mask != 0x80) {\n                    *dest = val;\n                }\n#endif /* USE_32_BIT_WRITES */\n#endif /* SKIP_HALFTONING_FOR_TIMING */\n                TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)dithered_line, y, 0);\n            } /* end component loop */\n        }\n        /* Update the strip data */\n        for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n            TIFFWriteDirectory(tfdev->tiff[comp_num]);\n            if (fmt) {\n                int sep_num = map_comp_to_sep[comp_num];\n\n                code = create_separation_file_name((tiffsep_device *)tfdev, name, gp_file_name_sizeof, sep_num, false);\n                if (code < 0) {\n                    code1 = code;\n                    continue;\n                }\n                code = tiffsep_close_sep_file((tiffsep_device *)tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    code1 = code;\n                }\n            }\n        }\n        code = code1;\n\n        /* free any allocations and exit with code */\ncleanup:\n        gs_free_object(pdev->memory, dithered_line, \""tiffsep1_print_page\"");\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            gs_free_object(pdev->memory, planes[comp_num], \""tiffsep1_print_page\"");\n        }\n    }\n    /*\n     * If we have any non encodable pixels then signal an error.\n     */\n    if (non_encodable_count) {\n        dmlprintf1(pdev->memory, \""WARNING:  Non encodable pixels = %d\\n\"", non_encodable_count);\n        code = gs_note_error(gs_error_rangecheck);\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep1_print_page(name)\"");\n    return code;\n}"", ""target"": 0}, {""func_name"": ""tiffsep_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep_device * const tfdev = (tiffsep_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, sep_num, code = 0, code1 = 0;\n    cmyk_composite_map cmyk_map[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    bool double_f = false;\n    int base_filename_length = length_base_file_name(tfdev, &double_f);\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int plane_count = 0;  /* quiet compiler */\n    int factor = tfdev->downscale.downscale_factor;\n    int mfs = tfdev->downscale.min_feature_size;\n    int dst_bpc = tfdev->BitsPerComponent;\n    gx_downscaler_t ds;\n    int width = gx_downscaler_scale(tfdev->width, factor);\n    int height = gx_downscaler_scale(tfdev->height, factor);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    /* Print the names of the spot colors */\n    if (num_order == 0) {\n        for (sep_num = 0; sep_num < num_spot; sep_num++) {\n            copy_separation_name(tfdev, name,\n                gp_file_name_sizeof - base_filename_length - SUFFIX_SIZE, sep_num, 0);\n            dmlprintf1(pdev->memory, \""%%%%SeparationName: %s\\n\"", name);\n        }\n    }\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* Write the page directory for the CMYK equivalent file. */\n    if (!tfdev->comp_file) {\n        pdev->color_info.depth = dst_bpc*4;        /* Create directory for 32 bit cmyk */\n        if (!tfdev->UseBigTIFF && tfdev->Compression==COMPRESSION_NONE &&\n            height > ((unsigned long) 0xFFFFFFFF - (file ? gp_ftell(file) : 0))/(width*4)) { /* note width is never 0 in print_page */\n            dmprintf(pdev->memory, \""CMYK composite file would be too large! Reduce resolution or enable compression.\\n\"");\n            return_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n        }\n\n        code = gx_device_open_output_file((gx_device *)pdev, pdev->fname, true, true, &(tfdev->comp_file));\n        if (code < 0) {\n            goto done;\n        }\n\n        tfdev->tiff_comp = tiff_from_filep(pdev, pdev->dname, tfdev->comp_file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tiff_comp) {\n            code = gs_note_error(gs_error_invalidfileaccess);\n            goto done;\n        }\n\n    }\n    code = tiff_set_fields_for_printer(pdev, tfdev->tiff_comp, factor, 0, tfdev->write_datetime);\n\n    if (dst_bpc == 1 || dst_bpc == 8) {\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n    }\n    else {\n        /* Catch-all just for safety's sake */\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, COMPRESSION_NONE, tfdev->MaxStripSize);\n    }\n\n    pdev->color_info.depth = save_depth;\n    if (code < 0) {\n        goto done;\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n\n    if (!tfdev->NoSeparationFiles && !num_order && num_comp < num_std_colorants + num_spot) {\n        dmlprintf(pdev->memory, \""Warning: skipping one or more colour separations, see: Devices.htm#TIFF\\n\"");\n    }\n\n    if (!tfdev->NoSeparationFiles) {\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n            code = create_separation_file_name(tfdev, name, gp_file_name_sizeof,\n                sep_num, true);\n            if (code < 0) {\n                goto done;\n            }\n\n            /*\n             * Close the old separation file if we are creating individual files\n             * for each page.\n             */\n            if (tfdev->sep_file[comp_num] != NULL && fmt != NULL) {\n                code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0)\n                    return code;\n            }\n            /* Open the separation file, if not already open */\n            if (tfdev->sep_file[comp_num] == NULL) {\n                code = gs_add_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    goto done;\n                }\n                code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n                if (code < 0) {\n                    goto done;\n                }\n                tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                    tfdev->sep_file[comp_num],\n                    tfdev->BigEndian, tfdev->UseBigTIFF);\n                if (!tfdev->tiff[comp_num]) {\n                    code = gs_note_error(gs_error_ioerror);\n                    goto done;\n                }\n            }\n\n            pdev->color_info.depth = dst_bpc;     /* Create files for 8 bit gray */\n            pdev->color_info.num_components = 1;\n            if (!tfdev->UseBigTIFF && tfdev->Compression == COMPRESSION_NONE &&\n                height * 8 / dst_bpc > ((unsigned long)0xFFFFFFFF - (file ? gp_ftell(file) : 0)) / width) /* note width is never 0 in print_page */\n            {\n                code = gs_note_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n                goto done;\n            }\n\n\n            code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], factor, 0, tfdev->write_datetime);\n            tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n            pdev->color_info.depth = save_depth;\n            pdev->color_info.num_components = save_numcomps;\n            if (code < 0) {\n                goto done;\n            }\n        }\n    }\n\n    build_cmyk_map((gx_device*) tfdev, num_comp, &tfdev->equiv_cmyk_colors, cmyk_map);\n    if (tfdev->PrintSpotCMYK) {\n        code = print_cmyk_equivalent_colors(tfdev, num_comp, cmyk_map);\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    {\n        int raster_plane = bitmap_raster(width * 8);\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS] = { 0 };\n        int cmyk_raster = width * NUM_CMYK_COMPONENTS;\n        int pixel, y;\n        byte * sep_line;\n        int plane_index;\n        int offset_plane = 0;\n\n        sep_line =\n            gs_alloc_bytes(pdev->memory, cmyk_raster, \""tiffsep_print_page\"");\n        if (!sep_line) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        if (!tfdev->NoSeparationFiles)\n            for (comp_num = 0; comp_num < num_comp; comp_num++ )\n                TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n        TIFFCheckpointDirectory(tfdev->tiff_comp);\n\n        /* Write the page data. */\n        {\n            gs_get_bits_params_t params;\n            int byte_width;\n\n            /* Return planar data */\n            params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n                 GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n                 GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n            params.x_offset = 0;\n            params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n            if (num_order > 0) {\n                /* In this case, there was a specification for a separation\n                   color order, which indicates what colorants we will\n                   actually creat individual separation files for.  We need\n                   to allocate for the standard colorants.  This is due to the\n                   fact that even when we specify a single spot colorant, we\n                   still create the composite CMYK output file. */\n                for (comp_num = 0; comp_num < num_std_colorants; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                      \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n                offset_plane = num_std_colorants;\n                /* Now we need to make sure that we do not allocate extra\n                   planes if any of the colorants in the order list are\n                   one of the standard colorant names */\n                plane_index = plane_count = num_std_colorants;\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    int temp_pos;\n\n                    temp_pos = tfdev->devn_params.separation_order_map[comp_num];\n                    if (temp_pos >= num_std_colorants) {\n                        /* We have one that is not a standard colorant name\n                           so allocate a new plane */\n                        planes[plane_count] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                        \""tiffsep_print_page\"");\n                        /* Assign the new plane to the appropriate position */\n                        params.data[plane_index] = planes[plane_count];\n                        if (params.data[plane_index] == NULL) {\n                            code = gs_note_error(gs_error_VMerror);\n                            goto cleanup;\n                        }\n                        plane_count += 1;\n                    } else {\n                        /* Assign params.data with the appropriate std.\n                           colorant plane position */\n                        params.data[plane_index] = planes[temp_pos];\n                    }\n                    plane_index += 1;\n                }\n            } else {\n                /* Sep color order number was not specified so just render all\n                   the  planes that we can */\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                    \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n            }\n            code = gx_downscaler_init_planar_trapped(&ds, (gx_device *)pdev, &params,\n                                                     num_comp, factor, mfs, 8, dst_bpc,\n                                                     tfdev->downscale.trap_w, tfdev->downscale.trap_h,\n                                                     tfdev->downscale.trap_order);\n            if (code < 0)\n                goto cleanup;\n            byte_width = (width * dst_bpc + 7)>>3;\n            for (y = 0; y < height; ++y) {\n                code = gx_downscaler_get_bits_rectangle(&ds, &params, y);\n                if (code < 0)\n                    goto cleanup;\n                /* Write separation data (tiffgray format) */\n                if (!tfdev->NoSeparationFiles) {\n                    for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                        byte *src;\n                        byte *dest = sep_line;\n\n                        if (num_order > 0) {\n                            src = params.data[tfdev->devn_params.separation_order_map[comp_num]];\n                        }\n                        else\n                            src = params.data[comp_num];\n                        for (pixel = 0; pixel < byte_width; pixel++, dest++, src++)\n                            *dest = MAX_COLOR_VALUE - *src;    /* Gray is additive */\n                        TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)sep_line, y, 0);\n                    }\n                }\n                /* Write CMYK equivalent data */\n                switch(dst_bpc)\n                {\n                default:\n                case 8:\n                    build_cmyk_raster_line_fromplanar(&params, sep_line, width,\n                                                      num_comp, cmyk_map, num_order,\n                                                      tfdev);\n                    break;\n                case 4:\n                    build_cmyk_raster_line_fromplanar_4bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 2:\n                    build_cmyk_raster_line_fromplanar_2bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 1:\n                    build_cmyk_raster_line_fromplanar_1bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                }\n                TIFFWriteScanline(tfdev->tiff_comp, (tdata_t)sep_line, y, 0);\n            }\ncleanup:\n            if (num_order > 0) {\n                /* Free up the standard colorants if num_order was set.\n                   In this process, we need to make sure that none of them\n                   were the standard colorants.  plane_count should have\n                   the sum of the std. colorants plus any non-standard\n                   ones listed in separation color order */\n                for (comp_num = 0; comp_num < plane_count; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num],\n                                                    \""tiffsep_print_page\"");\n                }\n            } else {\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num + offset_plane],\n                                                    \""tiffsep_print_page\"");\n                }\n            }\n            gx_downscaler_fin(&ds);\n            gs_free_object(pdev->memory, sep_line, \""tiffsep_print_page\"");\n        }\n        code1 = code;\n        if (!tfdev->NoSeparationFiles) {\n            for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                TIFFWriteDirectory(tfdev->tiff[comp_num]);\n                if (fmt) {\n                    int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n                    code = create_separation_file_name(tfdev, name, gp_file_name_sizeof, sep_num, false);\n                    if (code < 0) {\n                        code1 = code;\n                        continue;\n                    }\n                    code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                    if (code >= 0)\n                        code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                    if (code < 0) {\n                        code1 = code;\n                    }\n                }\n            }\n        }\n        TIFFWriteDirectory(tfdev->tiff_comp);\n        if (fmt) {\n            code = tiffsep_close_comp_file(tfdev, pdev->fname);\n        }\n        if (code1 < 0) {\n            code = code1;\n        }\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep_print_page(name)\"");\n    return code;\n}"", ""target"": 1}]","[{""func_name"": ""tiffsep1_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep1_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep1_device * const tfdev = (tiffsep1_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, code = 0, code1 = 0;\n    short map_comp_to_sep[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n       goto done;\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n\n        gs_free_object(pdev->memory, compname, \""tiffsep_print_page(compname)\"");\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n    for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n        int sep_num = map_comp_to_sep[comp_num];\n\n        code = create_separation_file_name((tiffsep_device *)tfdev, name,\n                                        gp_file_name_sizeof, sep_num, true);\n        if (code < 0) {\n            goto done;\n        }\n\n        /* Open the separation file, if not already open */\n        if (tfdev->sep_file[comp_num] == NULL) {\n            code = gs_add_outputfile_control_path(tfdev->memory, name);\n            if (code < 0) {\n                goto done;\n            }\n            code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n            if (code < 0) {\n                goto done;\n            }\n            tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                                                    tfdev->sep_file[comp_num],\n                                                    tfdev->BigEndian, tfdev->UseBigTIFF);\n            if (!tfdev->tiff[comp_num]) {\n                code = gs_note_error(gs_error_ioerror);\n                goto done;\n            }\n        }\n\n        pdev->color_info.depth = 8;     /* Create files for 8 bit gray */\n        pdev->color_info.num_components = 1;\n        code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], 1, 0, tfdev->write_datetime);\n        tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], 1, tfdev->Compression, tfdev->MaxStripSize);\n        pdev->color_info.depth = save_depth;\n        pdev->color_info.num_components = save_numcomps;\n        if (code < 0) {\n            goto done;\n        }\n\n    }   /* end initialization of separation files */\n\n\n    {   /* Get the expanded contone line, halftone and write out the dithered separations */\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS];\n        int width = tfdev->width;\n        int raster_plane = bitmap_raster(width * 8);\n        int dithered_raster = ((7 + width) / 8) + ARCH_SIZEOF_LONG;\n        int pixel, y;\n        gs_get_bits_params_t params;\n        gs_int_rect rect;\n        /* the dithered_line is assumed to be 32-bit aligned by the alloc */\n        uint32_t *dithered_line = (uint32_t *)gs_alloc_bytes(pdev->memory, dithered_raster,\n                                \""tiffsep1_print_page\"");\n\n        memset(planes, 0, sizeof(*planes) * GS_CLIENT_COLOR_MAX_COMPONENTS);\n\n        /* Return planar data */\n        params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n             GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n             GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n        params.x_offset = 0;\n        params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n        code = 0;\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                            \""tiffsep1_print_page\"");\n            if (planes[comp_num] == NULL) {\n                code = gs_error_VMerror;\n                break;\n            }\n        }\n\n        if (code < 0 || dithered_line == NULL) {\n            code = gs_note_error(gs_error_VMerror);\n            goto cleanup;\n        }\n\n        for (comp_num = 0; comp_num < num_comp; comp_num++ )\n            TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n\n        rect.p.x = 0;\n        rect.q.x = pdev->width;\n        /* Loop for the lines */\n        for (y = 0; y < pdev->height; ++y) {\n            rect.p.y = y;\n            rect.q.y = y + 1;\n            /* We have to reset the pointers since get_bits_rect will have moved them */\n            for (comp_num = 0; comp_num < num_comp; comp_num++)\n                params.data[comp_num] = planes[comp_num];\n            code = (*dev_proc(pdev, get_bits_rectangle))((gx_device *)pdev, &rect, &params, NULL);\n            if (code < 0)\n                break;\n\n            /* Dither the separation and write it out */\n            for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n\n/***** #define SKIP_HALFTONING_FOR_TIMING *****/ /* uncomment for timing test */\n#ifndef SKIP_HALFTONING_FOR_TIMING\n\n                /*\n                 * Define 32-bit writes by default. Testing shows that while this is more\n                 * complex code, it runs measurably and consistently faster than the more\n                 * obvious 8-bit code. The 8-bit code is kept to help future optimization\n                 * efforts determine what affects tight loop optimization. Subtracting the\n                 * time when halftoning is skipped shows that the 32-bit halftoning is\n                 * 27% faster.\n                 */\n#define USE_32_BIT_WRITES\n                byte *thresh_line_base = tfdev->thresholds[comp_num].dstart +\n                                    ((y % tfdev->thresholds[comp_num].dheight) *\n                                        tfdev->thresholds[comp_num].dwidth) ;\n                byte *thresh_ptr = thresh_line_base;\n                byte *thresh_limit = thresh_ptr + tfdev->thresholds[comp_num].dwidth;\n                byte *src = params.data[comp_num];\n#ifdef USE_32_BIT_WRITES\n                uint32_t *dest = dithered_line;\n                uint32_t val = 0;\n                const uint32_t *mask = &bit_order[0];\n#else   /* example 8-bit code */\n                byte *dest = dithered_line;\n                byte val = 0;\n                byte mask = 0x80;\n#endif /* USE_32_BIT_WRITES */\n\n                for (pixel = 0; pixel < width; pixel++, src++) {\n#ifdef USE_32_BIT_WRITES\n                    if (*src < *thresh_ptr++)\n                        val |= *mask;\n                    if (++mask == &(bit_order[32])) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = &bit_order[0];\n                    }\n#else   /* example 8-bit code */\n                    if (*src < *thresh_ptr++)\n                        val |= mask;\n                    mask >>= 1;\n                    if (mask == 0) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = 0x80;\n                    }\n#endif /* USE_32_BIT_WRITES */\n                    if (thresh_ptr >= thresh_limit)\n                        thresh_ptr = thresh_line_base;\n                } /* end src pixel loop - collect last bits if any */\n                /* the following relies on their being enough 'pad' in dithered_line */\n#ifdef USE_32_BIT_WRITES\n                if (mask != &bit_order[0]) {\n                    *dest = val;\n                }\n#else   /* example 8-bit code */\n                if (mask != 0x80) {\n                    *dest = val;\n                }\n#endif /* USE_32_BIT_WRITES */\n#endif /* SKIP_HALFTONING_FOR_TIMING */\n                TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)dithered_line, y, 0);\n            } /* end component loop */\n        }\n        /* Update the strip data */\n        for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n            TIFFWriteDirectory(tfdev->tiff[comp_num]);\n            if (fmt) {\n                int sep_num = map_comp_to_sep[comp_num];\n\n                code = create_separation_file_name((tiffsep_device *)tfdev, name, gp_file_name_sizeof, sep_num, false);\n                if (code < 0) {\n                    code1 = code;\n                    continue;\n                }\n                code = tiffsep_close_sep_file((tiffsep_device *)tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    code1 = code;\n                }\n            }\n        }\n        code = code1;\n\n        /* free any allocations and exit with code */\ncleanup:\n        gs_free_object(pdev->memory, dithered_line, \""tiffsep1_print_page\"");\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            gs_free_object(pdev->memory, planes[comp_num], \""tiffsep1_print_page\"");\n        }\n    }\n    /*\n     * If we have any non encodable pixels then signal an error.\n     */\n    if (non_encodable_count) {\n        dmlprintf1(pdev->memory, \""WARNING:  Non encodable pixels = %d\\n\"", non_encodable_count);\n        code = gs_note_error(gs_error_rangecheck);\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep1_print_page(name)\"");\n    return code;\n}""}, {""func_name"": ""tiffsep_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep_device * const tfdev = (tiffsep_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, sep_num, code = 0, code1 = 0;\n    cmyk_composite_map cmyk_map[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    bool double_f = false;\n    int base_filename_length = length_base_file_name(tfdev, &double_f);\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int plane_count = 0;  /* quiet compiler */\n    int factor = tfdev->downscale.downscale_factor;\n    int mfs = tfdev->downscale.min_feature_size;\n    int dst_bpc = tfdev->BitsPerComponent;\n    gx_downscaler_t ds;\n    int width = gx_downscaler_scale(tfdev->width, factor);\n    int height = gx_downscaler_scale(tfdev->height, factor);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    /* Print the names of the spot colors */\n    if (num_order == 0) {\n        for (sep_num = 0; sep_num < num_spot; sep_num++) {\n            copy_separation_name(tfdev, name,\n                gp_file_name_sizeof - base_filename_length - SUFFIX_SIZE, sep_num, 0);\n            dmlprintf1(pdev->memory, \""%%%%SeparationName: %s\\n\"", name);\n        }\n    }\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n       goto done;\n    }\n    /* Write the page directory for the CMYK equivalent file. */\n    if (!tfdev->comp_file) {\n        pdev->color_info.depth = dst_bpc*4;        /* Create directory for 32 bit cmyk */\n        if (!tfdev->UseBigTIFF && tfdev->Compression==COMPRESSION_NONE &&\n            height > ((unsigned long) 0xFFFFFFFF - (file ? gp_ftell(file) : 0))/(width*4)) { /* note width is never 0 in print_page */\n            dmprintf(pdev->memory, \""CMYK composite file would be too large! Reduce resolution or enable compression.\\n\"");\n            return_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n        }\n\n        code = gx_device_open_output_file((gx_device *)pdev, pdev->fname, true, true, &(tfdev->comp_file));\n        if (code < 0) {\n            goto done;\n        }\n\n        tfdev->tiff_comp = tiff_from_filep(pdev, pdev->dname, tfdev->comp_file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tiff_comp) {\n            code = gs_note_error(gs_error_invalidfileaccess);\n            goto done;\n        }\n\n    }\n    code = tiff_set_fields_for_printer(pdev, tfdev->tiff_comp, factor, 0, tfdev->write_datetime);\n\n    if (dst_bpc == 1 || dst_bpc == 8) {\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n    }\n    else {\n        /* Catch-all just for safety's sake */\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, COMPRESSION_NONE, tfdev->MaxStripSize);\n    }\n\n    pdev->color_info.depth = save_depth;\n    if (code < 0) {\n        goto done;\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n\n    if (!tfdev->NoSeparationFiles && !num_order && num_comp < num_std_colorants + num_spot) {\n        dmlprintf(pdev->memory, \""Warning: skipping one or more colour separations, see: Devices.htm#TIFF\\n\"");\n    }\n\n    if (!tfdev->NoSeparationFiles) {\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n            code = create_separation_file_name(tfdev, name, gp_file_name_sizeof,\n                sep_num, true);\n            if (code < 0) {\n                goto done;\n            }\n\n            /*\n             * Close the old separation file if we are creating individual files\n             * for each page.\n             */\n            if (tfdev->sep_file[comp_num] != NULL && fmt != NULL) {\n                code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0)\n                    return code;\n            }\n            /* Open the separation file, if not already open */\n            if (tfdev->sep_file[comp_num] == NULL) {\n                code = gs_add_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    goto done;\n                }\n                code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n                if (code < 0) {\n                    goto done;\n                }\n                tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                    tfdev->sep_file[comp_num],\n                    tfdev->BigEndian, tfdev->UseBigTIFF);\n                if (!tfdev->tiff[comp_num]) {\n                    code = gs_note_error(gs_error_ioerror);\n                    goto done;\n                }\n            }\n\n            pdev->color_info.depth = dst_bpc;     /* Create files for 8 bit gray */\n            pdev->color_info.num_components = 1;\n            if (!tfdev->UseBigTIFF && tfdev->Compression == COMPRESSION_NONE &&\n                height * 8 / dst_bpc > ((unsigned long)0xFFFFFFFF - (file ? gp_ftell(file) : 0)) / width) /* note width is never 0 in print_page */\n            {\n                code = gs_note_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n                goto done;\n            }\n\n\n            code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], factor, 0, tfdev->write_datetime);\n            tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n            pdev->color_info.depth = save_depth;\n            pdev->color_info.num_components = save_numcomps;\n            if (code < 0) {\n                goto done;\n            }\n        }\n    }\n\n    build_cmyk_map((gx_device*) tfdev, num_comp, &tfdev->equiv_cmyk_colors, cmyk_map);\n    if (tfdev->PrintSpotCMYK) {\n        code = print_cmyk_equivalent_colors(tfdev, num_comp, cmyk_map);\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    {\n        int raster_plane = bitmap_raster(width * 8);\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS] = { 0 };\n        int cmyk_raster = width * NUM_CMYK_COMPONENTS;\n        int pixel, y;\n        byte * sep_line;\n        int plane_index;\n        int offset_plane = 0;\n\n        sep_line =\n            gs_alloc_bytes(pdev->memory, cmyk_raster, \""tiffsep_print_page\"");\n        if (!sep_line) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        if (!tfdev->NoSeparationFiles)\n            for (comp_num = 0; comp_num < num_comp; comp_num++ )\n                TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n        TIFFCheckpointDirectory(tfdev->tiff_comp);\n\n        /* Write the page data. */\n        {\n            gs_get_bits_params_t params;\n            int byte_width;\n\n            /* Return planar data */\n            params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n                 GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n                 GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n            params.x_offset = 0;\n            params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n            if (num_order > 0) {\n                /* In this case, there was a specification for a separation\n                   color order, which indicates what colorants we will\n                   actually creat individual separation files for.  We need\n                   to allocate for the standard colorants.  This is due to the\n                   fact that even when we specify a single spot colorant, we\n                   still create the composite CMYK output file. */\n                for (comp_num = 0; comp_num < num_std_colorants; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                      \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n                offset_plane = num_std_colorants;\n                /* Now we need to make sure that we do not allocate extra\n                   planes if any of the colorants in the order list are\n                   one of the standard colorant names */\n                plane_index = plane_count = num_std_colorants;\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    int temp_pos;\n\n                    temp_pos = tfdev->devn_params.separation_order_map[comp_num];\n                    if (temp_pos >= num_std_colorants) {\n                        /* We have one that is not a standard colorant name\n                           so allocate a new plane */\n                        planes[plane_count] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                        \""tiffsep_print_page\"");\n                        /* Assign the new plane to the appropriate position */\n                        params.data[plane_index] = planes[plane_count];\n                        if (params.data[plane_index] == NULL) {\n                            code = gs_note_error(gs_error_VMerror);\n                            goto cleanup;\n                        }\n                        plane_count += 1;\n                    } else {\n                        /* Assign params.data with the appropriate std.\n                           colorant plane position */\n                        params.data[plane_index] = planes[temp_pos];\n                    }\n                    plane_index += 1;\n                }\n            } else {\n                /* Sep color order number was not specified so just render all\n                   the  planes that we can */\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                    \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n            }\n            code = gx_downscaler_init_planar_trapped(&ds, (gx_device *)pdev, &params,\n                                                     num_comp, factor, mfs, 8, dst_bpc,\n                                                     tfdev->downscale.trap_w, tfdev->downscale.trap_h,\n                                                     tfdev->downscale.trap_order);\n            if (code < 0)\n                goto cleanup;\n            byte_width = (width * dst_bpc + 7)>>3;\n            for (y = 0; y < height; ++y) {\n                code = gx_downscaler_get_bits_rectangle(&ds, &params, y);\n                if (code < 0)\n                    goto cleanup;\n                /* Write separation data (tiffgray format) */\n                if (!tfdev->NoSeparationFiles) {\n                    for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                        byte *src;\n                        byte *dest = sep_line;\n\n                        if (num_order > 0) {\n                            src = params.data[tfdev->devn_params.separation_order_map[comp_num]];\n                        }\n                        else\n                            src = params.data[comp_num];\n                        for (pixel = 0; pixel < byte_width; pixel++, dest++, src++)\n                            *dest = MAX_COLOR_VALUE - *src;    /* Gray is additive */\n                        TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)sep_line, y, 0);\n                    }\n                }\n                /* Write CMYK equivalent data */\n                switch(dst_bpc)\n                {\n                default:\n                case 8:\n                    build_cmyk_raster_line_fromplanar(&params, sep_line, width,\n                                                      num_comp, cmyk_map, num_order,\n                                                      tfdev);\n                    break;\n                case 4:\n                    build_cmyk_raster_line_fromplanar_4bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 2:\n                    build_cmyk_raster_line_fromplanar_2bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 1:\n                    build_cmyk_raster_line_fromplanar_1bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                }\n                TIFFWriteScanline(tfdev->tiff_comp, (tdata_t)sep_line, y, 0);\n            }\ncleanup:\n            if (num_order > 0) {\n                /* Free up the standard colorants if num_order was set.\n                   In this process, we need to make sure that none of them\n                   were the standard colorants.  plane_count should have\n                   the sum of the std. colorants plus any non-standard\n                   ones listed in separation color order */\n                for (comp_num = 0; comp_num < plane_count; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num],\n                                                    \""tiffsep_print_page\"");\n                }\n            } else {\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num + offset_plane],\n                                                    \""tiffsep_print_page\"");\n                }\n            }\n            gx_downscaler_fin(&ds);\n            gs_free_object(pdev->memory, sep_line, \""tiffsep_print_page\"");\n        }\n        code1 = code;\n        if (!tfdev->NoSeparationFiles) {\n            for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                TIFFWriteDirectory(tfdev->tiff[comp_num]);\n                if (fmt) {\n                    int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n                    code = create_separation_file_name(tfdev, name, gp_file_name_sizeof, sep_num, false);\n                    if (code < 0) {\n                        code1 = code;\n                        continue;\n                    }\n                    code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                    if (code >= 0)\n                        code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                    if (code < 0) {\n                        code1 = code;\n                    }\n                }\n            }\n        }\n        TIFFWriteDirectory(tfdev->tiff_comp);\n        if (fmt) {\n            code = tiffsep_close_comp_file(tfdev, pdev->fname);\n        }\n        if (code1 < 0) {\n            code = code1;\n        }\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep_print_page(name)\"");\n    return code;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:gdevtsep.c, func:tiffsep1_print_page)"", ""result"": [{""code"": ""static int\ntiffsep1_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep1_device * const tfdev = (tiffsep1_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, code = 0, code1 = 0;\n    short map_comp_to_sep[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n\n        gs_free_object(pdev->memory, compname, \""tiffsep_print_page(compname)\"");\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n    for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n        int sep_num = map_comp_to_sep[comp_num];\n\n        code = create_separation_file_name((tiffsep_device *)tfdev, name,\n                                        gp_file_name_sizeof, sep_num, true);\n        if (code < 0) {\n            goto done;\n        }\n\n        /* Open the separation file, if not already open */\n        if (tfdev->sep_file[comp_num] == NULL) {\n            code = gs_add_outputfile_control_path(tfdev->memory, name);\n            if (code < 0) {\n                goto done;\n            }\n            code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n            if (code < 0) {\n                goto done;\n            }\n            tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                                                    tfdev->sep_file[comp_num],\n                                                    tfdev->BigEndian, tfdev->UseBigTIFF);\n            if (!tfdev->tiff[comp_num]) {\n                code = gs_note_error(gs_error_ioerror);\n                goto done;\n            }\n        }\n\n        pdev->color_info.depth = 8;     /* Create files for 8 bit gray */\n        pdev->color_info.num_components = 1;\n        code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], 1, 0, tfdev->write_datetime);\n        tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], 1, tfdev->Compression, tfdev->MaxStripSize);\n        pdev->color_info.depth = save_depth;\n        pdev->color_info.num_components = save_numcomps;\n        if (code < 0) {\n            goto done;\n        }\n\n    }   /* end initialization of separation files */\n\n\n    {   /* Get the expanded contone line, halftone and write out the dithered separations */\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS];\n        int width = tfdev->width;\n        int raster_plane = bitmap_raster(width * 8);\n        int dithered_raster = ((7 + width) / 8) + ARCH_SIZEOF_LONG;\n        int pixel, y;\n        gs_get_bits_params_t params;\n        gs_int_rect rect;\n        /* the dithered_line is assumed to be 32-bit aligned by the alloc */\n        uint32_t *dithered_line = (uint32_t *)gs_alloc_bytes(pdev->memory, dithered_raster,\n                                \""tiffsep1_print_page\"");\n\n        memset(planes, 0, sizeof(*planes) * GS_CLIENT_COLOR_MAX_COMPONENTS);\n\n        /* Return planar data */\n        params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n             GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n             GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n        params.x_offset = 0;\n        params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n        code = 0;\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                            \""tiffsep1_print_page\"");\n            if (planes[comp_num] == NULL) {\n                code = gs_error_VMerror;\n                break;\n            }\n        }\n\n        if (code < 0 || dithered_line == NULL) {\n            code = gs_note_error(gs_error_VMerror);\n            goto cleanup;\n        }\n\n        for (comp_num = 0; comp_num < num_comp; comp_num++ )\n            TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n\n        rect.p.x = 0;\n        rect.q.x = pdev->width;\n        /* Loop for the lines */\n        for (y = 0; y < pdev->height; ++y) {\n            rect.p.y = y;\n            rect.q.y = y + 1;\n            /* We have to reset the pointers since get_bits_rect will have moved them */\n            for (comp_num = 0; comp_num < num_comp; comp_num++)\n                params.data[comp_num] = planes[comp_num];\n            code = (*dev_proc(pdev, get_bits_rectangle))((gx_device *)pdev, &rect, &params, NULL);\n            if (code < 0)\n                break;\n\n            /* Dither the separation and write it out */\n            for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n\n/***** #define SKIP_HALFTONING_FOR_TIMING *****/ /* uncomment for timing test */\n#ifndef SKIP_HALFTONING_FOR_TIMING\n\n                /*\n                 * Define 32-bit writes by default. Testing shows that while this is more\n                 * complex code, it runs measurably and consistently faster than the more\n                 * obvious 8-bit code. The 8-bit code is kept to help future optimization\n                 * efforts determine what affects tight loop optimization. Subtracting the\n                 * time when halftoning is skipped shows that the 32-bit halftoning is\n                 * 27% faster.\n                 */\n#define USE_32_BIT_WRITES\n                byte *thresh_line_base = tfdev->thresholds[comp_num].dstart +\n                                    ((y % tfdev->thresholds[comp_num].dheight) *\n                                        tfdev->thresholds[comp_num].dwidth) ;\n                byte *thresh_ptr = thresh_line_base;\n                byte *thresh_limit = thresh_ptr + tfdev->thresholds[comp_num].dwidth;\n                byte *src = params.data[comp_num];\n#ifdef USE_32_BIT_WRITES\n                uint32_t *dest = dithered_line;\n                uint32_t val = 0;\n                const uint32_t *mask = &bit_order[0];\n#else   /* example 8-bit code */\n                byte *dest = dithered_line;\n                byte val = 0;\n                byte mask = 0x80;\n#endif /* USE_32_BIT_WRITES */\n\n                for (pixel = 0; pixel < width; pixel++, src++) {\n#ifdef USE_32_BIT_WRITES\n                    if (*src < *thresh_ptr++)\n                        val |= *mask;\n                    if (++mask == &(bit_order[32])) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = &bit_order[0];\n                    }\n#else   /* example 8-bit code */\n                    if (*src < *thresh_ptr++)\n                        val |= mask;\n                    mask >>= 1;\n                    if (mask == 0) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = 0x80;\n                    }\n#endif /* USE_32_BIT_WRITES */\n                    if (thresh_ptr >= thresh_limit)\n                        thresh_ptr = thresh_line_base;\n                } /* end src pixel loop - collect last bits if any */\n                /* the following relies on their being enough 'pad' in dithered_line */\n#ifdef USE_32_BIT_WRITES\n                if (mask != &bit_order[0]) {\n                    *dest = val;\n                }\n#else   /* example 8-bit code */\n                if (mask != 0x80) {\n                    *dest = val;\n                }\n#endif /* USE_32_BIT_WRITES */\n#endif /* SKIP_HALFTONING_FOR_TIMING */\n                TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)dithered_line, y, 0);\n            } /* end component loop */\n        }\n        /* Update the strip data */\n        for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n            TIFFWriteDirectory(tfdev->tiff[comp_num]);\n            if (fmt) {\n                int sep_num = map_comp_to_sep[comp_num];\n\n                code = create_separation_file_name((tiffsep_device *)tfdev, name, gp_file_name_sizeof, sep_num, false);\n                if (code < 0) {\n                    code1 = code;\n                    continue;\n                }\n                code = tiffsep_close_sep_file((tiffsep_device *)tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    code1 = code;\n                }\n            }\n        }\n        code = code1;\n\n        /* free any allocations and exit with code */\ncleanup:\n        gs_free_object(pdev->memory, dithered_line, \""tiffsep1_print_page\"");\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            gs_free_object(pdev->memory, planes[comp_num], \""tiffsep1_print_page\"");\n        }\n    }\n    /*\n     * If we have any non encodable pixels then signal an error.\n     */\n    if (non_encodable_count) {\n        dmlprintf1(pdev->memory, \""WARNING:  Non encodable pixels = %d\\n\"", non_encodable_count);\n        code = gs_note_error(gs_error_rangecheck);\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep1_print_page(name)\"");\n    return code;\n}\n"", ""start_line"": 2689, ""end_line"": 2963, ""full_name"": ""tiffsep1_print_page"", ""file_path"": ""devices/gdevtsep.c""}]}, {""source"": ""code_info(file:gdevtsep.c, lines:2700-2750)"", ""result"": ""    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n""}]","The original code in `tiffsep1_print_page` (devices/gdevtsep.c:2727) set an error code (`gs_error_ioerror`) when multi-page output lacked a `%d` format specifier but continued execution. This led to uninitialized or invalid TIFF structures being accessed (e.g., `tfdev->tiff[comp_num]`) during subsequent operations like `TIFFWriteScanline`, causing a null pointer dereference. The patch adds `goto done;` to jump to the cleanup/return section (`devices/gdevtsep.c:2950`), ensuring termination before unsafe operations.",0.95,./github/other_context/CVE-2020-16306
33,CVE-2021-32437,CWE-476,c_cpp,The gf_hinter_finalize function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,https://github.com/gpac/gpac/commit/1653f31cf874eb6df964bea88d58d8e9b98b485e,fixed #1770 (fuzz),1,"[{""func_name"": ""gf_hinter_finalize"", ""file_path"": ""src/media_tools/isom_hinter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \""b=AS:%d\"", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \""a=x-copyright: %s\"", \""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\"");\n    } else {\n        sprintf(buf64, \""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\"", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-od-au;base64,%s\"", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-bifs-au;base64,%s\"", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \""a=isma-compliance:1,1.0,1\"");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \""a=mpeg4-iod:\\\""data:application/mpeg4-iod;base64,%s\\\""\"", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}"", ""target"": 0}]","[{""func_name"": ""gf_hinter_finalize"", ""file_path"": ""src/media_tools/isom_hinter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \""b=AS:%d\"", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \""a=x-copyright: %s\"", \""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\"");\n    } else {\n        sprintf(buf64, \""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\"", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-od-au;base64,%s\"", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-bifs-au;base64,%s\"", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \""a=isma-compliance:1,1.0,1\"");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \""a=mpeg4-iod:\\\""data:application/mpeg4-iod;base64,%s\\\""\"", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}""}]","{""function"": 2, ""value"": 1, ""code"": 1}","[{""source"": ""func_info(func:gf_isom_get_sample)"", ""result"": [{""code"": ""GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}"", ""start_line"": 1880, ""end_line"": 1883, ""full_name"": ""gf_isom_get_sample"", ""file_path"": ""src/isomedia/isom_read.c""}]}, {""source"": ""value_info(file:isom_hinter.c, value:samp)"", ""result"": {""value_trace"": [{""full_code"": ""samp = gf_isom_get_sample_info(file, Track, i+1, NULL, NULL)"", ""line"": 54, ""func_name"": ""gf_media_get_sample_average_infos""}, {""full_code"": ""*samp = NULL"", ""line"": 337, ""func_name"": ""gf_hinter_track_new""}, {""full_code"": ""samp = gf_isom_get_sample(file, TrackNum, 1, NULL)"", ""line"": 339, ""func_name"": ""gf_hinter_track_new""}, {""full_code"": ""*samp = gf_isom_get_sample(file, TrackNum, 1, NULL)"", ""line"": 515, ""func_name"": ""gf_hinter_track_new""}, {""full_code"": ""samp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex)"", ""line"": 724, ""func_name"": ""gf_hinter_track_process""}], ""struct_var"": ""samp"", ""struct_type"": ""GF_ISOSample*"", ""struct_definition"": ""typedef struct\n{\n\t/*! data size*/\n\tu32 dataLength;\n\t/*! data with padding if requested*/\n\tu8 *data;\n\t/*! decoding time*/\n\tu64 DTS;\n\t/*! relative offset for composition if needed*/\n\ts32 CTS_Offset;\n\t/*! SAP type*/\n\tGF_ISOSAPType IsRAP;\n\t/*! allocated data size - used only when using static sample in \\ref gf_isom_get_sample_ex*/\n\tu32 alloc_size;\n\t\n\t/*! number of packed samples in this sample. If 0 or 1, only 1 sample is present\n\tonly used for constant size and constant duration samples*/\n\tu32 nb_pack;\n}""}}, {""source"": ""code_info(file:isom_read.c, lines:145-155)"", ""result"": ""\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n""}, {""source"": ""func_info(file:isom_read.c, func:gf_isom_get_sample_ex)"", ""result"": [{""code"": ""GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n"", ""start_line"": 1837, ""end_line"": 1877, ""full_name"": ""gf_isom_get_sample_ex"", ""file_path"": ""src/isomedia/isom_read.c""}]}]","src/media_tools/isom_hinter.c:1235: 'samp = gf_isom_get_sample(...)' does not validate 'samp' before dereferencing 'samp->data'.\nsrc/isomedia/isom_read.c:1837-1877: 'gf_isom_get_sample_ex' returns NULL if 'trak' is invalid, 'sampleNumber' is 0, or 'Media_GetSample' fails. This allows invalid/crafted inputs to propagate a NULL 'samp' to 'gf_hinter_finalize'.",0.95,./github/other_context/CVE-2021-32437
34,CVE-2021-36222,CWE-476,c_cpp,ec_verify in kdc/kdc_preauth_ec.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.4 and 1.19.x before 1.19.2 allows remote attackers to cause a NULL pointer dereference and daemon crash. This occurs because a return value is not properly managed in a certain situation.,https://github.com/krb5/krb5/commit/fc98f520caefff2e5ee9a0026fdf5109944b3562,"Fix KDC null deref on bad encrypted challenge\n\nThe function ec_verify() in src/kdc/kdc_preauth_ec.c contains a check\nto avoid further processing if the armor key is NULL.  However, this\ncheck is bypassed by a call to k5memdup0() which overwrites retval\nwith 0 if the allocation succeeds.  If the armor key is NULL, a call\nto krb5_c_fx_cf2_simple() will then dereference it, resulting in a\ncrash.  Add a check before the k5memdup0() call to avoid overwriting\nretval.\n\nCVE-2021-36222:\n\nIn MIT krb5 releases 1.16 and later, an unauthenticated attacker can\ncause a null dereference in the KDC by sending a request containing a\nPA-ENCRYPTED-CHALLENGE padata element without using FAST.\n\n[ghudson@mit.edu: trimmed patch; added test case; edited commit\nmessage]\n\nticket: 9007 (new)\ntags: pullup\ntarget_version: 1.19-next\ntarget_version: 1.18-next",1,"[{""func_name"": ""ec_verify"", ""file_path"": ""src/kdc/kdc_preauth_ec.c"", ""func_code"": ""static void\nec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\""Encrypted Challenge used outside of FAST tunnel\""));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \""kdcchallengearmor\"",\n                                 &client_keys[i], \""challengelongterm\"",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}"", ""target"": 0}]","[{""func_name"": ""ec_verify"", ""file_path"": ""src/kdc/kdc_preauth_ec.c"", ""func_code"": ""static void\nec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\""Encrypted Challenge used outside of FAST tunnel\""));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    if (retval == 0)\n        realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \""kdcchallengearmor\"",\n                                 &client_keys[i], \""challengelongterm\"",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}""}]","{""function"": 2, ""code"": 2, ""value"": 2}","[{""source"": ""func_info(file:kdc_preauth_ec.c, func:ec_verify)"", ""result"": [{""code"": ""static void\nec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\""Encrypted Challenge used outside of FAST tunnel\""));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \""kdcchallengearmor\"",\n                                 &client_keys[i], \""challengelongterm\"",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}\n"", ""start_line"": 51, ""end_line"": 153, ""full_name"": ""ec_verify"", ""file_path"": ""src/kdc/kdc_preauth_ec.c""}]}, {""source"": ""code_info(file:kdc_preauth_ec.c, lines:80-100)"", ""result"": ""    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n""}, {""source"": ""value_info(file:kdc_preauth_ec.c, value:retval)"", ""result"": {""value_trace"": [{""full_code"": ""retval = 0"", ""line"": 58, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = ENOENT"", ""line"": 74, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = decode_krb5_enc_data(&scratch, &enc)"", ""line"": 81, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = ENOMEM"", ""line"": 86, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai)"", ""line"": 92, ""func_name"": ""ec_verify""}], ""struct_var"": ""retval"", ""struct_type"": ""krb5_error_code"", ""struct_definition"": ""krb5_error_code""}}, {""source"": ""func_info(func:fast_armor)"", ""result"": [{""code"": ""static krb5_keyblock *\nfast_armor(krb5_context context, krb5_kdcpreauth_rock rock)\n{\n    return rock->rstate->armor_key;\n}"", ""start_line"": 403, ""end_line"": 407, ""full_name"": ""fast_armor"", ""file_path"": ""src/kdc/kdc_preauth.c""}, {""code"": ""static krb5_keyblock *\nfast_armor(krb5_context context, krb5_clpreauth_rock rock)\n{\n    return ((krb5_init_creds_context)rock)->fast_state->armor_key;\n}"", ""start_line"": 428, ""end_line"": 432, ""full_name"": ""fast_armor<duplicate>0"", ""file_path"": ""src/lib/krb5/krb/preauth2.c""}]}, {""source"": ""code_info(file:kdc_preauth_ec.c, lines:100-120)"", ""result"": ""        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n""}, {""source"": ""value_info(file:kdc_preauth_ec.c, value:armor_key)"", ""result"": {""value_trace"": [{""full_code"": ""*armor_key = cb->fast_armor(context, rock)"", ""line"": 42, ""func_name"": ""ec_edata""}, {""full_code"": ""*armor_key = cb->fast_armor(context, rock)"", ""line"": 61, ""func_name"": ""ec_verify""}], ""struct_var"": ""armor_key"", ""struct_type"": ""krb5_keyblock*"", ""struct_definition"": ""krb5_keyblock""}}]","src/kdc/kdc_preauth_ec.c:74: 'armor_key' is NULL, setting 'retval' to ENOENT. src/kdc/kdc_preauth_ec.c:88: 'k5memdup0()' overwrites 'retval' with 0 on success, bypassing the error. src/kdc/kdc_preauth_ec.c:100-120: 'krb5_c_fx_cf2_simple(context, armor_key, ...)' dereferences the NULL 'armor_key', causing a crash. The patch adds 'if (retval == 0)' before 'k5memdup0()' to prevent error code overwrite.",0.95,./github/other_context/CVE-2021-36222
35,CVE-2021-39196,CWE-754,java,"pcapture is an open source dumpcap web service interface . In affected versions this vulnerability allows an authenticated but unprivileged user to use the REST API to capture and download packets with no capture filter and without adequate permissions. This is important because the capture filters can effectively limit the scope of information that a user can see in the data captures. If no filter is present, then all data on the local network segment where the program is running can be captured and downloaded. v3.12 fixes this problem. There is no workaround, you must upgrade to v3.12 or greater.",https://github.com/jdhwpgmbca/pcapture/commit/0f74f431e0970a2e5784dbd955cfa4760e3b1ef7,Fixed major security bug.\n\nA user could effectively specify an undefined url and the program would return a null filter rather than throwing an exception and returning an error to the user. This was a really bad bug. I found it when I was adding code to validate the path parameters. That will be coming in the next commit.,1,"[{""func_name"": ""findFilter"", ""file_path"": ""src/main/java/com/rtds/svc/CaptureTypeService.java"", ""func_code"": ""public String findFilter( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \""The url_suffix must not be null.\"" );\n        }\n        \n        CaptureType type = em.find( CaptureType.class, url_suffix );\n        \n        if( type != null )\n        {\n            return type.getCaptureFilter();\n        }\n        \n        return null;\n    }"", ""target"": 0}]","[{""func_name"": ""findFilter"", ""file_path"": ""src/main/java/com/rtds/svc/CaptureTypeService.java"", ""func_code"": ""public String findFilter( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \""The url_suffix must not be null.\"" );\n        }\n        \n        CaptureType type = em.find( CaptureType.class, url_suffix );\n        \n        if( type == null )\n        {\n            throw new IllegalArgumentException( \""The url_suffix must exist in the database.\"" );\n        }\n        \n        // It is okay for the capture filter itself to be null, but the CaptureType\n        // must be in the database, otherwise the user could effectively forge\n        // a capture filter for \""all\"" just by requesting a non-existent filter.\n        \n        return type.getCaptureFilter();\n    }""}]","{""caller"": 1, ""code"": 1}","[{""source"": ""caller_info(file:CaptureTypeService.java, func:findFilter)"", ""result"": [{""call_line"": 74, ""call_code"": ""this.captureTypeService.findFilter(type)"", ""caller_code"": ""    @POST\n    @Path(\""/{type}\"")\n    @Produces( MediaType.TEXT_PLAIN )\n    @RolesAllowed( { \""user\"", \""admin\"" } )\n    public Response startTypedCapture( @PathParam(\""type\"") String type ) throws IOException, GeneralSecurityException\n    {\n        String filter = captureTypeService.findFilter( type );\n        java.nio.file.Path script_path = java.nio.file.Path.of( startCaptureScript );\n        \n        logger.info(  \""startCaptureScript path {}\"", startCaptureScript );\n        \n        if( Files.notExists( script_path, LinkOption.NOFOLLOW_LINKS ) )\n        {\n            logger.error( \""startCaptureScript can't be found in specified location {}\"", startCaptureScript );\n        }\n        \n        java.nio.file.Path path = java.nio.file.Files.createTempFile( \""wireshark-capture-\"", \"".pcapng\"" );\n        \n        // This now works on Windows and Ubuntu Linux!\n        \n        ProcessBuilder pb;\n        \n        if( System.getProperty( \""os.name\"" ).toLowerCase().startsWith( \""win\"" ) )\n        {\n            if( filter != null )\n            {\n                // Hack for PowerShell quoting: I needed to surround the filter in single quotes, otherwise the\n                // filter would be interpreted as separate arguments! This does not appear to be an issue when\n                // running shell scripts on Linux.\n\n                StringBuilder f = new StringBuilder( \""'\"" );\n\n                f.append( filter );\n                f.append( \""'\"" );\n\n                pb = new ProcessBuilder( \""powershell.exe\"",  \""-ExecutionPolicy\"", \""RemoteSigned\"", \""-Command\"", startCaptureScript, f.toString(), path.toString() );\n            }\n            else\n            {\n                pb = new ProcessBuilder( \""powershell.exe\"",  \""-ExecutionPolicy\"", \""RemoteSigned\"", \""-Command\"", startCaptureScript, path.toString() );\n            }\n        }\n        else\n        {\n            if( filter != null )\n            {\n                pb = new ProcessBuilder( startCaptureScript, path.toString(), filter );\n            }\n            else\n            {\n                pb = new ProcessBuilder( startCaptureScript, path.toString() );\n            }\n        }\n        \n        pb.redirectErrorStream( true );\n        \n        // Start the process\n        \n        Process proc = pb.start();\n        \n        long pid;\n        \n        // Read the process ID from the output of the script. It will be used\n        // later to stop the process.\n        \n        try( InputStream in = proc.getInputStream() )\n        {\n            String length_string = new String( in.readAllBytes(), \""UTF8\"" );\n            \n            pid = Long.parseLong( length_string.trim() );\n        }\n        \n        Optional<SecurityIdentity> sidentity = Optional.ofNullable( identity );\n        Optional<String> principal_name = sidentity.map( sid -> sid.getPrincipal() ).map( p -> p.getName() );\n        \n        // Store the process information, file path and the name of the user in\n        // the database. This will be used later to lookup the process ID, and\n        // to remove the capture file.\n        \n        UUID dbid = dumpcapDbService.createDumpcapProcess(pid, path.toString(), type, principal_name );\n        \n        return Response.ok( dbid ).build();\n    }\n"", ""caller_start"": 68, ""file_path"": ""src/main/java/com/rtds/PacketCaptureResource.java""}]}, {""source"": ""code_info(file:startCaptureScript, lines:1-200)"", ""result"": ""#!/bin/bash\n\n# Run the dumpcap program, redirecting it's standard error and output to null, and printing the PID to the standard output.\n\n# You'll probably want to add a capture filter such as -f \""ether proto 0x99B8\"" for Goose. Other useful EtherTypes: 0x99B9 for GSE, and 0x88BA for SV.\n\nif [ -z \""$2\"" ]; then\n    nohup /usr/bin/tcpdump -w $1 &> /dev/null & echo $!\nelse\n    nohup /usr/bin/tcpdump -f \""$2\"" -w $1 &> /dev/null & echo $!\nfi\n""}]","src/main/java/com/rtds/svc/CaptureTypeService.java:53-63 originally returned null when a CaptureType was not found in the database. This allowed attackers to request non-existent URL suffixes, resulting in a null filter. The null filter propagated to src/main/java/com/rtds/PacketCaptureResource.java:74, where it was used to construct a packet capture command. The startCaptureScript (lines 1-200) confirms that when the filter argument is omitted, tcpdump is executed without a capture filter, enabling unrestricted packet capture.",0.95,./github/other_context/CVE-2021-39196
36,CVE-2021-39521,CWE-476,c_cpp,An issue was discovered in libredwg through v0.10.1.3751. A NULL pointer dereference exists in the function bit_read_BB() located in bits.c. It allows an attacker to cause Denial of Service.,https://github.com/LibreDWG/libredwg/commit/092725ed1332ea634081ddefe73ff36c635b4035,"decode: fix obj_string_stream overflow handling\n\nto avoid heap overflows, such as in fuzzing GH #262",2,"[{""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_WARN (\""obj_string_stream overflow\"");\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_WARN (\""obj_string_stream overflow\"");\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_WARN (\""obj_string_stream overflow\"");\n      str->byte = old_byte;\n      str->size = old_size;\n      obj->has_strings = 0;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}""}, {""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_ERROR (\""obj_string_stream overflow, bitsize \"" FORMAT_RL \"" => \"" FORMAT_RL,\n                 obj->bitsize, obj->size * 8);\n      str->byte = old_byte;\n      str->size = old_size;\n      obj->has_strings = 0;\n      obj->bitsize = obj->size * 8;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}""}]","{""value"": 7, ""function"": 3, ""caller"": 2, ""code"": 2}","[{""source"": ""value_info(file:decode_r2007.c, value:str->byte)"", ""result"": {""value_trace"": [{""full_code"": ""str->byte = 0"", ""line"": 1303, ""func_name"": ""obj_string_stream""}, {""full_code"": ""str->byte -= 2"", ""line"": 1328, ""func_name"": ""obj_string_stream""}, {""full_code"": ""str->byte -= 4"", ""line"": 1337, ""func_name"": ""obj_string_stream""}, {""full_code"": ""str->byte -= 2"", ""line"": 1346, ""func_name"": ""obj_string_stream""}], ""struct_var"": ""str"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:decode_r2007.c, value:str->size)"", ""result"": {""value_trace"": [{""full_code"": ""str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0)"", ""line"": 1305, ""func_name"": ""obj_string_stream""}], ""struct_var"": ""str"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:decode_r2007.c, value:obj->has_strings)"", ""result"": {""value_trace"": [{""full_code"": ""obj->has_strings = bit_read_B (str)"", ""line"": 1315, ""func_name"": ""obj_string_stream""}, {""full_code"": ""obj->has_strings = 1"", ""line"": 1321, ""func_name"": ""obj_string_stream""}, {""full_code"": ""obj->has_strings = 0"", ""line"": 1351, ""func_name"": ""obj_string_stream""}], ""struct_var"": ""obj"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:bits.c, func:bit_read_BB)"", ""result"": [{""code"": ""BITCODE_BB\nbit_read_BB (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  CHK_OVERFLOW(__FUNCTION__,0)\n  byte = dat->chain[dat->byte];\n  if (dat->bit < 7)\n    result = (byte & (0xc0 >> dat->bit)) >> (6 - dat->bit);\n  else\n    {\n      result = (byte & 0x01) << 1;\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          result |= (byte & 0x80) >> 7;\n        }\n    }\n\n  bit_advance_position (dat, 2);\n  return result;\n}"", ""start_line"": 178, ""end_line"": 200, ""full_name"": ""bit_read_BB"", ""file_path"": ""src/bits.c""}]}, {""source"": ""caller_info(file:decode_r2007.c, func:obj_string_stream)"", ""result"": [{""call_line"": 4363, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Entity *restrict ent)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = ent->dwg;\n  Dwg_Object *obj = &dwg->object[ent->objid];\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Class *klass = NULL;\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  PRE (R_13)\n  {\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat); // until the handles\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte-2, dat->bit);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    // skip for all types without strings\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      ent->num_eed = 0;\n      ent->preview_exists = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\"", ARGS_H (obj->handle))\n  LOG_INSANE (\"" @%lu.%u\"", dat->byte, dat->bit)\n  LOG_TRACE (\""\\n\"")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n  LOG_INSANE (\"" @%lu.%u\\n\"", dat->byte, dat->bit)\n  //LOG_TRACE (\""\\n\"")\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  // clang-format off\n  #include \""common_entity_data.spec\""\n  // clang-format on\n\n  dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);\n\n  // elsewhere: object data, handles, padding bits, crc\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""caller_start"": 4305, ""file_path"": ""src/decode.c""}, {""call_line"": 4464, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Object *restrict _obj)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = _obj->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->objid];\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0; // first possibly fatal problem\n  BITCODE_BL vcount;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte - 2, dat->bit)\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n        LOG_HANDLE (\"" (fixed)\"");\n      }\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      obj->tio.object->num_eed = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\\n\"", ARGS_H (obj->handle))\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, _obj);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: %u [RL]\\n\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n\n  // clang-format off\n  #include \""common_object_handle_data.spec\""\n  // clang-format on\n\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""caller_start"": 4419, ""file_path"": ""src/decode.c""}, {""call_line"": 4189, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat || !ent)\n    return DWG_ERR_INVALIDDWG;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\""bitsize: %u [RL] (@%lu.%lu)\\n\"", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  obj->was_bitsize_set = 0;\n  if (obj->bitsize)\n    {\n      obj->hdlpos = (obj->address * 8) + obj->bitsize;\n    }\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\""(bitsize: \"" FORMAT_RL \"", \"", obj->bitsize);\n          LOG_HANDLE (\""hdlpos: %lu\\n\"", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\"", ARGS_H (obj->handle))\n  LOG_INSANE (\"" @%lu.%u\"", dat->byte - obj->address, dat->bit)\n  LOG_TRACE (\""\\n\"")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \""common_entity_data.spec\""\n  // clang-format on\n\n  return error;\n}\n"", ""caller_start"": 4127, ""file_path"": ""src/encode.c""}, {""call_line"": 4325, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  BITCODE_BL vcount;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  {\n    Dwg_Object *_obj = obj;\n    VERSIONS (R_2000, R_2007)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n    obj->was_bitsize_set = 0;\n    if (obj->bitsize)\n      // the handle stream offset\n      obj->hdlpos = bit_position (dat) + obj->bitsize;\n    SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n    if (!_obj || !obj->tio.object)\n      return DWG_ERR_INVALIDDWG;\n\n    bit_write_H (dat, &obj->handle);\n    LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\\n\"", ARGS_H (obj->handle));\n    error |= dwg_encode_eed (dat, obj);\n\n    VERSIONS (R_13, R_14)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n  }\n\n  SINCE (R_13) {\n    Dwg_Object_Object *_obj = obj->tio.object;\n    FIELD_BL (num_reactors, 0);\n    SINCE (R_2004) { FIELD_B (is_xdic_missing, 0); }\n    SINCE (R_2013) { FIELD_B (has_ds_data, 0); } // AcDs DATA\n  }\n  return error;\n}\n"", ""caller_start"": 4303, ""file_path"": ""src/encode.c""}]}, {""source"": ""code_info(file:decode.c, lines:4363-4375)"", ""result"": ""      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n""}, {""source"": ""code_info(file:decode.c, lines:4464-4475)"", ""result"": ""      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n""}, {""source"": ""value_info(file:bits.c, value:chain)"", ""result"": {""value_trace"": [{""full_code"": ""*chain = (BITCODE_RC *)calloc (length + 1, 1)"", ""line"": 1444, ""func_name"": ""bit_read_TF""}, {""full_code"": ""*restrict chain = (BITCODE_RC *)calloc (bytes + (rest ? 2 : 1), 1)"", ""line"": 1468, ""func_name"": ""bit_read_bits""}, {""full_code"": ""chain = (unsigned char *)malloc (length + 1)"", ""line"": 1523, ""func_name"": ""bit_read_TV""}, {""full_code"": ""chain = (BITCODE_TU)malloc ((length + 1) * 2)"", ""line"": 1893, ""func_name"": ""bit_read_TU""}, {""full_code"": ""chain = (BITCODE_TV)malloc (length + 1)"", ""line"": 1919, ""func_name"": ""bit_read_T16""}], ""struct_var"": ""chain"", ""struct_type"": ""BITCODE_RC*"", ""struct_definition"": ""typedef unsigned char BITCODE_RC;""}}, {""source"": ""value_info(file:bits.c, value:byte)"", ""result"": {""value_trace"": [{""full_code"": ""byte = dat->chain[dat->byte]"", ""line"": 153, ""func_name"": ""bit_read_B""}, {""full_code"": ""byte = dat->chain[dat->byte]"", ""line"": 185, ""func_name"": ""bit_read_BB""}, {""full_code"": ""byte = dat->chain[dat->byte + 1]"", ""line"": 193, ""func_name"": ""bit_read_BB""}, {""full_code"": ""byte = dat->chain[dat->byte]"", ""line"": 212, ""func_name"": ""bit_write_BB""}, {""full_code"": ""byte = dat->chain[dat->byte + 1]"", ""line"": 223, ""func_name"": ""bit_write_BB""}], ""struct_var"": ""byte"", ""struct_type"": ""unsigned char"", ""struct_definition"": ""unsigned char""}}, {""source"": ""value_info(file:bits.c, value:size)"", ""result"": {""value_trace"": [{""full_code"": ""size = handle->code << 4"", ""line"": 1288, ""func_name"": ""bit_write_H""}, {""full_code"": ""size |= i + 1"", ""line"": 1289, ""func_name"": ""bit_write_H""}, {""full_code"": ""size = dat->byte - start_address"", ""line"": 1339, ""func_name"": ""bit_check_CRC""}, {""full_code"": ""size = dat->byte - start_address"", ""line"": 1376, ""func_name"": ""bit_write_CRC""}, {""full_code"": ""size = dat->byte - start_address"", ""line"": 1401, ""func_name"": ""bit_write_CRC_LE""}], ""struct_var"": ""size"", ""struct_type"": ""unsigned char"", ""struct_definition"": ""unsigned char""}}, {""source"": ""caller_info(file:bits.c, func:bit_read_BB)"", ""result"": [{""call_line"": 525, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BS\nbit_read_BS (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    {\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      return bit_read_RS (dat);\n    }\n  else if (two_bit_code == 1)\n    return (BITCODE_BS)bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    return 256;\n}"", ""caller_start"": 522, ""file_path"": ""src/bits.c""}, {""call_line"": 567, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BL\nbit_read_BL (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    {\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      return bit_read_RL (dat);\n    }\n  else if (two_bit_code == 1)\n    return (BITCODE_BL)bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\""bit_read_BL: unexpected 2-bit code: '11'\"")\n      return 256;\n    }\n}"", ""caller_start"": 564, ""file_path"": ""src/bits.c""}, {""call_line"": 634, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BS\nbit_read_BOT (Bit_Chain *dat)\n{\n  unsigned char two_bit_code;\n\n  two_bit_code = bit_read_BB (dat);\n\n  if (two_bit_code == 0)\n    {\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      return bit_read_RC (dat);\n    }\n  else if (two_bit_code == 1)\n    return bit_read_RC (dat) + 0x1f0;\n  else\n    return bit_read_RS (dat);\n}"", ""caller_start"": 629, ""file_path"": ""src/bits.c""}, {""call_line"": 680, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BLL\nbit_read_BLL (Bit_Chain *dat)\n{\n  unsigned int i, len;\n  BITCODE_BLL result = 0ULL;\n  len = bit_read_BB (dat) << 1 | bit_read_B (dat);\n  switch (len)\n    {\n    case 1:\n      return bit_read_RC (dat);\n    case 2:\n      return bit_read_RS (dat);\n    case 4:\n      return bit_read_RL (dat);\n    default:\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      for (i = 0; i < len; i++)\n        {\n          result <<= 8;\n          result |= bit_read_RC (dat);\n        }\n      return result;\n    }\n}"", ""caller_start"": 675, ""file_path"": ""src/bits.c""}]}, {""source"": ""func_info(file:decode.c, func:dwg_decode_entity)"", ""result"": [{""code"": ""static int\ndwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Entity *restrict ent)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = ent->dwg;\n  Dwg_Object *obj = &dwg->object[ent->objid];\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Class *klass = NULL;\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  PRE (R_13)\n  {\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat); // until the handles\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte-2, dat->bit);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    // skip for all types without strings\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      ent->num_eed = 0;\n      ent->preview_exists = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\"", ARGS_H (obj->handle))\n  LOG_INSANE (\"" @%lu.%u\"", dat->byte, dat->bit)\n  LOG_TRACE (\""\\n\"")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n  LOG_INSANE (\"" @%lu.%u\\n\"", dat->byte, dat->bit)\n  //LOG_TRACE (\""\\n\"")\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  // clang-format off\n  #include \""common_entity_data.spec\""\n  // clang-format on\n\n  dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);\n\n  // elsewhere: object data, handles, padding bits, crc\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""start_line"": 4305, ""end_line"": 4412, ""full_name"": ""dwg_decode_entity"", ""file_path"": ""src/decode.c""}]}, {""source"": ""func_info(file:decode.c, func:dwg_decode_object)"", ""result"": [{""code"": ""static int\ndwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Object *restrict _obj)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = _obj->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->objid];\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0; // first possibly fatal problem\n  BITCODE_BL vcount;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte - 2, dat->bit)\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n        LOG_HANDLE (\"" (fixed)\"");\n      }\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      obj->tio.object->num_eed = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\\n\"", ARGS_H (obj->handle))\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, _obj);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: %u [RL]\\n\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n\n  // clang-format off\n  #include \""common_object_handle_data.spec\""\n  // clang-format on\n\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""start_line"": 4419, ""end_line"": 4520, ""full_name"": ""dwg_decode_object"", ""file_path"": ""src/decode.c""}]}, {""source"": ""value_info(file:decode.c, value:error)"", ""result"": {""value_trace"": [{""full_code"": ""error = 0"", ""line"": 302, ""func_name"": ""decode_preR13_section""}, {""full_code"": ""error = dwg_decode_eed (dat, (Dwg_Object_Object *)ent)"", ""line"": 632, ""func_name"": ""decode_entity_preR13""}, {""full_code"": ""error = 0"", ""line"": 651, ""func_name"": ""decode_preR13""}, {""full_code"": ""error |= decode_preR13_entities (entities_start, entities_end, 0, dat, dwg)"", ""line"": 731, ""func_name"": ""decode_preR13""}, {""full_code"": ""error |= decode_preR13_section (SECTION_BLOCK, dat, dwg)"", ""line"": 735, ""func_name"": ""decode_preR13""}], ""struct_var"": ""error"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","src/decode_r2007.c:1308-1313 (overflow in `obj_string_stream` leaves `dat->byte` unbounded) → src/bits.c:185-193 (bit_read_BB accesses `dat->chain[dat->byte]` without bounds validation). Triggered when `obj_string_stream` returns an error but `dwg_decode_entity`/`dwg_decode_object` (src/decode.c:4363-4375, 4464-4475) continue processing, passing corrupted `Bit_Chain` to `bit_read_H` (src/bits.c:525, 567, etc.).",0.95,./github/other_context/CVE-2021-39521
37,CVE-2021-44108,"CWE-787, CWE-476",c_cpp,A null pointer dereference in src/amf/namf-handler.c in Open5GS 2.3.6 and earlier allows remote attackers to Denial of Service via a crafted sbi request to amf.,https://github.com/open5gs/open5gs/commit/d919b2744cd05abae043490f0a3dd1946c1ccb8c,[AMF] fix the memory problem (#1247)\n\n1. memory corruption\n- Overflow num_of_part in SBI message\n2. null pointer dereference\n- n2InfoContent->ngap_ie_type,5,"[{""func_name"": ""on_header_value"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown header field [%s]\"", data->header_field);\n        END\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""on_part_data_end"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""parse_multipart"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\""Invalid HTTP content [%d]\"", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown content-type[%s]\"", data.part[i].content_type);\n        END\n    }\n\n    if (data.part[i].content_id)\n        ogs_free(data.part[i].content_id);\n    if (data.part[i].content_type)\n        ogs_free(data.part[i].content_type);\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}"", ""target"": 0}, {""func_name"": ""on_part_data"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\""Overflow length [%d:%d]\"",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\""Unknown content_type [%s]\"",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""amf_namf_comm_handle_n1_n2_message_transfer"", ""file_path"": ""src/amf/namf-handler.c"", ""func_code"": ""int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\""No N1N2MessageTransferReqData\"");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\""No PDU Session Identity\"");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\""No SUPI\"");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\""No UE context [%s]\"", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\""[%s] No PDU Session Context [%d]\"",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\""No n1MessageContent\"");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\""No smInfo\"");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\""No n2InfoContent\"");\n            return OGS_ERROR;\n        }\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\""No ngapData\"");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (n2InfoContent->ngap_ie_type) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\""[%s:%d] No n1-n2-failure-notification-uri\"",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\""[%s:%d] Invalid URI [%s]\"",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\""[%s] No skipInd\"", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\""Not implemented ngap_ie_type[%d]\"",\n                n2InfoContent->ngap_ie_type);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}"", ""target"": 0}]","[{""func_name"": ""on_header_value"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            ogs_assert(data->part[data->num_of_part].content_type == NULL);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            ogs_assert(data->part[data->num_of_part].content_id == NULL);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown header field [%s]\"", data->header_field);\n        END\n    }\n\n    return 0;\n}""}, {""func_name"": ""on_part_data_end"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n        data->num_of_part++;\n    }\n\n    return 0;\n}""}, {""func_name"": ""parse_multipart"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\""Invalid HTTP content [%d]\"", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    if (data.num_of_part > OGS_SBI_MAX_NUM_OF_PART) {\n        /* Overflow Issues #1247 */\n        ogs_fatal(\""Overflow num_of_part[%d]\"", data.num_of_part);\n        ogs_assert_if_reached();\n    }\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown content-type[%s]\"", data.part[i].content_type);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n        END\n    }\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}""}, {""func_name"": ""on_part_data"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\""Overflow length [%d:%d]\"",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown content_type [%s]\"",\n                    data->part[data->num_of_part].content_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, (unsigned char *)at, length);\n        END\n    }\n    return 0;\n}""}, {""func_name"": ""amf_namf_comm_handle_n1_n2_message_transfer"", ""file_path"": ""src/amf/namf-handler.c"", ""func_code"": ""int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\""No N1N2MessageTransferReqData\"");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\""No PDU Session Identity\"");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\""No SUPI\"");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\""No UE context [%s]\"", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\""[%s] No PDU Session Context [%d]\"",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\""No n1MessageContent\"");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\""No smInfo\"");\n            return OGS_ERROR;\n        }\n\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\""No n2InfoContent\"");\n            return OGS_ERROR;\n        }\n\n        ngapIeType = n2InfoContent->ngap_ie_type;\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\""No ngapData\"");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (ngapIeType) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\""[%s:%d] No n1-n2-failure-notification-uri\"",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\""[%s:%d] Invalid URI [%s]\"",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\""[%s] No skipInd\"", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\""Not implemented ngapIeType[%d]\"", ngapIeType);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}""}]","{""function"": 2, ""code"": 2, ""caller"": 1}","[{""source"": ""func_info(func:multipart_parser_get_data)"", ""result"": [{""code"": ""void *multipart_parser_get_data(multipart_parser *p) {\n    return p->data;\n}"", ""start_line"": 106, ""end_line"": 108, ""full_name"": ""multipart_parser_get_data"", ""file_path"": ""lib/sbi/contrib/multipart_parser.c""}]}, {""source"": ""code_info(file:message.c, lines:100-200)"", ""result"": ""    if (message->Amf3GppAccessRegistration)\n        OpenAPI_amf3_gpp_access_registration_free(\n                message->Amf3GppAccessRegistration);\n    if (message->AccessAndMobilitySubscriptionData)\n        OpenAPI_access_and_mobility_subscription_data_free(\n                message->AccessAndMobilitySubscriptionData);\n    if (message->SmfSelectionSubscriptionData)\n        OpenAPI_smf_selection_subscription_data_free(\n                message->SmfSelectionSubscriptionData);\n    if (message->UeContextInSmfData)\n        OpenAPI_ue_context_in_smf_data_free(message->UeContextInSmfData);\n    if (message->SmContextCreateData)\n        OpenAPI_sm_context_create_data_free(message->SmContextCreateData);\n    if (message->SmContextCreatedData)\n        OpenAPI_sm_context_created_data_free(message->SmContextCreatedData);\n    if (message->SmContextCreateError)\n        OpenAPI_sm_context_create_error_free(message->SmContextCreateError);\n    if (message->SmContextUpdateData)\n        OpenAPI_sm_context_update_data_free(message->SmContextUpdateData);\n    if (message->SmContextUpdatedData)\n        OpenAPI_sm_context_updated_data_free(message->SmContextUpdatedData);\n    if (message->SmContextUpdateError)\n        OpenAPI_sm_context_update_error_free(message->SmContextUpdateError);\n    if (message->SmContextReleaseData)\n        OpenAPI_sm_context_release_data_free(message->SmContextReleaseData);\n    if (message->SmContextReleasedData)\n        OpenAPI_sm_context_released_data_free(message->SmContextReleasedData);\n    if (message->SessionManagementSubscriptionData)\n        OpenAPI_session_management_subscription_data_free(\n                message->SessionManagementSubscriptionData);\n    if (message->N1N2MessageTransferReqData)\n        OpenAPI_n1_n2_message_transfer_req_data_free(\n                message->N1N2MessageTransferReqData);\n    if (message->N1N2MessageTransferRspData)\n        OpenAPI_n1_n2_message_transfer_rsp_data_free(\n                message->N1N2MessageTransferRspData);\n    if (message->N1N2MsgTxfrFailureNotification)\n        OpenAPI_n1_n2_msg_txfr_failure_notification_free(\n                message->N1N2MsgTxfrFailureNotification);\n    if (message->SmContextStatusNotification)\n        OpenAPI_sm_context_status_notification_free(\n                message->SmContextStatusNotification);\n    if (message->PolicyAssociationRequest)\n        OpenAPI_policy_association_request_free(\n                message->PolicyAssociationRequest);\n    if (message->PolicyAssociation)\n        OpenAPI_policy_association_free(message->PolicyAssociation);\n    if (message->AmPolicyData)\n        OpenAPI_am_policy_data_free(message->AmPolicyData);\n    if (message->SmPolicyContextData)\n        OpenAPI_sm_policy_context_data_free(message->SmPolicyContextData);\n    if (message->SmPolicyDecision)\n        OpenAPI_sm_policy_decision_free(message->SmPolicyDecision);\n    if (message->SmPolicyData)\n        OpenAPI_sm_policy_data_free(message->SmPolicyData);\n    if (message->SmPolicyDeleteData)\n        OpenAPI_sm_policy_delete_data_free(message->SmPolicyDeleteData);\n    if (message->AuthorizedNetworkSliceInfo)\n        OpenAPI_authorized_network_slice_info_free(\n                message->AuthorizedNetworkSliceInfo);\n    if (message->PcfBinding)\n        OpenAPI_pcf_binding_free(message->PcfBinding);\n    if (message->AppSessionContext)\n        OpenAPI_app_session_context_free(message->AppSessionContext);\n    if (message->AppSessionContextUpdateDataPatch)\n        OpenAPI_app_session_context_update_data_patch_free(message->AppSessionContextUpdateDataPatch);\n    if (message->SmPolicyNotification)\n        OpenAPI_sm_policy_notification_free(message->SmPolicyNotification);\n    if (message->TerminationNotification)\n        OpenAPI_termination_notification_free(message->TerminationNotification);\n\n    for (i = 0; i < message->num_of_part; i++) {\n        if (message->part[i].pkbuf)\n            ogs_pkbuf_free(message->part[i].pkbuf);\n    }\n}\n\nogs_sbi_request_t *ogs_sbi_request_new(void)\n{\n    ogs_sbi_request_t *request = NULL;\n\n    ogs_pool_alloc(&request_pool, &request);\n    ogs_expect_or_return_val(request, NULL);\n    memset(request, 0, sizeof(ogs_sbi_request_t));\n\n    request->http.params = ogs_hash_make();\n    ogs_expect_or_return_val(request->http.params, NULL);\n    request->http.headers = ogs_hash_make();\n    ogs_expect_or_return_val(request->http.headers, NULL);\n\n    return request;\n}\n\nogs_sbi_response_t *ogs_sbi_response_new(void)\n{\n    ogs_sbi_response_t *response = NULL;\n\n    ogs_pool_alloc(&response_pool, &response);\n    ogs_expect_or_return_val(response, NULL);\n    memset(response, 0, sizeof(ogs_sbi_response_t));\n\n    response->http.params = ogs_hash_make();\n""}, {""source"": ""caller_info(func:amf_namf_comm_handle_n1_n2_message_transfer)"", ""result"": [{""call_line"": 162, ""call_code"": ""amf_namf_comm_handle_n1_n2_message_transfer(\n                                stream, &sbi_message)"", ""caller_code"": ""void amf_state_operational(ogs_fsm_t *s, amf_event_t *e)\n{\n    int rv;\n    char buf[OGS_ADDRSTRLEN];\n    const char *api_version = NULL;\n\n    ogs_sock_t *sock = NULL;\n    ogs_sockaddr_t *addr = NULL;\n    amf_gnb_t *gnb = NULL;\n    uint16_t max_num_of_ostreams = 0;\n\n    ogs_ngap_message_t ngap_message;\n    ogs_pkbuf_t *pkbuf = NULL;\n    int rc;\n\n    ogs_nas_5gs_message_t nas_message;\n    ran_ue_t *ran_ue = NULL;\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_sbi_object_t *sbi_object = NULL;\n    ogs_sbi_xact_t *sbi_xact = NULL;\n    int state = AMF_CREATE_SM_CONTEXT_NO_STATE;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *sbi_request = NULL;\n    OpenAPI_nf_type_e target_nf_type = OpenAPI_nf_type_NULL;\n\n    ogs_sbi_nf_instance_t *nf_instance = NULL;\n    ogs_sbi_subscription_t *subscription = NULL;\n    ogs_sbi_response_t *sbi_response = NULL;\n    ogs_sbi_message_t sbi_message;\n\n    amf_sm_debug(e);\n\n    ogs_assert(s);\n\n    switch (e->id) {\n    case OGS_FS..."", ""caller_start"": 46, ""file_path"": ""src/amf/amf-sm.c""}]}, {""source"": ""func_info(file:multipart_parser.c, func:multipart_parser_init)"", ""result"": [{""code"": ""multipart_parser* multipart_parser_init\n    (const char *boundary, const multipart_parser_settings* settings) {\n\n  multipart_parser* p = malloc(sizeof(multipart_parser) +\n                             "", ""start_line"": 79, ""end_line"": 96, ""full_name"": ""multipart_parser_init"", ""file_path"": ""lib/sbi/contrib/multipart_parser.c""}]}, {""source"": ""code_info(file:namf-handler.c, lines:50-120)"", ""result"": ""    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\""No N1N2MessageTransferReqData\"");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\""No PDU Session Identity\"");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\""No SUPI\"");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\""No UE context [%s]\"", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\""[%s] No PDU Session Context [%d]\"",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\""No n1MessageContent\"");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\""No smInfo\"");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n""}]","1. **Multipart Parsing Overflow**: Unchecked increment of `data->num_of_part` (lib/sbi/message.c:1918) during multipart parsing risks overflow beyond `OGS_SBI_MAX_NUM_OF_PART`, causing out-of-bounds access in `data->part[]` (lib/sbi/message.c:1834, 1868). The `multipart_parser_init` (lib/sbi/contrib/multipart_parser.c:79-96) initializes `data->num_of_part` to 0, and the patch adds bounds checks. 2. **Null Dereference**: `n2InfoContent->ngap_ie_type` (src/amf/namf-handler.c:118) is dereferenced without null check; the patch caches this value in `ngapIeType` (src/amf/namf-handler.c:54). `n2InfoContent` is populated from `smInfo->n2_info_content` (src/amf/namf-handler.c:118) in the SBI request. The chain is complete with all evidence.",1.0,./github/other_context/CVE-2021-44108
38,CVE-2021-44758,CWE-476,c_cpp,Heimdal before 7.7.1 allows attackers to cause a NULL pointer dereference in a SPNEGO acceptor via a preferred_mech_type of GSS_C_NO_OID and a nonzero initial_response value to send_accept.,https://github.com/heimdal/heimdal/commit/f9ec7002cdd526ae84fbacbf153162e118f22580,"spnego: CVE-2021-44758 send_reject when no mech selected\n\nThis fixes a DoS where an initial SPNEGO token that has no acceptable\nmechanisms causes a NULL dereference in acceptors.\n\nsend_accept() when called with a non-zero 'initial_response' did\nnot handle the case of gssspnego_ctx.preferred_mech_type equal\nto GSS_C_NO_OID.\n\nThe failure to handle GSS_C_NO_OID has been present since the\ninitial revision of gssapi/spnego,\n2baa7e7d613c26b2b037b368931519a84baec53d but might not have\nbeen exercised until later revisions.\n\nThe introduction of opportunistic token handling in\ngss_accept_sec_context(), 3c9d3266f47f594a29068c9d629908e7000ac663,\nintroduced two bugs:\n\n 1. The optional mechToken field is used unconditionally\n    possibly resulting in a segmentation fault.\n\n 2. If use of the opportunistic token is unsuccessful and the\n    mech type list length is one, send_accept() can be called\n    with 'initial_response' true and preferred mech set to\n    GSS_C_NO_OID.\n\nb53c90da0890a9cce6f95c552f094ff6d69027bf (""Make error reporting\nsomewhat more correct for SPNEGO"") attempted to fix the first\nissue and increased the likelihood of the second.\n\nThis change alters the behavior of acceptor_start() so it calls\nsend_reject() when no mechanism was selected.",1,"[{""func_name"": ""GSSAPI_CALLCONV"", ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c"", ""func_code"": ""static OM_uint32 GSSAPI_CALLCONV\nacceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_alloc_sec_context(minor_status, context_handle);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n    ret = gss_decapsulate_token (input_token_buffer,\n\t\t\t\t GSS_SPNEGO_MECHANISM,\n\t\t\t\t &data);\n    if (ret)\n\treturn ret;\n\n    ret = decode_NegotiationToken(data.value, data.length, &nt, &nt_len);\n    gss_release_buffer(minor_status, &data);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenInit) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    ni = &nt.u.negTokenInit;\n\n    if (ni->mechTypes.len < 1) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    ret = copy_MechTypeList(&ni->mechTypes, &ctx->initiator_mech_types);\n    if (ret) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * First we try the opportunistic token if we have support for it,\n     * don't try to verify we have credential for the token,\n     * gss_accept_sec_context() will (hopefully) tell us that.\n     * If that failes,\n     */\n\n    ret = select_mech(minor_status,\n\t\t      &ni->mechTypes.val[0],\n\t\t      0,\n\t\t      &preferred_mech_type);\n\n    if (ret == 0 && ni->mechToken != NULL) {\n\tgss_buffer_desc ibuf;\n\n\tibuf.length = ni->mechToken->length;\n\tibuf.value = ni->mechToken->data;\n\tmech_input_token = &ibuf;\n\n\tif (ctx->mech_src_name != GSS_C_NO_NAME)\n\t    gss_release_name(&junk, &ctx->mech_src_name);\n\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &ctx->negotiated_ctx_id,\n\t\t\t\t     acceptor_cred_handle,\n\t\t\t\t     mech_input_token,\n\t\t\t\t     input_chan_bindings,\n\t\t\t\t     &ctx->mech_src_name,\n\t\t\t\t     &ctx->negotiated_mech_type,\n\t\t\t\t     &mech_output_token,\n\t\t\t\t     &ctx->mech_flags,\n\t\t\t\t     &ctx->mech_time_rec,\n\t\t\t\t     delegated_cred_handle);\n\n\tif (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t    ctx->preferred_mech_type = preferred_mech_type;\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    &mech_output_token,\n\t\t\t\t    ni->mechListMIC,\n\t\t\t\t    output_token);\n\t    if (ret != GSS_S_COMPLETE)\n\t\tgoto out;\n\n\t    first_ok = 1;\n\t} else {\n\t    gss_mg_collect_error(preferred_mech_type, ret, *minor_status);\n\t}\n    }\n\n    /*\n     * If opportunistic token failed, lets try the other mechs.\n     */\n\n    if (!first_ok && ni->mechToken != NULL) {\n\tsize_t j;\n\n\tpreferred_mech_type = GSS_C_NO_OID;\n\n\t/* Call glue layer to find first mech we support */\n\tfor (j = 1; j < ni->mechTypes.len; ++j) {\n\t    ret = select_mech(minor_status,\n\t\t\t      &ni->mechTypes.val[j],\n\t\t\t      1,\n\t\t\t      &preferred_mech_type);\n\t    if (ret == 0)\n\t\tbreak;\n\t}\n\tif (preferred_mech_type == GSS_C_NO_OID) {\n\t    HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\t    free_NegotiationToken(&nt);\n\t    return ret;\n\t}\n\n\tctx->preferred_mech_type = preferred_mech_type;\n    }\n\n    /*\n     * The initial token always have a response\n     */\n\n    ret = send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token);\n    if (ret)\n\tgoto out;\n\nout:\n    if (mech_output_token.value != NULL)\n\tgss_release_buffer(&junk, &mech_output_token);\n    if (mech_buf.value != NULL) {\n\tfree(mech_buf.value);\n\tmech_buf.value = NULL;\n    }\n    free_NegotiationToken(&nt);\n\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&junk, context_handle,\n\t\t\t\t\t    GSS_C_NO_BUFFER);\n\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""GSSAPI_CALLCONV"", ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c"", ""func_code"": ""static OM_uint32 GSSAPI_CALLCONV\nacceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_alloc_sec_context(minor_status, context_handle);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n    ret = gss_decapsulate_token (input_token_buffer,\n\t\t\t\t GSS_SPNEGO_MECHANISM,\n\t\t\t\t &data);\n    if (ret)\n\treturn ret;\n\n    ret = decode_NegotiationToken(data.value, data.length, &nt, &nt_len);\n    gss_release_buffer(minor_status, &data);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenInit) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    ni = &nt.u.negTokenInit;\n\n    if (ni->mechTypes.len < 1) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    ret = copy_MechTypeList(&ni->mechTypes, &ctx->initiator_mech_types);\n    if (ret) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * First we try the opportunistic token if we have support for it,\n     * don't try to verify we have credential for the token,\n     * gss_accept_sec_context() will (hopefully) tell us that.\n     * If that failes,\n     */\n\n    ret = select_mech(minor_status,\n\t\t      &ni->mechTypes.val[0],\n\t\t      0,\n\t\t      &preferred_mech_type);\n\n    if (ret == 0 && ni->mechToken != NULL) {\n\tgss_buffer_desc ibuf;\n\n\tibuf.length = ni->mechToken->length;\n\tibuf.value = ni->mechToken->data;\n\tmech_input_token = &ibuf;\n\n\tif (ctx->mech_src_name != GSS_C_NO_NAME)\n\t    gss_release_name(&junk, &ctx->mech_src_name);\n\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &ctx->negotiated_ctx_id,\n\t\t\t\t     acceptor_cred_handle,\n\t\t\t\t     mech_input_token,\n\t\t\t\t     input_chan_bindings,\n\t\t\t\t     &ctx->mech_src_name,\n\t\t\t\t     &ctx->negotiated_mech_type,\n\t\t\t\t     &mech_output_token,\n\t\t\t\t     &ctx->mech_flags,\n\t\t\t\t     &ctx->mech_time_rec,\n\t\t\t\t     delegated_cred_handle);\n\n\tif (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t    ctx->preferred_mech_type = preferred_mech_type;\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    &mech_output_token,\n\t\t\t\t    ni->mechListMIC,\n\t\t\t\t    output_token);\n\t    if (ret != GSS_S_COMPLETE)\n\t\tgoto out;\n\n\t    first_ok = 1;\n\t} else {\n\t    gss_mg_collect_error(preferred_mech_type, ret, *minor_status);\n\t}\n    }\n\n    /*\n     * If opportunistic token failed, lets try the other mechs.\n     */\n\n    if (!first_ok && ni->mechToken != NULL) {\n\tsize_t j;\n\n\tpreferred_mech_type = GSS_C_NO_OID;\n\n\t/* Call glue layer to find first mech we support */\n\tfor (j = 1; j < ni->mechTypes.len; ++j) {\n\t    ret = select_mech(minor_status,\n\t\t\t      &ni->mechTypes.val[j],\n\t\t\t      1,\n\t\t\t      &preferred_mech_type);\n\t    if (ret == 0)\n\t\tbreak;\n\t}\n    }\n\n    ctx->preferred_mech_type = preferred_mech_type;\n\n    if (preferred_mech_type == GSS_C_NO_OID) {\n        send_reject(minor_status, output_token);\n        HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n        free_NegotiationToken(&nt);\n        return ret;\n    }\n\n    /*\n     * The initial token always have a response\n     */\n\n    ret = send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token);\n    if (ret)\n\tgoto out;\n\nout:\n    if (mech_output_token.value != NULL)\n\tgss_release_buffer(&junk, &mech_output_token);\n    if (mech_buf.value != NULL) {\n\tfree(mech_buf.value);\n\tmech_buf.value = NULL;\n    }\n    free_NegotiationToken(&nt);\n\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&junk, context_handle,\n\t\t\t\t\t    GSS_C_NO_BUFFER);\n\n    return ret;\n}""}]","{""code"": 1, ""function"": 1, ""caller"": 1}","[{""source"": ""code_info(file:accept_sec_context.c, lines:145-150)"", ""result"": ""\treturn ret;\n\n    *minor_status = 0;\n\n    return GSS_S_CONTINUE_NEEDED;\n}\n\n""}, {""source"": ""func_info(func:send_accept)"", ""result"": [{""code"": ""static OM_uint32\nsend_accept (OM_uint32 *minor_status,\n\t     gssspnego_ctx context_handle,\n\t     gss_buffer_t mech_token,\n\t     int initial_response,\n\t     gss_buffer_t mech_buf,\n\t     gss_buffer_t ou"", ""start_line"": 152, ""end_line"": 272, ""full_name"": ""send_accept"", ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c""}]}, {""source"": ""caller_info(file:accept_sec_context.c, func:send_accept)"", ""result"": [{""call_line"": 635, ""call_code"": ""send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token)"", ""caller_code"": ""acceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_all..."", ""caller_start"": 470, ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c""}, {""call_line"": 822, ""call_code"": ""send_accept (minor_status,\n\t\t\t\tctx,\n\t\t\t\tmech_output_token,\n\t\t\t\t0,\n\t\t\t\tget_mic ? &mech_buf : NULL,\n\t\t\t\toutput_token)"", ""caller_code"": ""acceptor_continue\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, ret2, minor;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenResp *na;\n    unsigned int negResult = accept_incomplete;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_t mech_output_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_buf;\n    gssspnego_ctx ctx;\n\n    mech_buf.value = NULL;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n\n    ret = decode_NegotiationToken(input_token_buffer->value,\n\t\t\t\t  input_token_b..."", ""caller_start"": 687, ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c""}]}]","The vulnerability is triggered by an initial SPNEGO token with no acceptable mechanisms. In `acceptor_start` (lib/gssapi/spnego/accept_sec_context.c:470), `preferred_mech_type` is initialized to `GSS_C_NO_OID` and remains unset if no valid mechanism is found. This value is assigned to `ctx->preferred_mech_type` (lib/gssapi/spnego/accept_sec_context.c:151-163). The `send_accept` call from `acceptor_start` (lib/gssapi/spnego/accept_sec_context.c:635) sets `initial_response=1`. The patch introduces a check after assignment to call `send_reject()` if `preferred_mech_type` is `GSS_C_NO_OID`, preventing the NULL dereference in `send_accept`.",1.0,./github/other_context/CVE-2021-44758
39,CVE-2022-1283,CWE-476,c_cpp,NULL Pointer Dereference in r_bin_ne_get_entrypoints function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability allows attackers to cause a denial of service (application crash).,https://github.com/radareorg/radare2/commit/18d1d064bf599a255d55f09fca3104776fc34a67,Fix null deref in the ne parser ##crash\n\n* Reported by @hmsec via huntr.dev\n* Reproducer: nepoc00\n* BountyID: bfeb8fb8-644d-4587-80d4-cb704c404013,2,"[{""func_name"": ""r_bin_ne_get_entrypoints"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}"", ""target"": 0}, {""func_name"": ""r_bin_ne_get_symbols"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (true) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\""entry%d\"", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}"", ""target"": 0}]","[{""func_name"": ""r_bin_ne_get_entrypoints"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tif (!bin->entry_table) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}""}, {""func_name"": ""r_bin_ne_get_symbols"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (entries) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\""entry%d\"", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}""}]","{""code"": 1, ""query"": 1, ""value"": 1}","[{""source"": ""code_info(file:ne.c, lines:1-1000)"", ""result"": ""/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */\n\n#include \""ne.h\""\n#define NE_BUG 0\n\nstatic char *__get_target_os(r_bin_ne_obj_t *bin) {\n\tswitch (bin->ne_header->targOS) {\n\tcase 1:\n\t\treturn \""OS/2\"";\n\tcase 2:\n\t\treturn \""Windows\"";\n\tcase 3:\n\t\treturn \""European MS-DOS 4.x\"";\n\tcase 4:\n\t\treturn \""Windows 386\"";\n\tcase 5:\n\t\treturn \""BOSS (Borland Operating System Services)\"";\n\tdefault:\n\t\treturn \""Unknown\"";\n\t}\n}\n\nstatic int __translate_perms(int flags) {\n\tint perms = 0;\n\tif (flags & IS_RX) {\n\t\tif (flags & IS_DATA) {\n\t\t\tperms = R_PERM_R;\n\t\t} else {\n\t\t\tperms = R_PERM_X;\n\t\t}\n\t}\n\tif (!perms) {\n\t\tperms = R_PERM_RWX;\n\t}\n\treturn perms;\n}\n\nstatic char *__read_nonnull_str_at(RBuffer *buf, ut64 offset) {\n\tut8 sz = r_buf_read8_at (buf, offset);\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tchar *str = malloc ((ut64)sz + 1);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (buf, offset + 1, (ut8 *)str, sz);\n\tstr[sz] = '\\0';\n\treturn str;\n}\n\nstatic char *__func_name_from_ord(const char *module, ut16 ordinal) {\n\tif (!module) {\n\t\treturn NULL;\n\t}\n\tchar *lower_module = strdup (module);\n\tr_str_case (lower_module, false);\n\tchar *path = r_str_newf (R_JOIN_4_PATHS (\""%s\"", R2_SDB_FORMAT, \""dll\"", \""%s.sdb\""), r_sys_prefix (NULL), lower_module);\n\tfree (lower_module);\n\tchar *ord = r_str_newf (\""%d\"", ordinal);\n\tchar *name;\n\tif (r_file_exists (path)) {\n\t\tSdb *sdb = sdb_new (NULL, path, 0);\n\t\tname = sdb_get (sdb, ord, NULL);\n\t\tif (!name) {\n\t\t\tname = ord;\n\t\t} else {\n\t\t\tfree (ord);\n\t\t}\n\t\tsdb_close (sdb);\n\t\tfree (sdb);\n\t} else {\n\t\tname = ord;\n\t}\n\tfree (path);\n\treturn name;\n}\n\nRList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\""%s.%\"" PFMT64d, se->flags & IS_MOVEABLE ? \""MOVEABLE\"" : \""FIXED\"", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}\n\nstatic int __find_symbol_by_paddr(const void *paddr, const void *sym) {\n\treturn (int)!(*(ut64 *)paddr == ((RBinSymbol *)sym)->paddr);\n}\n\nRList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (true) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\""entry%d\"", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic char *__resource_type_str(int type) {\n\tchar *typeName;\n\tswitch (type) {\n\tcase 1:\n\t\ttypeName = \""CURSOR\"";\n\t\tbreak;\n\tcase 2:\n\t\ttypeName = \""BITMAP\"";\n\t\tbreak;\n\tcase 3:\n\t\ttypeName = \""ICON\"";\n\t\tbreak;\n\tcase 4:\n\t\ttypeName = \""MENU\"";\n\t\tbreak;\n\tcase 5:\n\t\ttypeName = \""DIALOG\"";\n\t\tbreak;\n\tcase 6:\n\t\ttypeName = \""STRING\"";\n\t\tbreak;\n\tcase 7:\n\t\ttypeName = \""FONTDIR\"";\n\t\tbreak;\n\tcase 8:\n\t\ttypeName = \""FONT\"";\n\t\tbreak;\n\tcase 9:\n\t\ttypeName = \""ACCELERATOR\"";\n\t\tbreak;\n\tcase 10:\n\t\ttypeName = \""RCDATA\"";\n\t\tbreak;\n\tcase 11:\n\t\ttypeName = \""MESSAGETABLE\"";\n\t\tbreak;\n\tcase 12:\n\t\ttypeName = \""GROUP_CURSOR\"";\n\t\tbreak;\n\tcase 14:\n\t\ttypeName = \""GROUP_ICON\"";\n\t\tbreak;\n\tcase 15:\n\t\ttypeName = \""NAMETABLE\"";\n\t\tbreak;\n\tcase 16:\n\t\ttypeName = \""VERSION\"";\n\t\tbreak;\n\tcase 17:\n\t\ttypeName = \""DLGINCLUDE\"";\n\t\tbreak;\n\tcase 19:\n\t\ttypeName = \""PLUGPLAY\"";\n\t\tbreak;\n\tcase 20:\n\t\ttypeName = \""VXD\"";\n\t\tbreak;\n\tcase 21:\n\t\ttypeName = \""ANICURSOR\"";\n\t\tbreak;\n\tcase 22:\n\t\ttypeName = \""ANIICON\"";\n\t\tbreak;\n\tcase 23:\n\t\ttypeName = \""HTML\"";\n\t\tbreak;\n\tcase 24:\n\t\ttypeName = \""MANIFEST\"";\n\t\tbreak;\n\tdefault:\n\t\treturn r_str_newf (\""UNKNOWN (%d)\"", type);\n\t}\n\treturn strdup (typeName);\n}\n\nstatic void __free_resource_entry(void *entry) {\n\tr_ne_resource_entry *en = (r_ne_resource_entry *)entry;\n\tfree (en->name);\n\tfree (en);\n}\n\nstatic void __free_resource(void *resource) {\n\tr_ne_resource *res = (r_ne_resource *)resource;\n\tfree (res->name);\n\tr_list_free (res->entry);\n\tfree (res);\n}\n\nstatic bool __ne_get_resources(r_bin_ne_obj_t *bin) {\n\tif (!bin->resources) {\n\t\tbin->resources = r_list_newf (__free_resource);\n\t}\n\tut16 resoff = bin->ne_header->ResTableOffset + bin->header_offset;\n\tut16 alignment = r_buf_read_le16_at (bin->buf, resoff);\n\tut32 off = resoff + 2;\n\twhile (true) {\n\t\tNE_image_typeinfo_entry ti = {0};\n\t\tr_ne_resource *res = R_NEW0 (r_ne_resource);\n\t\tif (!res) {\n\t\t\tbreak;\n\t\t}\n\t\tres->entry = r_list_newf (__free_resource_entry);\n\t\tif (!res->entry) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ti, sizeof (ti));\n\t\tif (!ti.rtTypeID) {\n\t\t\tbreak;\n\t\t} else if (ti.rtTypeID & 0x8000) {\n\t\t\tres->name = __resource_type_str (ti.rtTypeID & ~0x8000);\n\t\t} else {\n\t\t\t// Offset to resident name table\n\t\t\tres->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ti.rtTypeID);\n\t\t}\n\t\toff += sizeof (NE_image_typeinfo_entry);\n\t\tint i;\n\t\tfor (i = 0; i < ti.rtResourceCount; i++) {\n\t\t\tNE_image_nameinfo_entry ni;\n\t\t\tr_ne_resource_entry *ren = R_NEW0 (r_ne_resource_entry);\n\t\t\tif (!ren) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ni, sizeof (NE_image_nameinfo_entry));\n\t\t\tren->offset = ni.rnOffset << alignment;\n\t\t\tren->size = ni.rnLength;\n\t\t\tif (ni.rnID & 0x8000) {\n\t\t\t\tren->name = r_str_newf (\""%d\"", ni.rnID & ~0x8000);\n\t\t\t} else {\n\t\t\t\t// Offset to resident name table\n\t\t\t\tren->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ni.rnID);\n\t\t\t}\n\t\t\tr_list_append (res->entry, ren);\n\t\t\toff += sizeof (NE_image_nameinfo_entry);\n\t\t}\n\t\tr_list_append (bin->resources, res);\n\t}\n\treturn true;\n}\n\nRList *r_bin_ne_get_imports(r_bin_ne_obj_t *bin) {\n\tRList *imports = r_list_newf ((RListFree)r_bin_import_free);\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tut16 off = bin->ne_header->ImportNameTable + bin->header_offset + 1;\n\tint i;\n\tfor (i = 0; i < bin->ne_header->ModRefs; i++) {\n\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\tif (!imp) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tr_bin_import_free (imp);\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\timp->name = name;\n\t\timp->ordinal = i + 1;\n\t\tr_list_append (imports, imp);\n\t\toff += sz;\n\t}\n\tbin->imports = imports;\n\treturn imports;\n}\n\nRList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}\n\nRList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n#if NE_BUG\n\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t} else {\n\t\t\t\t\tname = r_str_newf (\""UnknownModule%d_%x\"", rel.index, off); // ????\n\t\t\t\t}\n#else\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\""UnknownModule%d_%x\"", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n#endif\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\""%s.%s\"", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\""%s.%s\"", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \""FIXED\"")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}\n\nvoid __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\t// XXX this is endian unsafe\n\tif (r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header)) < 1) {\n\t\tR_FREE (bin->ne_header);\n\t\treturn;\n\t}\n\tif (bin->ne_header->FileAlnSzShftCnt > 15) {\n\t\tbin->ne_header->FileAlnSzShftCnt = 15;\n\t}\n\tut64 from = bin->ne_header->ModRefTable + bin->header_offset;\n\tut64 left = r_buf_size (bin->buf) - from;\n\tif (from + bin->ne_header->ModRefs * sizeof (ut16) >= left) {\n\t\tbin->ne_header->ModRefs = left / sizeof (ut16);\n\t}\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tsize_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tif (offset >= r_buf_size (bin->buf)) {\n\t\treturn;\n\t}\n\tsize_t remaining = r_buf_size (bin->buf) - offset;\n\tsize = R_MIN (remaining, size);\n\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry); // * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (size >= remaining) {\n\t\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);\n\t}\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (4, bin->ne_header->EntryTableLength);\n\tif (!bin->entry_table) {\n\t\tR_FREE (bin->segment_entries);\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}\n\nvoid r_bin_ne_free(r_bin_ne_obj_t *bin) {\n\t// r_list_free (bin->imports); // double free\n\tr_list_free (bin->resources);\n\tfree (bin->entry_table);\n\tfree (bin->ne_header);\n\tfree (bin->resident_name_table);\n\tfree (bin->segment_entries);\n\tfree (bin);\n}\n\nr_bin_ne_obj_t *r_bin_ne_new_buf(RBuffer *buf, bool verbose) {\n\tr_bin_ne_obj_t *bin = R_NEW0 (r_bin_ne_obj_t);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t__init(buf, bin);\n\treturn bin;\n}\n""}, {""source"": ""query_info(query:cpg.method.where(_.ast.isCall.code(\""bin->entry_tab...)"", ""result"": [""<global>"", ""r_bin_ne_get_entrypoints"", ""__init"", ""r_bin_ne_free""]}, {""source"": ""value_info(file:ne.c, value:bin->entry_table)"", ""result"": {""value_trace"": [{""full_code"": ""bin->entry_table = calloc (4, bin->ne_header->EntryTableLength)"", ""line"": 633, ""func_name"": ""__init""}], ""struct_var"": ""bin"", ""struct_type"": null, ""struct_definition"": null}}]","1. calloc for bin->entry_table in __init (libr/bin/format/ne/ne.c:633) may return NULL on failure. 2. __init returns without setting bin->entry_table to a valid pointer, leaving it as NULL. 3. The bin object is returned by r_bin_ne_new_buf even with NULL bin->entry_table. 4. r_bin_ne_get_entrypoints (libr/bin/format/ne/ne.c:355) dereferences bin->entry_table without a null check (pre-patch), causing a NULL dereference. 5. The patch adds a null check to return early, preventing the crash.",1.0,./github/other_context/CVE-2022-1283
40,CVE-2022-1620,CWE-476,c_cpp,NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 in GitHub repository vim/vim prior to 8.2.4901. NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 allows attackers to cause a denial of service (application crash) via a crafted input.,https://github.com/vim/vim/commit/8e4b76da1d7e987d43ca960dfbc372d1c617466f,patch 8.2.4901: NULL pointer access when using invalid pattern\n\nProblem:    NULL pointer access when using invalid pattern.\nSolution:   Check for failed regexp program.,1,"[{""func_name"": ""fname_match"", ""file_path"": ""src/buffer.c"", ""func_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""target"": 0}]","[{""func_name"": ""fname_match"", ""file_path"": ""src/buffer.c"", ""func_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}""}]","{""function"": 2, ""value"": 2, ""code"": 2, ""caller"": 6}","[{""source"": ""func_info(func:vim_regexec)"", ""result"": [{""code"": ""int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}"", ""start_line"": 2813, ""end_line"": 2817, ""full_name"": ""vim_regexec"", ""file_path"": ""src/regexp.c""}]}, {""source"": ""value_info(value:rmp)"", ""result"": {""value_trace"": [{""full_code"": ""rmp->rm_ic = p_fic || ignore_case"", ""line"": 2957, ""func_name"": ""fname_match""}, {""full_code"": ""rmp->rm_ic = TRUE"", ""line"": 2643, ""func_name"": ""ExpandOther""}, {""full_code"": ""want_settermprop = sense"", ""line"": 669, ""func_name"": ""main<duplicate>10""}, {""full_code"": ""want_settermprop = 1"", ""line"": 710, ""func_name"": ""main<duplicate>10""}, {""full_code"": ""want_settermprop = 0"", ""line"": 334, ""func_name"": ""src/libvterm/t/harness.c:<global>""}], ""struct_var"": ""rmp"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:regexp.c, lines:2724-2734)"", ""result"": ""    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n""}, {""source"": ""func_info(func:vim_regcomp)"", ""result"": [{""code"": ""    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \""\\%#=\"", that sets the regexp engine\n    if (STRNCMP(expr, \""\\\\%#=\"", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\""New regexp mode selected (%d): %s\"",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \""a\"");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \""Syntax error in \\\""%s\\\""\\n\"", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\""(NFA) Could not open \\\""%s\\\"" to write !!!\"",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n"", ""start_line"": 2572, ""end_line"": 2664, ""full_name"": ""vim_regcomp"", ""file_path"": ""src/regexp.c""}]}, {""source"": ""value_info(value:regmatch_T)"", ""result"": {""value_trace"": [{""full_code"": ""typedef struct { regprog_T *regprog; char_u *startp[NSUBEXP]; char_u *endp[NSUBEXP]; int rm_ic; } regmatch_T"", ""line"": 137, ""func_name"": null}], ""struct_var"": ""regmatch_T"", ""struct_type"": ""struct"", ""struct_definition"": ""struct""}}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""caller_info(file:cmdexpand.c, func:vim_regexec)"", ""result"": [{""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}, {""call_line"": 3226, ""call_code"": ""vim_regexec(regmatch, s, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandUserDefined(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches)\n{\n    char_u\t*retstr;\n    char_u\t*s;\n    char_u\t*e;\n    int\t\tkeep;\n    garray_T\tga;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tscore = 0;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    retstr = call_user_expand_func(call_func_retstr, xp);\n    if (retstr == NULL)\n\treturn FAIL;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 3);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 3);\n\n    for (s = retstr; *s != NUL; s = e)\n    {\n\te = vim_strchr(s, '\\n');\n\tif (e == NULL)\n\t    e = s + STRLEN(s);\n\tkeep = *e;\n\t*e = NUL;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, s, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(s, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\t\t// match everything\n\n\t*e = keep;\n\n\tif (match)\n\t{\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    if (!fuzzy)\n\t\t((char_u **)ga.ga_data)[ga.ga_len] = vim_strnsave(s, e - s);\n\t    else\n\t    {\n\t\tfuzmatch_str_T  *fuzmatch =\n\t\t\t\t&((fuzmatch_str_T  *)ga.ga_data)[ga.ga_len];\n\t\tfuzmatch->idx = ga.ga_len;\n\t\tfuzmatch->str = vim_strnsave(s, e - s);\n\t\tfuzmatch->score = score;\n\t    }\n\t    ++ga.ga_len;\n\t}\n\n\tif (*e != NUL)\n\t    ++e;\n    }\n    vim_free(retstr);\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\t\tFALSE) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n    return OK;\n}\n"", ""caller_start"": 3185, ""file_path"": ""src/cmdexpand.c""}, {""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}]}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""code_info(file:regexp.c, lines:2724-2734)"", ""result"": ""    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n""}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}]","1. Invalid regex pattern passed to 'vim_regcomp' (regexp.c:2572) → returns NULL on failure.\n2. Callers like 'ExpandGeneric' (cmdexpand.c:2861) invoke 'vim_regexec' without checking 'rmp->regprog != NULL'.\n3. 'vim_regexec' (regexp.c:2813) calls 'vim_regexec_string' (regexp.c:2729), which dereferences 'rmp->regprog->re_in_use' without NULL check → NULL pointer dereference.",0.95,./github/other_context/CVE-2022-1620
41,CVE-2022-2476,CWE-476,c_cpp,A null pointer dereference bug was found in wavpack-5.4.0 The results from the ASAN log: AddressSanitizer:DEADLYSIGNAL ===================================================================84257==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x561b47a970c6 bp 0x7fff13952fb0 sp 0x7fff1394fca0 T0) ==84257==The signal is caused by a WRITE memory access. ==84257==Hint: address points to the zero page. #0 0x561b47a970c5 in main cli/wvunpack.c:834 #1 0x7efc4f5c0082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) #2 0x561b47a945ed in _start (/usr/local/bin/wvunpack+0xa5ed) AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV cli/wvunpack.c:834 in main ==84257==ABORTING,https://github.com/dbry/WavPack/commit/25b4a2725d8568212e7cf89ca05ca29d128af7ac,issue #121: NULL pointer dereference in wvunpack.c\n\n* check for NULL pointer before dereferencing in wvunpack.c\n* sanitize custom extensions to be alphanumeric only,2,"[{""func_name"": ""wvunpack_main"", ""file_path"": ""cli/wvunpack.c"", ""func_code"": ""static int wvunpack_main(int argc, char **argv)\n#else\nint main(int argc, char **argv)\n#endif\n{\n#ifdef __EMX__ /* OS/2 */\n    _wildcard (&argc, &argv);\n#endif\n    int verify_only = 0, error_count = 0, add_extension = 0, output_spec = 0, c_count = 0, x_count = 0;\n    char outpath, **matches = NULL, *outfilename = NULL, **argv_fn = NULL, selfname [PATH_MAX];\n    int use_stdin = 0, use_stdout = 0, argc_fn = 0, argi, result;\n\n#if defined(_WIN32)\n    if (!GetModuleFileName (NULL, selfname, sizeof (selfname)))\n#endif\n    strncpy (selfname, *argv, sizeof (selfname));\n\n    if (filespec_name (selfname)) {\n        char *filename = filespec_name (selfname);\n\n        if (strstr (filename, \""ebug\"") || strstr (filename, \""DEBUG\""))\n            debug_logging_mode = TRUE;\n\n        while (strchr (filename, '{')) {\n            char *open_brace = strchr (filename, '{');\n            char *close_brace = strchr (open_brace, '}');\n\n            if (!close_brace)\n                break;\n\n            if (close_brace - open_brace > 1) {\n                int option_len = (int)(close_brace - open_brace) - 1;\n                char *option = malloc (option_len + 1);\n\n                argv_fn = realloc (argv_fn, sizeof (char *) * ++argc_fn);\n                memcpy (option, open_brace + 1, option_len);\n                argv_fn [argc_fn - 1] = option;\n                option [option_len] = 0;\n\n                if (debug_logging_mode)\n                    error_line (\""file arg %d: %s\"", argc_fn, option);\n            }\n\n            filename = close_brace;\n        }\n    }\n\n    if (debug_logging_mode) {\n        char **argv_t = argv;\n        int argc_t = argc;\n\n        while (--argc_t)\n            error_line (\""cli arg %d: %s\"", argc - argc_t, *++argv_t);\n    }\n\n#if defined (_WIN32)\n    set_console_title = 1;      // on Windows, we default to messing with the console title\n#endif                          // on Linux, this is considered uncool to do by default\n\n    // loop through command-line arguments\n\n    for (argi = 0; argi < argc + argc_fn - 1; ++argi) {\n        char *argcp;\n\n        if (argi < argc_fn)\n            argcp = argv_fn [argi];\n        else\n            argcp = argv [argi - argc_fn + 1];\n\n        if (argcp [0] == '-' && argcp [1] == '-' && argcp [2]) {\n            char *long_option = argcp + 2, *long_param = long_option;\n\n            while (*long_param)\n                if (*long_param++ == '=')\n                    break;\n\n            if (!strcmp (long_option, \""help\"")) {                        // --help\n                printf (\""%s\"", help);\n                return 0;\n            }\n            else if (!strcmp (long_option, \""version\"")) {                // --version\n                printf (\""wvunpack %s\\n\"", PACKAGE_VERSION);\n                printf (\""libwavpack %s\\n\"", WavpackGetLibraryVersionString ());\n                return 0;\n            }\n#ifdef _WIN32\n            else if (!strcmp (long_option, \""pause\""))                    // --pause\n                pause_mode = 1;\n            else if (!strcmp (long_option, \""drop\""))                     // --drop\n                drop_mode = 1;\n#endif\n            else if (!strcmp (long_option, \""normalize-floats\""))         // --normalize-floats\n                normalize_floats = 1;\n            else if (!strcmp (long_option, \""no-utf8-convert\""))          // --no-utf8-convert\n                no_utf8_convert = 1;\n            else if (!strncmp (long_option, \""skip\"", 4)) {               // --skip\n                parse_sample_time_index (&skip, long_param);\n\n                if (!skip.value_is_valid) {\n                    error_line (\""invalid --skip parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strncmp (long_option, \""until\"", 5)) {              // --until\n                parse_sample_time_index (&until, long_param);\n\n                if (!until.value_is_valid) {\n                    error_line (\""invalid --until parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strcmp (long_option, \""caf-be\"")) {                 // --caf-be\n                decode_format = WP_FORMAT_CAF;\n                caf_be = format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""caf-le\"")) {                 // --caf-le\n                decode_format = WP_FORMAT_CAF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsf\"")) {                    // --dsf\n                decode_format = WP_FORMAT_DSF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsdiff\"") || !strcmp (long_option, \""dff\"")) {\n                decode_format = WP_FORMAT_DFF;                          // --dsdiff or --dff\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""w64\"")) {                    // --w64\n                decode_format = WP_FORMAT_W64;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""wav\"")) {                    // --wav\n                decode_format = WP_FORMAT_WAV;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""raw-pcm\""))                  // --raw-pcm\n                raw_pcm = raw_decode = 1;\n            else if (!strcmp (long_option, \""raw\""))                      // --raw\n                raw_decode = 1;\n            else {\n                error_line (\""unknown option: %s !\"", long_option);\n                ++error_count;\n            }\n        }\n#if defined (_WIN32)\n        else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])\n#else\n        else if (argcp [0] == '-' && argcp [1])\n#endif\n            while (*++argcp)\n                switch (*argcp) {\n                    case 'Y': case 'y':\n                        overwrite_all = 1;\n                        break;\n\n                    case 'C': case 'c':\n                        if (++c_count == 2) {\n                            add_tag_extraction_to_list (\""cuesheet=%a.cue\"");\n                            c_count = 0;\n                        }\n\n                        break;\n\n                    case 'D': case 'd':\n                        delete_source = 1;\n                        break;\n\n#if defined (_WIN32)\n                    case 'L': case 'l':\n                        SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);\n                        break;\n#elif defined (__OS2__)\n                    case 'L': case 'l':\n                        DosSetPriority (0, PRTYC_IDLETIME, 0, 0);\n                        break;\n#endif\n#if defined (_WIN32)\n                    case 'O': case 'o':  // ignore -o in Windows to be Linux compatible\n                        break;\n#else\n                    case 'O': case 'o':\n                        output_spec = 1;\n                        break;\n#endif\n                    case 'T': case 't':\n                        copy_time = 1;\n                        break;\n\n                    case 'V': case 'v':\n                        ++verify_only;\n                        break;\n\n                    case 'F': case 'f':\n                        file_info = (char) strtol (++argcp, &argcp, 10);\n\n                        if (file_info < 0 || file_info > 10) {\n                            error_line (\""-f option must be 1-10, or omit (or 0) for all!\"");\n                            ++error_count;\n                        }\n                        else {\n                            quiet_mode = no_audio_decode = 1;\n                            file_info++;\n                        }\n\n                        --argcp;\n                        break;\n\n                    case 'S': case 's':\n                        no_audio_decode = 1;\n                        ++summary;\n                        break;\n\n                    case 'K': case 'k':\n                        outbuf_k = strtol (++argcp, &argcp, 10);\n\n                        if (outbuf_k < 1 || outbuf_k > 16384)       // range-check for reasonable values\n                            outbuf_k = 0;\n\n                        --argcp;\n                        break;\n\n                    case 'M': case 'm':\n                        calc_md5 = 1;\n                        break;\n\n                    case 'B': case 'b':\n                        blind_decode = 1;\n                        break;\n\n                    case 'N': case 'n':\n                        no_audio_decode = 1;\n                        break;\n\n                    case 'R': case 'r':\n                        raw_decode = 1;\n                        break;\n\n                    case 'W': case 'w':\n                        decode_format = WP_FORMAT_WAV;\n                        format_specified = 1;\n                        break;\n\n                    case 'Q': case 'q':\n                        quiet_mode = 1;\n                        break;\n\n                    case 'Z': case 'z':\n                        set_console_title = (char) strtol (++argcp, &argcp, 10);\n                        --argcp;\n                        break;\n\n                    case 'X': case 'x':\n                        if (++x_count == 3) {\n                            error_line (\""illegal option: %s !\"", argcp);\n                            ++error_count;\n                            x_count = 0;\n                        }\n\n                        break;\n\n                    case 'I': case 'i':\n                        ignore_wvc = 1;\n                        break;\n\n                    default:\n                        error_line (\""illegal option: %c !\"", *argcp);\n                        ++error_count;\n                }\n        else if (argi < argc_fn) {\n            error_line (\""invalid use of filename-embedded args: %s !\"", argcp);\n            ++error_count;\n        }\n        else {\n            if (x_count) {\n                if (x_count == 1) {\n                    if (tag_extract_stdout) {\n                        error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n                        ++error_count;\n                    }\n                    else {\n                        tag_extract_stdout = argcp;\n                        no_audio_decode = 1;\n                    }\n                }\n                else if (x_count == 2)\n                    add_tag_extraction_to_list (argcp);\n\n                x_count = 0;\n            }\n#if defined (_WIN32)\n            else if (drop_mode || !num_files) {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n            }\n            else {\n                error_line (\""extra unknown argument: %s !\"", argcp);\n                ++error_count;\n            }\n#else\n            else if (output_spec) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n                output_spec = 0;\n            }\n            else {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n#endif\n        }\n\n        if (argi < argc_fn)\n            free (argv_fn [argi]);\n    }\n\n    free (argv_fn);\n\n   // check for various command-line argument problems\n\n    if (output_spec) {\n        error_line (\""no output filename or path specified with -o option!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && num_files > 1) {\n        error_line (\""when stdin is used for input, it must be the only file!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && !outfilename)  // for stdin source, no output specification implies stdout\n        use_stdout = 1;\n\n    if (delete_source && (verify_only || skip.value_is_valid || until.value_is_valid)) {\n        error_line (\""can't delete in verify mode or when --skip or --until are used!\"");\n        delete_source = 0;\n    }\n\n    if (raw_decode && format_specified) {\n        error_line (\""-r (raw decode) and specifying a format (like -w) are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only && (format_specified || outfilename)) {\n        error_line (\""specifying output file or format and verify mode are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only > 1 && calc_md5) {\n        error_line (\""can't calculate MD5s in quick verify mode!\"");\n        ++error_count;\n    }\n\n    if (c_count == 1) {\n        if (tag_extract_stdout) {\n            error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n            error_count++;\n        }\n        else {\n            tag_extract_stdout = \""cuesheet\"";\n            no_audio_decode = 1;\n        }\n    }\n\n    if ((summary || file_info) && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified)) {\n        error_line (\""can't display file information and do anything else!\"");\n        ++error_count;\n    }\n\n    if (tag_extract_stdout && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified || raw_decode)) {\n        error_line (\""can't extract a tag to stdout and do anything else!\"");\n        ++error_count;\n    }\n\n    if ((tag_extract_stdout || num_tag_extractions) && use_stdout) {\n        error_line (\""can't extract tags when unpacking audio to stdout!\"");\n        ++error_count;\n    }\n\n    if (strcmp (WavpackGetLibraryVersionString (), PACKAGE_VERSION)) {\n        fprintf (stderr, version_warning, WavpackGetLibraryVersionString (), PACKAGE_VERSION);\n        fflush (stderr);\n    }\n    else if (!quiet_mode && !error_count) {\n        fprintf (stderr, sign_on, VERSION_OS, WavpackGetLibraryVersionString ());\n        fflush (stderr);\n    }\n\n    if (error_count) {\n        fprintf (stderr, \""\\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\\n\"");\n        fflush (stderr);\n        return 1;\n    }\n\n    if (!num_files) {\n        printf (\""%s\"", usage);\n        return 1;\n    }\n\n    setup_break ();\n\n    for (file_index = 0; file_index < num_files; ++file_index) {\n        char *infilename = matches [file_index];\n\n        // If the single infile specification begins with a '@', then it\n        // actually points to a file that contains the names of the files\n        // to be converted. This was included for use by Wim Speekenbrink's\n        // frontends, but could be used for other purposes.\n\n        if (*infilename == '@') {\n            FILE *list = fopen (infilename+1, \""rb\"");\n            char *listbuff = NULL, *cp;\n            int listbytes = 0, di, c;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if (list == NULL) {\n                error_line (\""file %s not found!\"", infilename+1);\n                free (infilename);\n                return 1;\n            }\n\n            while (1) {\n                int bytes_read;\n\n                listbuff = realloc (listbuff, listbytes + 1024);\n                memset (listbuff + listbytes, 0, 1024);\n                listbytes += bytes_read = (int) fread (listbuff + listbytes, 1, 1024, list);\n\n                if (bytes_read < 1024)\n                    break;\n            }\n\n#if defined (_WIN32)\n            listbuff = realloc (listbuff, listbytes *= 2);\n            TextToUTF8 (listbuff, listbytes);\n#endif\n            cp = listbuff;\n\n            while ((c = *cp++)) {\n\n                while (c == '\\n' || c == '\\r')\n                    c = *cp++;\n\n                if (c) {\n                    char *fname = malloc (PATH_MAX);\n                    int ci = 0;\n\n                    do\n                        fname [ci++] = c;\n                    while ((c = *cp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n                    fname [ci++] = '\\0';\n                    matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                    for (di = num_files - 1; di > file_index + 1; di--)\n                        matches [di] = matches [di - 1];\n\n                    matches [++file_index] = fname;\n                }\n\n                if (!c)\n                    break;\n            }\n\n            fclose (list);\n            free (listbuff);\n            free (infilename);\n        }\n#if defined (_WIN32)\n        else if (filespec_wild (infilename)) {\n            wchar_t *winfilename = utf8_to_utf16(infilename);\n            struct _wfinddata_t _wfinddata_t;\n            intptr_t file;\n            int di;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if ((file = _wfindfirst (winfilename, &_wfinddata_t)) != (intptr_t) -1) {\n                do {\n                    char *name_utf8;\n\n                    if (!(_wfinddata_t.attrib & _A_SUBDIR) && (name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {\n                        matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                        for (di = num_files - 1; di > file_index + 1; di--)\n                            matches [di] = matches [di - 1];\n\n                        matches [++file_index] = malloc (strlen (infilename) + strlen (name_utf8) + 10);\n                        strcpy (matches [file_index], infilename);\n                        *filespec_name (matches [file_index]) = '\\0';\n                        strcat (matches [file_index], name_utf8);\n                        free (name_utf8);\n                    }\n                } while (_wfindnext (file, &_wfinddata_t) == 0);\n\n                _findclose (file);\n            }\n\n            free (winfilename);\n            free (infilename);\n        }\n#endif\n    }\n\n    // If the outfile specification begins with a '@', then it actually points\n    // to a file that contains the output specification. This was included for\n    // use by Wim Speekenbrink's frontends because certain filenames could not\n    // be passed on the command-line, but could be used for other purposes.\n\n    if (outfilename && outfilename [0] == '@') {\n        char listbuff [PATH_MAX * 2], *lp = listbuff;\n        FILE *list = fopen (outfilename+1, \""rb\"");\n        int c;\n\n        if (list == NULL) {\n            error_line (\""file %s not found!\"", outfilename+1);\n            free(outfilename);\n            return 1;\n        }\n\n        memset (listbuff, 0, sizeof (listbuff));\n        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning\n\n#if defined (_WIN32)\n        TextToUTF8 (listbuff, PATH_MAX * 2);\n#endif\n\n        while ((c = *lp++) == '\\n' || c == '\\r');\n\n        if (c) {\n            int ci = 0;\n\n            do\n                outfilename [ci++] = c;\n            while ((c = *lp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n            outfilename [ci] = '\\0';\n        }\n        else {\n            error_line (\""output spec file is empty!\"");\n            free(outfilename);\n            fclose (list);\n            return 1;\n        }\n\n        fclose (list);\n    }\n\n    // if we found any files to process, this is where we start\n\n    if (num_files) {\n        if (outfilename && *outfilename != '-') {\n            outpath = (filespec_path (outfilename) != NULL);\n\n            if (num_files > 1 && !outpath) {\n                error_line (\""%s is not a valid output path\"", outfilename);\n                free (outfilename);\n                return 1;\n            }\n        }\n        else\n            outpath = 0;\n\n        add_extension = !outfilename || outpath || !filespec_ext (outfilename);\n\n        // loop through and process files in list\n\n        for (file_index = 0; file_index < num_files; ++file_index) {\n            if (check_break ())\n                break;\n\n            // generate output filename\n\n            if (outpath) {\n                strcat (outfilename, filespec_name (matches [file_index]));\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (matches [file_index]) + 10);\n                strcpy (outfilename, matches [file_index]);\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n\n            if (num_files > 1 && !quiet_mode) {\n                fprintf (stderr, \""\\n%s:\\n\"", matches [file_index]);\n                fflush (stderr);\n            }\n\n            if (verify_only > 1) {\n                result = quick_verify_file (matches [file_index], verify_only > 2);\n\n                // quick_verify_file() returns hard error to mean file cannot be quickly verified\n                // because it has no block checksums, so fall back to standard slow verify\n\n                if (result == WAVPACK_HARD_ERROR)\n                    result = unpack_file (matches [file_index], NULL, 0);\n            }\n            else\n                result = unpack_file (matches [file_index], verify_only ? NULL : outfilename, add_extension);\n\n            if (result != WAVPACK_NO_ERROR)\n                ++error_count;\n\n            if (result == WAVPACK_HARD_ERROR)\n                break;\n\n            // clean up in preparation for potentially another file\n\n            if (outpath)\n                *filespec_name (outfilename) = '\\0';\n            else if (*outfilename != '-') {\n                free (outfilename);\n                outfilename = NULL;\n            }\n\n            free (matches [file_index]);\n        }\n\n        if (num_files > 1) {\n            if (error_count) {\n                fprintf (stderr, \""\\n **** warning: errors occurred in %d of %d files! ****\\n\"", error_count, num_files);\n                fflush (stderr);\n            }\n            else if (!quiet_mode) {\n                fprintf (stderr, \""\\n **** %d files successfully processed ****\\n\"", num_files);\n                fflush (stderr);\n            }\n        }\n\n        free (matches);\n    }\n    else {\n        error_line (\""nothing to do!\"");\n        ++error_count;\n    }\n\n    if (outfilename)\n        free (outfilename);\n\n    if (set_console_title)\n        DoSetConsoleTitle (\""WvUnpack Completed\"");\n\n    return error_count ? 1 : 0;\n}"", ""target"": 0}, {""func_name"": ""process_metadata"", ""file_path"": ""src/open_utils.c"", ""func_code"": ""static int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n    switch (wpmd->id) {\n        case ID_DUMMY:\n            return TRUE;\n\n        case ID_DECORR_TERMS:\n            return read_decorr_terms (wps, wpmd);\n\n        case ID_DECORR_WEIGHTS:\n            return read_decorr_weights (wps, wpmd);\n\n        case ID_DECORR_SAMPLES:\n            return read_decorr_samples (wps, wpmd);\n\n        case ID_ENTROPY_VARS:\n            return read_entropy_vars (wps, wpmd);\n\n        case ID_HYBRID_PROFILE:\n            return read_hybrid_profile (wps, wpmd);\n\n        case ID_SHAPING_WEIGHTS:\n            return read_shaping_info (wps, wpmd);\n\n        case ID_FLOAT_INFO:\n            return read_float_info (wps, wpmd);\n\n        case ID_INT32_INFO:\n            return read_int32_info (wps, wpmd);\n\n        case ID_CHANNEL_INFO:\n            return read_channel_info (wpc, wpmd);\n\n        case ID_CHANNEL_IDENTITIES:\n            return read_channel_identities (wpc, wpmd);\n\n        case ID_CONFIG_BLOCK:\n            return read_config_info (wpc, wpmd);\n\n        case ID_NEW_CONFIG_BLOCK:\n            return read_new_config_info (wpc, wpmd);\n\n        case ID_SAMPLE_RATE:\n            return read_sample_rate (wpc, wpmd);\n\n        case ID_WV_BITSTREAM:\n            return init_wv_bitstream (wps, wpmd);\n\n        case ID_WVC_BITSTREAM:\n            return init_wvc_bitstream (wps, wpmd);\n\n        case ID_WVX_BITSTREAM:\n            return init_wvx_bitstream (wps, wpmd);\n\n        case ID_DSD_BLOCK:\n#ifdef ENABLE_DSD\n            return init_dsd_block (wpc, wpmd);\n#else\n            strcpy (wpc->error_message, \""not configured to handle DSD WavPack files!\"");\n            return FALSE;\n#endif\n\n        case ID_ALT_HEADER: case ID_ALT_TRAILER:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:\n            return read_wrapper_data (wpc, wpmd);\n\n        case ID_ALT_MD5_CHECKSUM:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_MD5_CHECKSUM:\n            if (wpmd->byte_length == 16) {\n                memcpy (wpc->config.md5_checksum, wpmd->data, 16);\n                wpc->config.flags |= CONFIG_MD5_CHECKSUM;\n                wpc->config.md5_read = 1;\n            }\n\n            return TRUE;\n\n        case ID_ALT_EXTENSION:\n            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {\n                memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);\n                wpc->file_extension [wpmd->byte_length] = 0;\n            }\n\n            return TRUE;\n\n        // we don't actually verify the checksum here (it's done right after the\n        // block is read), but it's a good indicator of version 5 files\n\n        case ID_BLOCK_CHECKSUM:\n            wpc->version_five = 1;\n            return TRUE;\n\n        default:\n            return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;\n    }\n}"", ""target"": 0}]","[{""func_name"": ""wvunpack_main"", ""file_path"": ""cli/wvunpack.c"", ""func_code"": ""static int wvunpack_main(int argc, char **argv)\n#else\nint main(int argc, char **argv)\n#endif\n{\n#ifdef __EMX__ /* OS/2 */\n    _wildcard (&argc, &argv);\n#endif\n    int verify_only = 0, error_count = 0, add_extension = 0, output_spec = 0, c_count = 0, x_count = 0;\n    char outpath, **matches = NULL, *outfilename = NULL, **argv_fn = NULL, selfname [PATH_MAX];\n    int use_stdin = 0, use_stdout = 0, argc_fn = 0, argi, result;\n\n#if defined(_WIN32)\n    if (!GetModuleFileName (NULL, selfname, sizeof (selfname)))\n#endif\n    strncpy (selfname, *argv, sizeof (selfname));\n\n    if (filespec_name (selfname)) {\n        char *filename = filespec_name (selfname);\n\n        if (strstr (filename, \""ebug\"") || strstr (filename, \""DEBUG\""))\n            debug_logging_mode = TRUE;\n\n        while (strchr (filename, '{')) {\n            char *open_brace = strchr (filename, '{');\n            char *close_brace = strchr (open_brace, '}');\n\n            if (!close_brace)\n                break;\n\n            if (close_brace - open_brace > 1) {\n                int option_len = (int)(close_brace - open_brace) - 1;\n                char *option = malloc (option_len + 1);\n\n                argv_fn = realloc (argv_fn, sizeof (char *) * ++argc_fn);\n                memcpy (option, open_brace + 1, option_len);\n                argv_fn [argc_fn - 1] = option;\n                option [option_len] = 0;\n\n                if (debug_logging_mode)\n                    error_line (\""file arg %d: %s\"", argc_fn, option);\n            }\n\n            filename = close_brace;\n        }\n    }\n\n    if (debug_logging_mode) {\n        char **argv_t = argv;\n        int argc_t = argc;\n\n        while (--argc_t)\n            error_line (\""cli arg %d: %s\"", argc - argc_t, *++argv_t);\n    }\n\n#if defined (_WIN32)\n    set_console_title = 1;      // on Windows, we default to messing with the console title\n#endif                          // on Linux, this is considered uncool to do by default\n\n    // loop through command-line arguments\n\n    for (argi = 0; argi < argc + argc_fn - 1; ++argi) {\n        char *argcp;\n\n        if (argi < argc_fn)\n            argcp = argv_fn [argi];\n        else\n            argcp = argv [argi - argc_fn + 1];\n\n        if (argcp [0] == '-' && argcp [1] == '-' && argcp [2]) {\n            char *long_option = argcp + 2, *long_param = long_option;\n\n            while (*long_param)\n                if (*long_param++ == '=')\n                    break;\n\n            if (!strcmp (long_option, \""help\"")) {                        // --help\n                printf (\""%s\"", help);\n                return 0;\n            }\n            else if (!strcmp (long_option, \""version\"")) {                // --version\n                printf (\""wvunpack %s\\n\"", PACKAGE_VERSION);\n                printf (\""libwavpack %s\\n\"", WavpackGetLibraryVersionString ());\n                return 0;\n            }\n#ifdef _WIN32\n            else if (!strcmp (long_option, \""pause\""))                    // --pause\n                pause_mode = 1;\n            else if (!strcmp (long_option, \""drop\""))                     // --drop\n                drop_mode = 1;\n#endif\n            else if (!strcmp (long_option, \""normalize-floats\""))         // --normalize-floats\n                normalize_floats = 1;\n            else if (!strcmp (long_option, \""no-utf8-convert\""))          // --no-utf8-convert\n                no_utf8_convert = 1;\n            else if (!strncmp (long_option, \""skip\"", 4)) {               // --skip\n                parse_sample_time_index (&skip, long_param);\n\n                if (!skip.value_is_valid) {\n                    error_line (\""invalid --skip parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strncmp (long_option, \""until\"", 5)) {              // --until\n                parse_sample_time_index (&until, long_param);\n\n                if (!until.value_is_valid) {\n                    error_line (\""invalid --until parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strcmp (long_option, \""caf-be\"")) {                 // --caf-be\n                decode_format = WP_FORMAT_CAF;\n                caf_be = format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""caf-le\"")) {                 // --caf-le\n                decode_format = WP_FORMAT_CAF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsf\"")) {                    // --dsf\n                decode_format = WP_FORMAT_DSF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsdiff\"") || !strcmp (long_option, \""dff\"")) {\n                decode_format = WP_FORMAT_DFF;                          // --dsdiff or --dff\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""w64\"")) {                    // --w64\n                decode_format = WP_FORMAT_W64;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""wav\"")) {                    // --wav\n                decode_format = WP_FORMAT_WAV;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""raw-pcm\""))                  // --raw-pcm\n                raw_pcm = raw_decode = 1;\n            else if (!strcmp (long_option, \""raw\""))                      // --raw\n                raw_decode = 1;\n            else {\n                error_line (\""unknown option: %s !\"", long_option);\n                ++error_count;\n            }\n        }\n#if defined (_WIN32)\n        else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])\n#else\n        else if (argcp [0] == '-' && argcp [1])\n#endif\n            while (*++argcp)\n                switch (*argcp) {\n                    case 'Y': case 'y':\n                        overwrite_all = 1;\n                        break;\n\n                    case 'C': case 'c':\n                        if (++c_count == 2) {\n                            add_tag_extraction_to_list (\""cuesheet=%a.cue\"");\n                            c_count = 0;\n                        }\n\n                        break;\n\n                    case 'D': case 'd':\n                        delete_source = 1;\n                        break;\n\n#if defined (_WIN32)\n                    case 'L': case 'l':\n                        SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);\n                        break;\n#elif defined (__OS2__)\n                    case 'L': case 'l':\n                        DosSetPriority (0, PRTYC_IDLETIME, 0, 0);\n                        break;\n#endif\n#if defined (_WIN32)\n                    case 'O': case 'o':  // ignore -o in Windows to be Linux compatible\n                        break;\n#else\n                    case 'O': case 'o':\n                        output_spec = 1;\n                        break;\n#endif\n                    case 'T': case 't':\n                        copy_time = 1;\n                        break;\n\n                    case 'V': case 'v':\n                        ++verify_only;\n                        break;\n\n                    case 'F': case 'f':\n                        file_info = (char) strtol (++argcp, &argcp, 10);\n\n                        if (file_info < 0 || file_info > 10) {\n                            error_line (\""-f option must be 1-10, or omit (or 0) for all!\"");\n                            ++error_count;\n                        }\n                        else {\n                            quiet_mode = no_audio_decode = 1;\n                            file_info++;\n                        }\n\n                        --argcp;\n                        break;\n\n                    case 'S': case 's':\n                        no_audio_decode = 1;\n                        ++summary;\n                        break;\n\n                    case 'K': case 'k':\n                        outbuf_k = strtol (++argcp, &argcp, 10);\n\n                        if (outbuf_k < 1 || outbuf_k > 16384)       // range-check for reasonable values\n                            outbuf_k = 0;\n\n                        --argcp;\n                        break;\n\n                    case 'M': case 'm':\n                        calc_md5 = 1;\n                        break;\n\n                    case 'B': case 'b':\n                        blind_decode = 1;\n                        break;\n\n                    case 'N': case 'n':\n                        no_audio_decode = 1;\n                        break;\n\n                    case 'R': case 'r':\n                        raw_decode = 1;\n                        break;\n\n                    case 'W': case 'w':\n                        decode_format = WP_FORMAT_WAV;\n                        format_specified = 1;\n                        break;\n\n                    case 'Q': case 'q':\n                        quiet_mode = 1;\n                        break;\n\n                    case 'Z': case 'z':\n                        set_console_title = (char) strtol (++argcp, &argcp, 10);\n                        --argcp;\n                        break;\n\n                    case 'X': case 'x':\n                        if (++x_count == 3) {\n                            error_line (\""illegal option: %s !\"", argcp);\n                            ++error_count;\n                            x_count = 0;\n                        }\n\n                        break;\n\n                    case 'I': case 'i':\n                        ignore_wvc = 1;\n                        break;\n\n                    default:\n                        error_line (\""illegal option: %c !\"", *argcp);\n                        ++error_count;\n                }\n        else if (argi < argc_fn) {\n            error_line (\""invalid use of filename-embedded args: %s !\"", argcp);\n            ++error_count;\n        }\n        else {\n            if (x_count) {\n                if (x_count == 1) {\n                    if (tag_extract_stdout) {\n                        error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n                        ++error_count;\n                    }\n                    else {\n                        tag_extract_stdout = argcp;\n                        no_audio_decode = 1;\n                    }\n                }\n                else if (x_count == 2)\n                    add_tag_extraction_to_list (argcp);\n\n                x_count = 0;\n            }\n#if defined (_WIN32)\n            else if (drop_mode || !num_files) {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n            }\n            else {\n                error_line (\""extra unknown argument: %s !\"", argcp);\n                ++error_count;\n            }\n#else\n            else if (output_spec) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n                output_spec = 0;\n            }\n            else {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n#endif\n        }\n\n        if (argi < argc_fn)\n            free (argv_fn [argi]);\n    }\n\n    free (argv_fn);\n\n   // check for various command-line argument problems\n\n    if (output_spec) {\n        error_line (\""no output filename or path specified with -o option!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && num_files > 1) {\n        error_line (\""when stdin is used for input, it must be the only file!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && !outfilename)  // for stdin source, no output specification implies stdout\n        use_stdout = 1;\n\n    if (delete_source && (verify_only || skip.value_is_valid || until.value_is_valid)) {\n        error_line (\""can't delete in verify mode or when --skip or --until are used!\"");\n        delete_source = 0;\n    }\n\n    if (raw_decode && format_specified) {\n        error_line (\""-r (raw decode) and specifying a format (like -w) are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only && (format_specified || outfilename)) {\n        error_line (\""specifying output file or format and verify mode are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only > 1 && calc_md5) {\n        error_line (\""can't calculate MD5s in quick verify mode!\"");\n        ++error_count;\n    }\n\n    if (c_count == 1) {\n        if (tag_extract_stdout) {\n            error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n            error_count++;\n        }\n        else {\n            tag_extract_stdout = \""cuesheet\"";\n            no_audio_decode = 1;\n        }\n    }\n\n    if ((summary || file_info) && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified)) {\n        error_line (\""can't display file information and do anything else!\"");\n        ++error_count;\n    }\n\n    if (tag_extract_stdout && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified || raw_decode)) {\n        error_line (\""can't extract a tag to stdout and do anything else!\"");\n        ++error_count;\n    }\n\n    if ((tag_extract_stdout || num_tag_extractions) && use_stdout) {\n        error_line (\""can't extract tags when unpacking audio to stdout!\"");\n        ++error_count;\n    }\n\n    if (strcmp (WavpackGetLibraryVersionString (), PACKAGE_VERSION)) {\n        fprintf (stderr, version_warning, WavpackGetLibraryVersionString (), PACKAGE_VERSION);\n        fflush (stderr);\n    }\n    else if (!quiet_mode && !error_count) {\n        fprintf (stderr, sign_on, VERSION_OS, WavpackGetLibraryVersionString ());\n        fflush (stderr);\n    }\n\n    if (error_count) {\n        fprintf (stderr, \""\\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\\n\"");\n        fflush (stderr);\n        return 1;\n    }\n\n    if (!num_files) {\n        printf (\""%s\"", usage);\n        return 1;\n    }\n\n    setup_break ();\n\n    for (file_index = 0; file_index < num_files; ++file_index) {\n        char *infilename = matches [file_index];\n\n        // If the single infile specification begins with a '@', then it\n        // actually points to a file that contains the names of the files\n        // to be converted. This was included for use by Wim Speekenbrink's\n        // frontends, but could be used for other purposes.\n\n        if (*infilename == '@') {\n            FILE *list = fopen (infilename+1, \""rb\"");\n            char *listbuff = NULL, *cp;\n            int listbytes = 0, di, c;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if (list == NULL) {\n                error_line (\""file %s not found!\"", infilename+1);\n                free (infilename);\n                return 1;\n            }\n\n            while (1) {\n                int bytes_read;\n\n                listbuff = realloc (listbuff, listbytes + 1024);\n                memset (listbuff + listbytes, 0, 1024);\n                listbytes += bytes_read = (int) fread (listbuff + listbytes, 1, 1024, list);\n\n                if (bytes_read < 1024)\n                    break;\n            }\n\n#if defined (_WIN32)\n            listbuff = realloc (listbuff, listbytes *= 2);\n            TextToUTF8 (listbuff, listbytes);\n#endif\n            cp = listbuff;\n\n            while ((c = *cp++)) {\n\n                while (c == '\\n' || c == '\\r')\n                    c = *cp++;\n\n                if (c) {\n                    char *fname = malloc (PATH_MAX);\n                    int ci = 0;\n\n                    do\n                        fname [ci++] = c;\n                    while ((c = *cp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n                    fname [ci++] = '\\0';\n                    matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                    for (di = num_files - 1; di > file_index + 1; di--)\n                        matches [di] = matches [di - 1];\n\n                    matches [++file_index] = fname;\n                }\n\n                if (!c)\n                    break;\n            }\n\n            fclose (list);\n            free (listbuff);\n            free (infilename);\n        }\n#if defined (_WIN32)\n        else if (filespec_wild (infilename)) {\n            wchar_t *winfilename = utf8_to_utf16(infilename);\n            struct _wfinddata_t _wfinddata_t;\n            intptr_t file;\n            int di;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if ((file = _wfindfirst (winfilename, &_wfinddata_t)) != (intptr_t) -1) {\n                do {\n                    char *name_utf8;\n\n                    if (!(_wfinddata_t.attrib & _A_SUBDIR) && (name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {\n                        matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                        for (di = num_files - 1; di > file_index + 1; di--)\n                            matches [di] = matches [di - 1];\n\n                        matches [++file_index] = malloc (strlen (infilename) + strlen (name_utf8) + 10);\n                        strcpy (matches [file_index], infilename);\n                        *filespec_name (matches [file_index]) = '\\0';\n                        strcat (matches [file_index], name_utf8);\n                        free (name_utf8);\n                    }\n                } while (_wfindnext (file, &_wfinddata_t) == 0);\n\n                _findclose (file);\n            }\n\n            free (winfilename);\n            free (infilename);\n        }\n#endif\n    }\n\n    // If the outfile specification begins with a '@', then it actually points\n    // to a file that contains the output specification. This was included for\n    // use by Wim Speekenbrink's frontends because certain filenames could not\n    // be passed on the command-line, but could be used for other purposes.\n\n    if (outfilename && outfilename [0] == '@') {\n        char listbuff [PATH_MAX * 2], *lp = listbuff;\n        FILE *list = fopen (outfilename+1, \""rb\"");\n        int c;\n\n        if (list == NULL) {\n            error_line (\""file %s not found!\"", outfilename+1);\n            free(outfilename);\n            return 1;\n        }\n\n        memset (listbuff, 0, sizeof (listbuff));\n        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning\n\n#if defined (_WIN32)\n        TextToUTF8 (listbuff, PATH_MAX * 2);\n#endif\n\n        while ((c = *lp++) == '\\n' || c == '\\r');\n\n        if (c) {\n            int ci = 0;\n\n            do\n                outfilename [ci++] = c;\n            while ((c = *lp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n            outfilename [ci] = '\\0';\n        }\n        else {\n            error_line (\""output spec file is empty!\"");\n            free(outfilename);\n            fclose (list);\n            return 1;\n        }\n\n        fclose (list);\n    }\n\n    // if we found any files to process, this is where we start\n\n    if (num_files) {\n        if (outfilename && *outfilename != '-') {\n            outpath = (filespec_path (outfilename) != NULL);\n\n            if (num_files > 1 && !outpath) {\n                error_line (\""%s is not a valid output path\"", outfilename);\n                free (outfilename);\n                return 1;\n            }\n        }\n        else\n            outpath = 0;\n\n        add_extension = !outfilename || outpath || !filespec_ext (outfilename);\n\n        // loop through and process files in list\n\n        for (file_index = 0; file_index < num_files; ++file_index) {\n            if (check_break ())\n                break;\n\n            // generate output filename\n\n            if (outpath) {\n                strcat (outfilename, filespec_name (matches [file_index]));\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (matches [file_index]) + 10);\n                strcpy (outfilename, matches [file_index]);\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n\n            if (num_files > 1 && !quiet_mode) {\n                fprintf (stderr, \""\\n%s:\\n\"", matches [file_index]);\n                fflush (stderr);\n            }\n\n            if (verify_only > 1) {\n                result = quick_verify_file (matches [file_index], verify_only > 2);\n\n                // quick_verify_file() returns hard error to mean file cannot be quickly verified\n                // because it has no block checksums, so fall back to standard slow verify\n\n                if (result == WAVPACK_HARD_ERROR)\n                    result = unpack_file (matches [file_index], NULL, 0);\n            }\n            else\n                result = unpack_file (matches [file_index], verify_only ? NULL : outfilename, add_extension);\n\n            if (result != WAVPACK_NO_ERROR)\n                ++error_count;\n\n            if (result == WAVPACK_HARD_ERROR)\n                break;\n\n            // clean up in preparation for potentially another file\n\n            if (outpath) {\n                if (filespec_name (outfilename))\n                    *filespec_name (outfilename) = '\\0';\n            }\n            else if (*outfilename != '-') {\n                free (outfilename);\n                outfilename = NULL;\n            }\n\n            free (matches [file_index]);\n        }\n\n        if (num_files > 1) {\n            if (error_count) {\n                fprintf (stderr, \""\\n **** warning: errors occurred in %d of %d files! ****\\n\"", error_count, num_files);\n                fflush (stderr);\n            }\n            else if (!quiet_mode) {\n                fprintf (stderr, \""\\n **** %d files successfully processed ****\\n\"", num_files);\n                fflush (stderr);\n            }\n        }\n\n        free (matches);\n    }\n    else {\n        error_line (\""nothing to do!\"");\n        ++error_count;\n    }\n\n    if (outfilename)\n        free (outfilename);\n\n    if (set_console_title)\n        DoSetConsoleTitle (\""WvUnpack Completed\"");\n\n    return error_count ? 1 : 0;\n}""}, {""func_name"": ""process_metadata"", ""file_path"": ""src/open_utils.c"", ""func_code"": ""static int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n    switch (wpmd->id) {\n        case ID_DUMMY:\n            return TRUE;\n\n        case ID_DECORR_TERMS:\n            return read_decorr_terms (wps, wpmd);\n\n        case ID_DECORR_WEIGHTS:\n            return read_decorr_weights (wps, wpmd);\n\n        case ID_DECORR_SAMPLES:\n            return read_decorr_samples (wps, wpmd);\n\n        case ID_ENTROPY_VARS:\n            return read_entropy_vars (wps, wpmd);\n\n        case ID_HYBRID_PROFILE:\n            return read_hybrid_profile (wps, wpmd);\n\n        case ID_SHAPING_WEIGHTS:\n            return read_shaping_info (wps, wpmd);\n\n        case ID_FLOAT_INFO:\n            return read_float_info (wps, wpmd);\n\n        case ID_INT32_INFO:\n            return read_int32_info (wps, wpmd);\n\n        case ID_CHANNEL_INFO:\n            return read_channel_info (wpc, wpmd);\n\n        case ID_CHANNEL_IDENTITIES:\n            return read_channel_identities (wpc, wpmd);\n\n        case ID_CONFIG_BLOCK:\n            return read_config_info (wpc, wpmd);\n\n        case ID_NEW_CONFIG_BLOCK:\n            return read_new_config_info (wpc, wpmd);\n\n        case ID_SAMPLE_RATE:\n            return read_sample_rate (wpc, wpmd);\n\n        case ID_WV_BITSTREAM:\n            return init_wv_bitstream (wps, wpmd);\n\n        case ID_WVC_BITSTREAM:\n            return init_wvc_bitstream (wps, wpmd);\n\n        case ID_WVX_BITSTREAM:\n            return init_wvx_bitstream (wps, wpmd);\n\n        case ID_DSD_BLOCK:\n#ifdef ENABLE_DSD\n            return init_dsd_block (wpc, wpmd);\n#else\n            strcpy (wpc->error_message, \""not configured to handle DSD WavPack files!\"");\n            return FALSE;\n#endif\n\n        case ID_ALT_HEADER: case ID_ALT_TRAILER:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:\n            return read_wrapper_data (wpc, wpmd);\n\n        case ID_ALT_MD5_CHECKSUM:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_MD5_CHECKSUM:\n            if (wpmd->byte_length == 16) {\n                memcpy (wpc->config.md5_checksum, wpmd->data, 16);\n                wpc->config.flags |= CONFIG_MD5_CHECKSUM;\n                wpc->config.md5_read = 1;\n            }\n\n            return TRUE;\n\n        case ID_ALT_EXTENSION:\n            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {\n                int i, j;\n\n                for (i = j = 0; i < wpmd->byte_length; ++i)\n                    if (isalnum (((char *) wpmd->data) [i]))\n                        wpc->file_extension [j++] = ((char *) wpmd->data) [i];\n\n                wpc->file_extension [j] = 0;\n            }\n\n            return TRUE;\n\n        // we don't actually verify the checksum here (it's done right after the\n        // block is read), but it's a good indicator of version 5 files\n\n        case ID_BLOCK_CHECKSUM:\n            wpc->version_five = 1;\n            return TRUE;\n\n        default:\n            return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;\n    }\n}""}]","{""value"": 1, ""function"": 1}","[{""source"": ""value_info(file:wvunpack.c, value:filespec_name)"", ""result"": {""value_trace"": [{""full_code"": ""*filespec_name (outfilename) = '\\0'"", ""line"": 911, ""func_name"": ""main<duplicate>7""}], ""struct_var"": ""filespec_name"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:filespec_name)"", ""result"": [{""code"": ""char *filespec_name (char *filespec)\n{\n    char *cp = filespec + strlen (filespec);\n\n    while (--cp >= filespec) {\n\n        if (*cp == '\\\\' || *cp == ':')\n            break;\n    }\n\n    if (strlen (cp + 1))\n        return cp + 1;\n    else\n        return NULL;\n}"", ""start_line"": 267, ""end_line"": 281, ""full_name"": ""filespec_name"", ""file_path"": ""cli/utils.c""}, {""code"": ""char *filespec_name (char *filespec)\n{\n    char *cp = filespec + strlen (filespec);\n\n    while (--cp >= filespec)\n        if (*cp == '/')\n            break;\n\n    if (strlen (cp + 1))\n        return cp + 1;\n    else\n        return NULL;\n}"", ""start_line"": 285, ""end_line"": 297, ""full_name"": ""filespec_name<duplicate>0"", ""file_path"": ""cli/utils.c""}]}]","1. `filespec_name(outfilename)` is called in cli/wvunpack.c:908 (original code) without a NULL check.\n2. `filespec_name` (cli/utils.c:267-281/285-297) returns NULL if the filename component after the last path separator is empty (e.g., input ends with a path separator like ""dir/"").\n3. The returned NULL pointer is dereferenced at cli/wvunpack.c:908 (`*filespec_name(...)`), causing a SEGV when writing '\0' to address 0x0.",0.95,./github/other_context/CVE-2022-2476
42,CVE-2022-47022,CWE-476,c_cpp,An issue was discovered in open-mpi hwloc 2.1.0 allows attackers to cause a denial of service or other unspecified impacts via glibc-cpuset in topology-linux.c.,https://github.com/open-mpi/hwloc/commit/ac1f8db9a0790d2bf153711ff4cbf6101f89aace,linux: handle glibc cpuset allocation failures\n\nCloses #544\nCVE-2022-47022\n\nSigned-off-by: Brice Goglin <Brice.Goglin@inria.fr>,5,"[{""func_name"": ""hwloc_linux_get_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  int err __hwloc_attribute_unused;\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int kernel_nr_cpus;\n\n  /* find the kernel nr_cpus so as to use a large enough cpu_set size */\n  kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);\n  setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);\n  plinux_set = CPU_ALLOC(kernel_nr_cpus);\n\n  err = sched_getaffinity(tid, setsize, plinux_set);\n\n  if (err < 0) {\n    CPU_FREE(plinux_set);\n    return -1;\n  }\n\n  last = -1;\n  if (topology->levels[0][0]->complete_cpuset)\n    last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n  if (last == -1)\n    /* round the maximal support number, the topology isn't ready yet (complete_cpuset is missing or empty)*/\n    last = kernel_nr_cpus-1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<=(unsigned) last; cpu++)\n    if (CPU_ISSET_S(cpu, setsize, plinux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n\n  CPU_FREE(plinux_set);\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n    if (CPU_ISSET(cpu, &linux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_from_ulong(hwloc_set, mask);\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_find_kernel_nr_cpus"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_find_kernel_nr_cpus(hwloc_topology_t topology)\n{\n  static int _nr_cpus = -1;\n  int nr_cpus = _nr_cpus;\n  hwloc_bitmap_t possible_bitmap;\n\n  if (nr_cpus != -1)\n    /* already computed */\n    return nr_cpus;\n\n  if (topology->levels[0][0]->complete_cpuset)\n    /* start with a nr_cpus that may contain the whole topology */\n    nr_cpus = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset) + 1;\n  if (nr_cpus <= 0)\n    /* start from scratch, the topology isn't ready yet (complete_cpuset is missing (-1) or empty (0))*/\n    nr_cpus = 1;\n\n  /* reading /sys/devices/system/cpu/kernel_max would be easier (single value to parse instead of a list),\n   * but its value may be way too large (5119 on CentOS7).\n   * /sys/devices/system/cpu/possible is better because it matches the current hardware.\n   */\n\n  possible_bitmap = hwloc__alloc_read_path_as_cpulist(\""/sys/devices/system/cpu/possible\"", -1); /* binding only supported in real fsroot, no need for data->root_fd */\n  if (possible_bitmap) {\n    int max_possible = hwloc_bitmap_last(possible_bitmap);\n    hwloc_debug_bitmap(\""possible CPUs are %s\\n\"", possible_bitmap);\n    if (nr_cpus < max_possible + 1)\n      nr_cpus = max_possible + 1;\n    hwloc_bitmap_free(possible_bitmap);\n  }\n\n  while (1) {\n    cpu_set_t *set = CPU_ALLOC(nr_cpus);\n    size_t setsize = CPU_ALLOC_SIZE(nr_cpus);\n    int err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */\n    CPU_FREE(set);\n    nr_cpus = setsize * 8; /* that's the value that was actually tested */\n    if (!err)\n      /* Found it. Only update the static value with the final one,\n       * to avoid sharing intermediate values that we modify,\n       * in case there's ever multiple concurrent calls.\n       */\n      return _nr_cpus = nr_cpus;\n    nr_cpus *= 2;\n  }\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_set_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_set_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_const_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  /* The resulting binding is always strict */\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int err;\n\n  last = hwloc_bitmap_last(hwloc_set);\n  if (last == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  setsize = CPU_ALLOC_SIZE(last+1);\n  plinux_set = CPU_ALLOC(last+1);\n\n  CPU_ZERO_S(setsize, plinux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET_S(cpu, setsize, plinux_set);\n  hwloc_bitmap_foreach_end();\n\n  err = sched_setaffinity(tid, setsize, plinux_set);\n\n  CPU_FREE(plinux_set);\n  return err;\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n  CPU_ZERO(&linux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET(cpu, &linux_set);\n  hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_get_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_get_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_getaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n     assert (last != -1);\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n\n     err = pthread_getaffinity_np(tid, setsize, plinux_set);\n     if (err) {\n        CPU_FREE(plinux_set);\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<=(unsigned) last; cpu++)\n       if (CPU_ISSET_S(cpu, setsize, plinux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_getaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_getaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     if (err) {\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n       if (CPU_ISSET(cpu, &linux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_getaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_getaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      if (err) {\n        errno = err;\n        return -1;\n      }\n\n     hwloc_bitmap_from_ulong(hwloc_set, mask);\n  }\n#endif /* CPU_SET */\n\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_set_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_set_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_setaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(hwloc_set);\n     if (last == -1) {\n       errno = EINVAL;\n       return -1;\n     }\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n\n     CPU_ZERO_S(setsize, plinux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET_S(cpu, setsize, plinux_set);\n     hwloc_bitmap_foreach_end();\n\n     err = pthread_setaffinity_np(tid, setsize, plinux_set);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n     CPU_ZERO(&linux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET(cpu, &linux_set);\n     hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_setaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_setaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_setaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_setaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#endif /* CPU_SET */\n\n  if (err) {\n    errno = err;\n    return -1;\n  }\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""hwloc_linux_get_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  int err __hwloc_attribute_unused;\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int kernel_nr_cpus;\n\n  /* find the kernel nr_cpus so as to use a large enough cpu_set size */\n  kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);\n  if (kernel_nr_cpus < 0)\n    return -1;\n  setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);\n  plinux_set = CPU_ALLOC(kernel_nr_cpus);\n  if (!plinux_set)\n    return -1;\n\n  err = sched_getaffinity(tid, setsize, plinux_set);\n\n  if (err < 0) {\n    CPU_FREE(plinux_set);\n    return -1;\n  }\n\n  last = -1;\n  if (topology->levels[0][0]->complete_cpuset)\n    last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n  if (last == -1)\n    /* round the maximal support number, the topology isn't ready yet (complete_cpuset is missing or empty)*/\n    last = kernel_nr_cpus-1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<=(unsigned) last; cpu++)\n    if (CPU_ISSET_S(cpu, setsize, plinux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n\n  CPU_FREE(plinux_set);\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n    if (CPU_ISSET(cpu, &linux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_from_ulong(hwloc_set, mask);\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n\n  return 0;\n}""}, {""func_name"": ""hwloc_linux_find_kernel_nr_cpus"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_find_kernel_nr_cpus(hwloc_topology_t topology)\n{\n  static int _nr_cpus = -1;\n  int nr_cpus = _nr_cpus;\n  hwloc_bitmap_t possible_bitmap;\n\n  if (nr_cpus != -1)\n    /* already computed */\n    return nr_cpus;\n\n  if (topology->levels[0][0]->complete_cpuset)\n    /* start with a nr_cpus that may contain the whole topology */\n    nr_cpus = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset) + 1;\n  if (nr_cpus <= 0)\n    /* start from scratch, the topology isn't ready yet (complete_cpuset is missing (-1) or empty (0))*/\n    nr_cpus = 1;\n\n  /* reading /sys/devices/system/cpu/kernel_max would be easier (single value to parse instead of a list),\n   * but its value may be way too large (5119 on CentOS7).\n   * /sys/devices/system/cpu/possible is better because it matches the current hardware.\n   */\n\n  possible_bitmap = hwloc__alloc_read_path_as_cpulist(\""/sys/devices/system/cpu/possible\"", -1); /* binding only supported in real fsroot, no need for data->root_fd */\n  if (possible_bitmap) {\n    int max_possible = hwloc_bitmap_last(possible_bitmap);\n    hwloc_debug_bitmap(\""possible CPUs are %s\\n\"", possible_bitmap);\n    if (nr_cpus < max_possible + 1)\n      nr_cpus = max_possible + 1;\n    hwloc_bitmap_free(possible_bitmap);\n  }\n\n  while (1) {\n    cpu_set_t *set = CPU_ALLOC(nr_cpus);\n    size_t setsize = CPU_ALLOC_SIZE(nr_cpus);\n    int err;\n    if (!set)\n      return -1; /* caller will return an error, and we'll try again later */\n    err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */\n    CPU_FREE(set);\n    nr_cpus = setsize * 8; /* that's the value that was actually tested */\n    if (!err)\n      /* Found it. Only update the static value with the final one,\n       * to avoid sharing intermediate values that we modify,\n       * in case there's ever multiple concurrent calls.\n       */\n      return _nr_cpus = nr_cpus;\n    nr_cpus *= 2;\n  }\n}""}, {""func_name"": ""hwloc_linux_set_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_set_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_const_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  /* The resulting binding is always strict */\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int err;\n\n  last = hwloc_bitmap_last(hwloc_set);\n  if (last == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  setsize = CPU_ALLOC_SIZE(last+1);\n  plinux_set = CPU_ALLOC(last+1);\n  if (!plinux_set)\n    return -1;\n\n  CPU_ZERO_S(setsize, plinux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET_S(cpu, setsize, plinux_set);\n  hwloc_bitmap_foreach_end();\n\n  err = sched_setaffinity(tid, setsize, plinux_set);\n\n  CPU_FREE(plinux_set);\n  return err;\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n  CPU_ZERO(&linux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET(cpu, &linux_set);\n  hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n}""}, {""func_name"": ""hwloc_linux_get_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_get_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_getaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n     assert (last != -1);\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n     if (!plinux_set)\n       return -1;\n\n     err = pthread_getaffinity_np(tid, setsize, plinux_set);\n     if (err) {\n        CPU_FREE(plinux_set);\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<=(unsigned) last; cpu++)\n       if (CPU_ISSET_S(cpu, setsize, plinux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_getaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_getaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     if (err) {\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n       if (CPU_ISSET(cpu, &linux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_getaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_getaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      if (err) {\n        errno = err;\n        return -1;\n      }\n\n     hwloc_bitmap_from_ulong(hwloc_set, mask);\n  }\n#endif /* CPU_SET */\n\n  return 0;\n}""}, {""func_name"": ""hwloc_linux_set_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_set_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_setaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(hwloc_set);\n     if (last == -1) {\n       errno = EINVAL;\n       return -1;\n     }\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n     if (!plinux_set)\n       return -1;\n\n     CPU_ZERO_S(setsize, plinux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET_S(cpu, setsize, plinux_set);\n     hwloc_bitmap_foreach_end();\n\n     err = pthread_setaffinity_np(tid, setsize, plinux_set);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n     CPU_ZERO(&linux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET(cpu, &linux_set);\n     hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_setaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_setaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_setaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_setaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#endif /* CPU_SET */\n\n  if (err) {\n    errno = err;\n    return -1;\n  }\n  return 0;\n}""}]","{""caller"": 3}","[{""source"": ""caller_info(file:topology-linux.c, func:hwloc_linux_get_tid_cpubind)"", ""result"": [{""call_line"": 1205, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, tid, tidset)"", ""caller_code"": ""static int\nhwloc_linux_foreach_proc_tid_get_cpubind_cb(hwloc_topology_t topology, pid_t tid, void *_data, int idx)\n{\n  struct hwloc_linux_foreach_proc_tid_get_cpubind_cb_data_s *data = _data;\n  hwloc_bitmap_t cpuset = data->cpuset;\n  hwloc_bitmap_t tidset = data->tidset;\n  int flags = data->flags;\n\n  if (hwloc_linux_get_tid_cpubind(topology, tid, tidset))\n    return -1;\n\n  /* reset the cpuset on first iteration */\n  if (!idx)\n    hwloc_bitmap_zero(cpuset);\n\n  if (flags & HWLOC_CPUBIND_STRICT) {\n    /* if STRICT, we want all threads to have the same binding */\n    if (!idx) {\n      /* this is the first thread, copy its binding */\n      hwloc_bitmap_copy(cpuset, tidset);\n    } else if (!hwloc_bitmap_isequal(cpuset, tidset)) {\n      /* this is not the first thread, and it's binding is different */\n      errno = EXDEV;\n      return -1;\n    }\n  } else {\n    /* if not STRICT, just OR all thread bindings */\n    hwloc_bitmap_or(cpuset, cpuset, tidset);\n  }\n  return 0;\n}"", ""caller_start"": 1197, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1263, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, pid, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_get_proc_cpubind(hwloc_topology_t topology, pid_t pid, hwloc_bitmap_t hwloc_set, int flags)\n{\n  if (pid == 0)\n    pid = topology->pid;\n  if (flags & HWLOC_CPUBIND_THREAD)\n    return hwloc_linux_get_tid_cpubind(topology, pid, hwloc_set);\n  else\n    return hwloc_linux_get_pid_cpubind(topology, pid, hwloc_set, flags);\n}"", ""caller_start"": 1257, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1297, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_get_thisthread_cpubind(hwloc_topology_t topology, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n  return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);\n}"", ""caller_start"": 1290, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 199, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, tid, cpuset)"", ""caller_code"": ""int hwloc_ps_read_process(hwloc_topology_t topology, hwloc_const_bitmap_t topocpuset,\n\t\t\t  struct hwloc_ps_process *proc,\n\t\t\t  unsigned long flags)\n{\n#ifdef HAVE_DIRENT_H\n  hwloc_pid_t realpid;\n  hwloc_bitmap_t cpuset;\n  unsigned pathlen;\n  char *path;\n  int fd;\n  ssize_t n;\n\n  if (hwloc_pid_from_number(&realpid, proc->pid, 0, 0 /* ignore failures */) < 0)\n    return -1;\n\n  cpuset = hwloc_bitmap_alloc();\n  if (!cpuset)\n    return -1;\n\n  pathlen = 6 + 21 + 1 + 7 + 1; /* enough for /proc/%ld/cmdline /proc/%ld/comm and /proc/%ld/stat */\n  path = malloc(pathlen);\n\n  snprintf(path, pathlen, \""/proc/%ld/cmdline\"", proc->pid);\n  fd = open(path, O_RDONLY);\n  if (fd < 0) {\n    free(path);\n    goto out;\n  }\n  n = read(fd, proc->name, sizeof(proc->name) - 1);\n  close(fd);\n  if (n <= 0) {\n    /* Ignore kernel threads and errors */\n    free(path);\n    goto out;\n  }\n  proc->name[n] = '\\0';\n\n  if (flags & HWLOC_PS_FLAG_SHORTNAME) {\n    /* try to get a small name from comm */\n    char comm[16] = \""\"";\n    snprintf(path, pathlen, \""/proc/%ld/comm\"", proc->pid);\n    fd = open(path, O_RDONLY);\n    if (fd >= 0) {\n      n = read(fd, comm, sizeof(comm) - 1);\n      close(fd);\n      if (n > 0) {\n\tcomm[n] = '\\0';\n\tif (n > 1 && comm[n-1] == '\\n')\n\t  comm[n-1] = '\\0';\n      }\n\n    } else {\n      /* Old kernel, have to look at old file */\n      char stats[32];\n      char *parenl = NULL, *parenr;\n\n      snprintf(path, pathlen, \""/proc/%ld/stat\"", proc->pid);\n      fd = open(path, O_RDONLY);\n      if (fd >= 0) {\n\t/* \""pid (comm) ...\"" */\n\tn = read(fd, stats, sizeof(stats) - 1);\n\tclose(fd);\n\tif (n > 0) {\n\t  stats[n] = '\\0';\n\t  parenl = strchr(stats, '(');\n\t  parenr = strchr(stats, ')');\n\t  if (!parenr)\n\t    parenr = &stats[sizeof(stats)-1];\n\t  *parenr = '\\0';\n\t  if (parenl)\n\t    snprintf(comm, sizeof(comm), \""%s\"", parenl+1);\n\t}\n      }\n    }\n\n    if (*comm)\n      snprintf(proc->name, sizeof(proc->name), \""%s\"", comm);\n  }\n\n  free(path);\n\n  proc->string[0] = '\\0'; /* might be set later if hwloc_ps_pidcmd is called */\n\n  if (flags & HWLOC_PS_FLAG_UID) {\n    proc->uid = HWLOC_PS_ALL_UIDS;\n#ifdef HWLOC_LINUX_SYS\n    pathlen = 6 + 21 + 1 + 6 + 1;\n    path = malloc(pathlen);\n    snprintf(path, pathlen, \""/proc/%ld/status\"", proc->pid);\n    fd = open(path, O_RDONLY);\n    if (fd >= 0) {\n      char status[1024];\n      char *uid;\n      if (read(fd, &status, sizeof(status)) > 0) {\n        status[1023] = '\\0';\n        uid = strstr(status, \""Uid:\"");\n        if (uid)\n          proc->uid = strtoul(uid+4, NULL, 0);\n        close(fd);\n      }\n    }\n    free(path);\n#endif\n    /* On *BSD, parse the end of the single-line in /proc/pid/status\n     * (but the format is different between FreeBSD and NetBSD).\n     * It may be a good time to switch to a portable library for gathering this info.\n     */\n  }\n\n  if (flags & HWLOC_PS_FLAG_THREADS) {\n#ifdef HWLOC_LINUX_SYS\n    /* check if some threads must be displayed */\n    DIR *taskdir;\n\n    pathlen = 6 + 21 + 1 + 4 + 1;\n    path = malloc(pathlen);\n    snprintf(path, pathlen, \""/proc/%ld/task\"", proc->pid);\n    taskdir = opendir(path);\n    if (taskdir) {\n      struct dirent *taskdirent;\n      long tid;\n      char *end;\n      unsigned nbth = 0;\n      /* count threads */\n      while ((taskdirent = readdir(taskdir))) {\n\ttid = strtol(taskdirent->d_name, &end, 10);\n\tif (*end)\n\t  /* Not a number */\n\t  continue;\n\tnbth++;\n      }\n      if (nbth > 1) {\n\t/* if there's more than one thread, see if some are bound */\n\tproc->threads = calloc(nbth, sizeof(*proc->threads));\n\tif (proc->threads) {\n\t  /* reread the directory but gather info now */\n\t  rewinddir(taskdir);\n\t  unsigned i = 0;\n\t  while ((taskdirent = readdir(taskdir))) {\n\t    char *path2;\n\t    unsigned path2len;\n\n\t    tid = strtol(taskdirent->d_name, &end, 10);\n\t    if (*end)\n\t      /* Not a number */\n\t      continue;\n\n\t    proc->threads[i].tid = tid;\n\n\t    path2len = pathlen + 1 + 21 + 1 + 4 + 1;\n\t    path2 = malloc(path2len);\n\t    if (path2) {\n\t      int commfd;\n\t      snprintf(path2, path2len, \""%s/%ld/comm\"", path, tid);\n\t      commfd = open(path2, O_RDWR);\n\t      if (commfd >= 0) {\n\t\tn = read(commfd, proc->threads[i].name, sizeof(proc->threads[i].name));\n\t\tclose(commfd);\n\t\tif (n <= 0)\n\t\t  proc->threads[i].name[0] = '\\0';\n\t\telse if ((size_t)n < sizeof(proc->threads[i].name))\n\t\t  proc->threads[i].name[n] = '\\0';\n\t\tproc->threads[i].name[sizeof(proc->threads[i].name)-1] = '\\0';\n\t\tend = strchr(proc->threads[i].name, '\\n');\n\t\tif (end)\n\t\t  *end = '\\0';\n\t      }\n\t      free(path2);\n\t    }\n\n\t    if (flags & HWLOC_PS_FLAG_LASTCPULOCATION) {\n\t      if (hwloc_linux_get_tid_last_cpu_location(topology, tid, cpuset))\n\t\tgoto next;\n\t    } else {\n\t      if (hwloc_linux_get_tid_cpubind(topology, tid, cpuset))\n\t\tgoto next;\n\t    }\n\t    hwloc_bitmap_and(cpuset, cpuset, topocpuset);\n\t    if (hwloc_bitmap_iszero(cpuset))\n\t      goto next;\n\n\t    proc->threads[i].cpuset = hwloc_bitmap_dup(cpuset);\n\t    if (!hwloc_bitmap_isequal(cpuset, topocpuset)) {\n\t      proc->threads[i].bound = 1;\n\t      proc->nboundthreads++;\n\t    }\n\n\t  next:\n\t    i++;\n\t    proc->nthreads++;\n\t    if (i == nbth)\n\t      /* ignore the lastly created threads, I'm too lazy to reallocate */\n\t      break;\n\t  }\n\t} else {\n\t  /* failed to alloc, behave as if there were no threads */\n\t}\n      }\n      closedir(taskdir);\n    }\n    free(path);\n#endif /* HWLOC_LINUX_SYS */\n  }\n\n  if (flags & HWLOC_PS_FLAG_LASTCPULOCATION) {\n    if (hwloc_get_proc_last_cpu_location(topology, realpid, cpuset, 0))\n      goto out;\n  } else {\n    if (hwloc_get_proc_cpubind(topology, realpid, cpuset, 0))\n      goto out;\n  }\n\n  hwloc_bitmap_and(cpuset, cpuset, topocpuset);\n  if (hwloc_bitmap_iszero(cpuset))\n    goto out;\n\n  proc->bound = !hwloc_bitmap_isequal(cpuset, topocpuset);\n  proc->cpuset = cpuset;\n  return 0;\n\n out:\n  hwloc_bitmap_free(cpuset);\n#endif /* HAVE_DIRENT_H */\n  return -1;\n}\n"", ""caller_start"": 25, ""file_path"": ""utils/hwloc/common-ps.c""}]}, {""source"": ""caller_info(file:topology-linux.c, func:hwloc_linux_find_kernel_nr_cpus)"", ""result"": [{""call_line"": 988, ""call_code"": ""hwloc_linux_find_kernel_nr_cpus(topology)"", ""caller_code"": ""int\nhwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  int err __hwloc_attribute_unused;\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int kernel_nr_cpus;\n\n  /* find the kernel nr_cpus so as to use a large enough cpu_set size */\n  kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);\n  setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);\n  plinux_set = CPU_ALLOC(kernel_nr_cpus);\n\n  err = sched_getaffinity(tid, setsize, plinux_set);\n\n  if (err < 0) {\n    CPU_FREE(plinux_set);\n    return -1;\n  }\n\n  last = -1;\n  if (topology->levels[0][0]->complete_cpuset)\n    last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n  if (last == -1)\n    /* round the maximal support number, the topology isn't ready yet (complete_cpuset is missing or empty)*/\n    last = kernel_nr_cpus-1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<=(unsigned) last; cpu++)\n    if (CPU_ISSET_S(cpu, setsize, plinux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n\n  CPU_FREE(plinux_set);\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n    if (CPU_ISSET(cpu, &linux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_from_ulong(hwloc_set, mask);\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n\n  return 0;\n}\n"", ""caller_start"": 975, ""file_path"": ""hwloc/topology-linux.c""}]}, {""source"": ""caller_info(file:topology-linux.c, func:hwloc_linux_set_tid_cpubind)"", ""result"": [{""call_line"": 1179, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, tid, (hwloc_bitmap_t) data)"", ""caller_code"": ""static int\nhwloc_linux_foreach_proc_tid_set_cpubind_cb(hwloc_topology_t topology, pid_t tid, void *data, int idx __hwloc_attribute_unused)\n{\n  return hwloc_linux_set_tid_cpubind(topology, tid, (hwloc_bitmap_t) data);\n}"", ""caller_start"": 1176, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1252, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, pid, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_set_proc_cpubind(hwloc_topology_t topology, pid_t pid, hwloc_const_bitmap_t hwloc_set, int flags)\n{\n  if (pid == 0)\n    pid = topology->pid;\n  if (flags & HWLOC_CPUBIND_THREAD)\n    return hwloc_linux_set_tid_cpubind(topology, pid, hwloc_set);\n  else\n    return hwloc_linux_set_pid_cpubind(topology, pid, hwloc_set, flags);\n}"", ""caller_start"": 1246, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1287, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_set_thisthread_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n  return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);\n}"", ""caller_start"": 1280, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 575, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, tid_number, cpubind_set)"", ""caller_code"": ""int main(int argc, char *argv[])\n{\n  hwloc_topology_t topology;\n  int depth = -1;\n  hwloc_bitmap_t cpubind_set, membind_set;\n  int got_cpubind = 0, got_membind = 0;\n  int working_on_cpubind = 1; /* membind if 0 */\n  int get_binding = 0;\n  int use_nodeset = 0;\n  int get_last_cpu_location = 0;\n  unsigned long flags = 0;\n  unsigned long restrict_flags = 0;\n  int force = 0;\n  int single = 0;\n  int verbose = 0;\n  int no_smt = -1;\n  int only_hbm = -1;\n  int logical = 1;\n  int taskset = 0;\n  unsigned cpubind_flags = 0;\n  hwloc_membind_policy_t membind_policy = HWLOC_MEMBIND_BIND;\n  int got_mempolicy = 0;\n  unsigned membind_flags = 0;\n  int opt;\n  int ret;\n  int pid_number = -1;\n  int tid_number = -1;\n  hwloc_pid_t pid = 0; /* only valid when pid_number > 0, but gcc-4.8 still reports uninitialized warnings */\n  hwloc_memattr_id_t best_memattr_id = (hwloc_memattr_id_t) -1;\n  const char *best_memattr_str = NULL;\n  char *callname;\n  char *restrictstring = NULL;\n  struct hwloc_calc_location_context_s lcontext;\n  struct hwloc_calc_set_context_s scontext;\n\n  callname = strrchr(argv[0], '/');\n  if (!callname)\n    callname = argv[0];\n  else\n    callname++;\n\n  /* skip argv[0], handle options */\n  argv++;\n  argc--;\n\n  hwloc_utils_check_api_version(callname);\n\n  cpubind_set = hwloc_bitmap_alloc();\n  membind_set = hwloc_bitmap_alloc();\n\n  while (argc >= 1) {\n    opt = 0;\n\n    if (!strcmp (argv[0], \""--disallowed\"") || !strcmp (argv[0], \""--whole-system\"")) {\n      flags |= HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED;\n      goto next_config;\n    }\n    if (!strcmp (argv[0], \""--restrict\"")) {\n      if (argc < 2) {\n        usage (callname, stderr);\n        exit(EXIT_FAILURE);\n      }\n      if(strncmp(argv[1], \""nodeset=\"", 7))\n        restrictstring = strdup(argv[1]);\n      else {\n        restrictstring = strdup(argv[1]+8);\n        restrict_flags |= HWLOC_RESTRICT_FLAG_BYNODESET;\n      }\n      opt = 1;\n      goto next_config;\n    }\n    if (!strcmp (argv[0], \""--restrict-flags\"")) {\n      if (argc < 2) {\n        usage (callname, stderr);\n        exit(EXIT_FAILURE);\n      }\n      restrict_flags = hwloc_utils_parse_restrict_flags(argv[1]);\n      opt = 1;\n      goto next_config;\n    }\n    if (!strcmp(argv[0], \""--no-smt\"")) {\n      no_smt = 0;\n      goto next_config;\n    }\n    if (!strncmp(argv[0], \""--no-smt=\"", 9)) {\n      no_smt = atoi(argv[0] + 9);\n      goto next_config;\n    }\n    if (!strcmp(argv[0], \""--hbm\"")) {\n      only_hbm = 1;\n      goto next_config;\n    }\n    if (!strcmp(argv[0], \""--no-hbm\"")) {\n      only_hbm = 0;\n      goto next_config;\n    }\n    if (!strcmp (argv[0], \""--best-memattr\"")) {\n      if (argc < 2) {\n        usage (callname, stderr);\n        exit(EXIT_FAILURE);\n      }\n      best_memattr_str = argv[1];\n      opt = 1;\n      goto next_config;\n    }\n\n    break;\n\n  next_config:\n    argc -= opt+1;\n    argv += opt+1;\n  }\n\n  hwloc_topology_init(&topology);\n  hwloc_topology_set_all_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_ALL);\n  hwloc_topology_set_flags(topology, flags);\n  ret = hwloc_topology_load(topology);\n  if (ret < 0) {\n    perror(\""Couldn't load the topology\"");\n    return EXIT_FAILURE;\n  }\n  if (restrictstring) {\n    hwloc_bitmap_t restrictset = hwloc_bitmap_alloc();\n    hwloc_bitmap_sscanf(restrictset, restrictstring);\n    if (hwloc_topology_restrict (topology, restrictset, restrict_flags)) {\n      perror(\""Restricting the topology\"");\n      /* FALLTHRU */\n    }\n    hwloc_bitmap_free(restrictset);\n    free(restrictstring);\n  }\n  depth = hwloc_topology_get_depth(topology);\n\n  while (argc >= 1) {\n    char *location;\n    int nodeset_location;\n\n    if (!strcmp(argv[0], \""--\"")) {\n      argc--;\n      argv++;\n      break;\n    }\n\n    opt = 0;\n\n    if (*argv[0] == '-') {\n      if (!strcmp(argv[0], \""-v\"") || !strcmp(argv[0], \""--verbose\"")) {\n\tverbose++;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""-q\"") || !strcmp(argv[0], \""--quiet\"")) {\n\tverbose--;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""-h\"") || !strcmp(argv[0], \""--help\"")) {\n        usage(callname, stdout);\n\treturn EXIT_SUCCESS;\n      }\n      if (!strcmp(argv[0], \""--single\"")) {\n\tsingle = 1;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""-f\"") || !strcmp(argv[0], \""--force\"")) {\n\tforce = 1;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""--strict\"")) {\n\tcpubind_flags |= HWLOC_CPUBIND_STRICT;\n\tmembind_flags |= HWLOC_MEMBIND_STRICT;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""--pid\"")) {\n        if (argc < 2) {\n          usage (callname, stderr);\n          exit(EXIT_FAILURE);\n        }\n        pid_number = atoi(argv[1]);\n        opt = 1;\n        goto next;\n      }\n#ifdef HWLOC_LINUX_SYS\n      if (!strcmp(argv[0], \""--tid\"")) {\n        if (argc < 2) {\n          usage (callname, stderr);\n          exit(EXIT_FAILURE);\n        }\n        tid_number = atoi(argv[1]);\n        opt = 1;\n        goto next;\n      }\n#endif\n      if (!strcmp (argv[0], \""--version\"")) {\n\tprintf(\""%s %s\\n\"", callname, HWLOC_VERSION);\n\texit(EXIT_SUCCESS);\n      }\n      if (!strcmp(argv[0], \""-l\"") || !strcmp(argv[0], \""--logical\"")) {\n        logical = 1;\n        goto next;\n      }\n      if (!strcmp(argv[0], \""-p\"") || !strcmp(argv[0], \""--physical\"")) {\n        logical = 0;\n        goto next;\n      }\n      if (!strcmp(argv[0], \""--taskset\"")) {\n        taskset = 1;\n        goto next;\n      }\n      if (!strcmp (argv[0], \""-e\"") || !strncmp (argv[0], \""--get-last-cpu-location\"", 10)) {\n\tget_last_cpu_location = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--get\"")) {\n\tget_binding = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--nodeset\"")) {\n\tuse_nodeset = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--cpubind\"")) {\n\tworking_on_cpubind = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--membind\"")) {\n\tworking_on_cpubind = 0;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--mempolicy\"")) {\n\tif (!strncmp(argv[1], \""default\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_DEFAULT;\n\telse if (!strncmp(argv[1], \""firsttouch\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_FIRSTTOUCH;\n\telse if (!strncmp(argv[1], \""bind\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_BIND;\n\telse if (!strncmp(argv[1], \""interleave\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_INTERLEAVE;\n\telse if (!strncmp(argv[1], \""nexttouch\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_NEXTTOUCH;\n\telse {\n\t  fprintf(stderr, \""Unrecognized memory binding policy %s\\n\"", argv[1]);\n          usage (callname, stderr);\n          exit(EXIT_FAILURE);\n\t}\n\tgot_mempolicy = 1;\n\topt = 1;\n\tgoto next;\n      }\n\n      fprintf (stderr, \""Unrecognized option: %s\\n\"", argv[0]);\n      usage(callname, stderr);\n      return EXIT_FAILURE;\n    }\n\n    location = argv[0];\n    nodeset_location = 0;\n    if (!strncmp(location, \""nodeset=\"", 8)) {\n      location += 8;\n      nodeset_location = 1;\n    }\n\n    lcontext.topology = topology;\n    lcontext.topodepth = depth;\n    lcontext.only_hbm = only_hbm;\n    lcontext.logical = logical;\n    lcontext.verbose = verbose;\n    scontext.nodeset_input = use_nodeset || nodeset_location;\n    scontext.nodeset_output = working_on_cpubind ? 0 : 1;\n    scontext.output_set = working_on_cpubind ? cpubind_set : membind_set;\n    ret = hwloc_calc_process_location_as_set(&lcontext, &scontext, location);\n    if (ret < 0) {\n      fprintf(stderr, \""argument `%s' unrecognized, assuming this is the executable.\\n\"", argv[0]);\n      break;\n    }\n    if (working_on_cpubind)\n      got_cpubind = 1;\n    else\n      got_membind = 1;\n\n  next:\n    argc -= opt+1;\n    argv += opt+1;\n  }\n\n  if (pid_number > 0 && tid_number > 0) {\n    fprintf(stderr, \""cannot operate both on tid and pid\\n\"");\n    return EXIT_FAILURE;\n  }\n\n  if (pid_number > 0) {\n    if (hwloc_pid_from_number(&pid, pid_number, !(get_binding || get_last_cpu_location), 1 /* verbose */) < 0) {\n      fprintf(stderr, \""failed to use pid\\n\"");\n      return EXIT_FAILURE;\n    }\n    /* no need to set_pid()\n     * the doc just says we're operating on pid, not that we're retrieving the topo/cpuset as seen from inside pid\n     */\n  }\n\n  if (get_last_cpu_location && !working_on_cpubind) {\n    fprintf(stderr, \""Options --membind and --get-last-cpu-location cannot be combined.\\n\"");\n    return EXIT_FAILURE;\n  }\n  if ((get_binding || get_last_cpu_location) && (got_cpubind || got_membind)) {\n    /* doesn't work because get_binding/get_last_cpu_location overwrites cpubind_set */\n    fprintf(stderr, \""Cannot display and set binding at the same time.\\n\"");\n    return EXIT_FAILURE;\n  }\n\n  if (!got_cpubind && !got_membind && !get_binding && !get_last_cpu_location) {\n    if (verbose >= 0)\n      fprintf(stderr, \""got neither CPU nor memory binding locations.\\n\"");\n  }\n\n  if (get_binding || get_last_cpu_location) {\n    char *s;\n    const char *policystr = NULL;\n    int err;\n    if (working_on_cpubind) {\n      if (get_last_cpu_location) {\n\tif (pid_number > 0)\n\t  err = hwloc_get_proc_last_cpu_location(topology, pid, cpubind_set, 0);\n#ifdef HWLOC_LINUX_SYS\n\telse if (tid_number > 0)\n\t  err = hwloc_linux_get_tid_last_cpu_location(topology, tid_number, cpubind_set);\n#endif\n\telse\n\t  err = hwloc_get_last_cpu_location(topology, cpubind_set, 0);\n      } else {\n\tif (pid_number > 0)\n\t  err = hwloc_get_proc_cpubind(topology, pid, cpubind_set, 0);\n#ifdef HWLOC_LINUX_SYS\n\telse if (tid_number > 0)\n\t  err = hwloc_linux_get_tid_cpubind(topology, tid_number, cpubind_set);\n#endif\n\telse\n\t  err = hwloc_get_cpubind(topology, cpubind_set, 0);\n      }\n      if (err) {\n\tconst char *errmsg = strerror(errno);\n\tif (pid_number > 0)\n\t  fprintf(stderr, \""hwloc_get_proc_%s %d failed (errno %d %s)\\n\"", get_last_cpu_location ? \""last_cpu_location\"" : \""cpubind\"", pid_number, errno, errmsg);\n\telse if (tid_number > 0)\n\t  fprintf(stderr, \""hwloc_get_tid_%s %d failed (errno %d %s)\\n\"", get_last_cpu_location ? \""last_cpu_location\"" : \""cpubind\"", tid_number, errno, errmsg);\n\telse\n\t  fprintf(stderr, \""hwloc_get_%s failed (errno %d %s)\\n\"", get_last_cpu_location ? \""last_cpu_location\"" : \""cpubind\"", errno, errmsg);\n\treturn EXIT_FAILURE;\n      }\n      if (use_nodeset) {\n\thwloc_bitmap_t nset = hwloc_bitmap_alloc();\n\thwloc_cpuset_to_nodeset(topology, cpubind_set, nset);\n\tif (taskset)\n\t  hwloc_bitmap_taskset_asprintf(&s, nset);\n\telse\n\t  hwloc_bitmap_asprintf(&s, nset);\n\thwloc_bitmap_free(nset);\n      } else {\n\tif (taskset)\n\t  hwloc_bitmap_taskset_asprintf(&s, cpubind_set);\n\telse\n\t  hwloc_bitmap_asprintf(&s, cpubind_set);\n      }\n\n      } else {\n      hwloc_membind_policy_t policy;\n      if (pid_number > 0) {\n\terr = hwloc_get_proc_membind(topology, pid, membind_set, &policy, use_nodeset ? HWLOC_MEMBIND_BYNODESET : 0);\n      } else if (tid_number > 0) {\n\terr = -1; errno = ENOSYS;\n      } else {\n\terr = hwloc_get_membind(topology, membind_set, &policy, use_nodeset ? HWLOC_MEMBIND_BYNODESET : 0);\n      }\n      if (err) {\n\tconst char *errmsg = strerror(errno);\n        if (pid_number > 0)\n          fprintf(stderr, \""hwloc_get_proc_membind %d failed (errno %d %s)\\n\"", pid_number, errno, errmsg);\n        else\n\t  fprintf(stderr, \""hwloc_get_membind failed (errno %d %s)\\n\"", errno, errmsg);\n\treturn EXIT_FAILURE;\n      }\n      if (taskset)\n\thwloc_bitmap_taskset_asprintf(&s, membind_set);\n      else\n\thwloc_bitmap_asprintf(&s, membind_set);\n      switch (policy) {\n      case HWLOC_MEMBIND_FIRSTTOUCH: policystr = \""firsttouch\""; break;\n      case HWLOC_MEMBIND_BIND: policystr = \""bind\""; break;\n      case HWLOC_MEMBIND_INTERLEAVE: policystr = \""interleave\""; break;\n      case HWLOC_MEMBIND_NEXTTOUCH: policystr = \""nexttouch\""; break;\n      default: fprintf(stderr, \""unknown memory policy %d\\n\"", policy); assert(0); break;\n      }\n    }\n    if (policystr)\n      printf(\""%s (%s)\\n\"", s, policystr);\n    else\n      printf(\""%s\\n\"", s);\n    free(s);\n  }\n\n  if (got_membind) {\n    if (hwloc_bitmap_iszero(membind_set)) {\n      if (verbose >= 0)\n\tfprintf(stderr, \""cannot membind to empty set\\n\"");\n      if (!force)\n\tgoto failed_binding;\n    }\n\n    if (best_memattr_str) {\n      struct hwloc_location loc;\n      char *s;\n      best_memattr_id = hwloc_utils_parse_memattr_name(topology, best_memattr_str);\n      if (best_memattr_id == (hwloc_memattr_id_t) -1) {\n        fprintf(stderr, \""unrecognized memattr %s\\n\"", best_memattr_str);\n        return EXIT_FAILURE;\n      }\n\n      loc.type = HWLOC_LOCATION_TYPE_CPUSET;\n      loc.location.cpuset = cpubind_set;\n      if (verbose > 0) {\n        hwloc_bitmap_asprintf(&s, membind_set);\n        fprintf(stderr, \""memory binding set was %s before filtering by best memattr\\n\"", s);\n        free(s);\n      }\n      hwloc_utils_get_best_node_in_nodeset_by_memattr(topology, best_memattr_id, membind_set, &loc);\n      if (verbose > 0) {\n        hwloc_bitmap_asprintf(&s, membind_set);\n        /* double-space before %s for alignment with previous verbose message */\n        fprintf(stderr, \""memory binding is now  %s after filtering by best memattr\\n\"", s);\n        free(s);\n      }\n      if (hwloc_bitmap_iszero(membind_set)) {\n        fprintf(stderr, \""failed to find a best memory node for memory attribute `%s' among the given membind set.\\n\"", best_memattr_str);\n        return EXIT_FAILURE;\n      }\n    }\n\n    if (verbose > 0) {\n      char *s;\n      hwloc_bitmap_asprintf(&s, membind_set);\n      fprintf(stderr, \""binding on memory set %s\\n\"", s);\n      free(s);\n    }\n    if (single)\n      hwloc_bitmap_singlify(membind_set);\n    if (pid_number > 0)\n      ret = hwloc_set_proc_membind(topology, pid, membind_set, membind_policy, membind_flags | HWLOC_MEMBIND_BYNODESET);\n    else if (tid_number > 0) {\n      ret = -1; errno = ENOSYS;\n    } else\n      ret = hwloc_set_membind(topology, membind_set, membind_policy, membind_flags | HWLOC_MEMBIND_BYNODESET);\n    if (ret && verbose >= 0) {\n      int bind_errno = errno;\n      const char *errmsg = strerror(bind_errno);\n      char *s;\n      hwloc_bitmap_asprintf(&s, membind_set);\n      if (pid_number > 0)\n        fprintf(stderr, \""hwloc_set_proc_membind %s (policy %d flags 0x%x) PID %d failed (errno %d %s)\\n\"",\n\t\ts, membind_policy, membind_flags, pid_number, bind_errno, errmsg);\n      else\n        fprintf(stderr, \""hwloc_set_membind %s (policy %d flags 0x%x) failed (errno %d %s)\\n\"",\n\t\ts, membind_policy, membind_flags, bind_errno, errmsg);\n      free(s);\n    }\n    if (ret && !force)\n      goto failed_binding;\n  } else {\n    if (got_mempolicy)\n      fprintf(stderr, \""--mempolicy ignored unless memory binding is also requested with --membind.\\n\"");\n  }\n\n  if (!got_cpubind && no_smt != -1) {\n    hwloc_bitmap_copy(cpubind_set, hwloc_topology_get_topology_cpuset(topology));\n    got_cpubind = 1;\n  }\n\n  if (got_cpubind) {\n    if (hwloc_bitmap_iszero(cpubind_set)) {\n      if (verbose >= 0)\n\tfprintf(stderr, \""cannot cpubind to empty set\\n\"");\n      if (!force)\n\tgoto failed_binding;\n    }\n    if (verbose > 0) {\n      char *s;\n      hwloc_bitmap_asprintf(&s, cpubind_set);\n      fprintf(stderr, \""binding on cpu set %s\\n\"", s);\n      free(s);\n    }\n    if (got_membind && !hwloc_bitmap_isequal(membind_set, cpubind_set)) {\n      if (verbose)\n\tfprintf(stderr, \""Conflicting CPU and memory binding requested, adding HWLOC_CPUBIND_NOMEMBIND flag.\\n\"");\n      cpubind_flags |= HWLOC_CPUBIND_NOMEMBIND;\n    }\n    if (no_smt != -1) {\n      if (hwloc_get_type_depth(topology, HWLOC_OBJ_CORE) == HWLOC_TYPE_DEPTH_UNKNOWN) {\n\tfprintf(stderr, \""Topology has no Core object, ignoring --no-smt\\n\"");\n      } else {\n\thwloc_bitmap_singlify_per_core(topology, cpubind_set, no_smt);\n      }\n    }\n    if (single)\n      hwloc_bitmap_singlify(cpubind_set);\n    if (pid_number > 0)\n      ret = hwloc_set_proc_cpubind(topology, pid, cpubind_set, cpubind_flags);\n#ifdef HWLOC_LINUX_SYS\n    else if (tid_number > 0)\n      ret = hwloc_linux_set_tid_cpubind(topology, tid_number, cpubind_set);\n#endif\n    else\n      ret = hwloc_set_cpubind(topology, cpubind_set, cpubind_flags);\n    if (ret && verbose >= 0) {\n      int bind_errno = errno;\n      const char *errmsg = strerror(bind_errno);\n      char *s;\n      hwloc_bitmap_asprintf(&s, cpubind_set);\n      if (pid_number > 0)\n        fprintf(stderr, \""hwloc_set_proc_cpubind %s (flags 0x%x) PID %d failed (errno %d %s)\\n\"",\n\t\ts, cpubind_flags, pid_number, bind_errno, errmsg);\n      else if (tid_number > 0)\n        fprintf(stderr, \""hwloc_set_tid_cpubind %s (flags 0x%x) PID %d failed (errno %d %s)\\n\"",\n\t\ts, cpubind_flags, tid_number, bind_errno, errmsg);\n      else\n        fprintf(stderr, \""hwloc_set_cpubind %s (flags 0x%x) failed (errno %d %s)\\n\"",\n\t\ts, cpubind_flags, bind_errno, errmsg);\n      free(s);\n    }\n    if (ret && !force)\n      goto failed_binding;\n  }\n\n  hwloc_bitmap_free(cpubind_set);\n  hwloc_bitmap_free(membind_set);\n\n  hwloc_topology_destroy(topology);\n\n  if (pid_number > 0 || tid_number > 0)\n    return EXIT_SUCCESS;\n\n  if (0 == argc) {\n    if (get_binding || get_last_cpu_location)\n      return EXIT_SUCCESS;\n    fprintf(stderr, \""%s: nothing to do!\\n\"", callname);\n    return EXIT_FAILURE;\n  }\n\n  /* FIXME: check whether Windows execvp() passes INHERIT_PARENT_AFFINITY to CreateProcess()\n   * because we need to propagate processor group affinity. However process-wide affinity\n   * isn't supported with processor groups so far.\n   */\n  ret = execvp(argv[0], argv);\n  if (ret) {\n      fprintf(stderr, \""%s: Failed to launch executable \\\""%s\\\""\\n\"",\n              callname, argv[0]);\n      perror(\""execvp\"");\n  }\n  return EXIT_FAILURE;\n\n\nfailed_binding:\n  hwloc_bitmap_free(cpubind_set);\n  hwloc_bitmap_free(membind_set);\n  hwloc_topology_destroy(topology);\n  return EXIT_FAILURE;\n}\n"", ""caller_start"": 70, ""file_path"": ""utils/hwloc/hwloc-bind.c""}]}]","The root cause is unhandled NULL returns from CPU_ALLOC() in hwloc/topology-linux.c functions (hwloc_linux_get_tid_cpubind:987, hwloc_linux_find_kernel_nr_cpus:959, hwloc_linux_set_tid_cpubind:879, etc.). These functions allocated memory for cpu_set_t without checking for failure, risking dereference of invalid pointers. The patch adds NULL checks to return -1 on failure. Callers (e.g., hwloc_linux_get_proc_cpubind:1257, hwloc_linux_foreach_proc_tid_get_cpubind_cb:1197, hwloc_linux_set_tid_cpubind:1179) propagate errors via return values, eventually leading to error handling in main() (hwloc-bind.c:70) which exits on failure, preventing invalid memory access.",0.95,./github/other_context/CVE-2022-47022
43,CVE-2023-41358,CWE-476,c_cpp,An issue was discovered in FRRouting FRR through 9.0. bgpd/bgp_packet.c processes NLRIs if the attribute length is zero.,https://github.com/FRRouting/frr/commit/28ccc24d38df1d51ed8a563507e5d6f6171fdd38,"bgpd: Do not process NLRIs if the attribute length is zero\n\n```\n3  0x00007f423aa42476 in __GI_raise (sig=sig@entry=11) at ../sysdeps/posix/raise.c:26\n4  0x00007f423aef9740 in core_handler (signo=11, siginfo=0x7fffc414deb0, context=<optimized out>) at lib/sigevent.c:246\n5  <signal handler called>\n6  0x0000564dea2fc71e in route_set_aspath_prepend (rule=0x564debd66d50, prefix=0x7fffc414ea30, object=0x7fffc414e400)\n    at bgpd/bgp_routemap.c:2258\n7  0x00007f423aeec7e0 in route_map_apply_ext (map=<optimized out>, prefix=prefix@entry=0x7fffc414ea30,\n    match_object=match_object@entry=0x7fffc414e400, set_object=set_object@entry=0x7fffc414e400, pref=pref@entry=0x0) at lib/routemap.c:2690\n8  0x0000564dea2d277e in bgp_input_modifier (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, attr=attr@entry=0x7fffc414e770,\n    afi=afi@entry=AFI_IP, safi=safi@entry=SAFI_UNICAST, rmap_name=rmap_name@entry=0x0, label=0x0, num_labels=0, dest=0x564debdd5130)\n    at bgpd/bgp_route.c:1772\n9  0x0000564dea2df762 in bgp_update (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, addpath_id=addpath_id@entry=0,\n    attr=0x7fffc414eb50, afi=afi@entry=AFI_IP, safi=<optimized out>, safi@entry=SAFI_UNICAST, type=9, sub_type=0, prd=0x0, label=0x0,\n    num_labels=0, soft_reconfig=0, evpn=0x0) at bgpd/bgp_route.c:4374\n10 0x0000564dea2e2047 in bgp_nlri_parse_ip (peer=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50, packet=0x7fffc414eaf0)\n    at bgpd/bgp_route.c:6249\n11 0x0000564dea2c5a58 in bgp_nlri_parse (peer=peer@entry=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50,\n    packet=packet@entry=0x7fffc414eaf0, mp_withdraw=mp_withdraw@entry=false) at bgpd/bgp_packet.c:339\n12 0x0000564dea2c5d66 in bgp_update_receive (peer=peer@entry=0x7f4238f59010, size=size@entry=109) at bgpd/bgp_packet.c:2024\n13 0x0000564dea2c901d in bgp_process_packet (thread=<optimized out>) at bgpd/bgp_packet.c:2933\n14 0x00007f423af0bf71 in event_call (thread=thread@entry=0x7fffc414ee40) at lib/event.c:1995\n15 0x00007f423aebb198 in frr_run (master=0x564deb73c670) at lib/libfrr.c:1213\n16 0x0000564dea261b83 in main (argc=<optimized out>, argv=<optimized out>) at bgpd/bgp_main.c:505\n```\n\nWith the configuration:\n\n```\nfrr version 9.1-dev-MyOwnFRRVersion\nfrr defaults traditional\nhostname ip-172-31-13-140\nlog file /tmp/debug.log\nlog syslog\nservice integrated-vtysh-config\n!\ndebug bgp keepalives\ndebug bgp neighbor-events\ndebug bgp updates in\ndebug bgp updates out\n!\nrouter bgp 100\n bgp router-id 9.9.9.9\n no bgp ebgp-requires-policy\n bgp bestpath aigp\n neighbor 172.31.2.47 remote-as 200\n !\n address-family ipv4 unicast\n  neighbor 172.31.2.47 default-originate\n  neighbor 172.31.2.47 route-map RM_IN in\n exit-address-family\nexit\n!\nroute-map RM_IN permit 10\n set as-path prepend 200\nexit\n!\n```\n\nThe issue is that we try to process NLRIs even if the attribute length is 0.\n\nLater bgp_update() will handle route-maps and a crash occurs because all the\nattributes are NULL, including aspath, where we dereference.\n\nAccording to the RFC 4271:\n\nA value of 0 indicates that neither the Network Layer\n         Reachability Information field nor the Path Attribute field is\n         present in this UPDATE message.\n\nBut with a fuzzed UPDATE message this can be faked. I think it's reasonable\nto skip processing NLRIs if both update_len and attribute_len are 0.\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",1,"[{""func_name"": ""bgp_update_receive"", ""file_path"": ""bgpd/bgp_packet.c"", ""func_code"": ""static int bgp_update_receive(struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(peer)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \""%s [FSM] Update packet received under status %s\"",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet length is short for unfeasible length)\"",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet unfeasible length overflow %d)\"",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\""%s [Error] Packet Error (update packet is short for attribute length)\"",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\""%s [Error] Packet Error (update packet attribute length overflow %d)\"",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\"",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\""%pBP rcvd UPDATE w/ attr: %s\"", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\""%pBP rcvd UPDATE wlen %d attrlen %d alen %d\"", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\"",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \""%s [Error] Error parsing NLRI\"", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)\n\t    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tafi = nlris[NLRI_MP_UPDATE].afi;\n\t\t\tsafi = nlris[NLRI_MP_UPDATE].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\""%s %d, %s %d\"",\n\t\t\t\t\t\t\t\""EOR REQ\"",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\""EOR RCV\"",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\""%s: rcvd End-of-RIB for %s from %s in vrf %s\"",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}"", ""target"": 0}]","[{""func_name"": ""bgp_update_receive"", ""file_path"": ""bgpd/bgp_packet.c"", ""func_code"": ""static int bgp_update_receive(struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(peer)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \""%s [FSM] Update packet received under status %s\"",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet length is short for unfeasible length)\"",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet unfeasible length overflow %d)\"",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\""%s [Error] Packet Error (update packet is short for attribute length)\"",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\""%s [Error] Packet Error (update packet attribute length overflow %d)\"",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\"",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\""%pBP rcvd UPDATE w/ attr: %s\"", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len && attribute_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\""%pBP rcvd UPDATE wlen %d attrlen %d alen %d\"", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\"",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \""%s [Error] Error parsing NLRI\"", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)\n\t    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tafi = nlris[NLRI_MP_UPDATE].afi;\n\t\t\tsafi = nlris[NLRI_MP_UPDATE].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\""%s %d, %s %d\"",\n\t\t\t\t\t\t\t\""EOR REQ\"",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\""EOR RCV\"",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\""%s: rcvd End-of-RIB for %s from %s in vrf %s\"",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:bgp_packet.c, lines:2040-2060)"", ""result"": ""\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\""%pBP rcvd UPDATE w/ attr: %s\"", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n""}, {""source"": ""value_info(file:bgp_packet.c, value:attribute_len)"", ""result"": {""value_trace"": [{""full_code"": ""attribute_len = stream_getw(s)"", ""line"": 1990, ""func_name"": ""bgp_update_receive""}], ""struct_var"": ""attribute_len"", ""struct_type"": ""bgp_size_t"", ""struct_definition"": ""typedef uint16_t bgp_size_t;""}}]","1. A malformed BGP UPDATE message with attribute_len=0 and non-zero update_len is received.\n2. In bgpd/bgp_packet.c:2050, `if (update_len)` is true, but `attribute_len` (derived from stream_getw(s) at bgpd/bgp_packet.c:1990) is zero.\n3. Attributes (e.g., aspath) are not parsed, leaving `attr` uninitialized/NULL.\n4. bgp_nlri_parse (bgpd/bgp_packet.c:339) and bgp_update (bgpd/bgp_route.c:4374) process the NULL `attr`.\n5. Route-map application (bgpd/bgp_route.c:1772) calls route_set_aspath_prepend (bgpd/bgp_routemap.c:2258), which dereferences the NULL aspath, causing a crash.",0.95,./github/other_context/CVE-2023-41358
44,CVE-2023-43898,CWE-476,c_cpp,Nothings stb 2.28 was discovered to contain a Null Pointer Dereference via the function stbi__convert_format. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted pic file.,https://github.com/nothings/stb/commit/4e58258d8c434111fe2e8f1146ae0a72b0e8c554,"Fix nullptr dereference when a PIC file causes stbi__pic_load_core to return 0, and the requested number of components to stbi_load_from_memory is not 0 or 4",1,"[{""func_name"": ""stbi__pic_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *result;\n   int i, x,y, internal_comp;\n   STBI_NOTUSED(ri);\n\n   if (!comp) comp = &internal_comp;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n\n   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n\n   if (stbi__at_eof(s))  return stbi__errpuc(\""bad file\"",\""file too short (pic header)\"");\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\""too large\"", \""PIC image too large to decode\"");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\n   if (!result) return stbi__errpuc(\""outofmem\"", \""Out of memory\"");\n   memset(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      STBI_FREE(result);\n      result=0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}"", ""target"": 0}]","[{""func_name"": ""stbi__pic_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *result;\n   int i, x,y, internal_comp;\n   STBI_NOTUSED(ri);\n\n   if (!comp) comp = &internal_comp;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n\n   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n\n   if (stbi__at_eof(s))  return stbi__errpuc(\""bad file\"",\""file too short (pic header)\"");\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\""too large\"", \""PIC image too large to decode\"");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\n   if (!result) return stbi__errpuc(\""outofmem\"", \""Out of memory\"");\n   memset(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      STBI_FREE(result);\n      return 0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:stb_image.h, lines:6531-6550)"", ""result"": ""   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}\n\nstatic int stbi__pic_test(stbi__context *s)\n{\n   int r = stbi__pic_test_core(s);\n   stbi__rewind(s);\n   return r;\n}\n#endif\n\n// *************************************************************************************************\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\n\n#ifndef STBI_NO_GIF\n""}]","The vulnerability arises when `stbi__pic_load_core` (called at `stb_image.h:6528`) returns 0, indicating failure. In the original code, `result` is set to 0 (`result=0;` at `stb_image.h:6530`), but execution continues. The null `result` is then passed to `stbi__convert_format(result, 4, req_comp, x, y)` at `stb_image.h:6534`, causing a null pointer dereference. The patch replaces `result=0;` with `return 0;` to exit the function immediately, preventing the dereference.",1.0,./github/other_context/CVE-2023-43898
45,CVE-2016-9624,CWE-476,c_cpp,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,https://github.com/tats/w3m/commit/73397b6b7954971e3015b4f96b919ec90390e671,Prevent dereference near-null pointer in formUpdateBuffer\n\nBug-Debian: https://github.com/tats/w3m/issues/35\nOrigin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=e2c7ecec6f9b730ad3c9bf8c8df9212970f183d7,1,"[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len || spos < 0 || epos < 0)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}"", ""target"": 0}]","[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len || spos < 0 || epos < 0)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}""}]","{""caller"": 4, ""value"": 3, ""code"": 1}","[{""source"": ""caller_info(func:formUpdateBuffer)"", ""result"": [{""call_line"": 219, ""call_code"": ""formUpdateBuffer(a2, buf, f2)"", ""caller_code"": ""void\nformRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi)\n{\n    int i;\n    Anchor *a2;\n    FormItemList *f2;\n\n    for (i = 0; i < buf->formitem->nanchor; i++) {\n\ta2 = &buf->formitem->anchors[i];\n\tf2 = (FormItemList *)a2->url;\n\tif (f2->parent == fi->parent && f2 != fi &&\n\t    f2->type == FORM_INPUT_RADIO && Strcmp(f2->name, fi->name) == 0) {\n\t    f2->checked = 0;\n\t    formUpdateBuffer(a2, buf, f2);\n\t}\n    }\n    fi->checked = 1;\n    formUpdateBuffer(a, buf, fi);\n}"", ""caller_start"": 206, ""file_path"": ""form.c""}, {""call_line"": 223, ""call_code"": ""formUpdateBuffer(a, buf, fi)"", ""caller_code"": ""void\nformRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi)\n{\n    int i;\n    Anchor *a2;\n    FormItemList *f2;\n\n    for (i = 0; i < buf->formitem->nanchor; i++) {\n\ta2 = &buf->formitem->anchors[i];\n\tf2 = (FormItemList *)a2->url;\n\tif (f2->parent == fi->parent && f2 != fi &&\n\t    f2->type == FORM_INPUT_RADIO && Strcmp(f2->name, fi->name) == 0) {\n\t    f2->checked = 0;\n\t    formUpdateBuffer(a2, buf, f2);\n\t}\n    }\n    fi->checked = 1;\n    formUpdateBuffer(a, buf, fi);\n}"", ""caller_start"": 206, ""file_path"": ""form.c""}, {""call_line"": 272, ""call_code"": ""formUpdateBuffer(a, buf, f1)"", ""caller_code"": ""void\nformResetBuffer(Buffer *buf, AnchorList *formitem)\n{\n    int i;\n    Anchor *a;\n    FormItemList *f1, *f2;\n\n    if (buf == NULL || buf->formitem == NULL || formitem == NULL)\n\treturn;\n    for (i = 0; i < buf->formitem->nanchor && i < formitem->nanchor; i++) {\n\ta = &buf->formitem->anchors[i];\n\tif (a->y != a->start.line)\n\t    continue;\n\tf1 = (FormItemList *)a->url;\n\tf2 = (FormItemList *)formitem->anchors[i].url;\n\tif (f1->type != f2->type ||\n\t    strcmp(((f1->name == NULL) ? \""\"" : f1->name->ptr),\n\t\t   ((f2->name == NULL) ? \""\"" : f2->name->ptr)))\n\t    break;\t\t/* What's happening */\n\tswitch (f1->type) {\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_FILE:\n\tcase FORM_TEXTAREA:\n\t    f1->value = f2->value;\n\t    f1->init_value = f2->init_value;\n\t    break;\n\tcase FORM_INPUT_CHECKBOX:\n\tcase FORM_INPUT_RADIO:\n\t    f1->checked = f2->checked;\n\t    f1->init_checked = f2->init_checked;\n\t    break;\n\tcase FORM_SELECT:\n#ifdef MENU_SELECT\n\t    f1->select_option = f2->select_option;\n\t    f1->value = f2->value;\n\t    f1->label = f2->label;\n\t    f1->selected = f2->selected;\n\t    f1->init_value = f2->init_value;\n\t    f1->init_label = f2->init_label;\n\t    f1->init_selected = f2->init_selected;\n#endif\t\t\t\t/* MENU_SELECT */\n\t    break;\n\tdefault:\n\t    continue;\n\t}\n\tformUpdateBuffer(a, buf, f1);\n    }\n}\n"", ""caller_start"": 226, ""file_path"": ""form.c""}, {""call_line"": 1031, ""call_code"": ""formUpdateBuffer(a, buf, fi)"", ""caller_code"": ""void\npreFormUpdateBuffer(Buffer *buf)\n{\n    struct pre_form *pf;\n    struct pre_form_item *pi;\n    int i;\n    Anchor *a;\n    FormList *fl;\n    FormItemList *fi;\n#ifdef MENU_SELECT\n    FormSelectOptionItem *opt;\n    int j;\n#endif\n\n    if (!buf || !buf->formitem || !PreForm)\n\treturn;\n\n    for (pf = PreForm; pf; pf = pf->next) {\n\tif (pf->re_url) {\n\t    Str url = parsedURL2Str(&buf->currentURL);\n\t    if (!RegexMatch(pf->re_url, url->ptr, url->length, 1))\n\t\tcontinue;\n\t}\n\telse if (pf->url) {\n\t    if (Strcmp_charp(parsedURL2Str(&buf->currentURL), pf->url))\n\t\tcontinue;\n\t}\n\telse\n\t    continue;\n\tfor (i = 0; i < buf->formitem->nanchor; i++) {\n\t    a = &buf->formitem->anchors[i];\n\t    fi = (FormItemList *)a->url;\n\t    fl = fi->parent;\n\t    if (pf->name && (!fl->name || strcmp(fl->name, pf->name)))\n\t\tcontinue;\n\t    if (pf->action\n\t\t&& (!fl->action || Strcmp_charp(fl->action, pf->action)))\n\t\tcontinue;\n\t    for (pi = pf->item; pi; pi = pi->next) {\n\t\tif (pi->type != fi->type)\n\t\t    continue;\n\t\tif (pi->type == FORM_INPUT_SUBMIT ||\n\t\t    pi->type == FORM_INPUT_IMAGE) {\n\t\t    if ((!pi->name || !*pi->name ||\n\t\t\t (fi->name && !Strcmp_charp(fi->name, pi->name))) &&\n\t\t\t(!pi->value || !*pi->value ||\n\t\t\t (fi->value && !Strcmp_charp(fi->value, pi->value))))\n\t\t\tbuf->submit = a;\n\t\t    continue;\n\t\t}\n\t\tif (!pi->name || !fi->name || Strcmp_charp(fi->name, pi->name))\n\t\t    continue;\n\t\tswitch (pi->type) {\n\t\tcase FORM_INPUT_TEXT:\n\t\tcase FORM_INPUT_FILE:\n\t\tcase FORM_INPUT_PASSWORD:\n\t\tcase FORM_TEXTAREA:\n\t\t    fi->value = Strnew_charp(pi->value);\n\t\t    formUpdateBuffer(a, buf, fi);\n\t\t    break;\n\t\tcase FORM_INPUT_CHECKBOX:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value)) {\n\t\t\tfi->checked = pi->checked;\n\t\t\tformUpdateBuffer(a, buf, fi);\n\t\t    }\n\t\t    break;\n\t\tcase FORM_INPUT_RADIO:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value))\n\t\t\tformRecheckRadio(a, buf, fi);\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase FORM_SELECT:\n\t\t    for (j = 0, opt = fi->select_option; opt != NULL;\n\t\t\t j++, opt = opt->next) {\n\t\t\tif (pi->value && opt->value &&\n\t\t\t    !Strcmp_charp(opt->value, pi->value)) {\n\t\t\t    fi->selected = j;\n\t\t\t    fi->value = opt->value;\n\t\t\t    fi->label = opt->label;\n\t\t\t    updateSelectOption(fi, fi->select_option);\n\t\t\t    formUpdateBuffer(a, buf, fi);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n#endif\n\t\t}\n\t    }\n\t}\n    }\n}\n"", ""caller_start"": 973, ""file_path"": ""form.c""}]}, {""source"": ""value_info(file:form.c, value:buf->currentLine)"", ""result"": {""value_trace"": [{""full_code"": ""buf->currentLine = buf->lastLine = NULL"", ""line"": 72, ""func_name"": ""clearBuffer""}, {""full_code"": ""buf->currentLine = l"", ""line"": 255, ""func_name"": ""gotoLine""}], ""struct_var"": ""buf"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:form.c, lines:430-450)"", ""result"": ""    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n""}, {""source"": ""caller_info(file:form.c, func:formRecheckRadio)"", ""result"": [{""call_line"": 1043, ""call_code"": ""formRecheckRadio(a, buf, fi)"", ""caller_code"": ""void\npreFormUpdateBuffer(Buffer *buf)\n{\n    struct pre_form *pf;\n    struct pre_form_item *pi;\n    int i;\n    Anchor *a;\n    FormList *fl;\n    FormItemList *fi;\n#ifdef MENU_SELECT\n    FormSelectOptionItem *opt;\n    int j;\n#endif\n\n    if (!buf || !buf->formitem || !PreForm)\n\treturn;\n\n    for (pf = PreForm; pf; pf = pf->next) {\n\tif (pf->re_url) {\n\t    Str url = parsedURL2Str(&buf->currentURL);\n\t    if (!RegexMatch(pf->re_url, url->ptr, url->length, 1))\n\t\tcontinue;\n\t}\n\telse if (pf->url) {\n\t    if (Strcmp_charp(parsedURL2Str(&buf->currentURL), pf->url))\n\t\tcontinue;\n\t}\n\telse\n\t    continue;\n\tfor (i = 0; i < buf->formitem->nanchor; i++) {\n\t    a = &buf->formitem->anchors[i];\n\t    fi = (FormItemList *)a->url;\n\t    fl = fi->parent;\n\t    if (pf->name && (!fl->name || strcmp(fl->name, pf->name)))\n\t\tcontinue;\n\t    if (pf->action\n\t\t&& (!fl->action || Strcmp_charp(fl->action, pf->action)))\n\t\tcontinue;\n\t    for (pi = pf->item; pi; pi = pi->next) {\n\t\tif (pi->type != fi->type)\n\t\t    continue;\n\t\tif (pi->type == FORM_INPUT_SUBMIT ||\n\t\t    pi->type == FORM_INPUT_IMAGE) {\n\t\t    if ((!pi->name || !*pi->name ||\n\t\t\t (fi->name && !Strcmp_charp(fi->name, pi->name))) &&\n\t\t\t(!pi->value || !*pi->value ||\n\t\t\t (fi->value && !Strcmp_charp(fi->value, pi->value))))\n\t\t\tbuf->submit = a;\n\t\t    continue;\n\t\t}\n\t\tif (!pi->name || !fi->name || Strcmp_charp(fi->name, pi->name))\n\t\t    continue;\n\t\tswitch (pi->type) {\n\t\tcase FORM_INPUT_TEXT:\n\t\tcase FORM_INPUT_FILE:\n\t\tcase FORM_INPUT_PASSWORD:\n\t\tcase FORM_TEXTAREA:\n\t\t    fi->value = Strnew_charp(pi->value);\n\t\t    formUpdateBuffer(a, buf, fi);\n\t\t    break;\n\t\tcase FORM_INPUT_CHECKBOX:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value)) {\n\t\t\tfi->checked = pi->checked;\n\t\t\tformUpdateBuffer(a, buf, fi);\n\t\t    }\n\t\t    break;\n\t\tcase FORM_INPUT_RADIO:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value))\n\t\t\tformRecheckRadio(a, buf, fi);\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase FORM_SELECT:\n\t\t    for (j = 0, opt = fi->select_option; opt != NULL;\n\t\t\t j++, opt = opt->next) {\n\t\t\tif (pi->value && opt->value &&\n\t\t\t    !Strcmp_charp(opt->value, pi->value)) {\n\t\t\t    fi->selected = j;\n\t\t\t    fi->value = opt->value;\n\t\t\t    fi->label = opt->label;\n\t\t\t    updateSelectOption(fi, fi->select_option);\n\t\t\t    formUpdateBuffer(a, buf, fi);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n#endif\n\t\t}\n\t    }\n\t}\n    }\n}\n"", ""caller_start"": 973, ""file_path"": ""form.c""}, {""call_line"": 3485, ""call_code"": ""formRecheckRadio(a, Currentbuf, fi)"", ""caller_code"": ""static void\n_followForm(int submit)\n{\n    Line *l;\n    Anchor *a, *a2;\n    char *p;\n    FormItemList *fi, *f2;\n    Str tmp, tmp2;\n    int multipart = 0, i;\n\n    if (Currentbuf->firstLine == NULL)\n\treturn;\n    l = Currentbuf->currentLine;\n\n    a = retrieveCurrentForm(Currentbuf);\n    if (a == NULL)\n\treturn;\n    fi = (FormItemList *)a->url;\n    switch (fi->type) {\n    case FORM_INPUT_TEXT:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly)\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t/* FIXME: gettextize? */\n\tp = inputStrHist(\""TEXT:\"", fi->value ? fi->value->ptr : NULL, TextHist);\n\tif (p == NULL || fi->readonly)\n\t    break;\n\tfi->value = Strnew_charp(p);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->accept || fi->parent->nitems == 1)\n\t    goto do_submit;\n\tbreak;\n    case FORM_INPUT_FILE:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly)\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t/* FIXME: gettextize? */\n\tp = inputFilenameHist(\""Filename:\"", fi->value ? fi->value->ptr : NULL,\n\t\t\t      NULL);\n\tif (p == NULL || fi->readonly)\n\t    break;\n\tfi->value = Strnew_charp(p);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->accept || fi->parent->nitems == 1)\n\t    goto do_submit;\n\tbreak;\n    case FORM_INPUT_PASSWORD:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly) {\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t    break;\n\t}\n\t/* FIXME: gettextize? */\n\tp = inputLine(\""Password:\"", fi->value ? fi->value->ptr : NULL,\n\t\t      IN_PASSWORD);\n\tif (p == NULL)\n\t    break;\n\tfi->value = Strnew_charp(p);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->accept)\n\t    goto do_submit;\n\tbreak;\n    case FORM_TEXTAREA:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly)\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\tinput_textarea(fi);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tbreak;\n    case FORM_INPUT_RADIO:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly) {\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t    break;\n\t}\n\tformRecheckRadio(a, Currentbuf, fi);\n\tbreak;\n    case FORM_INPUT_CHECKBOX:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly) {\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t    break;\n\t}\n\tfi->checked = !fi->checked;\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tbreak;\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (submit)\n\t    goto do_submit;\n\tif (!formChooseOptionByMenu(fi,\n\t\t\t\t    Currentbuf->cursorX - Currentbuf->pos +\n\t\t\t\t    a->start.pos + Currentbuf->rootX,\n\t\t\t\t    Currentbuf->cursorY + Currentbuf->rootY))\n\t    break;\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->parent->nitems == 1)\n\t    goto do_submit;\n\tbreak;\n#endif\t\t\t\t/* MENU_SELECT */\n    case FORM_INPUT_IMAGE:\n    case FORM_INPUT_SUBMIT:\n    case FORM_INPUT_BUTTON:\n      do_submit:\n\ttmp = Strnew();\n\ttmp2 = Strnew();\n\tmultipart = (fi->parent->method == FORM_METHOD_POST &&\n\t\t     fi->parent->enctype == FORM_ENCTYPE_MULTIPART);\n\tquery_from_followform(&tmp, fi, multipart);\n\n\ttmp2 = Strdup(fi->parent->action);\n\tif (!Strcmp_charp(tmp2, \""!CURRENT_URL!\"")) {\n\t    /* It means \""current URL\"" */\n\t    tmp2 = parsedURL2Str(&Currentbuf->currentURL);\n\t    if ((p = strchr(tmp2->ptr, '?')) != NULL)\n\t\tStrshrink(tmp2, (tmp2->ptr + tmp2->length) - p);\n\t}\n\n\tif (fi->parent->method == FORM_METHOD_GET) {\n\t    if ((p = strchr(tmp2->ptr, '?')) != NULL)\n\t\tStrshrink(tmp2, (tmp2->ptr + tmp2->length) - p);\n\t    Strcat_charp(tmp2, \""?\"");\n\t    Strcat(tmp2, tmp);\n\t    loadLink(tmp2->ptr, a->target, NULL, NULL);\n\t}\n\telse if (fi->parent->method == FORM_METHOD_POST) {\n\t    Buffer *buf;\n\t    if (multipart) {\n\t\tstruct stat st;\n\t\tstat(fi->parent->body, &st);\n\t\tfi->parent->length = st.st_size;\n\t    }\n\t    else {\n\t\tfi->parent->body = tmp->ptr;\n\t\tfi->parent->length = tmp->length;\n\t    }\n\t    buf = loadLink(tmp2->ptr, a->target, NULL, fi->parent);\n\t    if (multipart) {\n\t\tunlink(fi->parent->body);\n\t    }\n\t    if (buf && !(buf->bufferprop & BP_REDIRECTED)) {\t/* buf must be Currentbuf */\n\t\t/* BP_REDIRECTED means that the buffer is obtained through\n\t\t * Location: header. In this case, buf->form_submit must not be set\n\t\t * because the page is not loaded by POST method but GET method.\n\t\t */\n\t\tbuf->form_submit = save_submit_formlist(fi);\n\t    }\n\t}\n\telse if ((fi->parent->method == FORM_METHOD_INTERNAL && (!Strcmp_charp(fi->parent->action, \""map\"") || !Strcmp_charp(fi->parent->action, \""none\""))) || Currentbuf->bufferprop & BP_INTERNAL) {\t/* internal */\n\t    do_internal(tmp2->ptr, tmp->ptr);\n\t}\n\telse {\n\t    disp_err_message(\""Can't send form because of illegal method.\"",\n\t\t\t     FALSE);\n\t}\n\tbreak;\n    case FORM_INPUT_RESET:\n\tfor (i = 0; i < Currentbuf->formitem->nanchor; i++) {\n\t    a2 = &Currentbuf->formitem->anchors[i];\n\t    f2 = (FormItemList *)a2->url;\n\t    if (f2->parent == fi->parent &&\n\t\tf2->name && f2->value &&\n\t\tf2->type != FORM_INPUT_SUBMIT &&\n\t\tf2->type != FORM_INPUT_HIDDEN &&\n\t\tf2->type != FORM_INPUT_RESET) {\n\t\tf2->value = f2->init_value;\n\t\tf2->checked = f2->init_checked;\n#ifdef MENU_SELECT\n\t\tf2->label = f2->init_label;\n\t\tf2->selected = f2->init_selected;\n#endif\t\t\t\t/* MENU_SELECT */\n\t\tformUpdateBuffer(a2, Currentbuf, f2);\n\t    }\n\t}\n\tbreak;\n    case FORM_INPUT_HIDDEN:\n    default:\n\tbreak;\n    }\n    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n}\n"", ""caller_start"": 3400, ""file_path"": ""main.c""}]}, {""source"": ""caller_info(file:form.c, func:formResetBuffer)"", ""result"": [{""call_line"": 607, ""call_code"": ""formResetBuffer(buf, sbuf.formitem)"", ""caller_code"": ""void\nreshapeBuffer(Buffer *buf)\n{\n    URLFile f;\n    Buffer sbuf;\n#ifdef USE_M17N\n    wc_uint8 old_auto_detect = WcOption.auto_detect;\n#endif\n\n    if (!buf->need_reshape)\n\treturn;\n    buf->need_reshape = FALSE;\n    buf->width = INIT_BUFFER_WIDTH;\n    if (buf->sourcefile == NULL)\n\treturn;\n    init_stream(&f, SCM_LOCAL, NULL);\n    examineFile(buf->mailcap_source ? buf->mailcap_source : buf->sourcefile,\n\t\t&f);\n    if (f.stream == NULL)\n\treturn;\n    copyBuffer(&sbuf, buf);\n    clearBuffer(buf);\n    while (buf->frameset) {\n\tdeleteFrameSet(buf->frameset);\n\tbuf->frameset = popFrameTree(&(buf->frameQ));\n    }\n\n    buf->href = NULL;\n    buf->name = NULL;\n    buf->img = NULL;\n    buf->formitem = NULL;\n    buf->formlist = NULL;\n    buf->linklist = NULL;\n    buf->maplist = NULL;\n    if (buf->hmarklist)\n\tbuf->hmarklist->nmark = 0;\n    if (buf->imarklist)\n\tbuf->imarklist->nmark = 0;\n\n    if (buf->header_source) {\n\tif (buf->currentURL.scheme != SCM_LOCAL ||\n\t    buf->mailcap_source || !strcmp(buf->currentURL.file, \""-\"")) {\n\t    URLFile h;\n\t    init_stream(&h, SCM_LOCAL, NULL);\n\t    examineFile(buf->header_source, &h);\n\t    if (h.stream) {\n\t\treadHeader(&h, buf, TRUE, NULL);\n\t\tUFclose(&h);\n\t    }\n\t}\n\telse if (buf->search_header)\t/* -m option */\n\t    readHeader(&f, buf, TRUE, NULL);\n    }\n\n#ifdef USE_M17N\n    WcOption.auto_detect = WC_OPT_DETECT_OFF;\n    UseContentCharset = FALSE;\n#endif\n    if (is_html_type(buf->type))\n\tloadHTMLBuffer(&f, buf);\n    else\n\tloadBuffer(&f, buf);\n    UFclose(&f);\n#ifdef USE_M17N\n    WcOption.auto_detect = old_auto_detect;\n    UseContentCharset = TRUE;\n#endif\n\n    buf->height = LASTLINE + 1;\n    if (buf->firstLine && sbuf.firstLine) {\n\tLine *cur = sbuf.currentLine;\n\tint n;\n\n\tbuf->pos = sbuf.pos + cur->bpos;\n\twhile (cur->bpos && cur->prev)\n\t    cur = cur->prev;\n\tif (cur->real_linenumber > 0)\n\t    gotoRealLine(buf, cur->real_linenumber);\n\telse\n\t    gotoLine(buf, cur->linenumber);\n\tn = (buf->currentLine->linenumber - buf->topLine->linenumber)\n\t    - (cur->linenumber - sbuf.topLine->linenumber);\n\tif (n) {\n\t    buf->topLine = lineSkip(buf, buf->topLine, n, FALSE);\n\t    if (cur->real_linenumber > 0)\n\t\tgotoRealLine(buf, cur->real_linenumber);\n\t    else\n\t\tgotoLine(buf, cur->linenumber);\n\t}\n\tbuf->pos -= buf->currentLine->bpos;\n\tif (FoldLine && !is_html_type(buf->type))\n\t    buf->currentColumn = 0;\n\telse\n\t    buf->currentColumn = sbuf.currentColumn;\n\tarrangeCursor(buf);\n    }\n    if (buf->check_url & CHK_URL)\n\tchkURLBuffer(buf);\n#ifdef USE_NNTP\n    if (buf->check_url & CHK_NMID)\n\tchkNMIDBuffer(buf);\n    if (buf->real_scheme == SCM_NNTP || buf->real_scheme == SCM_NEWS)\n\treAnchorNewsheader(buf);\n#endif\n    formResetBuffer(buf, sbuf.formitem);\n}\n"", ""caller_start"": 503, ""file_path"": ""buffer.c""}, {""call_line"": 6758, ""call_code"": ""formResetBuffer(newBuf, newBuf->formitem)"", ""caller_code"": ""Buffer *\nloadHTMLBuffer(URLFile *f, Buffer *newBuf)\n{\n    FILE *src = NULL;\n    Str tmp;\n\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (newBuf->sourcefile == NULL &&\n\t(f->scheme != SCM_LOCAL || newBuf->mailcap)) {\n\ttmp = tmpfname(TMPF_SRC, \"".html\"");\n\tsrc = fopen(tmp->ptr, \""w\"");\n\tif (src)\n\t    newBuf->sourcefile = tmp->ptr;\n    }\n\n    loadHTMLstream(f, newBuf, src, newBuf->bufferprop & BP_FRAME);\n\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    if (src)\n\tfclose(src);\n\n    return newBuf;\n}"", ""caller_start"": 6736, ""file_path"": ""file.c""}, {""call_line"": 7296, ""call_code"": ""formResetBuffer(newBuf, newBuf->formitem)"", ""caller_code"": ""Buffer *\nloadHTMLString(Str page)\n{\n    URLFile f;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    Buffer *newBuf;\n\n    init_stream(&f, SCM_LOCAL, newStrStream(page));\n\n    newBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (SETJMP(AbortLoading) != 0) {\n\tTRAP_OFF;\n\tdiscardBuffer(newBuf);\n\tUFclose(&f);\n\treturn NULL;\n    }\n    TRAP_ON;\n\n#ifdef USE_M17N\n    newBuf->document_charset = InnerCharset;\n#endif\n    loadHTMLstream(&f, newBuf, NULL, TRUE);\n#ifdef USE_M17N\n    newBuf->document_charset = WC_CES_US_ASCII;\n#endif\n\n    TRAP_OFF;\n    UFclose(&f);\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->type = \""text/html\"";\n    newBuf->real_type = newBuf->type;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    return newBuf;\n}"", ""caller_start"": 7262, ""file_path"": ""file.c""}, {""call_line"": 4119, ""call_code"": ""formResetBuffer(Currentbuf, formitem)"", ""caller_code"": ""DEFUN(backBf, BACK, \""Back to previous buffer\"")\n{\n    Buffer *buf = Currentbuf->linkBuffer[LB_N_FRAME];\n\n    if (!checkBackBuffer(Currentbuf)) {\n\tif (close_tab_back && nTab >= 1) {\n\t    deleteTab(CurrentTab);\n\t    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n\t}\n\telse\n\t    /* FIXME: gettextize? */\n\t    disp_message(\""Can't back...\"", TRUE);\n\treturn;\n    }\n\n    delBuffer(Currentbuf);\n\n    if (buf) {\n\tif (buf->frameQ) {\n\t    struct frameset *fs;\n\t    long linenumber = buf->frameQ->linenumber;\n\t    long top = buf->frameQ->top_linenumber;\n\t    int pos = buf->frameQ->pos;\n\t    int currentColumn = buf->frameQ->currentColumn;\n\t    AnchorList *formitem = buf->frameQ->formitem;\n\n\t    fs = popFrameTree(&(buf->frameQ));\n\t    deleteFrameSet(buf->frameset);\n\t    buf->frameset = fs;\n\n\t    if (buf == Currentbuf) {\n\t\trFrame();\n\t\tCurrentbuf->topLine = lineSkip(Currentbuf,\n\t\t\t\t\t       Currentbuf->firstLine, top - 1,\n\t\t\t\t\t       FALSE);\n\t\tgotoLine(Currentbuf, linenumber);\n\t\tCurrentbuf->pos = pos;\n\t\tCurrentbuf->currentColumn = currentColumn;\n\t\tarrangeCursor(Currentbuf);\n\t\tformResetBuffer(Currentbuf, formitem);\n\t    }\n\t}\n\telse if (RenderFrame && buf == Currentbuf) {\n\t    delBuffer(Currentbuf);\n\t}\n    }\n    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n}\n"", ""caller_start"": 4080, ""file_path"": ""main.c""}]}, {""source"": ""caller_info(file:form.c, func:preFormUpdateBuffer)"", ""result"": [{""call_line"": 2275, ""call_code"": ""preFormUpdateBuffer(b)"", ""caller_code"": ""Buffer *\nloadGeneralFile(char *path, ParsedURL *volatile current, char *referer,\n\t\tint flag, FormList *volatile request)\n{\n    URLFile f, *volatile of = NULL;\n    ParsedURL pu;\n    Buffer *b = NULL;\n    Buffer *(*volatile proc)(URLFile *, Buffer *) = loadBuffer;\n    char *volatile tpath;\n    char *volatile t = \""text/plain\"", *p, *volatile real_type = NULL;\n    Buffer *volatile t_buf = NULL;\n    int volatile searchHeader = SearchHeader;\n    int volatile searchHeader_through = TRUE;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    TextList *extra_header = newTextList();\n    volatile Str uname = NULL;\n    volatile Str pwd = NULL;\n    volatile Str realm = NULL;\n    int volatile add_auth_cookie_flag;\n    unsigned char status = HTST_NORMAL;\n    URLOption url_option;\n    Str tmp;\n    Str volatile page = NULL;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n#endif\n    HRequest hr;\n    ParsedURL *volatile auth_pu;\n\n    tpath = path;\n    prevtrap = NULL;\n    add_auth_cookie_flag = 0;\n\n    checkRedirection(NULL);\n\n  load_doc:\n    {\n\tconst char *sc_redirect;\n\tparseURL2(tpath, &pu, current);\n\tsc_redirect = query_SCONF_SUBSTITUTE_URL(&pu);\n\tif (sc_redirect && *sc_redirect && checkRedirection(&pu)) {\n\t    tpath = (char *)sc_redirect;\n\t    request = NULL;\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    *current = pu;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n    }\n    TRAP_OFF;\n    url_option.referer = referer;\n    url_option.flag = flag;\n    f = openURL(tpath, &pu, current, &url_option, request, extra_header, of,\n\t\t&hr, &status);\n    of = NULL;\n#ifdef USE_M17N\n    content_charset = 0;\n#endif\n    if (f.stream == NULL) {\n\tswitch (f.scheme) {\n\tcase SCM_LOCAL:\n\t    {\n\t\tstruct stat st;\n\t\tif (stat(pu.real_file, &st) < 0)\n\t\t    return NULL;\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t    if (UseExternalDirBuffer) {\n\t\t\tStr cmd = Sprintf(\""%s?dir=%s#current\"",\n\t\t\t\t\t  DirBufferCommand, pu.file);\n\t\t\tb = loadGeneralFile(cmd->ptr, NULL, NO_REFERER, 0,\n\t\t\t\t\t    NULL);\n\t\t\tif (b != NULL && b != NO_BUFFER) {\n\t\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\t\t    b->filename = b->currentURL.real_file;\n\t\t\t}\n\t\t\treturn b;\n\t\t    }\n\t\t    else {\n\t\t\tpage = loadLocalDir(pu.real_file);\n\t\t\tt = \""local:directory\"";\n#ifdef USE_M17N\n\t\t\tcharset = SystemCharset;\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase SCM_FTPDIR:\n\t    page = loadFTPDir(&pu, &charset);\n\t    t = \""ftp:directory\"";\n\t    break;\n#ifdef USE_NNTP\n\tcase SCM_NEWS_GROUP:\n\t    page = loadNewsgroup(&pu, &charset);\n\t    t = \""news:group\"";\n\t    break;\n#endif\n\tcase SCM_UNKNOWN:\n#ifdef USE_EXTERNAL_URI_LOADER\n\t    tmp = searchURIMethods(&pu);\n\t    if (tmp != NULL) {\n\t\tb = loadGeneralFile(tmp->ptr, current, referer, flag, request);\n\t\tif (b != NULL && b != NO_BUFFER)\n\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\treturn b;\n\t    }\n#endif\n\t    /* FIXME: gettextize? */\n\t    disp_err_message(Sprintf(\""Unknown URI: %s\"",\n\t\t\t\t     parsedURL2Str(&pu)->ptr)->ptr, FALSE);\n\t    break;\n\t}\n\tif (page && page->length > 0)\n\t    goto page_loaded;\n\treturn NULL;\n    }\n\n    if (status == HTST_MISSING) {\n\tTRAP_OFF;\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    /* openURL() succeeded */\n    if (SETJMP(AbortLoading) != 0) {\n\t/* transfer interrupted */\n\tTRAP_OFF;\n\tif (b)\n\t    discardBuffer(b);\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    b = NULL;\n    if (f.is_cgi) {\n\t/* local CGI */\n\tsearchHeader = TRUE;\n\tsearchHeader_through = FALSE;\n    }\n    if (header_string)\n\theader_string = NULL;\n    TRAP_ON;\n    if (pu.scheme == SCM_HTTP ||\n#ifdef USE_SSL\n\tpu.scheme == SCM_HTTPS ||\n#endif\t\t\t\t/* USE_SSL */\n\t((\n#ifdef USE_GOPHER\n\t     (pu.scheme == SCM_GOPHER && non_null(GOPHER_proxy)) ||\n#endif\t\t\t\t/* USE_GOPHER */\n\t     (pu.scheme == SCM_FTP && non_null(FTP_proxy))\n\t ) && !Do_not_use_proxy && !check_no_proxy(pu.host))) {\n\n\tif (fmInitialized) {\n\t    term_cbreak();\n\t    /* FIXME: gettextize? */\n\t    message(Sprintf(\""%s contacted. Waiting for reply...\"", pu.host)->\n\t\t    ptr, 0, 0);\n\t    refresh();\n\t}\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n#if 0\t\t\t\t/* USE_SSL */\n\tif (IStype(f.stream) == IST_SSL) {\n\t    Str s = ssl_get_certificate(f.stream, pu.host);\n\t    if (s == NULL)\n\t\treturn NULL;\n\t    else\n\t\tt_buf->ssl_certificate = s->ptr;\n\t}\n#endif\n\treadHeader(&f, t_buf, FALSE, &pu);\n\tif (((http_response_code >= 301 && http_response_code <= 303)\n\t     || http_response_code == 307)\n\t    && (p = checkHeader(t_buf, \""Location:\"")) != NULL\n\t    && checkRedirection(&pu)) {\n\t    /* document moved */\n\t    /* 301: Moved Permanently */\n\t    /* 302: Found */\n\t    /* 303: See Other */\n\t    /* 307: Temporary Redirect (HTTP/1.1) */\n\t    tpath = url_encode(p, NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n\tt = checkContentType(t_buf);\n\tif (t == NULL && pu.file != NULL) {\n\t    if (!((http_response_code >= 400 && http_response_code <= 407) ||\n\t\t  (http_response_code >= 500 && http_response_code <= 505)))\n\t\tt = guessContentType(pu.file);\n\t}\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n\tif (add_auth_cookie_flag && realm && uname && pwd) {\n\t    /* If authorization is required and passed */\n\t    add_auth_user_passwd(&pu, qstr_unquote(realm)->ptr, uname, pwd, \n\t\t\t\t  0);\n\t    add_auth_cookie_flag = 0;\n\t}\n\tif ((p = checkHeader(t_buf, \""WWW-Authenticate:\"")) != NULL &&\n\t    http_response_code == 401) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \""WWW-Authenticate:\"") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \""realm\"")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \""Authorization:\"", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n\tif ((p = checkHeader(t_buf, \""Proxy-Authenticate:\"")) != NULL &&\n\t    http_response_code == 407) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \""Proxy-Authenticate:\"")\n\t\t!= NULL\n\t\t&& (realm = get_auth_param(hauth.param, \""realm\"")) != NULL) {\n\t\tauth_pu = schemeToProxy(pu.scheme);\n\t\tgetAuthCookie(&hauth, \""Proxy-Authorization:\"",\n\t\t\t      extra_header, auth_pu, &hr, request, \n\t\t\t      &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tadd_auth_user_passwd(auth_pu, qstr_unquote(realm)->ptr, uname, pwd, 1);\n\t\tgoto load_doc;\n\t    }\n\t}\n\t/* XXX: RFC2617 3.2.3 Authentication-Info: ? */\n\n\tif (status == HTST_CONNECT) {\n\t    of = &f;\n\t    goto load_doc;\n\t}\n\n\tf.modtime = mymktime(checkHeader(t_buf, \""Last-Modified:\""));\n    }\n#ifdef USE_NNTP\n    else if (pu.scheme == SCM_NEWS || pu.scheme == SCM_NNTP) {\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, TRUE, &pu);\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n    }\n#endif\t\t\t\t/* USE_NNTP */\n#ifdef USE_GOPHER\n    else if (pu.scheme == SCM_GOPHER) {\n\tswitch (*pu.file) {\n\tcase '0':\n\t    t = \""text/plain\"";\n\t    break;\n\tcase '1':\n\tcase 'm':\n\t    page = loadGopherDir(&f, &pu, &charset);\n\t    t = \""gopher:directory\"";\n\t    TRAP_OFF;\n\t    goto page_loaded;\n\tcase 's':\n\t    t = \""audio/basic\"";\n\t    break;\n\tcase 'g':\n\t    t = \""image/gif\"";\n\t    break;\n\tcase 'h':\n\t    t = \""text/html\"";\n\t    break;\n\t}\n    }\n#endif\t\t\t\t/* USE_GOPHER */\n    else if (pu.scheme == SCM_FTP) {\n\tcheck_compression(path, &f);\n\tif (f.compression != CMP_NOCOMPRESS) {\n\t    char *t1 = uncompressed_file_type(pu.file, NULL);\n\t    real_type = f.guess_type;\n#if 0\n\t    if (t1 && strncasecmp(t1, \""application/\"", 12) == 0) {\n\t\tf.compression = CMP_NOCOMPRESS;\n\t\tt = real_type;\n\t    }\n\t    else\n#endif\n\t    if (t1)\n\t\tt = t1;\n\t    else\n\t\tt = real_type;\n\t}\n\telse {\n\t    real_type = guessContentType(pu.file);\n\t    if (real_type == NULL)\n\t\treal_type = \""text/plain\"";\n\t    t = real_type;\n\t}\n#if 0\n\tif (!strncasecmp(t, \""application/\"", 12)) {\n\t    char *tmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n\t    current_content_length = 0;\n\t    if (save2tmp(f, tmpf) < 0)\n\t\tUFclose(&f);\n\t    else {\n\t\tUFclose(&f);\n\t\tTRAP_OFF;\n\t\tdoFileMove(tmpf, guess_save_name(t_buf, pu.file));\n\t    }\n\t    return NO_BUFFER;\n\t}\n#endif\n    }\n    else if (pu.scheme == SCM_DATA) {\n\tt = f.guess_type;\n    }\n    else if (searchHeader) {\n\tsearchHeader = SearchHeader = FALSE;\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, searchHeader_through, &pu);\n\tif (f.is_cgi && (p = checkHeader(t_buf, \""Location:\"")) != NULL &&\n\t    checkRedirection(&pu)) {\n\t    /* document moved */\n\t    tpath = url_encode(remove_space(p), NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n#ifdef AUTH_DEBUG\n\tif ((p = checkHeader(t_buf, \""WWW-Authenticate:\"")) != NULL) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \""WWW-Authenticate:\"") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \""realm\"")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \""Authorization:\"", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n#endif /* defined(AUTH_DEBUG) */\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n    }\n    else if (DefaultType) {\n\tt = DefaultType;\n\tDefaultType = NULL;\n    }\n    else {\n\tt = guessContentType(pu.file);\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n\treal_type = t;\n\tif (f.guess_type)\n\t    t = f.guess_type;\n    }\n\n    /* XXX: can we use guess_type to give the type to loadHTMLstream\n     *      to support default utf8 encoding for XHTML here? */\n    f.guess_type = t;\n    \n  page_loaded:\n    if (page) {\n\tFILE *src;\n#ifdef USE_IMAGE\n\tif (image_source)\n\t    return NULL;\n#endif\n\ttmp = tmpfname(TMPF_SRC, \"".html\"");\n\tsrc = fopen(tmp->ptr, \""w\"");\n\tif (src) {\n\t    Str s;\n\t    s = wc_Str_conv_strict(page, InnerCharset, charset);\n\t    Strfputs(s, src);\n\t    fclose(src);\n\t}\n\tif (do_download) {\n\t    char *file;\n\t    if (!src)\n\t\treturn NULL;\n\t    file = guess_filename(pu.file);\n#ifdef USE_GOPHER\n\t    if (f.scheme == SCM_GOPHER)\n\t\tfile = Sprintf(\""%s.html\"", file)->ptr;\n#endif\n#ifdef USE_NNTP\n\t    if (f.scheme == SCM_NEWS_GROUP)\n\t\tfile = Sprintf(\""%s.html\"", file)->ptr;\n#endif\n\t    doFileMove(tmp->ptr, file);\n\t    return NO_BUFFER;\n\t}\n\tb = loadHTMLString(page);\n\tif (b) {\n\t    copyParsedURL(&b->currentURL, &pu);\n\t    b->real_scheme = pu.scheme;\n\t    b->real_type = t;\n\t    if (src)\n\t\tb->sourcefile = tmp->ptr;\n#ifdef USE_M17N\n\t    b->document_charset = charset;\n#endif\n\t}\n\treturn b;\n    }\n\n    if (real_type == NULL)\n\treal_type = t;\n    proc = loadBuffer;\n\n    current_content_length = 0;\n    if ((p = checkHeader(t_buf, \""Content-Length:\"")) != NULL)\n\tcurrent_content_length = strtoclen(p);\n    if (do_download) {\n\t/* download only */\n\tchar *file;\n\tTRAP_OFF;\n\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (pu.scheme == SCM_LOCAL) {\n\t    struct stat st;\n\t    if (PreserveTimestamp && !stat(pu.real_file, &st))\n\t\tf.modtime = st.st_mtime;\n\t    file = conv_from_system(guess_save_name(NULL, pu.real_file));\n\t}\n\telse\n\t    file = guess_save_name(t_buf, pu.file);\n\tif (doFileSave(f, file) == 0)\n\t    UFhalfclose(&f);\n\telse\n\t    UFclose(&f);\n\treturn NO_BUFFER;\n    }\n\n    if ((f.content_encoding != CMP_NOCOMPRESS) && AutoUncompress\n\t&& !(w3m_dump & DUMP_EXTRA)) {\n\tuncompress_stream(&f, &pu.real_file);\n    }\n    else if (f.compression != CMP_NOCOMPRESS) {\n\tif (!(w3m_dump & DUMP_SOURCE) &&\n\t    (w3m_dump & ~DUMP_FRAME || is_text_type(t)\n\t     || searchExtViewer(t))) {\n\t    if (t_buf == NULL)\n\t\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    uncompress_stream(&f, &t_buf->sourcefile);\n\t    uncompressed_file_type(pu.file, &f.ext);\n\t}\n\telse {\n\t    t = compress_application_type(f.compression);\n\t    f.compression = CMP_NOCOMPRESS;\n\t}\n    }\n#ifdef USE_IMAGE\n    if (image_source) {\n\tBuffer *b = NULL;\n\tif (IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (save2tmp(f, image_source) == 0) {\n\t    b = newBuffer(INIT_BUFFER_WIDTH);\n\t    b->sourcefile = image_source;\n\t    b->real_type = t;\n\t}\n\tUFclose(&f);\n\tTRAP_OFF;\n\treturn b;\n    }\n#endif\n\n    if (is_html_type(t))\n\tproc = loadHTMLBuffer;\n    else if (is_plain_text_type(t))\n\tproc = loadBuffer;\n#ifdef USE_IMAGE\n    else if (activeImage && displayImage && !useExtImageViewer &&\n\t     !(w3m_dump & ~DUMP_FRAME) && !strncasecmp(t, \""image/\"", 6))\n\tproc = loadImageBuffer;\n#endif\n    else if (w3m_backend) ;\n    else if (!(w3m_dump & ~DUMP_FRAME) || is_dump_text_type(t)) {\n\tif (!do_download && searchExtViewer(t) != NULL) {\n\t    proc = DO_EXTERNAL;\n\t}\n\telse {\n\t    TRAP_OFF;\n\t    if (pu.scheme == SCM_LOCAL) {\n\t\tUFclose(&f);\n\t\t_doFileCopy(pu.real_file,\n\t\t\t    conv_from_system(guess_save_name\n\t\t\t\t\t     (NULL, pu.real_file)), TRUE);\n\t    }\n\t    else {\n\t\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\t\tif (doFileSave(f, guess_save_name(t_buf, pu.file)) == 0)\n\t\t    UFhalfclose(&f);\n\t\telse\n\t\t    UFclose(&f);\n\t    }\n\t    return NO_BUFFER;\n\t}\n    }\n    else if (w3m_dump & DUMP_FRAME)\n\treturn NULL;\n\n    if (t_buf == NULL)\n\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n    copyParsedURL(&t_buf->currentURL, &pu);\n    t_buf->filename = pu.real_file ? pu.real_file :\n\tpu.file ? conv_to_system(pu.file) : NULL;\n    if (flag & RG_FRAME) {\n\tt_buf->bufferprop |= BP_FRAME;\n    }\n#ifdef USE_SSL\n    t_buf->ssl_certificate = f.ssl_certificate;\n#endif\n    frame_source = flag & RG_FRAME_SRC;\n    if (proc == DO_EXTERNAL) {\n\tb = doExternal(f, t, t_buf);\n    } else {\n\tb = loadSomething(&f, proc, t_buf);\n    }\n    UFclose(&f);\n    frame_source = 0;\n    if (b && b != NO_BUFFER) {\n\tb->real_scheme = f.scheme;\n\tb->real_type = real_type;\n\tif (w3m_backend)\n\t    b->type = allocStr(t, -1);\n\tif (pu.label) {\n\t    if (proc == loadHTMLBuffer) {\n\t\tAnchor *a;\n\t\ta = searchURLLabel(b, pu.label);\n\t\tif (a != NULL) {\n\t\t    gotoLine(b, a->start.line);\n\t\t    if (label_topline)\n\t\t\tb->topLine = lineSkip(b, b->topLine,\n\t\t\t\t\t      b->currentLine->linenumber\n\t\t\t\t\t      - b->topLine->linenumber, FALSE);\n\t\t    b->pos = a->start.pos;\n\t\t    arrangeCursor(b);\n\t\t}\n\t    }\n\t    else {\t\t/* plain text */\n\t\tint l = atoi(pu.label);\n\t\tgotoRealLine(b, l);\n\t\tb->pos = 0;\n\t\tarrangeCursor(b);\n\t    }\n\t}\n    }\n    if (header_string)\n\theader_string = NULL;\n#ifdef USE_NNTP\n    if (b && b != NO_BUFFER && (f.scheme == SCM_NNTP || f.scheme == SCM_NEWS))\n\treAnchorNewsheader(b);\n#endif\n    if (b && b != NO_BUFFER)\n\tpreFormUpdateBuffer(b);\n    TRAP_OFF;\n    return b;\n}\n"", ""caller_start"": 1685, ""file_path"": ""file.c""}, {""call_line"": 921, ""call_code"": ""preFormUpdateBuffer(buf)"", ""caller_code"": ""Buffer *\nrenderFrame(Buffer *Cbuf, int force_reload)\n{\n    Str tmp;\n    FILE *f;\n    Buffer *buf;\n    int flag;\n    struct frameset *fset;\n#ifdef USE_M17N\n    wc_ces doc_charset = DocumentCharset;\n#endif\n\n    tmp = tmpfname(TMPF_FRAME, \"".html\"");\n    f = fopen(tmp->ptr, \""w\"");\n    if (f == NULL)\n\treturn NULL;\n    /* \n     * if (Cbuf->frameQ != NULL) fset = Cbuf->frameQ->frameset; else */\n    fset = Cbuf->frameset;\n    if (fset == NULL || createFrameFile(fset, f, Cbuf, 0, force_reload) < 0)\n\treturn NULL;\n    fclose(f);\n    flag = RG_FRAME;\n    if ((Cbuf->currentURL).is_nocache)\n\tflag |= RG_NOCACHE;\n    renderFrameSet = Cbuf->frameset;\n    flushFrameSet(renderFrameSet);\n#ifdef USE_M17N\n    DocumentCharset = InnerCharset;\n#endif\n    buf = loadGeneralFile(tmp->ptr, NULL, NULL, flag, NULL);\n#ifdef USE_M17N\n    DocumentCharset = doc_charset;\n#endif\n    renderFrameSet = NULL;\n    if (buf == NULL || buf == NO_BUFFER)\n\treturn NULL;\n    buf->sourcefile = tmp->ptr;\n#ifdef USE_M17N\n    buf->document_charset = Cbuf->document_charset;\n#endif\n    copyParsedURL(&buf->currentURL, &Cbuf->currentURL);\n    preFormUpdateBuffer(buf);\n    return buf;\n}\n"", ""caller_start"": 879, ""file_path"": ""frame.c""}]}, {""source"": ""value_info(file:form.c, value:Buffer)"", ""result"": {""value_trace"": [{""full_code"": ""b->linkBuffer[REV_LB[i]] = NULL"", ""line"": 94, ""func_name"": ""discardBuffer""}, {""full_code"": ""buf->nextBuffer = b->nextBuffer"", ""line"": 151, ""func_name"": ""deleteBuffer""}, {""full_code"": ""newbuf->nextBuffer = first"", ""line"": 166, ""func_name"": ""replaceBuffer""}, {""full_code"": ""newbuf->nextBuffer = delbuf->nextBuffer"", ""line"": 170, ""func_name"": ""replaceBuffer""}, {""full_code"": ""buf->nextBuffer = newbuf"", ""line"": 175, ""func_name"": ""replaceBuffer""}], ""struct_var"": ""Buffer"", ""struct_type"": ""Buffer"", ""struct_definition"": ""typedef struct _Buffer {\n    char *filename;\n    char *buffername;\n    Line *firstLine;\n    Line *topLine;\n    Line *currentLine;\n    Line *lastLine;\n    struct _Buffer *nextBuffer;\n    struct _Buffer *linkBuffer[MAX_LB];\n    short width;\n    short height;\n    char *type;\n    char *real_type;\n    int allLine;\n    short bufferprop;\n    int currentColumn;\n    short cursorX;\n    short cursorY;\n    int pos;\n    int visualpos;\n    short rootX;\n    short rootY;\n    short COLS;\n    short LINES;\n    InputStream pagerSource;\n    AnchorList *href;\n    AnchorList *name;\n    AnchorList *img;\n    AnchorList *formitem;\n    LinkList *linklist;\n    FormList *formlist;\n    MapList *maplist;\n    HmarkerList *hmarklist;\n    HmarkerList *imarklist;\n    ParsedURL currentURL;\n    ParsedURL *baseURL;\n    char *baseTarget;\n    int real_scheme;\n    char *sourcefile;\n    struct frameset *frameset;\n    struct frameset_queue *frameQ;\n    int *clone;\n    size_t trbyte;\n    char check_url;\n#ifdef USE_M17N\n    wc...""}}, {""source"": ""value_info(value:currentLine)"", ""result"": {""value_trace"": [{""full_code"": ""currentLine = sbuf.currentLine"", ""line"": 1767, ""func_name"": ""dispincsrch""}, {""full_code"": ""currentLine = Currentbuf->currentLine"", ""line"": 1817, ""func_name"": ""dispincsrch""}], ""struct_var"": ""currentLine"", ""struct_type"": ""Line*"", ""struct_definition"": ""typedef struct _Line {\n    char *lineBuf;\n    Lineprop *propBuf;\n#ifdef USE_ANSI_COLOR\n    Linecolor *colorBuf;\n#endif\n    struct _Line *next;\n    struct _Line *prev;\n    int len;\n    int width;\n    long linenumber;\t\t/* on buffer */\n    long real_linenumber;\t/* on file */\n    unsigned short usrflags;\n    int size;\n    int bpos;\n    int bwidth;\n} Line;""}}]","form.c:443-445: Access to `buf->currentLine->len` without a prior NULL check. `buf->currentLine` can be NULL if `clearBuffer` (form.c:72) is called, or if `gotoLine` (form.c:255) fails to initialize it. Callers like `formRecheckRadio` (form.c:219) and `preFormUpdateBuffer` (form.c:1031) may pass a `buf` with `currentLine` uninitialized, leading to a segmentation fault when the check is bypassed. The vulnerability is triggered when a crafted HTML page invokes form handling logic that calls `formUpdateBuffer` with an invalid `buf->currentLine`.",0.95,./github/other_context/CVE-2016-9624
46,CVE-2017-10917,CWE-476,c_cpp,"Xen through 4.8.x does not validate the port numbers of polled event channel ports, which allows guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) or possibly obtain sensitive information, aka XSA-221.",https://github.com/xen-project/xen/commit/e7719a0dfac7a20cb7da5529e09773d8271bb78b,"evtchn: avoid NULL derefs\n\nCommit fbbd5009e6 (""evtchn: refactor low-level event channel port ops"")\nadded a de-reference of the struct evtchn pointer for a port without\nfirst making sure the bucket pointer is non-NULL. This de-reference is\nactually entirely unnecessary, as all relevant callers (beyond the\nproblematic do_poll()) already hold the port number in their hands, and\nthe actual leaf functions need nothing else.\n\nFor FIFO event channels there's a second problem in that the ordering\nof reads and updates to ->num_evtchns and ->event_array[] was so far\nundefined (the read side isn't always holding the domain's event lock).\nAdd respective barriers.\n\nThis is XSA-221.\n\nReported-by: Ankur Arora <ankur.a.arora@oracle.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>",12,"[{""func_name"": ""evtchn_fifo_is_masked"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_masked(struct domain *d,\n                                    const struct evtchn *evtchn)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, evtchn->port);\n    if ( unlikely(!word) )\n        return 1;\n\n    return test_bit(EVTCHN_FIFO_MASKED, word);\n}"", ""target"": 0}, {""func_name"": ""evtchn_fifo_word_from_port"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static inline event_word_t *evtchn_fifo_word_from_port(struct domain *d,\n                                                       unsigned int port)\n{\n    unsigned int p, w;\n\n    if ( unlikely(port >= d->evtchn_fifo->num_evtchns) )\n        return NULL;\n\n    p = port / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    w = port % EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    return d->evtchn_fifo->event_array[p] + w;\n}"", ""target"": 0}, {""func_name"": ""add_page_to_event_array"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static int add_page_to_event_array(struct domain *d, unsigned long gfn)\n{\n    void *virt;\n    unsigned int slot;\n    unsigned int port = d->evtchn_fifo->num_evtchns;\n    int rc;\n\n    slot = d->evtchn_fifo->num_evtchns / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    if ( slot >= EVTCHN_FIFO_MAX_EVENT_ARRAY_PAGES )\n        return -ENOSPC;\n\n    rc = map_guest_page(d, gfn, &virt);\n    if ( rc < 0 )\n        return rc;\n\n    d->evtchn_fifo->event_array[slot] = virt;\n    d->evtchn_fifo->num_evtchns += EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    /*\n     * Re-raise any events that were pending while this array page was\n     * missing.\n     */\n    for ( ; port < d->evtchn_fifo->num_evtchns; port++ )\n    {\n        struct evtchn *evtchn;\n\n        if ( !port_is_valid(d, port) )\n            break;\n\n        evtchn = evtchn_from_port(d, port);\n        if ( evtchn->pending )\n            evtchn_fifo_set_pending(d->vcpu[evtchn->notify_vcpu_id], evtchn);\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""evtchn_fifo_is_pending"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_pending(struct domain *d,\n                                     const struct evtchn *evtchn)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, evtchn->port);\n    if ( unlikely(!word) )\n        return 0;\n\n    return test_bit(EVTCHN_FIFO_PENDING, word);\n}"", ""target"": 0}, {""func_name"": ""do_poll"", ""file_path"": ""xen/common/schedule.c"", ""func_code"": ""static long do_poll(struct sched_poll *sched_poll)\n{\n    struct vcpu   *v = current;\n    struct domain *d = v->domain;\n    evtchn_port_t  port;\n    long           rc;\n    unsigned int   i;\n\n    /* Fairly arbitrary limit. */\n    if ( sched_poll->nr_ports > 128 )\n        return -EINVAL;\n\n    if ( !guest_handle_okay(sched_poll->ports, sched_poll->nr_ports) )\n        return -EFAULT;\n\n    set_bit(_VPF_blocked, &v->pause_flags);\n    v->poll_evtchn = -1;\n    set_bit(v->vcpu_id, d->poll_mask);\n\n    arch_vcpu_block(v);\n\n#ifndef CONFIG_X86 /* set_bit() implies mb() on x86 */\n    /* Check for events /after/ setting flags: avoids wakeup waiting race. */\n    smp_mb();\n\n    /*\n     * Someone may have seen we are blocked but not that we are polling, or\n     * vice versa. We are certainly being woken, so clean up and bail. Beyond\n     * this point others can be guaranteed to clean up for us if they wake us.\n     */\n    rc = 0;\n    if ( (v->poll_evtchn == 0) ||\n         !test_bit(_VPF_blocked, &v->pause_flags) ||\n         !test_bit(v->vcpu_id, d->poll_mask) )\n        goto out;\n#endif\n\n    rc = 0;\n    if ( local_events_need_delivery() )\n        goto out;\n\n    for ( i = 0; i < sched_poll->nr_ports; i++ )\n    {\n        rc = -EFAULT;\n        if ( __copy_from_guest_offset(&port, sched_poll->ports, i, 1) )\n            goto out;\n\n        rc = -EINVAL;\n        if ( port >= d->max_evtchns )\n            goto out;\n\n        rc = 0;\n        if ( evtchn_port_is_pending(d, evtchn_from_port(d, port)) )\n            goto out;\n    }\n\n    if ( sched_poll->nr_ports == 1 )\n        v->poll_evtchn = port;\n\n    if ( sched_poll->timeout != 0 )\n        set_timer(&v->poll_timer, sched_poll->timeout);\n\n    TRACE_2D(TRC_SCHED_BLOCK, d->domain_id, v->vcpu_id);\n    raise_softirq(SCHEDULE_SOFTIRQ);\n\n    return 0;\n\n out:\n    v->poll_evtchn = 0;\n    clear_bit(v->vcpu_id, d->poll_mask);\n    clear_bit(_VPF_blocked, &v->pause_flags);\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""dump_irqs"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct evtchn *evtchn;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                          desc->affinity);\n        printk(\""   IRQ:%4d affinity:%s vec:%02x type=%-15s\""\n               \"" status=%08x \"",\n               irq, keyhandler_scratch, desc->arch.vector,\n               desc->handler->typename, desc->status);\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d domain-list=\"", action->in_flight);\n\n            for ( i = 0; i < action->nr_guests; i++ )\n            {\n                d = action->guest[i];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                evtchn = evtchn_from_port(d, info->evtchn);\n                printk(\""%u:%3d(%c%c%c)\"",\n                       d->domain_id, pirq,\n                       (evtchn_port_is_pending(d, evtchn) ? 'P' : '-'),\n                       (evtchn_port_is_masked(d, evtchn) ? 'M' : '-'),\n                       (info->masked ? 'M' : '-'));\n                if ( i != action->nr_guests )\n                    printk(\"",\"");\n            }\n\n            printk(\""\\n\"");\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}"", ""target"": 0}, {""func_name"": ""pirq_guest_unmask"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""int pirq_guest_unmask(struct domain *d)\n{\n    unsigned int pirq = 0, n, i;\n    struct pirq *pirqs[16];\n\n    do {\n        n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq,\n                                   ARRAY_SIZE(pirqs));\n        for ( i = 0; i < n; ++i )\n        {\n            pirq = pirqs[i]->pirq;\n            if ( pirqs[i]->masked &&\n                 !evtchn_port_is_masked(d, evtchn_from_port(d, pirqs[i]->evtchn)) )\n                pirq_guest_eoi(pirqs[i]);\n        }\n    } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) );\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""domain_dump_evtchn_info"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void domain_dump_evtchn_info(struct domain *d)\n{\n    unsigned int port;\n    int irq;\n\n    bitmap_scnlistprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                         d->poll_mask, d->max_vcpus);\n    printk(\""Event channel information for domain %d:\\n\""\n           \""Polling vCPUs: {%s}\\n\""\n           \""    port [p/m/s]\\n\"", d->domain_id, keyhandler_scratch);\n\n    spin_lock(&d->event_lock);\n\n    for ( port = 1; port < d->max_evtchns; ++port )\n    {\n        const struct evtchn *chn;\n        char *ssid;\n\n        if ( !port_is_valid(d, port) )\n            continue;\n        chn = evtchn_from_port(d, port);\n        if ( chn->state == ECS_FREE )\n            continue;\n\n        printk(\""    %4u [%d/%d/\"",\n               port,\n               !!evtchn_port_is_pending(d, chn),\n               !!evtchn_port_is_masked(d, chn));\n        evtchn_port_print_state(d, chn);\n        printk(\""]: s=%d n=%d x=%d\"",\n               chn->state, chn->notify_vcpu_id, chn->xen_consumer);\n\n        switch ( chn->state )\n        {\n        case ECS_UNBOUND:\n            printk(\"" d=%d\"", chn->u.unbound.remote_domid);\n            break;\n        case ECS_INTERDOMAIN:\n            printk(\"" d=%d p=%d\"",\n                   chn->u.interdomain.remote_dom->domain_id,\n                   chn->u.interdomain.remote_port);\n            break;\n        case ECS_PIRQ:\n            irq = domain_pirq_to_irq(d, chn->u.pirq.irq);\n            printk(\"" p=%d i=%d\"", chn->u.pirq.irq, irq);\n            break;\n        case ECS_VIRQ:\n            printk(\"" v=%d\"", chn->u.virq);\n            break;\n        }\n\n        ssid = xsm_show_security_evtchn(d, chn);\n        if (ssid) {\n            printk(\"" Z=%s\\n\"", ssid);\n            xfree(ssid);\n        } else {\n            printk(\""\\n\"");\n        }\n    }\n\n    spin_unlock(&d->event_lock);\n}"", ""target"": 0}, {""func_name"": ""evtchn_port_is_pending"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_pending(struct domain *d,\n                                            const struct evtchn *evtchn)\n{\n    return d->evtchn_port_ops->is_pending(d, evtchn);\n}"", ""target"": 0}, {""func_name"": ""evtchn_port_is_masked"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_masked(struct domain *d,\n                                           const struct evtchn *evtchn)\n{\n    return d->evtchn_port_ops->is_masked(d, evtchn);\n}"", ""target"": 0}, {""func_name"": ""evtchn_2l_is_masked"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_masked(struct domain *d,\n                                  const struct evtchn *evtchn)\n{\n    return test_bit(evtchn->port, &shared_info(d, evtchn_mask));\n}"", ""target"": 0}, {""func_name"": ""evtchn_2l_is_pending"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_pending(struct domain *d,\n                                   const struct evtchn *evtchn)\n{\n    return test_bit(evtchn->port, &shared_info(d, evtchn_pending));\n}"", ""target"": 0}]","[{""func_name"": ""evtchn_fifo_is_masked"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_masked(struct domain *d, evtchn_port_t port)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, port);\n    if ( unlikely(!word) )\n        return 1;\n\n    return test_bit(EVTCHN_FIFO_MASKED, word);\n}""}, {""func_name"": ""evtchn_fifo_word_from_port"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static inline event_word_t *evtchn_fifo_word_from_port(struct domain *d,\n                                                       unsigned int port)\n{\n    unsigned int p, w;\n\n    if ( unlikely(port >= d->evtchn_fifo->num_evtchns) )\n        return NULL;\n\n    /*\n     * Callers aren't required to hold d->event_lock, so we need to synchronize\n     * with add_page_to_event_array().\n     */\n    smp_rmb();\n\n    p = port / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    w = port % EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    return d->evtchn_fifo->event_array[p] + w;\n}""}, {""func_name"": ""add_page_to_event_array"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static int add_page_to_event_array(struct domain *d, unsigned long gfn)\n{\n    void *virt;\n    unsigned int slot;\n    unsigned int port = d->evtchn_fifo->num_evtchns;\n    int rc;\n\n    slot = d->evtchn_fifo->num_evtchns / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    if ( slot >= EVTCHN_FIFO_MAX_EVENT_ARRAY_PAGES )\n        return -ENOSPC;\n\n    rc = map_guest_page(d, gfn, &virt);\n    if ( rc < 0 )\n        return rc;\n\n    d->evtchn_fifo->event_array[slot] = virt;\n\n    /* Synchronize with evtchn_fifo_word_from_port(). */\n    smp_wmb();\n\n    d->evtchn_fifo->num_evtchns += EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    /*\n     * Re-raise any events that were pending while this array page was\n     * missing.\n     */\n    for ( ; port < d->evtchn_fifo->num_evtchns; port++ )\n    {\n        struct evtchn *evtchn;\n\n        if ( !port_is_valid(d, port) )\n            break;\n\n        evtchn = evtchn_from_port(d, port);\n        if ( evtchn->pending )\n            evtchn_fifo_set_pending(d->vcpu[evtchn->notify_vcpu_id], evtchn);\n    }\n\n    return 0;\n}""}, {""func_name"": ""evtchn_fifo_is_pending"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_pending(struct domain *d, evtchn_port_t port)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, port);\n    if ( unlikely(!word) )\n        return 0;\n\n    return test_bit(EVTCHN_FIFO_PENDING, word);\n}""}, {""func_name"": ""do_poll"", ""file_path"": ""xen/common/schedule.c"", ""func_code"": ""static long do_poll(struct sched_poll *sched_poll)\n{\n    struct vcpu   *v = current;\n    struct domain *d = v->domain;\n    evtchn_port_t  port;\n    long           rc;\n    unsigned int   i;\n\n    /* Fairly arbitrary limit. */\n    if ( sched_poll->nr_ports > 128 )\n        return -EINVAL;\n\n    if ( !guest_handle_okay(sched_poll->ports, sched_poll->nr_ports) )\n        return -EFAULT;\n\n    set_bit(_VPF_blocked, &v->pause_flags);\n    v->poll_evtchn = -1;\n    set_bit(v->vcpu_id, d->poll_mask);\n\n    arch_vcpu_block(v);\n\n#ifndef CONFIG_X86 /* set_bit() implies mb() on x86 */\n    /* Check for events /after/ setting flags: avoids wakeup waiting race. */\n    smp_mb();\n\n    /*\n     * Someone may have seen we are blocked but not that we are polling, or\n     * vice versa. We are certainly being woken, so clean up and bail. Beyond\n     * this point others can be guaranteed to clean up for us if they wake us.\n     */\n    rc = 0;\n    if ( (v->poll_evtchn == 0) ||\n         !test_bit(_VPF_blocked, &v->pause_flags) ||\n         !test_bit(v->vcpu_id, d->poll_mask) )\n        goto out;\n#endif\n\n    rc = 0;\n    if ( local_events_need_delivery() )\n        goto out;\n\n    for ( i = 0; i < sched_poll->nr_ports; i++ )\n    {\n        rc = -EFAULT;\n        if ( __copy_from_guest_offset(&port, sched_poll->ports, i, 1) )\n            goto out;\n\n        rc = -EINVAL;\n        if ( port >= d->max_evtchns )\n            goto out;\n\n        rc = 0;\n        if ( evtchn_port_is_pending(d, port) )\n            goto out;\n    }\n\n    if ( sched_poll->nr_ports == 1 )\n        v->poll_evtchn = port;\n\n    if ( sched_poll->timeout != 0 )\n        set_timer(&v->poll_timer, sched_poll->timeout);\n\n    TRACE_2D(TRC_SCHED_BLOCK, d->domain_id, v->vcpu_id);\n    raise_softirq(SCHEDULE_SOFTIRQ);\n\n    return 0;\n\n out:\n    v->poll_evtchn = 0;\n    clear_bit(v->vcpu_id, d->poll_mask);\n    clear_bit(_VPF_blocked, &v->pause_flags);\n    return rc;\n}""}, {""func_name"": ""dump_irqs"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                          desc->affinity);\n        printk(\""   IRQ:%4d affinity:%s vec:%02x type=%-15s\""\n               \"" status=%08x \"",\n               irq, keyhandler_scratch, desc->arch.vector,\n               desc->handler->typename, desc->status);\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d domain-list=\"", action->in_flight);\n\n            for ( i = 0; i < action->nr_guests; i++ )\n            {\n                d = action->guest[i];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                printk(\""%u:%3d(%c%c%c)\"",\n                       d->domain_id, pirq,\n                       evtchn_port_is_pending(d, info->evtchn) ? 'P' : '-',\n                       evtchn_port_is_masked(d, info->evtchn) ? 'M' : '-',\n                       (info->masked ? 'M' : '-'));\n                if ( i != action->nr_guests )\n                    printk(\"",\"");\n            }\n\n            printk(\""\\n\"");\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}""}, {""func_name"": ""pirq_guest_unmask"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""int pirq_guest_unmask(struct domain *d)\n{\n    unsigned int pirq = 0, n, i;\n    struct pirq *pirqs[16];\n\n    do {\n        n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq,\n                                   ARRAY_SIZE(pirqs));\n        for ( i = 0; i < n; ++i )\n        {\n            pirq = pirqs[i]->pirq;\n            if ( pirqs[i]->masked &&\n                 !evtchn_port_is_masked(d, pirqs[i]->evtchn) )\n                pirq_guest_eoi(pirqs[i]);\n        }\n    } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) );\n\n    return 0;\n}""}, {""func_name"": ""domain_dump_evtchn_info"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void domain_dump_evtchn_info(struct domain *d)\n{\n    unsigned int port;\n    int irq;\n\n    bitmap_scnlistprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                         d->poll_mask, d->max_vcpus);\n    printk(\""Event channel information for domain %d:\\n\""\n           \""Polling vCPUs: {%s}\\n\""\n           \""    port [p/m/s]\\n\"", d->domain_id, keyhandler_scratch);\n\n    spin_lock(&d->event_lock);\n\n    for ( port = 1; port < d->max_evtchns; ++port )\n    {\n        const struct evtchn *chn;\n        char *ssid;\n\n        if ( !port_is_valid(d, port) )\n            continue;\n        chn = evtchn_from_port(d, port);\n        if ( chn->state == ECS_FREE )\n            continue;\n\n        printk(\""    %4u [%d/%d/\"",\n               port,\n               evtchn_port_is_pending(d, port),\n               evtchn_port_is_masked(d, port));\n        evtchn_port_print_state(d, chn);\n        printk(\""]: s=%d n=%d x=%d\"",\n               chn->state, chn->notify_vcpu_id, chn->xen_consumer);\n\n        switch ( chn->state )\n        {\n        case ECS_UNBOUND:\n            printk(\"" d=%d\"", chn->u.unbound.remote_domid);\n            break;\n        case ECS_INTERDOMAIN:\n            printk(\"" d=%d p=%d\"",\n                   chn->u.interdomain.remote_dom->domain_id,\n                   chn->u.interdomain.remote_port);\n            break;\n        case ECS_PIRQ:\n            irq = domain_pirq_to_irq(d, chn->u.pirq.irq);\n            printk(\"" p=%d i=%d\"", chn->u.pirq.irq, irq);\n            break;\n        case ECS_VIRQ:\n            printk(\"" v=%d\"", chn->u.virq);\n            break;\n        }\n\n        ssid = xsm_show_security_evtchn(d, chn);\n        if (ssid) {\n            printk(\"" Z=%s\\n\"", ssid);\n            xfree(ssid);\n        } else {\n            printk(\""\\n\"");\n        }\n    }\n\n    spin_unlock(&d->event_lock);\n}""}, {""func_name"": ""evtchn_port_is_pending"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_pending(struct domain *d,\n                                            evtchn_port_t port)\n{\n    return d->evtchn_port_ops->is_pending(d, port);\n}""}, {""func_name"": ""evtchn_port_is_masked"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_masked(struct domain *d,\n                                           evtchn_port_t port)\n{\n    return d->evtchn_port_ops->is_masked(d, port);\n}""}, {""func_name"": ""evtchn_2l_is_masked"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_masked(struct domain *d, evtchn_port_t port)\n{\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return port >= max_ports || test_bit(port, &shared_info(d, evtchn_mask));\n}""}, {""func_name"": ""evtchn_2l_is_pending"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_pending(struct domain *d, evtchn_port_t port)\n{\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return port < max_ports && test_bit(port, &shared_info(d, evtchn_pending));\n}""}]","{""function"": 1, ""caller"": 1}","[{""source"": ""func_info(file:event.h, func:evtchn_from_port)"", ""result"": [{""code"": ""static inline struct evtchn *evtchn_from_port(struct domain *d, unsigned int p)\n{\n    if ( p < EVTCHNS_PER_BUCKET )\n        return &d->evtchn[p];\n    return bucket_from_port(d, p) + (p % EVTCHNS_PER_BUCKET);\n}"", ""start_line"": 95, ""end_line"": 100, ""full_name"": ""evtchn_from_port"", ""file_path"": ""xen/include/xen/event.h""}]}, {""source"": ""caller_info(func:evtchn_from_port)"", ""result"": [{""call_line"": 1489, ""call_code"": ""evtchn_from_port(d, pirqs[i]->evtchn)"", ""caller_code"": ""int pirq_guest_unmask(struct domain *d)\n{\n    unsigned int pirq = 0, n, i;\n    struct pirq *pirqs[16];\n\n    do {\n        n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq,\n                                   ARRAY_SIZE(pirqs));\n        for ( i = 0; i < n; ++i )\n        {\n            pirq = pirqs[i]->pirq;\n            if ( pirqs[i]->masked &&\n                 !evtchn_port_is_masked(d, evtchn_from_port(d, pirqs[i]->evtchn)) )\n                pirq_guest_eoi(pirqs[i]);\n        }\n    } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) );\n\n    return 0;\n}"", ""caller_start"": 1477, ""file_path"": ""xen/arch/x86/irq.c""}, {""call_line"": 2290, ""call_code"": ""evtchn_from_port(d, info->evtchn)"", ""caller_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct evtchn *evtchn;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                          desc->affinity);\n        printk(\""   IRQ:%4d affinity:%s vec:%02x type=%-15s\""\n               \"" status=%08x \"",\n               irq, keyhandler_scratch, desc->arch.vector,\n               desc->handler->typename, desc->status);\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d domain-list=\"", action->in_flight);\n\n            for ( i = 0; i < action->nr_guests; i++ )\n            {\n                d = action->guest[i];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                evtchn = evtchn_from_port(d, info->evtchn);\n                printk(\""%u:%3d(%c%c%c)\"",\n                       d->domain_id, pirq,\n                       (evtchn_port_is_pending(d, evtchn) ? 'P' : '-'),\n                       (evtchn_port_is_masked(d, evtchn) ? 'M' : '-'),\n                       (info->masked ? 'M' : '-'));\n                if ( i != action->nr_guests )\n                    printk(\"",\"");\n            }\n\n            printk(\""\\n\"");\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}\n"", ""caller_start"": 2242, ""file_path"": ""xen/arch/x86/irq.c""}, {""call_line"": 172, ""call_code"": ""evtchn_from_port(d, port)"", ""caller_code"": ""static int get_free_port(struct domain *d)\n{\n    struct evtchn *chn;\n    struct evtchn **grp;\n    int            port;\n\n    if ( d->is_dying )\n        return -EINVAL;\n\n    for ( port = 0; port_is_valid(d, port); port++ )\n    {\n        if ( port > d->max_evtchn_port )\n            return -ENOSPC;\n        if ( evtchn_from_port(d, port)->state == ECS_FREE\n             && !evtchn_port_is_busy(d, port) )\n            return port;\n    }\n\n    if ( port == d->max_evtchns || port > d->max_evtchn_port )\n        return -ENOSPC;\n\n    if ( !group_from_port(d, port) )\n    {\n        grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n        if ( !grp )\n            return -ENOMEM;\n        group_from_port(d, port) = grp;\n    }\n\n    chn = alloc_evtchn_bucket(d, port);\n    if ( !chn )\n        return -ENOMEM;\n    bucket_from_port(d, port) = chn;\n\n    write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n\n    return port;\n}"", ""caller_start"": 159, ""file_path"": ""xen/common/event_channel.c""}, {""call_line"": 227, ""call_code"": ""evtchn_from_port(d, port)"", ""caller_code"": ""static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)\n{\n    struct evtchn *chn;\n    struct domain *d;\n    int            port;\n    domid_t        dom = alloc->dom;\n    long           rc;\n\n    d = rcu_lock_domain_by_any_id(dom);\n    if ( d == NULL )\n        return -ESRCH;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT_DOM(port, d);\n    chn = evtchn_from_port(d, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )\n        chn->u.unbound.remote_domid = current->domain->domain_id;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    alloc->port = port;\n\n out:\n    spin_unlock(&d->event_lock);\n    rcu_unlock_domain(d);\n\n    return rc;\n}"", ""caller_start"": 211, ""file_path"": ""xen/common/event_channel.c""}]}]","Unvalidated port numbers in Xen's event channel handling allowed NULL dereferences. Specifically:\n1. `evtchn_from_port` (xen/include/xen/event.h:95-100) returns a struct evtchn* based on the port, but does not validate the port's validity beyond basic bounds checks.\n2. Callers like `pirq_guest_unmask` (xen/arch/x86/irq.c:1489) and `dump_irqs` (xen/arch/x86/irq.c:2290) used `evtchn_from_port` without validating the returned pointer.\n3. If the port was invalid (e.g., beyond allocated buckets), `evtchn_from_port` would return NULL. Subsequent dereferences (e.g., in `evtchn_port_is_masked`) would cause a NULL pointer dereference.\n4. The patch replaces struct-based calls with direct port usage (e.g., `evtchn_port_is_masked(d, port)`) and adds barriers in FIFO handling (xen/common/event_fifo.c:28, 594) to ensure proper memory ordering.",0.95,./github/other_context/CVE-2017-10917
47,CVE-2017-11733,CWE-476,c_cpp,"A null pointer dereference vulnerability was found in the function stackswap (called from decompileSTACKSWAP) in util/decompile.c in Ming 0.4.8, which allows attackers to cause a denial of service via a crafted file.",https://github.com/libming/libming/commit/eda5a20206862a11805303cdd125566c9f9f9103,"Fix null-pointer dereference issue in stackswap.\n\nAvoid processing stackswap when stack only contains one element. In this\ncase, print a warning if debug mode is enabled, and return cleanly.\n\nThis commit fixes CVE-2017-11733 (fixes #78).",5,"[{""func_name"": ""readUInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""unsigned long readUInt32(FILE *f)\n{\n  int part1 = readUInt8(f);\n  int part2 = readUInt8(f) << 8;\n  int part3 = readUInt8(f) << 16;\n  unsigned long part4 = ((unsigned long)readUInt8(f)) << 24;\n  return part1 + part2 + part3 + part4;\n}"", ""target"": 1}, {""func_name"": ""readSInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""long readSInt32(FILE *f)\n{\n  return (long)readUInt8(f) + (readUInt8(f)<<8) + (readUInt8(f)<<16) + (readUInt8(f)<<24);\n}"", ""target"": 1}, {""func_name"": ""readUInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""int readUInt16(FILE *f)\n{\n  return readUInt8(f) + (readUInt8(f)<<8);\n}"", ""target"": 1}, {""func_name"": ""readSInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""int readSInt16(FILE *f)\n{\n  return readUInt8(f) + readSInt8(f)*256;\n}"", ""target"": 1}, {""func_name"": ""stackswap"", ""file_path"": ""util/decompile.c"", ""func_code"": ""void\nstackswap()\n{\n#ifdef DEBUG\n\tprintf(\""*stackswap*\\n\"");\n#endif\n\tstruct SWF_ACTIONPUSHPARAM *p = peek();\t\t/* peek() includes error handling */\n\tchar type = Stack->type;\n\tStack->type = Stack->next->type;\n\tStack->val  = Stack->next->val;\n\tStack->next->type = type;\n\tStack->next->val  = p;\n}"", ""target"": 0}]","[{""func_name"": ""readUInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""unsigned long readUInt32(FILE *f)\n{\n  unsigned long result = 0u;\n  result |= readUInt8(f);\n  result |= readUInt8(f) << 8;\n  result |= readUInt8(f) << 16;\n  result |= readUInt8(f) << 24;\n  return result;\n}""}, {""func_name"": ""readSInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""long readSInt32(FILE *f)\n{\n  long result = 0;\n  result |= readUInt8(f);\n  result |= readUInt8(f) << 8;\n  result |= readUInt8(f) << 16;\n  result |= readUInt8(f) << 24;\n  return result;\n}""}, {""func_name"": ""readUInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""unsigned int readUInt16(FILE *f)\n{\n  unsigned int result = 0u;\n  result |= readUInt8(f);\n  result |= readUInt8(f) << 8;\n  return result;\n}""}, {""func_name"": ""readSInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""int readSInt16(FILE *f)\n{\n  int result = 0;\n  result |= readUInt8(f);\n  result |= readSInt8(f) << 8;\n  return result;\n}""}, {""func_name"": ""stackswap"", ""file_path"": ""util/decompile.c"", ""func_code"": ""void\nstackswap()\n{\n#ifdef DEBUG\n\tprintf(\""*stackswap*\\n\"");\n#endif\n\tstruct SWF_ACTIONPUSHPARAM *p = peek();\t\t/* peek() includes error handling */\n\tchar type = Stack->type;\n\n        if (Stack->next == NULL) {\n#if DEBUG\n\t\tSWF_warn(\""stackswap: can't swap (stack contains only one element)\\n\"");\n#endif\n                return;\n        }\n\n\tStack->type = Stack->next->type;\n\tStack->val  = Stack->next->val;\n\tStack->next->type = type;\n\tStack->next->val  = p;\n}""}]","{""caller"": 1, ""function"": 1}","[{""source"": ""caller_info(file:decompile.c, func:decompileSTACKSWAP)"", ""result"": [{""call_line"": 3178, ""call_code"": ""decompileSTACKSWAP(&actions[n])"", ""caller_code"": ""int\ndecompileAction(int n, SWF_ACTION *actions, int maxn)\n{\n\tif( n > maxn ) SWF_error(\""Action overflow!!\"");\n\n#ifdef DEBUG\n\tfprintf(stderr,\""%d:\\tACTION[%3.3d]: %s\\n\"",\n\t        actions[n].SWF_ACTIONRECORD.Offset, n, \n\t        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));\n#endif\n\n\tswitch(actions[n].SWF_ACTIONRECORD.ActionCode)\n\t{\n\tcase SWFACTION_END:\n\t\treturn 0;\n\n\tcase SWFACTION_CONSTANTPOOL:\n\t\tdecompileCONSTANTPOOL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GOTOLABEL:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,1);\n\n\tcase SWFACTION_GOTOFRAME:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,0);\n\n\tcase SWFACTION_GOTOFRAME2:\n\t\treturn decompileGOTOFRAME2(n, actions, maxn);\n\n\tcase SWFACTION_WAITFORFRAME:\n\t\tdecompileWAITFORFRAME(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL2:\n\t\tdecompileGETURL2(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL:\n\t\tdecompileGETURL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSH:\n\t\tdecompilePUSH(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSHDUP:\n\t\tde..."", ""caller_start"": 3128, ""file_path"": ""util/decompile.c""}]}, {""source"": ""func_info(file:decompile.c, func:decompileSTACKSWAP)"", ""result"": [{""code"": ""static void\ndecompileSTACKSWAP (SWF_ACTION *act)\n{\n\tSanityCheck(SWF_STACKSWAP,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_STACKSWAP,\n\t\t\""not a STACKSWAP\"")\n\tstackswap();\n}"", ""start_line"": 1352, ""end_line"": 1359, ""full_name"": ""decompileSTACKSWAP"", ""file_path"": ""util/decompile.c""}]}]","The root cause is the absence of stack depth validation in `decompileSTACKSWAP` (called from `util/decompile.c:3178`), which directly invokes `stackswap()` without ensuring the stack has at least two elements. This allows `stackswap` to dereference `Stack->next` when it is NULL (util/decompile.c:633-635). The patch at `util/decompile.c:627+` adds a check for this condition, but the trigger chain relies on `decompileSTACKSWAP` (util/decompile.c:1352-1359) not enforcing stack constraints before calling `stackswap`.",0.95,./github/other_context/CVE-2017-11733
48,CVE-2017-13764,CWE-476,c_cpp,"In Wireshark 2.4.0, the Modbus dissector could crash with a NULL pointer dereference. This was addressed in epan/dissectors/packet-mbtcp.c by adding length validation.",https://github.com/wireshark/wireshark/commit/b87ffbd12bddf64582c0a6e082b462744474de94,"Modbus: do not trigger an exception before saving pkt_info structure\n\nOtherwise on second pass pkt_info is null, leading to a segmentation fault\n\nBug: 13925\nChange-Id: I61cfbee894506fb6c4205c9a2ad19e6973821f23\nReviewed-on: https://code.wireshark.org/review/22833\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit b16d487cbc70a441d26a1052b22d1bb0132b1cbc)\nReviewed-on: https://code.wireshark.org/review/22839",1,"[{""func_name"": ""dissect_modbus"", ""file_path"": ""epan/dissectors/packet-mbtcp.c"", ""func_code"": ""static int\ndissect_modbus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    proto_tree          *modbus_tree;\n    proto_item          *mi;\n    int                 offset = 0;\n    int*                packet_type = (int*)data;\n    gint                payload_start, payload_len, len;\n    guint8              function_code, exception_code;\n    modbus_pkt_info_t   *pkt_info;\n\n    /* Reject the packet if data passed from the mbrtu or mbtcp dissector is NULL */\n    if (packet_type == NULL)\n        return 0;\n\n    len = tvb_captured_length(tvb);\n\n    /* If the packet is zero-length, we should not attempt to dissect any further */\n    if (len == 0)\n        return 0;\n\n    /* Add items to protocol tree specific to Modbus */\n    mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, \""Modbus\"");\n    modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr);\n\n    function_code = tvb_get_guint8(tvb, offset) & 0x7F;\n    proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n           modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope());\n           modbus_conv_data->register_format = global_mbus_register_format;\n           conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data);\n        }\n\n        pkt_info->register_format = modbus_conv_data->register_format;\n\n        if (*packet_type == QUERY_PACKET) {\n            /*create the modbus_request frame. It holds the request information.*/\n            modbus_request_info_t    *frame_ptr = wmem_new(wmem_file_scope(), modbus_request_info_t);\n\n            /* load information into the modbus request frame */\n            frame_ptr->fnum = pinfo->num;\n            frame_ptr->function_code = function_code;\n            pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1);\n            pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3);\n\n            wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            guint8                req_function_code;\n            guint32               req_frame_num;\n            modbus_request_info_t *request_data;\n\n            wmem_list_frame_t *frame = wmem_list_head(modbus_conv_data->modbus_request_frame_data);\n            /* Step backward through all logged instances of request frames, looking for a request frame number that\n            occurred immediately prior to current frame number that has a matching function code */\n            while (frame && !pkt_info->request_found) {\n                request_data = (modbus_request_info_t *)wmem_list_frame_data(frame);\n                req_frame_num = request_data->fnum;\n                req_function_code = request_data->function_code;\n                if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) {\n                    pkt_info->reg_base = request_data->base_address;\n                    pkt_info->num_reg = request_data->num_reg;\n                    pkt_info->request_found = TRUE;\n                    pkt_info->req_frame_num = req_frame_num;\n                }\n                frame = wmem_list_frame_next(frame);\n            }\n\n\n        }\n        p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info);\n\n    }\n    else { /* !visited */\n        pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0);\n    }\n\n\n    /* Find exception - last bit set in function code */\n    if (tvb_get_guint8(tvb, offset) & 0x80 ) {\n        exception_code = tvb_get_guint8(tvb, offset+1);\n    }\n    else {\n        exception_code = 0;\n    }\n\n    payload_start = offset + 1;\n    payload_len = len - 1;\n\n    if (exception_code != 0) {\n        proto_item_set_text(mi, \""Function %u:  %s.  Exception: %s\"",\n                            function_code,\n                            val_to_str_const(function_code, function_code_vals, \""Unknown Function\""),\n                            val_to_str(exception_code,\n                                       exception_code_vals,\n                                       \""Unknown Exception Code (%u)\""));\n        proto_tree_add_uint(modbus_tree, hf_modbus_exceptioncode, tvb, payload_start, 1,\n                            exception_code);\n    }\n    else {\n\n        /* Follow different dissection path depending on whether packet is query or response */\n        if (*packet_type == QUERY_PACKET) {\n            dissect_modbus_request(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            dissect_modbus_response(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n\n    }\n\n    return tvb_captured_length(tvb);\n}"", ""target"": 0}]","[{""func_name"": ""dissect_modbus"", ""file_path"": ""epan/dissectors/packet-mbtcp.c"", ""func_code"": ""static int\ndissect_modbus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    proto_tree          *modbus_tree;\n    proto_item          *mi;\n    int                 offset = 0;\n    int*                packet_type = (int*)data;\n    gint                payload_start, payload_len, len;\n    guint8              function_code, exception_code;\n    modbus_pkt_info_t   *pkt_info;\n\n    /* Reject the packet if data passed from the mbrtu or mbtcp dissector is NULL */\n    if (packet_type == NULL)\n        return 0;\n\n    len = tvb_captured_length(tvb);\n\n    /* If the packet is zero-length, we should not attempt to dissect any further */\n    if (len == 0)\n        return 0;\n\n    /* Add items to protocol tree specific to Modbus */\n    mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, \""Modbus\"");\n    modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr);\n\n    function_code = tvb_get_guint8(tvb, offset) & 0x7F;\n    proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n           modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope());\n           modbus_conv_data->register_format = global_mbus_register_format;\n           conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data);\n        }\n\n        pkt_info->register_format = modbus_conv_data->register_format;\n\n        if (*packet_type == QUERY_PACKET) {\n            /*create the modbus_request frame. It holds the request information.*/\n            modbus_request_info_t    *frame_ptr = wmem_new0(wmem_file_scope(), modbus_request_info_t);\n            gint captured_length = tvb_captured_length(tvb);\n\n            /* load information into the modbus request frame */\n            frame_ptr->fnum = pinfo->num;\n            frame_ptr->function_code = function_code;\n            if (captured_length >= 3) {\n                pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1);\n                if (captured_length >= 5)\n                    pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3);\n            }\n\n            wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            guint8                req_function_code;\n            guint32               req_frame_num;\n            modbus_request_info_t *request_data;\n\n            wmem_list_frame_t *frame = wmem_list_head(modbus_conv_data->modbus_request_frame_data);\n            /* Step backward through all logged instances of request frames, looking for a request frame number that\n            occurred immediately prior to current frame number that has a matching function code */\n            while (frame && !pkt_info->request_found) {\n                request_data = (modbus_request_info_t *)wmem_list_frame_data(frame);\n                req_frame_num = request_data->fnum;\n                req_function_code = request_data->function_code;\n                if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) {\n                    pkt_info->reg_base = request_data->base_address;\n                    pkt_info->num_reg = request_data->num_reg;\n                    pkt_info->request_found = TRUE;\n                    pkt_info->req_frame_num = req_frame_num;\n                }\n                frame = wmem_list_frame_next(frame);\n            }\n\n\n        }\n        p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info);\n\n    }\n    else { /* !visited */\n        pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0);\n    }\n\n\n    /* Find exception - last bit set in function code */\n    if (tvb_get_guint8(tvb, offset) & 0x80 ) {\n        exception_code = tvb_get_guint8(tvb, offset+1);\n    }\n    else {\n        exception_code = 0;\n    }\n\n    payload_start = offset + 1;\n    payload_len = len - 1;\n\n    if (exception_code != 0) {\n        proto_item_set_text(mi, \""Function %u:  %s.  Exception: %s\"",\n                            function_code,\n                            val_to_str_const(function_code, function_code_vals, \""Unknown Function\""),\n                            val_to_str(exception_code,\n                                       exception_code_vals,\n                                       \""Unknown Exception Code (%u)\""));\n        proto_tree_add_uint(modbus_tree, hf_modbus_exceptioncode, tvb, payload_start, 1,\n                            exception_code);\n    }\n    else {\n\n        /* Follow different dissection path depending on whether packet is query or response */\n        if (*packet_type == QUERY_PACKET) {\n            dissect_modbus_request(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            dissect_modbus_response(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n\n    }\n\n    return tvb_captured_length(tvb);\n}""}]","{""code"": 3, ""value"": 1, ""function"": 4}","[{""source"": ""code_info(file:packet-mbtcp.c, lines:1550-1580)"", ""result"": ""    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n           modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope());\n           modbus_conv_data->register_format = global_mbus_register_format;\n           conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data);\n        }\n\n        pkt_info->register_format = modbus_conv_data->register_format;\n\n        if (*packet_type == QUERY_PACKET) {\n            /*create the modbus_request frame. It holds the request information.*/\n            modbus_request_info_t    *frame_ptr = wmem_new(wmem_file_scope(), modbus_request_info_t);\n\n            /* load information into the modbus request frame */\n            frame_ptr->fnum = pinfo->num;\n            frame_ptr->function_code = function_code;\n            pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1);\n            pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3);\n\n            wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n""}, {""source"": ""value_info(file:packet-mbtcp.c, value:pkt_info)"", ""result"": {""value_trace"": [{""full_code"": ""pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t)"", ""line"": 1558, ""func_name"": ""dissect_modbus""}, {""full_code"": ""pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0)"", ""line"": 1608, ""func_name"": ""dissect_modbus""}], ""struct_var"": ""pkt_info"", ""struct_type"": ""modbus_pkt_info_t*"", ""struct_definition"": ""typedef struct {\n    guint8  function_code;\n    gint    register_format;\n    guint16 reg_base;\n    guint16 num_reg;\n    guint32 req_frame_num;\n    gboolean request_found;\n}""}}, {""source"": ""func_info(func:p_get_proto_data)"", ""result"": [{""code"": ""void *\np_get_proto_data(wmem_allocator_t *scope, struct _packet_info* pinfo, int proto, guint32 key)\n{\n  proto_data_t  temp, *p1;\n  GSList       *item;\n\n  temp.proto = proto;\n  temp.key = key;\n  temp.proto_data = NULL;\n\n  if (scope == pinfo->pool) {\n    item = g_slist_find_custom(pinfo->proto_data, &temp, p_compare);\n  } else if (scope == wmem_file_scope()) {\n    item = g_slist_find_custom(pinfo->fd->pfd, &temp, p_compare);\n  } else {\n    DISSECTOR_ASSERT(!\""invalid wmem scope\"");\n  }\n\n  if (item) {\n    p1 = (proto_data_t *)item->data;\n    return p1->proto_data;\n  }\n\n  return NULL;\n}"", ""start_line"": 97, ""end_line"": 121, ""full_name"": ""p_get_proto_data"", ""file_path"": ""epan/proto_data.c""}]}, {""source"": ""code_info(file:packet-mbtcp.c, lines:1540-1560)"", ""result"": ""    if (len == 0)\n        return 0;\n\n    /* Add items to protocol tree specific to Modbus */\n    mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, \""Modbus\"");\n    modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr);\n\n    function_code = tvb_get_guint8(tvb, offset) & 0x7F;\n    proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n""}, {""source"": ""code_info(file:packet-mbtcp.c, lines:1590-1610)"", ""result"": ""                request_data = (modbus_request_info_t *)wmem_list_frame_data(frame);\n                req_frame_num = request_data->fnum;\n                req_function_code = request_data->function_code;\n                if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) {\n                    pkt_info->reg_base = request_data->base_address;\n                    pkt_info->num_reg = request_data->num_reg;\n                    pkt_info->request_found = TRUE;\n                    pkt_info->req_frame_num = req_frame_num;\n                }\n                frame = wmem_list_frame_next(frame);\n            }\n\n\n        }\n        p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info);\n\n    }\n    else { /* !visited */\n        pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0);\n    }\n\n\n""}, {""source"": ""func_info(file:proto_data.c, func:p_add_proto_data)"", ""result"": [{""code"": ""void\np_add_proto_data(wmem_allocator_t *tmp_scope, struct _packet_info* pinfo, int proto, guint32 key, void *proto_data)\n{\n  proto_data_t     *p1;\n  GSList          **proto_list;\n  wmem_allocator_t *scope;\n\n  if (tmp_scope == pinfo->pool) {\n    scope = tmp_scope;\n    proto_list = &pinfo->proto_data;\n  } else if (tmp_scope == wmem_file_scope()) {\n    scope = wmem_file_scope();\n    proto_list = &pinfo->fd->pfd;\n  } else {\n    DISSECTOR_ASSERT(!\""invalid wmem scope\"");\n  }\n\n  p1 = (proto_data_t *)wmem_alloc(scope, sizeof(proto_data_t));\n\n  p1->proto = proto;\n  p1->key = key;\n  p1->proto_data = proto_data;\n\n  /* Add it to the GSLIST */\n  *proto_list = g_slist_prepend(*proto_list, p1);\n}"", ""start_line"": 70, ""end_line"": 95, ""full_name"": ""p_add_proto_data"", ""file_path"": ""epan/proto_data.c""}]}, {""source"": ""func_info(file:proto_data.c, func:p_get_proto_data)"", ""result"": [{""code"": ""void *\np_get_proto_data(wmem_allocator_t *scope, struct _packet_info* pinfo, int proto, guint32 key)\n{\n  proto_data_t  temp, *p1;\n  GSList       *item;\n\n  temp.proto = proto;\n  temp.key = key;\n  temp.proto_data = NULL;\n\n  if (scope == pinfo->pool) {\n    item = g_slist_find_custom(pinfo->proto_data, &temp, p_compare);\n  } else if (scope == wmem_file_scope()) {\n    item = g_slist_find_custom(pinfo->fd->pfd, &temp, p_compare);\n  } else {\n    DISSECTOR_ASSERT(!\""invalid wmem scope\"");\n  }\n\n  if (item) {\n    p1 = (proto_data_t *)item->data;\n    return p1->proto_data;\n  }\n\n  return NULL;\n}"", ""start_line"": 97, ""end_line"": 121, ""full_name"": ""p_get_proto_data"", ""file_path"": ""epan/proto_data.c""}]}, {""source"": ""func_info(file:proto_data.c, func:p_compare)"", ""result"": [{""code"": ""static gint\np_compare(gconstpointer a, gconstpointer b)\n{\n  const proto_data_t *ap = (const proto_data_t *)a;\n  const proto_data_t *bp = (const proto_data_t *)b;\n\n  if (ap -> proto > bp -> proto) {\n    return 1;\n  } else if (ap -> proto == bp -> proto) {\n    if (ap->key > bp->key){\n      return 1;\n    } else if (ap -> key == bp -> key) {\n      return 0;\n    }\n    return -1;\n  } else {\n    return -1;\n  }\n}"", ""start_line"": 50, ""end_line"": 68, ""full_name"": ""p_compare<duplicate>1"", ""file_path"": ""epan/proto_data.c""}]}]","The segmentation fault is triggered by a null `pkt_info` during the second pass of `dissect_modbus` (packet-mbtcp.c:1573-1574). The initial allocation of `pkt_info` occurs via `wmem_new0` (line 1558) during the first pass and is stored using `p_add_proto_data` (line 1608). On the second pass, `pkt_info` is retrieved via `p_get_proto_data` (line 1608), which returns null. The `p_get_proto_data` function (proto_data.c:97-121) searches for the `proto_data` entry in `pinfo->fd->pfd` using `g_slist_find_custom` with `p_compare` (proto_data.c:50-68). The `p_compare` function correctly matches `proto` and `key`, but the entry is not found, leading to a null return. The root cause is that the `proto_data` entry added during the first pass is not present in the `pinfo->fd->pfd` list during the second pass, likely due to incorrect scope or key mismatch. The patch (packet-mbtcp.c:1575-1577) prevents out-of-bounds reads but does not address the null `pkt_info` issue.",0.95,./github/other_context/CVE-2017-13764
49,CVE-2017-15056,CWE-476,c_cpp,"p_lx_elf.cpp in UPX 3.94 mishandles ELF headers, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by an Invalid Pointer Read in PackLinuxElf64::unpack().",https://github.com/upx/upx/commit/ef336dbcc6dc8344482f8cf6c909ae96c3286317,Protect against bad crafted input.\n\nhttps://github.com/upx/upx/issues/128\n	modified:   p_lx_elf.cpp,4,"[{""func_name"": ""PackLinuxElf64::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 1024\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;\n    Elf64_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te64(&phdr->p_offset);\n                unsigned const dyn_len = get_te64(&phdr->p_filesz);\n                Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf64::PackLinuxElf64help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    e_phoff = get_te64(&ehdri.e_phoff);\n    e_shoff = get_te64(&ehdri.e_shoff);\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te64(&sec_dynsym->sh_link) + shdri;\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(get_te64(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 512\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Peek at resulting Ehdr and Phdrs for use in controlling unpacking.\n    // Uncompress an extra time, and don't verify or update checksums.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te32(&phdr->p_offset);\n                unsigned const dyn_len = get_te32(&phdr->p_filesz);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::PackLinuxElf32help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    e_phoff = get_te32(&ehdri.e_phoff);\n    e_shoff = get_te32(&ehdri.e_shoff);\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}"", ""target"": 0}]","[{""func_name"": ""PackLinuxElf64::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 1024\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;\n    Elf64_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te64(&phdr->p_offset);\n                unsigned const dyn_len = get_te64(&phdr->p_filesz);\n                Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}""}, {""func_name"": ""PackLinuxElf64::PackLinuxElf64help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te64(&ehdri.e_phoff);\n    if ((unsigned long)file_size < (e_phoff + e_phnum * sizeof(Elf64_Phdr))) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te64(&ehdri.e_shoff);\n    if ((unsigned long)file_size < (e_shoff + e_shnum * sizeof(Elf64_Shdr))) {\n        throwCantUnpack(\""bad e_shoff\"");\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te64(&sec_dynsym->sh_link) + shdri;\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(get_te64(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}""}, {""func_name"": ""PackLinuxElf32::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 512\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Peek at resulting Ehdr and Phdrs for use in controlling unpacking.\n    // Uncompress an extra time, and don't verify or update checksums.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te32(&phdr->p_offset);\n                unsigned const dyn_len = get_te32(&phdr->p_filesz);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}""}, {""func_name"": ""PackLinuxElf32::PackLinuxElf32help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    if ((unsigned long)file_size < ((unsigned long)e_phoff + e_phnum * sizeof(Elf32_Phdr))) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    if ((unsigned long)file_size < ((unsigned long)e_shoff + e_shnum * sizeof(Elf32_Shdr))) {\n        throwCantUnpack(\""bad e_shoff\"");\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}""}]","{""code"": 7, ""value"": 10, ""function"": 2}","[{""source"": ""code_info(file:p_lx_elf.cpp, lines:100-200)"", ""result"": ""static unsigned\nfunpad4(InputFile *fi)\n{\n    unsigned d = 3u & (0 - fi->tell());\n    if (d)\n        fi->seek(d, SEEK_CUR);\n    return d;\n}\n\nstatic void alloc_file_image(MemBuffer &mb, off_t size)\n{\n    assert(mem_size_valid_bytes(size));\n    if (mb.getVoidPtr() == NULL) {\n        mb.alloc(size);\n    } else {\n        assert(size <= (off_t) mb.getSize());\n    }\n}\n\nint\nPackLinuxElf32::checkEhdr(Elf32_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf32_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf32_Ehdr::EI_DATA] !=ei_data\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf32_Ehdr::ET_EXEC && type != Elf32_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf32_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf32_Phdr))\n        return 6;\n\n    if (type == Elf32_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        unsigned const entry = get_te32(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nint\nPackLinuxElf64::checkEhdr(Elf64_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n    unsigned char osabi0 = buf[Elf32_Ehdr::EI_OSABI];\n    if (0==osabi0) {\n        osabi0 = opt->o_unix.osabi0;\n    }\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf64_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf64_Ehdr::EI_DATA] !=ei_data\n    ||                     osabi0!=ei_osabi\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf64_Ehdr::ET_EXEC && type != Elf64_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf64_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf64_Phdr))\n        return 6;\n\n    if (type == Elf64_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        upx_uint64_t const entry = get_te64(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:200-300)"", ""result"": ""            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nPackLinuxElf::PackLinuxElf(InputFile *f)\n    : super(f), e_phnum(0), dynstr(NULL),\n    sz_phdrs(0), sz_elf_hdrs(0), sz_pack2(0), sz_pack2a(0),\n    lg2_page(12), page_size(1u<<lg2_page), is_big(0), is_pie(0),\n    xct_off(0), xct_va(0), jni_onload_va(0),\n    e_machine(0), ei_class(0), ei_data(0), ei_osabi(0), osabi_note(NULL),\n    o_elf_shnum(0)\n{\n}\n\nPackLinuxElf::~PackLinuxElf()\n{\n}\n\nvoid\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    e_phoff = get_te32(&ehdri.e_phoff);\n    e_shoff = get_te32(&ehdri.e_shoff);\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n\nvoid PackLinuxElf::pack3(OutputFile *fo, Filter &ft)\n{\n    unsigned disp;\n    unsigned const zero = 0;\n    unsigned len = sz_pack2a;  // after headers and all PT_LOAD\n\n    unsigned const t = (4 & len) ^ ((!!xct_off)<<2);  // 0 or 4\n    fo->write(&zero, t);\n    len += t;\n\n    set_te32(&disp, 2*sizeof(disp) + len - (sz_elf_hdrs + sizeof(p_info) + sizeof(l_info)));\n    fo->write(&disp, sizeof(disp));  // .e_entry - &first_b_info\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phoff)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phoff"", ""line"": 248, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phoff"", ""line"": 664, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phnum)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phnum"", ""line"": 234, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 371, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 463, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 650, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 2986, ""func_name"": ""PackLinuxElf32.ARM_is_QNX:int(void)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:50-100)"", ""result"": ""#define PT_GNU_STACK64  Elf64_Phdr::PT_GNU_STACK\n\n//static unsigned const EF_ARM_HASENTRY = 0x02;\nstatic unsigned const EF_ARM_EABI_VER4 = 0x04000000;\nstatic unsigned const EF_ARM_EABI_VER5 = 0x05000000;\n\nunsigned char PackLinuxElf::o_shstrtab[] = {  \\\n/*start*/       '\\0',\n/*offset  1*/   '.','n','o','t','e','.','g','n','u','.','b','u','i','l','d','-','i','d','\\0',\n/*offset 20*/   '.','s','h','s','t','r','t','a','b','\\0'\n};\n\nstatic unsigned\numin(unsigned a, unsigned b)\n{\n    return (a < b) ? a : b;\n}\n\nstatic upx_uint64_t\numin64(upx_uint64_t a, upx_uint64_t b)\n{\n    return (a < b) ? a : b;\n}\n\nstatic unsigned\nup4(unsigned x)\n{\n    return ~3u & (3+ x);\n}\n\nstatic unsigned\nfpad4(OutputFile *fo)\n{\n    unsigned len = fo->st_size();\n    unsigned d = 3u & (0 - len);\n    unsigned zero = 0;\n    fo->write(&zero, d);\n    return d + len;\n}\n\nstatic unsigned\nfpad8(OutputFile *fo)\n{\n    unsigned len = fo->st_size();\n    unsigned d = 7u & (0 - len);\n    upx_uint64_t zero = 0;\n    fo->write(&zero, d);\n    return d + len;\n}\n\nstatic unsigned\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:0-50)"", ""result"": ""/* p_lx_elf.cpp --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2017 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2017 Laszlo Molnar\n   Copyright (C) 2000-2017 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \""conf.h\""\n\n#include \""file.h\""\n#include \""filter.h\""\n#include \""linker.h\""\n#include \""packer.h\""\n#include \""p_elf.h\""\n#include \""p_unix.h\""\n#include \""p_lx_exc.h\""\n#include \""p_lx_elf.h\""\n#include \""ui.h\""\n\n#define PT_LOAD32   Elf32_Phdr::PT_LOAD\n#define PT_LOAD64   Elf64_Phdr::PT_LOAD\n#define PT_NOTE32   Elf32_Phdr::PT_NOTE\n#define PT_NOTE64   Elf64_Phdr::PT_NOTE\n#define PT_GNU_STACK32  Elf32_Phdr::PT_GNU_STACK\n#define PT_GNU_STACK64  Elf64_Phdr::PT_GNU_STACK\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phoff)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phoff"", ""line"": 248, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phoff"", ""line"": 664, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phnum)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phnum"", ""line"": 234, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 371, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 463, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 650, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 2986, ""func_name"": ""PackLinuxElf32.ARM_is_QNX:int(void)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:0-50)"", ""result"": ""/* p_lx_elf.cpp --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2017 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2017 Laszlo Molnar\n   Copyright (C) 2000-2017 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \""conf.h\""\n\n#include \""file.h\""\n#include \""filter.h\""\n#include \""linker.h\""\n#include \""packer.h\""\n#include \""p_elf.h\""\n#include \""p_unix.h\""\n#include \""p_lx_exc.h\""\n#include \""p_lx_elf.h\""\n#include \""ui.h\""\n\n#define PT_LOAD32   Elf32_Phdr::PT_LOAD\n#define PT_LOAD64   Elf64_Phdr::PT_LOAD\n#define PT_NOTE32   Elf32_Phdr::PT_NOTE\n#define PT_NOTE64   Elf64_Phdr::PT_NOTE\n#define PT_GNU_STACK32  Elf32_Phdr::PT_GNU_STACK\n#define PT_GNU_STACK64  Elf64_Phdr::PT_GNU_STACK\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:300-400)"", ""result"": ""    fo->write(&disp, sizeof(disp));  // .e_entry - &first_b_info\n    len += sizeof(disp);\n    set_te32(&disp, len);  // distance back to beginning (detect dynamic reloc)\n    fo->write(&disp, sizeof(disp));\n    len += sizeof(disp);\n\n    if (xct_off) {  // is_shlib\n        upx_uint64_t const firstpc_va = (jni_onload_va\n            ? jni_onload_va\n            : elf_unsigned_dynamic(Elf32_Dyn::DT_INIT) );\n        set_te32(&disp, firstpc_va - load_va);\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n\n        set_te32(&disp, hatch_off);\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n\n        set_te32(&disp, xct_off);\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n    }\n    sz_pack2 = len;  // 0 mod 8\n\n    super::pack3(fo, ft);  // append the decompressor\n    set_te16(&linfo.l_lsize, up4(  // MATCH03: up4\n    get_te16(&linfo.l_lsize) + len - sz_pack2a));\n\n    len = fpad4(fo);  // MATCH03\n    ACC_UNUSED(len);\n}\n\nvoid PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)\n{\n    super::pack3(fo, ft);  // loader follows compressed PT_LOADs\n    // Then compressed gaps (including debuginfo.)\n    unsigned total_in = 0, total_out = 0;\n    for (unsigned k = 0; k < e_phnum; ++k) {\n        Extent x;\n        x.size = find_LOAD_gap(phdri, k, e_phnum);\n        if (x.size) {\n            x.offset = get_te32(&phdri[k].p_offset) +\n                       get_te32(&phdri[k].p_filesz);\n            packExtent(x, total_in, total_out, 0, fo);\n        }\n    }\n    // write block end marker (uncompressed size 0)\n    b_info hdr; memset(&hdr, 0, sizeof(hdr));\n    set_le32(&hdr.sz_cpr, UPX_MAGIC_LE32);\n    fo->write(&hdr, sizeof(hdr));\n    fpad4(fo);\n\n    set_te32(&elfout.phdr[0].p_filesz, sz_pack2 + lsize);\n    set_te32(&elfout.phdr[0].p_memsz,  sz_pack2 + lsize);\n    if (0!=xct_off) {  // shared library\n        Elf32_Phdr *phdr = phdri;\n        unsigned off = fo->st_size();\n        unsigned off_init = 0;  // where in file\n        unsigned va_init = sz_pack2;   // virtual address\n        so_slide = 0;\n        for (int j = e_phnum; --j>=0; ++phdr) {\n            unsigned const len  = get_te32(&phdr->p_filesz);\n            unsigned const ioff = get_te32(&phdr->p_offset);\n            unsigned const type = get_te32(&phdr->p_type);\n            if (phdr->PT_INTERP==type) {\n                // Rotate to highest position, so it can be lopped\n                // by decrementing e_phnum.\n                memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));\n                memmove(phdr, 1+phdr, j * sizeof(*phdr));  // overlapping\n                memcpy(&phdr[j], (unsigned char *)ibuf, sizeof(*phdr));\n                --phdr;\n                set_te16(&ehdri.e_phnum, --e_phnum);\n                continue;\n            }\n            if (phdr->PT_LOAD32==type) {\n                if (xct_off < ioff) {  // Slide up non-first PT_LOAD.\n                    fi->seek(ioff, SEEK_SET);\n                    fi->readx(ibuf, len);\n                    off += ~page_mask & (ioff - off);\n                    fo->seek(off, SEEK_SET);\n                    fo->write(ibuf, len);\n                    so_slide = off - ioff;\n                    set_te32(&phdr->p_offset, so_slide + ioff);\n                }\n                else {  // Change length of first PT_LOAD.\n                    va_init += get_te32(&phdr->p_vaddr);\n                    set_te32(&phdr->p_filesz, sz_pack2 + lsize);\n                    set_te32(&phdr->p_memsz,  sz_pack2 + lsize);\n                }\n                continue;  // all done with this PT_LOAD\n            }\n            // Compute new offset of &DT_INIT.d_val.\n            if (/*0==jni_onload_sym &&*/ phdr->PT_DYNAMIC==type) {\n                off_init = so_slide + ioff;\n                fi->seek(ioff, SEEK_SET);\n                fi->read(ibuf, len);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)(void *)ibuf;\n                for (int j2 = len; j2 > 0; ++dyn, j2 -= sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        unsigned const t = (unsigned char *)&dyn->d_val -\n                                           (unsigned char *)ibuf;\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:100-200)"", ""result"": ""static unsigned\nfunpad4(InputFile *fi)\n{\n    unsigned d = 3u & (0 - fi->tell());\n    if (d)\n        fi->seek(d, SEEK_CUR);\n    return d;\n}\n\nstatic void alloc_file_image(MemBuffer &mb, off_t size)\n{\n    assert(mem_size_valid_bytes(size));\n    if (mb.getVoidPtr() == NULL) {\n        mb.alloc(size);\n    } else {\n        assert(size <= (off_t) mb.getSize());\n    }\n}\n\nint\nPackLinuxElf32::checkEhdr(Elf32_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf32_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf32_Ehdr::EI_DATA] !=ei_data\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf32_Ehdr::ET_EXEC && type != Elf32_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf32_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf32_Phdr))\n        return 6;\n\n    if (type == Elf32_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        unsigned const entry = get_te32(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nint\nPackLinuxElf64::checkEhdr(Elf64_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n    unsigned char osabi0 = buf[Elf32_Ehdr::EI_OSABI];\n    if (0==osabi0) {\n        osabi0 = opt->o_unix.osabi0;\n    }\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf64_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf64_Ehdr::EI_DATA] !=ei_data\n    ||                     osabi0!=ei_osabi\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf64_Ehdr::ET_EXEC && type != Elf64_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf64_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf64_Phdr))\n        return 6;\n\n    if (type == Elf64_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        upx_uint64_t const entry = get_te64(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:p_lx_elf.cpp, func:PackLinuxElf32)"", ""result"": [{""code"": ""PackLinuxElf32::PackLinuxElf32(InputFile *f)\n    : super(f), phdri(NULL) , shdri(NULL), gnu_stack(NULL), note_body(NULL),\n    page_mask(~0u<<lg2_page),\n    dynseg(NULL), hashtab(NULL), gashtab(NULL), dynsym(NULL),\n    jni_onload_sym(NULL),\n    shstrtab(NULL),\n    sec_strndx(NULL), sec_dynsym(NULL), sec_dynstr(NULL)\n{\n    memset(&ehdri, 0, sizeof(ehdri));\n    if (f) {\n        f->seek(0, SEEK_SET);\n        f->readx(&ehdri, sizeof(ehdri));\n    }\n}"", ""start_line"": 605, ""end_line"": 618, ""full_name"": ""PackLinuxElf32.PackLinuxElf32:ANY(InputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""func_info(file:p_lx_elf.cpp, func:PackLinuxElf64)"", ""result"": [{""code"": ""PackLinuxElf64::PackLinuxElf64(InputFile *f)\n    : super(f), phdri(NULL), shdri(NULL), gnu_stack(NULL), note_body(NULL),\n    page_mask(~0ull<<lg2_page),\n    dynseg(NULL), hashtab(NULL), gashtab(NULL), dynsym(NULL),\n    jni_onload_sym(NULL),\n    shstrtab(NULL),\n    sec_strndx(NULL), sec_dynsym(NULL), sec_dynstr(NULL)\n{\n    memset(&ehdri, 0, sizeof(ehdri));\n    if (f) {\n        f->seek(0, SEEK_SET);\n        f->readx(&ehdri, sizeof(ehdri));\n    }\n}"", ""start_line"": 625, ""end_line"": 638, ""full_name"": ""PackLinuxElf64.PackLinuxElf64:ANY(InputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}]","1. **Trigger**: A crafted ELF file provides invalid `e_phoff` or `e_phnum` in its ELF header (p_lx_elf.cpp:605-618 for 32-bit, p_lx_elf.cpp:625-638 for 64-bit). These values are read into `ehdri` via `f->readx(&ehdri, sizeof(ehdri))`.\n2. **Propagation**: `ehdri.e_phoff` and `ehdri.e_phnum` are accessed in `PackLinuxElf32help1` (p_lx_elf.cpp:234, 248) and `PackLinuxElf64help1` (p_lx_elf.cpp:650, 664) without sufficient bounds checks.\n3. **Validation Gap**: While `checkEhdr` validates `e_phnum >= 1` (p_lx_elf.cpp:100-200), it does not verify `e_phoff` validity or ensure program headers fit within the file size.\n4. **Impact**: Unvalidated `e_phoff`/`e_phnum` leads to out-of-bounds memory access in `PackLinuxElf64::unpack()` (e.g., reading program headers beyond the file's size), causing an invalid pointer read and potential crash.",0.95,./github/other_context/CVE-2017-15056
50,CVE-2017-17479,"CWE-787, CWE-476",c_cpp,"In OpenJPEG 2.3.0, a stack-based buffer overflow was discovered in the pgxtoimage function in jpwl/convert.c. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.",https://github.com/uclouvain/openjpeg/commit/0bc90e4062a5f9258c91eca018c019b179066c62,jp3d/jpwl convert: fix write stack buffer overflow\n\nMissing buffer length formatter in fscanf call might lead to write\nstack buffer overflow.\n\nfixes #1044 (CVE-2017-17480),3,"[{""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jpwl/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\"", temp, &endian1, &endian2,\n               signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}"", ""target"": 0}, {""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jp3d/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\"", temp, &endian1, &endian2,\n               signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}"", ""target"": 0}, {""func_name"": ""imagetopnm"", ""file_path"": ""src/bin/jp2/convert.c"", ""func_code"": ""int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \""%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\""\n                \""\\n\\t: refused.\\n\"", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \""wb\"");\n\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \""RGB_ALPHA\"" : \""GRAYSCALE_ALPHA\"");\n\n            fprintf(fdest, \""P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\""\n                    \""MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\"", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \""P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \""%c\"", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \""WARNING -> [PGM file] Only the first component\\n\"");\n        fprintf(stderr, \""           is written to the file\\n\"");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \""imagetopnm: memory out\\n\"");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \""%d.%s\"", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \""_%u.pgm\"", compno);\n        } else {\n            sprintf(destname, \""%s\"", outfile);\n        }\n\n        fdest = fopen(destname, \""wb\"");\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \""P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jpwl/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\"", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}""}, {""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jp3d/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\"", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}""}, {""func_name"": ""imagetopnm"", ""file_path"": ""src/bin/jp2/convert.c"", ""func_code"": ""int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \""%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\""\n                \""\\n\\t: refused.\\n\"", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \""wb\"");\n\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \""RGB_ALPHA\"" : \""GRAYSCALE_ALPHA\"");\n\n            fprintf(fdest, \""P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\""\n                    \""MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\"", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \""P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \""%c\"", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \""WARNING -> [PGM file] Only the first component\\n\"");\n        fprintf(stderr, \""           is written to the file\\n\"");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \""imagetopnm: memory out\\n\"");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \""%d.%s\"", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \""_%u.pgm\"", compno);\n        } else {\n            sprintf(destname, \""%s\"", outfile);\n        }\n\n        fdest = fopen(destname, \""wb\"");\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \""P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        if (!red) {\n            fclose(fdest);\n            continue;\n        }\n\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}""}]","{""value"": 2}","[{""source"": ""value_info(file:convert.c, value:temp)"", ""result"": {""value_trace"": [{""full_code"": ""temp[32]"", ""line"": 1334, ""func_name"": ""pgxtoimage<duplicate>0""}, {""full_code"": ""temp = (unsigned char)(curr >> 8)"", ""line"": 3118, ""func_name"": ""imagetoraw<duplicate>0""}, {""full_code"": ""temp = (unsigned char) curr"", ""line"": 3124, ""func_name"": ""imagetoraw<duplicate>0""}, {""full_code"": ""temp = (unsigned char)(curr >> 8)"", ""line"": 3141, ""func_name"": ""imagetoraw<duplicate>0""}, {""full_code"": ""temp = (unsigned char) curr"", ""line"": 3147, ""func_name"": ""imagetoraw<duplicate>0""}], ""struct_var"": ""temp"", ""struct_type"": ""char[32]"", ""struct_definition"": null}}, {""source"": ""value_info(file:convert.c, value:temp)"", ""result"": {""value_trace"": [{""full_code"": ""temp[32]"", ""line"": 174, ""func_name"": ""pgxtovolume""}], ""struct_var"": ""temp"", ""struct_type"": ""char[32]"", ""struct_definition"": null}}]","In src/bin/jpwl/convert.c:298 and src/bin/jp3d/convert.c:298, the fscanf format string uses %[\\t] without a length modifier to read into 'temp' (char[32]). This allows input exceeding 32 bytes to overflow the stack buffer. The patch adds %31[\\t] to restrict input length.",0.95,./github/other_context/CVE-2017-17479
51,CVE-2017-17439,CWE-476,c_cpp,"In Heimdal through 7.4, remote unauthenticated attackers are able to crash the KDC by sending a crafted UDP packet containing empty data fields for client name or realm. The parser would unconditionally dereference NULL pointers in that case, leading to a segmentation fault. This is related to the _kdc_as_rep function in kdc/kerberos5.c and the der_length_visible_string function in lib/asn1/der_length.c.",https://github.com/heimdal/heimdal/commit/1a6a6e462dc2ac6111f9e02c6852ddec4849b887,Security: Avoid NULL structure pointer member dereference\n\nThis can happen in the error path when processing malformed AS\nrequests with a NULL client name.  Bug originally introduced on\nFri Feb 13 09:26:01 2015 +0100 in commit:\n\n    a873e21d7c06f22943a90a41dc733ae76799390d\n\n    kdc: base _kdc_fast_mk_error() on krb5_mk_error_ext()\n\nOriginal patch by Jeffrey Altman <jaltman@secure-endpoints.com>,1,"[{""func_name"": ""_kdc_as_rep"", ""file_path"": ""kdc/kerberos5.c"", ""func_code"": ""krb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""FAST unwrap request from %s failed: %d\"", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No server in request\"");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed server name from %s\"", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No client in request\"");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed client name from %s\"", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \""AS-REQ %s from %s for %s\"",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \""Anonymous ticket w/o anonymous flag\"");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\""Request for a anonymous ticket with non \""\n\t\t\""anonymous client name: %s\"", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""client %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \""WRONG_REALM - %s -> %s\"",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""target %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""Client (%s) from %s has no common enctypes with KDC \""\n\t\t\""to use for the session key\"",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \""Looking for %s pa-data -- %s\"", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\""%s pre-authentication succeeded -- %s\"",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\"");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \""Doesn't have a client key available\"");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \""Bad KDC options\"");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \""Ticket may not be forwardable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \""Ticket may not be proxiable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \""Ticket may not be postdate\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \""Bad address list in requested\"");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \""Client have no reply key\"");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \""AS-REQ\"", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \""add_enc_pa_rep failed: %s: %d\"", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \""Reply packet too large\"");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""_kdc_as_rep"", ""file_path"": ""kdc/kerberos5.c"", ""func_code"": ""krb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""FAST unwrap request from %s failed: %d\"", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No server in request\"");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed server name from %s\"", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No client in request\"");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed client name from %s\"", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \""AS-REQ %s from %s for %s\"",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \""Anonymous ticket w/o anonymous flag\"");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\""Request for a anonymous ticket with non \""\n\t\t\""anonymous client name: %s\"", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""client %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \""WRONG_REALM - %s -> %s\"",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""target %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""Client (%s) from %s has no common enctypes with KDC \""\n\t\t\""to use for the session key\"",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \""Looking for %s pa-data -- %s\"", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\""%s pre-authentication succeeded -- %s\"",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\"");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \""Doesn't have a client key available\"");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \""Bad KDC options\"");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \""Ticket may not be forwardable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \""Ticket may not be proxiable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \""Ticket may not be postdate\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \""Bad address list in requested\"");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \""Client have no reply key\"");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \""AS-REQ\"", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \""add_enc_pa_rep failed: %s: %d\"", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \""Reply packet too large\"");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->name : NULL,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->realm : NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}""}]","{""code"": 8, ""value"": 8, ""function"": 1}","[{""source"": ""code_info(file:kerberos5.c, lines:145-155)"", ""result"": ""    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:2200-2260)"", ""result"": ""\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \""add_enc_pa_rep failed: %s: %d\"", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \""Reply packet too large\"");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n""}, {""source"": ""func_info(file:der_length.c, func:der_length_visible_string)"", ""result"": [{""code"": ""size_t\nder_length_visible_string (const heim_visible_string *data)\n{\n    return strlen(*data);\n}"", ""start_line"": 242, ""end_line"": 246, ""full_name"": ""der_length_visible_string"", ""file_path"": ""lib/asn1/der_length.c""}]}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:100-220)"", ""result"": ""}\n\n\n/*\n * Detect if `key' is the using the the precomputed `default_salt'.\n */\n\nstatic krb5_boolean\nis_default_salt_p(const krb5_salt *default_salt, const Key *key)\n{\n    if (key->salt == NULL)\n\treturn TRUE;\n    if (default_salt->salttype != key->salt->type)\n\treturn FALSE;\n    if (krb5_data_cmp(&default_salt->saltvalue, &key->salt->salt))\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n * return the first appropriate key of `princ' in `ret_key'.  Look for\n * all the etypes in (`etypes', `len'), stopping as soon as we find\n * one, but preferring one that has default salt.\n */\n\nkrb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1000-1200)"", ""result"": ""    case ETYPE_DES_CBC_MD5:\n    case ETYPE_DES3_CBC_SHA1:\n    case ETYPE_ARCFOUR_HMAC_MD5:\n    case ETYPE_ARCFOUR_HMAC_MD5_56:\n    /*\n     * The following three is \""old\"" windows enctypes and is needed for\n     * windows 2000 hosts.\n     */\n    case ETYPE_ARCFOUR_MD4:\n    case ETYPE_ARCFOUR_HMAC_OLD:\n    case ETYPE_ARCFOUR_HMAC_OLD_EXP:\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nmake_etype_info_entry(krb5_context context, ETYPE_INFO_ENTRY *ent, Key *key)\n{\n    ent->etype = key->key.keytype;\n    if(key->salt){\n#if 0\n\tALLOC(ent->salttype);\n\n\tif(key->salt->type == hdb_pw_salt)\n\t    *ent->salttype = 0; /* or 1? or NULL? */\n\telse if(key->salt->type == hdb_afs3_salt)\n\t    *ent->salttype = 2;\n\telse {\n\t    kdc_log(context, config, 0, \""unknown salt-type: %d\"",\n\t\t    key->salt->type);\n\t    return KRB5KRB_ERR_GENERIC;\n\t}\n\t/* according to `the specs', we can't send a salt if\n\t   we have AFS3 salted key, but that requires that you\n\t   *know* what cell you are using (e.g by assuming\n\t   that the cell is the same as the realm in lower\n\t   case) */\n#elif 0\n\tALLOC(ent->salttype);\n\t*ent->salttype = key->salt->type;\n#else\n\t/*\n\t * We shouldn't sent salttype since it is incompatible with the\n\t * specification and it breaks windows clients.  The afs\n\t * salting problem is solved by using KRB5-PADATA-AFS3-SALT\n\t * implemented in Heimdal 0.7 and later.\n\t */\n\tent->salttype = NULL;\n#endif\n\tkrb5_copy_data(context, &key->salt->salt,\n\t\t       &ent->salt);\n    } else {\n\t/* we return no salt type at all, as that should indicate\n\t * the default salt type and make everybody happy.  some\n\t * systems (like w2k) dislike being told the salt type\n\t * here. */\n\n\tent->salttype = NULL;\n\tent->salt = NULL;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\nget_pa_etype_info(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO pa;\n    unsigned char *buf;\n    size_t len;\n\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info_entry(context, &pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}\n\n/*\n *\n */\n\nextern int _krb5_AES_SHA1_string_to_default_iterator;\nextern int _krb5_AES_SHA2_string_to_default_iterator;\n\nstatic krb5_error_code\nmake_s2kparams(int value, size_t len, krb5_data **ps2kparams)\n{\n    krb5_data *s2kparams;\n    krb5_error_code ret;\n\n    ALLOC(s2kparams);\n    if (s2kparams == NULL)\n\treturn ENOMEM;\n    ret = krb5_data_alloc(s2kparams, len);\n    if (ret) {\n\tfree(s2kparams);\n\treturn ret;\n    }\n    _krb5_put_int(s2kparams->data, value, len);\n    *ps2kparams = s2kparams;\n    return 0;\n}\n\nstatic krb5_error_code\nmake_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)\n{\n    krb5_error_code ret;\n\n    ent->etype = key->key.keytype;\n    if(key->salt) {\n\tALLOC(ent->salt);\n\tif (ent->salt == NULL)\n\t    return ENOMEM;\n\t*ent->salt = malloc(key->salt->salt.length + 1);\n\tif (*ent->salt == NULL) {\n\t    free(ent->salt);\n\t    ent->salt = NULL;\n\t    return ENOMEM;\n\t}\n\tmemcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);\n\t(*ent->salt)[key->salt->salt.length] = '\\0';\n    } else\n\tent->salt = NULL;\n\n    ent->s2kparams = NULL;\n\n    switch (key->key.keytype) {\n    case ETYPE_AES128_CTS_HMAC_SHA1_96:\n    case ETYPE_AES256_CTS_HMAC_SHA1_96:\n\tret = make_s2kparams(_krb5_AES_SHA1_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case KRB5_ENCTYPE_AES128_CTS_HMAC_SHA256_128:\n    case KRB5_ENCTYPE_AES256_CTS_HMAC_SHA384_192:\n\tret = make_s2kparams(_krb5_AES_SHA2_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n\t/* Check if this was a AFS3 salted key */\n\tif(key->salt && key->salt->type == hdb_afs3_salt)\n\t    ret = make_s2kparams(1, 1, &ent->s2kparams);\n\telse\n\t    ret = 0;\n\tbreak;\n    default:\n\tret = 0;\n\tbreak;\n    }\n    return ret;\n}\n\n/*\n * Return an ETYPE-INFO2. Enctypes are storted the same way as in the\n * database (client supported enctypes first, then the unsupported\n * enctypes).\n */\n\nstatic krb5_error_code\nget_pa_etype_info2(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO2 pa;\n    unsigned char *buf;\n    size_t len;\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1200-1400)"", ""result"": ""    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info2_entry(&pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO2(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO2(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}\n\n/*\n *\n */\n\nstatic void\nlog_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_enctype cetype,\n\t   krb5_enctype setype,\n\t   const KDC_REQ_BODY *b)\n{\n    krb5_error_code ret;\n    struct rk_strpool *p;\n    char *str;\n    size_t i;\n\n    p = rk_strpoolprintf(NULL, \""%s\"", \""Client supported enctypes: \"");\n\n    for (i = 0; i < b->etype.len; i++) {\n\tret = krb5_enctype_to_string(context, b->etype.val[i], &str);\n\tif (ret == 0) {\n\t    p = rk_strpoolprintf(p, \""%s\"", str);\n\t    free(str);\n\t} else\n\t    p = rk_strpoolprintf(p, \""%d\"", b->etype.val[i]);\n\tif (p && i + 1 < b->etype.len)\n\t    p = rk_strpoolprintf(p, \"", \"");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \""out of memory\"");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \""no encryption types\"");\n\n    {\n\tchar *cet;\n\tchar *set;\n\n\tret = krb5_enctype_to_string(context, cetype, &cet);\n\tif(ret == 0) {\n\t    ret = krb5_enctype_to_string(context, setype, &set);\n\t    if (ret == 0) {\n\t\tp = rk_strpoolprintf(p, \"", using %s/%s\"", cet, set);\n\t\tfree(set);\n\t    }\n\t    free(cet);\n\t}\n\tif (ret != 0)\n\t    p = rk_strpoolprintf(p, \"", using enctypes %d/%d\"",\n\t\t\t\t cetype, setype);\n    }\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \""%s\"", str);\n    free(str);\n\n    {\n\tchar fixedstr[128];\n\tunparse_flags(KDCOptions2int(b->kdc_options), asn1_KDCOptions_units(),\n\t\t      fixedstr, sizeof(fixedstr));\n\tif(*fixedstr)\n\t    kdc_log(context, config, 0, \""Requested flags: %s\"", fixedstr);\n    }\n}\n\n/*\n * verify the flags on `client' and `server', returning 0\n * if they are OK and generating an error messages and returning\n * and error code otherwise.\n */\n\nkrb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client (%s) is locked out\"", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client (%s) has invalid bit set\"", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \""Principal may not act as client -- %s\"", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Client not yet valid until %s -- %s\"",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Client expired at %s -- %s\"",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client's key must be changed -- %s\"", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Client's key has expired at %s -- %s\"",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client server locked out -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Server has invalid flag set -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \""Principal may not act as server -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \""AS-REQ is required for server -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Server not yet valid until %s -- %s\"",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1400-1600)"", ""result"": ""\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Server expired at %s -- %s\"",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Server's key has expired at -- %s\"",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Return TRUE if `from' is part of `addresses' taking into consideration\n * the configuration variables that tells us how strict we should be about\n * these checks\n */\n\nkrb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}\n\n/*\n *\n */\n\nstatic krb5_boolean\nsend_pac_p(krb5_context context, KDC_REQ *req)\n{\n    krb5_error_code ret;\n    PA_PAC_REQUEST pacreq;\n    const PA_DATA *pa;\n    int i = 0;\n\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PA_PAC_REQUEST);\n    if (pa == NULL)\n\treturn TRUE;\n\n    ret = decode_PA_PAC_REQUEST(pa->padata_value.data,\n\t\t\t\tpa->padata_value.length,\n\t\t\t\t&pacreq,\n\t\t\t\tNULL);\n    if (ret)\n\treturn TRUE;\n    i = pacreq.include_pac;\n    free_PA_PAC_REQUEST(&pacreq);\n    if (i == 0)\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ngenerate_pac(kdc_request_t r, Key *skey)\n{\n    krb5_error_code ret;\n    krb5_pac p = NULL;\n    krb5_data data;\n\n    ret = _kdc_pac_generate(r->context, r->client, &p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""PAC generation failed for -- %s\"",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    if (p == NULL)\n\treturn 0;\n\n    ret = _krb5_pac_sign(r->context, p, r->et.authtime,\n\t\t\t r->client->entry.principal,\n\t\t\t &skey->key, /* Server key */\n\t\t\t &skey->key, /* FIXME: should be krbtgt key */\n\t\t\t &data);\n    krb5_pac_free(r->context, p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""PAC signing failed for -- %s\"",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    \n    ret = _kdc_tkt_add_if_relevant_ad(r->context, &r->et,\n\t\t\t\t      KRB5_AUTHDATA_WIN2K_PAC,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n\n    return ret;\n}\n\n/*\n *\n */\n\nkrb5_boolean\n_kdc_is_anonymous(krb5_context context, krb5_principal principal)\n{\n    if ((principal->name.name_type != KRB5_NT_WELLKNOWN &&\n\t principal->name.name_type != KRB5_NT_UNKNOWN) ||\n\tprincipal->name.name_string.len != 2 ||\n\tstrcmp(principal->name.name_string.val[0], KRB5_WELLKNOWN_NAME) != 0 ||\n\tstrcmp(principal->name.name_string.val[1], KRB5_ANON_NAME) != 0)\n\treturn 0;\n    return 1;\n}\n\nstatic int\nrequire_preauth_p(kdc_request_t r)\n{\n    return r->config->require_preauth\n\t|| r->client->entry.flags.require_preauth\n\t|| r->server->entry.flags.require_preauth;\n}\n\n\n/*\n *\n */\n\nstatic krb5_error_code\nadd_enc_pa_rep(kdc_request_t r)\n{\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    Checksum checksum;\n    krb5_data cdata;\n    size_t len;\n\n    ret = krb5_crypto_init(r->context, &r->reply_key, 0, &crypto);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_create_checksum(r->context, crypto,\n\t\t\t       KRB5_KU_AS_REQ, 0,\n\t\t\t       r->request.data, r->request.length,\n\t\t\t       &checksum);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(Checksum, cdata.data, cdata.length,\n\t\t       &checksum, &len, ret);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n    heim_assert(cdata.length == len, \""ASN.1 internal error\"");\n\n    if (r->ek.encrypted_pa_data == NULL) {\n\tALLOC(r->ek.encrypted_pa_data);\n\tif (r->ek.encrypted_pa_data == NULL)\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1600-1800)"", ""result"": ""\tif (r->ek.encrypted_pa_data == NULL)\n\t    return ENOMEM;\n    }\n    ret = krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t  KRB5_PADATA_REQ_ENC_PA_REP, cdata.data, cdata.length);\n    if (ret)\n\treturn ret;\n    \n    return krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t   KRB5_PADATA_FX_FAST, NULL, 0);\n}\n\n/*\n *\n */\n\nkrb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""FAST unwrap request from %s failed: %d\"", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No server in request\"");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed server name from %s\"", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No client in request\"");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed client name from %s\"", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \""AS-REQ %s from %s for %s\"",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \""Anonymous ticket w/o anonymous flag\"");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\""Request for a anonymous ticket with non \""\n\t\t\""anonymous client name: %s\"", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""client %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \""WRONG_REALM - %s -> %s\"",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""target %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""Client (%s) from %s has no common enctypes with KDC \""\n\t\t\""to use for the session key\"",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1800-2000)"", ""result"": ""\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \""Looking for %s pa-data -- %s\"", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\""%s pre-authentication succeeded -- %s\"",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\"");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \""Doesn't have a client key available\"");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \""Bad KDC options\"");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \""Ticket may not be forwardable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \""Ticket may not be proxiable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \""Ticket may not be postdate\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \""Bad address list in requested\"");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}]","kdc/kerberos5.c:2233-2239: Dereference of `r->client_princ->name` and `r->client_princ->realm` in `_kdc_fast_mk_error()` without NULL check. kdc/kerberos5.c:2260: `r->client_princ` is explicitly set to NULL during error handling. Malformed AS requests with empty client name/realm fields are parsed by `_krb5_principalname2krb5_principal` (unavailable code), which fails and triggers the error path. `der_length_visible_string` (lib/asn1/der_length.c:242-246) returns 0 for empty strings, leading to parsing failure and `r->client_princ` being NULL.",0.95,./github/other_context/CVE-2017-17439
52,CVE-2017-6850,CWE-476,c_cpp,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,https://github.com/jasper-software/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.\nAlso, added some comments marking I/O stream interfaces that probably\nneed to be changed (in the long term) to fix integer overflow problems.",8,"[{""func_name"": ""jp2_cdef_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""jp2_bpcc_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"", ""target"": 1}, {""func_name"": ""jp2_pclr_putdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}"", ""target"": 1}, {""func_name"": ""jp2_pclr_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""jp2_box_put"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""jp2_box_get"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n\t  '\""', boxinfo->name, '\""', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\""warning: cannot handle large 64-bit box length\\n\"");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\""cannot parse box data\\n\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}"", ""target"": 1}, {""func_name"": ""jp2_cmap_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"", ""target"": 1}, {""func_name"": ""jp2_box_create"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}"", ""target"": 0}]","[{""func_name"": ""jp2_cdef_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_bpcc_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_pclr_putdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\t/* Eliminate warning about unused variable. */\n\tbox = 0;\n\tout = 0;\n\treturn -1;\n}""}, {""func_name"": ""jp2_pclr_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\tpclr->bpc = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_box_put"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}""}, {""func_name"": ""jp2_box_get"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jp2_box_create0())) {\n\t\tgoto error;\n\t}\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \""preliminary processing of JP2 box: \""\n\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n\t  '\""', boxinfo->name, '\""', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\""warning: cannot handle large 64-bit box length\\n\"");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\""cannot parse box data\\n\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_cmap_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}""}, {""func_name"": ""jp2_box_create"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:jp2_cod.c, func:jp2_cdef_destroy)"", ""result"": [{""code"": ""static void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}"", ""start_line"": 226, ""end_line"": 233, ""full_name"": ""jp2_cdef_destroy"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c""}]}, {""source"": ""code_info(file:jp2_cod.c, lines:145-155)"", ""result"": ""\t{JP2_BOX_BPCC, \""BPCC\"", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \""COLR\"", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \""PCLR\"", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \""CMAP\"", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \""CDEF\"", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \""RES\"", JP2_BOX_SUPER,\n""}]","In 'jp2_cdef_getdata' (src/libjasper/jp2/jp2_cod.c:463), 'cdef->ents' was not initialized before the patch. If an error occurred during 'jp2_getuint16', 'cdef->ents' remained uninitialized. In 'jp2_cdef_destroy' (src/libjasper/jp2/jp2_cod.c:226-233), an uninitialized 'cdef->ents' could be non-zero, leading to 'jas_free(cdef->ents)' on invalid memory. The patch initializes 'cdef->ents = 0;' to ensure it is zeroed on error, preventing the invalid free.",0.95,./github/other_context/CVE-2017-6850
53,CVE-2017-7452,CWE-476,c_cpp,The iwbmp_read_info_header function in imagew-bmp.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.,https://github.com/jsummers/imageworsener/commit/45000700386baa6fbde03d98dd60cc4049230b82,Fixed a BMP decoding bug (buffer underrun)\n\nFixes issue #8,1,"[{""func_name"": ""iwbmp_read_info_header"", ""file_path"": ""src/imagew-bmp.c"", ""func_code"": ""static int iwbmp_read_info_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[124];\n\tint retval = 0;\n\tsize_t n;\n\n\t// First, read just the \""size\"" field. It tells the size of the header\n\t// structure, and identifies the BMP version.\n\tif(!iwbmp_read(rctx,buf,4)) goto done;\n\trctx->infoheader_size = iw_get_ui32le(&buf[0]);\n\n\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \""Windows BMP v2\"" or \""OS/2 BMP v1\"" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\""Unsupported BMP version\"");\n\t\tgoto done;\n\t}\n\n\tif(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {\n\t\tgoto done;\n\t}\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}"", ""target"": 0}]","[{""func_name"": ""iwbmp_read_info_header"", ""file_path"": ""src/imagew-bmp.c"", ""func_code"": ""static int iwbmp_read_info_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[124];\n\tint retval = 0;\n\tsize_t n;\n\n\t// First, read just the \""size\"" field. It tells the size of the header\n\t// structure, and identifies the BMP version.\n\tif(!iwbmp_read(rctx,buf,4)) goto done;\n\trctx->infoheader_size = iw_get_ui32le(&buf[0]);\n\tif(rctx->infoheader_size<12) goto done;\n\n\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \""Windows BMP v2\"" or \""OS/2 BMP v1\"" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\""Unsupported BMP version\"");\n\t\tgoto done;\n\t}\n\n\tif(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {\n\t\tgoto done;\n\t}\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}""}]","{""code"": 2, ""function"": 5, ""value"": 2}","[{""source"": ""code_info(file:imagew-bmp.c, lines:375-385)"", ""result"": ""\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \""Windows BMP v2\"" or \""OS/2 BMP v1\"" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n""}, {""source"": ""func_info(file:imagew-bmp.c, func:iwbmp_read)"", ""result"": [{""code"": ""static int iwbmp_read(struct iwbmprcontext *rctx,\n\t\tiw_byte *buf, size_t buflen)\n{\n\tint ret;\n\tsize_t bytesread = 0;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\tbuf,buflen,&bytesread);\n\tif(!ret || bytesread!=buflen) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"", ""start_line"": 65, ""end_line"": 77, ""full_name"": ""iwbmp_read"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""value_info(file:imagew-bmp.c, value:rctx->infoheader_size)"", ""result"": {""value_trace"": [{""full_code"": ""rctx->infoheader_size = iw_get_ui32le(&buf[0])"", ""line"": 373, ""func_name"": ""iwbmp_read_info_header""}], ""struct_var"": ""rctx"", ""struct_type"": ""iwbmprcontext*"", ""struct_definition"": ""struct iwbmprcontext {\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\tint bmpversion;\n\tint width, height;\n\tint topdown;\n\tint has_fileheader;\n\tunsigned int bitcount; // bits per pixel\n\tunsigned int compression; // IWBMP_BI_*\n\tint uses_bitfields; // 'compression' is BI_BITFIELDS\n\tint has_alpha_channel;\n\tint bitfields_set;\n\tint need_16bit;\n\tunsigned int palette_entries;\n\tsize_t fileheader_size;\n\tsize_t infoheader_size;\n\tsize_t bitfields_nbytes; // Bytes consumed by BITFIELDs, if not part of the header.\n\tsize_t palette_nbytes;\n\tsize_t bfOffBits;\n\tstruct iw_palette palette;\n\n\t// For 16- & 32-bit images:\n\tunsigned int bf_mask[4];\n\tint bf_high_bit[4];\n\tint bf_low_bit[4];\n\tint bf_bits_count[4]; // number of bits in each channel\n\n\tstruct iw_csdescr csdescr;\n}""}}, {""source"": ""code_info(file:imagew-bmp.c, lines:385-405)"", ""result"": ""\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n""}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v2_header)"", ""result"": [{""code"": ""static int decode_v2_header(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\n\trctx->width = iw_get_ui16le(&buf[4]);\n\trctx->height = iw_get_ui16le(&buf[6]);\n\tnplanes = iw_get_ui16le(&buf[8]);\n\tif(nplanes!=1) return 0;\n\trctx->bitcount = iw_get_ui16le(&buf[10]);\n\tif(rctx->bitcount!=1 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=24)\n\t{\n\t\treturn 0;\n\t}\n\tif(rctx->bitcount<=8) {\n\t\tsize_t palette_start, palette_end;\n\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\n\t\t// Since v2 BMPs have no direct way to indicate that the palette is not\n\t\t// full-sized, assume the palette ends no later than the start of the\n\t\t// bitmap bits.\n\t\tpalette_start = rctx->fileheader_size + rctx->infoheader_size;\n\t\tpalette_end = palette_start + rctx->palette_nbytes;\n\t\tif(rctx->bfOffBits >= palette_start+3 && rctx->bfOffBits < palette_end) {\n\t\t\trctx->palette_entries = (unsigned int)((rctx->bfOffBits - palette_start)/3);\n\t\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\t\t}\n\t}\n\treturn 1;\n}\n"", ""start_line"": 132, ""end_line"": 163, ""full_name"": ""decode_v2_header"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""value_info(file:imagew-bmp.c, value:buf)"", ""result"": {""value_trace"": [{""full_code"": ""buf[1024]"", ""line"": 81, ""func_name"": ""iwbmp_skip_bytes""}, {""full_code"": ""buf[14]"", ""line"": 99, ""func_name"": ""iwbmp_read_file_header""}, {""full_code"": ""buf[124]"", ""line"": 366, ""func_name"": ""iwbmp_read_info_header""}], ""struct_var"": ""buf"", ""struct_type"": ""uint8_t[1024]"", ""struct_definition"": null}}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v3_header_fields)"", ""result"": [{""code"": ""static int decode_v3_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\tint biXPelsPerMeter, biYPelsPerMeter;\n\tunsigned int biClrUsed = 0;\n\t//unsigned int biSizeImage;\n\n\trctx->width = iw_get_i32le(&buf[4]);\n\trctx->height = iw_get_i32le(&buf[8]);\n\tif(rctx->height<0) {\n\t\trctx->height = -rctx->height;\n\t\trctx->topdown = 1;\n\t}\n\n\tnplanes = iw_get_ui16le(&buf[12]);\n\tif(nplanes!=1) return 0;\n\n\trctx->bitcount = iw_get_ui16le(&buf[14]);\n\t// We allow bitcount=2 because it's legal in Windows CE BMPs.\n\tif(rctx->bitcount!=1 && rctx->bitcount!=2 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=16 && rctx->bitcount!=24 &&\n\t\trctx->bitcount!=32)\n\t{\n\t\tiw_set_errorf(rctx->ctx,\""Bad or unsupported bit count (%d)\"",(int)rctx->bitcount);\n\t\treturn 0;\n\t}\n\n\tif(rctx->infoheader_size<=16) {\n\t\tgoto infoheaderdone;\n\t}\n\n\trctx->compression = iw_get_ui32le(&buf[16]);\n\tif(rctx->compression==IWBMP_BI_BITFIELDS) {\n\t\tif(rctx->bitcount==1) {\n\t\t\tiw_set_error(rctx->ctx,\""Huffman 1D compression not supported\"");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(rctx->bitcount!=16 && rctx->bitcount!=32) {\n\t\t\tiw_set_error(rctx->ctx,\""Bad or unsupported image type\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// The compression field is overloaded: BITFIELDS is not a type of\n\t\t// compression. Un-overload it.\n\t\trctx->uses_bitfields = 1;\n\n\t\t// The v4/v5 documentation for the \""BitCount\"" field says that the\n\t\t// BITFIELDS data comes after the header, the same as with v3.\n\t\t// The v4/v5 documentation for the \""Compression\"" field says that the\n\t\t// BITFIELDS data is stored in the \""Mask\"" fields of the header.\n\t\t// Am I supposed to conclude that it is redundantly stored in both\n\t\t// places?\n\t\t// Evidence and common sense suggests the \""BitCount\"" documentation is\n\t\t// incorrect, and v4/v5 BMPs never have a separate \""bitfields\"" segment.\n\t\tif(rctx->bmpversion==3) {\n\t\t\trctx->bitfields_nbytes = 12;\n\t\t}\n\n\t\trctx->compression=IWBMP_BI_RGB;\n\t}\n\n\t//biSizeImage = iw_get_ui32le(&buf[20]);\n\tbiXPelsPerMeter = iw_get_i32le(&buf[24]);\n\tbiYPelsPerMeter = iw_get_i32le(&buf[28]);\n\n\trctx->img->density_code = IW_DENSITY_UNITS_PER_METER;\n\trctx->img->density_x = (double)biXPelsPerMeter;\n\trctx->img->density_y = (double)biYPelsPerMeter;\n\tif(!iw_is_valid_density(rctx->img->density_x,rctx->img->density_y,rctx->img->density_code)) {\n\t\trctx->img->density_code=IW_DENSITY_UNKNOWN;\n\t}\n\n\tbiClrUsed = iw_get_ui32le(&buf[32]);\n\tif(biClrUsed>100000) return 0;\n\ninfoheaderdone:\n\t// The documentation of the biClrUsed field is not very clear.\n\t// I'm going to assume that if biClrUsed is 0 and bitcount<=8, then\n\t// the number of palette colors is the maximum that would be useful\n\t// for that bitcount. In all other cases, the number of palette colors\n\t// equals biClrUsed.\n\tif(biClrUsed==0 && rctx->bitcount<=8) {\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t}\n\telse {\n\t\trctx->palette_entries = biClrUsed;\n\t}\n\trctx->palette_nbytes = 4*rctx->palette_entries;\n\treturn 1;\n}\n"", ""start_line"": 166, ""end_line"": 255, ""full_name"": ""decode_v3_header_fields"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v4_header_fields)"", ""result"": [{""code"": ""static int decode_v4_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tint k;\n\tunsigned int cstype;\n\n\tif(rctx->uses_bitfields) {\n\t\t// Set the bitfields masks here, instead of in iwbmp_read_bitfields().\n\t\tfor(k=0;k<4;k++) {\n\t\t\trctx->bf_mask[k] = 0;\n\t\t}\n\t\tfor(k=0;k<4;k++) {\n\t\t\tif(rctx->infoheader_size < (size_t)(40+k*4+4)) break;\n\t\t\trctx->bf_mask[k] = iw_get_ui32le(&buf[40+k*4]);\n\t\t\tif(!process_bf_mask(rctx,k)) return 0;\n\t\t}\n\t\trctx->bitfields_set=1; // Remember not to overwrite the bf_* fields.\n\n\t\tif(rctx->bf_mask[3]!=0) {\n\t\t\t// The documentation says this is the mask that \""specifies the\n\t\t\t// alpha component of each pixel.\""\n\t\t\t// It doesn't say whther it's associated, or unassociated alpha.\n\t\t\t// It doesn't say whether 0=transparent, or 0=opaque.\n\t\t\t// It doesn't say how to tell whether an image has an alpha\n\t\t\t// channel.\n\t\t\t// These are the answers I'm going with:\n\t\t\t// - Unassociated alpha\n\t\t\t// - 0=transparent\n\t\t\t// - 16- and 32-bit images have an alpha channel if 'compression'\n\t\t\t// is set to BI_BITFIELDS, and this alpha mask is nonzero.\n\t\t\trctx->has_alpha_channel = 1;\n\t\t}\n\t}\n\n\tif(rctx->infoheader_size < 108) return 1;\n\n\tcstype = iw_get_ui32le(&buf[56]);\n\tswitch(cstype) {\n\tcase IWBMPCS_CALIBRATED_RGB:\n\t\t//  \""indicates that endpoints and gamma values are given in the\n\t\t//    appropriate fields.\""  (TODO)\n\t\tbreak;\n\n\tcase IWBMPCS_DEVICE_RGB:\n\tcase IWBMPCS_SRGB:\n\tcase IWBMPCS_WINDOWS:\n\t\tbreak;\n\n\tcase IWBMPCS_PROFILE_LINKED:\n\tcase IWBMPCS_PROFILE_EMBEDDED:\n\t\tif(rctx->bmpversion<5) {\n\t\t\tiw_warning(rctx->ctx,\""Invalid colorspace type for BMPv4\"");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tiw_warningf(rctx->ctx,\""Unrecognized or unsupported colorspace type (0x%x)\"",cstype);\n\t}\n\n\t// Read Gamma fields\n\tif(cstype==IWBMPCS_CALIBRATED_RGB) {\n\t\tunsigned int bmpgamma;\n\t\tdouble gamma[3];\n\t\tdouble avggamma;\n\n\t\tfor(k=0;k<3;k++) {\n\t\t\tbmpgamma = iw_get_ui32le(&buf[96+k*4]);\n\t\t\tgamma[k] = ((double)bmpgamma)/65536.0;\n\t\t}\n\t\tavggamma = (gamma[0] + gamma[1] + gamma[2])/3.0;\n\n\t\tif(avggamma>=0.1 && avggamma<=10.0) {\n\t\t\tiw_make_gamma_csdescr(&rctx->csdescr,1.0/avggamma);\n\t\t}\n\t}\n\n\treturn 1;\n}\n"", ""start_line"": 260, ""end_line"": 336, ""full_name"": ""decode_v4_header_fields"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v5_header_fields)"", ""result"": [{""code"": ""static int decode_v5_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int intent_bmp_style;\n\tint intent_iw_style;\n\n\tintent_bmp_style = iw_get_ui32le(&buf[108]);\n\tintent_iw_style = IW_INTENT_UNKNOWN;\n\tswitch(intent_bmp_style) {\n\t\tcase 1: intent_iw_style = IW_INTENT_SATURATION; break; // LCS_GM_BUSINESS\n\t\tcase 2: intent_iw_style = IW_INTENT_RELATIVE; break; // LCS_GM_GRAPHICS\n\t\tcase 4: intent_iw_style = IW_INTENT_PERCEPTUAL; break; // LCS_GM_IMAGES\n\t\tcase 8: intent_iw_style = IW_INTENT_ABSOLUTE; break; // LCS_GM_ABS_COLORIMETRIC\n\t}\n\trctx->img->rendering_intent = intent_iw_style;\n\n\t// The profile may either be after the color table, or after the bitmap bits.\n\t// I'm assuming that we will never need to use the profile size in order to\n\t// find the bitmap bits; i.e. that if the bfOffBits field in the file header\n\t// is not available, the profile must be after the bits.\n\t//profile_offset = iw_get_ui32le(&buf[112]); // bV5ProfileData;\n\t//profile_size = iw_get_ui32le(&buf[116]); // bV5ProfileSize;\n\n\treturn 1;\n}\n"", ""start_line"": 339, ""end_line"": 362, ""full_name"": ""decode_v5_header_fields"", ""file_path"": ""src/imagew-bmp.c""}]}]","src/imagew-bmp.c:373: infoheader_size is read without validation. If <12, subsequent code (lines 375-385) calls decode_v2_header (line 132) which accesses buf[10] (out-of-bounds if buffer is undersized). The patch (line 372) adds infoheader_size < 12 check to prevent this. Trigger chain: [1] Crafted BMP with infoheader_size < 12 → [2] iwbmp_read_info_header reads into undersized buffer → [3] decode_v2_header accesses buf[10] (invalid memory) → [4] NULL pointer dereference.",0.95,./github/other_context/CVE-2017-7452
54,CVE-2017-7458,CWE-476,c_cpp,The NetworkInterface::getHost function in NetworkInterface.cpp in ntopng before 3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty field that should have contained a hostname or IP address.,https://github.com/ntop/ntopng/commit/01f47e04fd7c8d54399c9e465f823f0017069f8f,Security fix: prevents empty host from being used,2,"[{""func_name"": ""NetworkInterface::getHost"", ""file_path"": ""src/NetworkInterface.cpp"", ""func_code"": ""Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {\n  struct in_addr  a4;\n  struct in6_addr a6;\n  Host *h = NULL;\n\n  /* Check if address is invalid */\n  if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)\n     && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {\n    /* Looks like a symbolic name */\n    struct host_find_info info;\n\n    memset(&info, 0, sizeof(info));\n    info.host_to_find = host_ip, info.vlan_id = vlan_id;\n    walker(walker_hosts, find_host_by_name, (void*)&info);\n\n    h = info.h;\n  } else {\n    IpAddress *ip = new IpAddress();\n\n    if(ip) {\n      ip->set(host_ip);\n\n      if(!isView())\n\th = hosts_hash->get(vlan_id, ip);\n      else {\n\tfor(u_int8_t s = 0; s<numSubInterfaces; s++) {\n\t  h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);\n\t  if(h) break;\n\t}\n      }\n\n      delete ip;\n    }\n  }\n\n  return(h);\n}"", ""target"": 0}, {""func_name"": ""Lua::setParamsTable"", ""file_path"": ""src/Lua.cpp"", ""func_code"": ""void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \""[HTTP] %s\"", query_string);\n\n    tok = strtok_r(query_string, \""&\"", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \""csrf\"", strlen(\""csrf\"")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \""%s = %s\"", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \""r\""))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \""r\"")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \""Discarded '%s'='%s' as argument is a valid file path\"",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \""'%s'='%s'\"", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \""Not enough memory\"");\n      }\n\n      tok = strtok_r(NULL, \""&\"", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\""_GET\""); /* Default */\n}"", ""target"": 0}]","[{""func_name"": ""NetworkInterface::getHost"", ""file_path"": ""src/NetworkInterface.cpp"", ""func_code"": ""Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {\n  struct in_addr  a4;\n  struct in6_addr a6;\n  Host *h = NULL;\n\n  if(!host_ip) return(NULL);\n\n  /* Check if address is invalid */\n  if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)\n     && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {\n    /* Looks like a symbolic name */\n    struct host_find_info info;\n\n    memset(&info, 0, sizeof(info));\n    info.host_to_find = host_ip, info.vlan_id = vlan_id;\n    walker(walker_hosts, find_host_by_name, (void*)&info);\n\n    h = info.h;\n  } else {\n    IpAddress *ip = new IpAddress();\n\n    if(ip) {\n      ip->set(host_ip);\n\n      if(!isView())\n\th = hosts_hash->get(vlan_id, ip);\n      else {\n\tfor(u_int8_t s = 0; s<numSubInterfaces; s++) {\n\t  h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);\n\t  if(h) break;\n\t}\n      }\n\n      delete ip;\n    }\n  }\n\n  return(h);\n}""}, {""func_name"": ""Lua::setParamsTable"", ""file_path"": ""src/Lua.cpp"", ""func_code"": ""void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \""[HTTP] %s\"", query_string);\n\n    tok = strtok_r(query_string, \""&\"", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \""csrf\"", strlen(\""csrf\"")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))\n\t && (strlen(_equal) > 1)) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \""%s = %s\"", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \""r\""))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \""r\"")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \""Discarded '%s'='%s' as argument is a valid file path\"",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \""'%s'='%s'\"", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \""Not enough memory\"");\n      }\n\n      tok = strtok_r(NULL, \""&\"", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\""_GET\""); /* Default */\n}""}]","{""caller"": 3, ""value"": 1, ""function"": 1, ""code"": 1}","[{""source"": ""caller_info(file:NetworkInterface.cpp, func:getHost)"", ""result"": [{""call_line"": 2305, ""call_code"": ""getHost(host_ip, vlan_id)"", ""caller_code"": ""Host* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,\n\t\t\t\t      char *host_ip, u_int16_t vlan_id) {\n  if(host_ip != NULL) {\n    Host *h = getHost(host_ip, vlan_id);\n\n    if(h && h->match(allowed_hosts))\n      return(h);\n  }\n\n  return(NULL);\n}"", ""caller_start"": 2302, ""file_path"": ""src/NetworkInterface.cpp""}, {""call_line"": 3827, ""call_code"": ""getHost(host_ip, vlan_id)"", ""caller_code"": ""bool NetworkInterface::correlateHostActivity(lua_State* vm,\n\t\t\t\t\t     AddressTree *allowed_hosts,\n\t\t\t\t\t     char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, correlator_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}"", ""caller_start"": 3824, ""file_path"": ""src/NetworkInterface.cpp""}, {""call_line"": 3848, ""call_code"": ""getHost(host_ip, vlan_id)"", ""caller_code"": ""bool NetworkInterface::similarHostActivity(lua_State* vm,\n\t\t\t\t\t   AddressTree *allowed_hosts,\n\t\t\t\t\t   char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, similarity_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}"", ""caller_start"": 3845, ""file_path"": ""src/NetworkInterface.cpp""}, {""call_line"": 1512, ""call_code"": ""ntop_interface->getHost(host_ip, vlan_id)"", ""caller_code"": ""static int ntop_get_interface_flows(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char buf[64];\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  Host *host = NULL;\n  Paginator *p = NULL;\n  int numFlows = -1;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  if((p = new(std::nothrow) Paginator()) == NULL)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n    host = ntop_interface->getHost(host_ip, vlan_id);\n  }\n\n  if(lua_type(vm, 2) == LUA_TTABLE)\n    p->readOptions(vm, 2);\n\n  if(ntop_interface)\n    numFlows = ntop_interface->getFlows(vm, get_allowed_nets(vm), location, host, p);\n\n  if(p) delete p;\n  return numFlows < 0 ? CONST_LUA_ERROR : CONST_LUA_OK;\n}"", ""caller_start"": 1493, ""file_path"": ""src/Lua.cpp""}]}, {""source"": ""value_info(file:NetworkInterface.cpp, value:host_ip)"", ""result"": {""value_trace"": [{""full_code"": ""*host_ip = NULL"", ""line"": 304, ""func_name"": ""ntop_get_ndpi_interface_stats:int(lua_State*)""}, {""full_code"": ""*host_ip = NULL"", ""line"": 1496, ""func_name"": ""ntop_get_interface_flows:int(lua_State*,LocationPolicy)""}], ""struct_var"": ""host_ip"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""func_info(func:get_host_vlan_info)"", ""result"": [{""code"": ""static void get_host_vlan_info(char* lua_ip, char** host_ip,\n\t\t\t       u_int16_t* vlan_id,\n\t\t\t       char *buf, u_int buf_len) {\n  char *where, *vlan = NULL;\n\n  snprintf(buf, buf_len, \""%s\"", lua_ip);\n\n  if(((*host_ip) = strtok_r(buf, \""@\"", &where)) != NULL)\n    vlan = strtok_r(NULL, \""@\"", &where);\n\n  if(vlan)\n    (*vlan_id) = (u_int16_t)atoi(vlan);\n}"", ""start_line"": 90, ""end_line"": 102, ""full_name"": ""get_host_vlan_info:void(char*,char**,u_int16_t*,char*,u_int)"", ""file_path"": ""src/Lua.cpp""}]}, {""source"": ""code_info(file:Lua.cpp, lines:1490-1510)"", ""result"": ""\n/* ****************************************** */\n\nstatic int ntop_get_interface_flows(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char buf[64];\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  Host *host = NULL;\n  Paginator *p = NULL;\n  int numFlows = -1;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  if((p = new(std::nothrow) Paginator()) == NULL)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n""}, {""source"": ""caller_info(file:NetworkInterface.cpp, func:correlateHostActivity)"", ""result"": [{""call_line"": 1802, ""call_code"": ""ntop_interface->correlateHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id)"", ""caller_code"": ""static int ntop_correalate_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n   /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->correlateHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}"", ""caller_start"": 1788, ""file_path"": ""src/Lua.cpp""}]}, {""source"": ""caller_info(file:NetworkInterface.cpp, func:similarHostActivity)"", ""result"": [{""call_line"": 1824, ""call_code"": ""ntop_interface->similarHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id)"", ""caller_code"": ""static int ntop_similar_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->similarHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}"", ""caller_start"": 1810, ""file_path"": ""src/Lua.cpp""}]}]","src/Lua.cpp:90-102: get_host_vlan_info splits input like '@vlan' into host_ip (empty string) and vlan. src/Lua.cpp:1503,1788,1810: host_ip is passed as empty string to NetworkInterface::getHost. src/NetworkInterface.cpp:2200: getHost checks !host_ip (NULL) but not empty strings → inet_pton crash.",0.95,./github/other_context/CVE-2017-7458
55,CVE-2018-1000879,CWE-476,c_cpp,"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted archive file.",https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175,"Skip 0-length ACL fields\n\nCurrently, it is possible to create an archive that crashes bsdtar\nwith a malformed ACL:\n\nProgram received signal SIGSEGV, Segmentation fault.\narchive_acl_from_text_l (acl=<optimised out>, text=0x7e2e92 """", want_type=<optimised out>, sc=<optimised out>) at libarchive/archive_acl.c:1726\n1726				switch (*s) {\n(gdb) p n\n$1 = 1\n(gdb) p field[n]\n$2 = {start = 0x0, end = 0x0}\n\nStop this by checking that the length is not zero before beginning\nthe switch statement.\n\nI am pretty sure this is the bug mentioned in the qsym paper [1],\nand I was able to replicate it with a qsym + AFL + afl-rb setup.\n\n[1] https://www.usenix.org/conference/usenixsecurity18/presentation/yun",1,"[{""func_name"": ""archive_acl_from_text_l"", ""file_path"": ""libarchive/archive_acl.c"", ""func_code"": ""int\narchive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \""default:user::rwx\""\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \""defaultuser::rwx\"" is the default ACL corresponding\n\t\t\t * to \""user::rwx\"", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \""efault\"", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""roup\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""ther\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ask\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \""other:rwx\"" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \""default:\"" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \""user\"", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \""group\"", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \""owner@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \""group@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \""everyone@\"", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \""deny\"", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \""allow\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \""audit\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \""alarm\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}"", ""target"": 0}]","[{""func_name"": ""archive_acl_from_text_l"", ""file_path"": ""libarchive/archive_acl.c"", ""func_code"": ""int\narchive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \""default:user::rwx\""\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \""defaultuser::rwx\"" is the default ACL corresponding\n\t\t\t * to \""user::rwx\"", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \""efault\"", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tif (len == 0) {\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""roup\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""ther\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ask\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \""other:rwx\"" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \""default:\"" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \""user\"", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \""group\"", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \""owner@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \""group@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \""everyone@\"", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \""deny\"", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \""allow\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \""audit\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \""alarm\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}""}]","{""code"": 4, ""value"": 3, ""function"": 2}","[{""source"": ""code_info(file:archive_acl.c, lines:1720-1730)"", ""result"": ""\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n""}, {""source"": ""value_info(file:archive_acl.c, value:s)"", ""result"": {""value_trace"": [{""full_code"": ""s = (char *)malloc(length * sizeof(char))"", ""line"": 938, ""func_name"": ""archive_acl_to_text_l""}, {""full_code"": ""s = field[0].start"", ""line"": 1219, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""s = field[n].start"", ""line"": 1239, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""s = field[0].start"", ""line"": 1313, ""func_name"": ""archive_acl_from_text_w""}], ""struct_var"": ""s"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""code_info(file:archive_acl.c, lines:1700-1750)"", ""result"": ""\t\t\t * to \""user::rwx\"", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \""efault\"", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""roup\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""ther\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ask\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n""}, {""source"": ""value_info(file:archive_acl.c, value:field)"", ""result"": {""value_trace"": [{""full_code"": ""field[6]"", ""line"": 1151, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""field[6]"", ""line"": 1635, ""func_name"": ""archive_acl_from_text_l""}], ""struct_var"": ""field"", ""struct_type"": ""std.array"", ""struct_definition"": null}}, {""source"": ""code_info(file:archive_acl.c, lines:1150-1200)"", ""result"": ""\t\tconst wchar_t *end;\n\t} field[6], name;\n\n\tconst wchar_t *s, *st;\n\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\twchar_t sep;\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\twhile (text != NULL && *text != L'\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst wchar_t *start, *end;\n\t\t\tnext_field_w(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == L':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == L'#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n""}, {""source"": ""code_info(file:archive_acl.c, lines:1630-1680)"", ""result"": ""    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n""}, {""source"": ""value_info(file:archive_acl.c, value:field)"", ""result"": {""value_trace"": [{""full_code"": ""field[6]"", ""line"": 1151, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""field[6]"", ""line"": 1635, ""func_name"": ""archive_acl_from_text_l""}], ""struct_var"": ""field"", ""struct_type"": ""std.array"", ""struct_definition"": null}}, {""source"": ""func_info(file:archive_acl.c, func:next_field)"", ""result"": [{""code"": ""static void\nnext_field(const char **p, const char **start,\n    const char **end, char *sep)\n{\n\t/* Skip leading whitespace to find start of field. */\n\twhile (**p == ' ' || **p == '\\t' || **p == '\\n') {\n\t\t(*p)++;\n\t}\n\t*start = *p;\n\n\t/* Scan for the separator. */\n\twhile (**p != '\\0' && **p != ',' && **p != ':' && **p != '\\n' &&\n\t    **p != '#') {\n\t\t(*p)++;\n\t}\n\t*sep = **p;\n\n\t/* Locate end of field, trim trailing whitespace if necessary */\n\tif (*p == *start) {\n\t\t*end = *p;\n\t} else {\n\t\t*end = *p - 1;\n\t\twhile (**end == ' ' || **end == '\\t' || **end == '\\n') {\n\t\t\t(*end)--;\n\t\t}\n\t\t(*end)++;\n\t}\n\n\t/* Handle in-field comments */\n\tif (*sep == '#') {\n\t\twhile (**p != '\\0' && **p != ',' && **p != '\\n') {\n\t\t\t(*p)++;\n\t\t}\n\t\t*sep = **p;\n\t}\n\n\t/* Adjust scanner location. */\n\tif (**p != '\\0')\n\t\t(*p)++;\n}"", ""start_line"": 2061, ""end_line"": 2100, ""full_name"": ""next_field"", ""file_path"": ""libarchive/archive_acl.c""}]}, {""source"": ""func_info(file:archive_acl.c, func:next_field_w)"", ""result"": [{""code"": ""static void\nnext_field_w(const wchar_t **wp, const wchar_t **start,\n    const wchar_t **end, wchar_t *sep)\n{\n\t/* Skip leading whitespace to find start of field. */\n\twhile (**wp == L' ' || **wp == L'\\t' || **wp == L'\\n') {\n\t\t(*wp)++;\n\t}\n\t*start = *wp;\n\n\t/* Scan for the separator. */\n\twhile (**wp != L'\\0' && **wp != L',' && **wp != L':' &&\n\t    **wp != L'\\n' && **wp != L'#') {\n\t\t(*wp)++;\n\t}\n\t*sep = **wp;\n\n\t/* Locate end of field, trim trailing whitespace if necessary */\n\tif (*wp == *start) {\n\t\t*end = *wp;\n\t} else {\n\t\t*end = *wp - 1;\n\t\twhile (**end == L' ' || **end == L'\\t' || **end == L'\\n') {\n\t\t\t(*end)--;\n\t\t}\n\t\t(*end)++;\n\t}\n\n\t/* Handle in-field comments */\n\tif (*sep == L'#') {\n\t\twhile (**wp != L'\\0' && **wp != L',' && **wp != L'\\n') {\n\t\t\t(*wp)++;\n\t\t}\n\t\t*sep = **wp;\n\t}\n\n\t/* Adjust scanner location. */\n\tif (**wp != L'\\0')\n\t\t(*wp)++;\n}"", ""start_line"": 1576, ""end_line"": 1615, ""full_name"": ""next_field_w"", ""file_path"": ""libarchive/archive_acl.c""}]}]","libarchive/archive_acl.c:1726: Dereference of *s (s = field[n].start, which is 0x0) when len == 0. The 'field' array is initialized with up to numfields (5 or 6) entries. If parsed fields are insufficient, remaining entries (e.g., field[n]) have start/end = NULL (libarchive/archive_acl.c:1660-1665). For a malformed ACL with <numfields entries, len = 0 (due to field[n].end - field[n].start = 0), leading to *s dereference of NULL. The patch adds len == 0 check to skip invalid fields.",0.95,./github/other_context/CVE-2018-1000879
56,CVE-2018-15858,CWE-476,c_cpp,Unchecked NULL pointer usage when handling invalid aliases in CopyKeyAliasesToKeymap in xkbcomp/keycodes.c in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file.,https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f,"keycodes: don't try to copy zero key aliases\n\nMove the aliases copy to within the (num_key_aliases > 0) block.\n\nPassing info->aliases into this fuction with invalid aliases will\ncause log messages but num_key_aliases stays on 0. The key_aliases array\nis never allocated and remains NULL. We then loop through the aliases, causing\na null-pointer dereference.\n\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>",1,"[{""func_name"": ""CopyKeyAliasesToKeymap"", ""file_path"": ""src/xkbcomp/keycodes.c"", ""func_code"": ""static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to alias %s to non-existent key %s; Ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to create alias with the name of a real key; \""\n                    \""Alias \\\""%s = %s\\\"" ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}"", ""target"": 0}]","[{""func_name"": ""CopyKeyAliasesToKeymap"", ""file_path"": ""src/xkbcomp/keycodes.c"", ""func_code"": ""static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to alias %s to non-existent key %s; Ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to create alias with the name of a real key; \""\n                    \""Alias \\\""%s = %s\\\"" ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n\n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:keycodes.c, lines:580-597)"", ""result"": ""        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to create alias with the name of a real key; \""\n                    \""Alias \\\""%s = %s\\\"" ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n""}, {""source"": ""value_info(file:keycodes.c, value:num_key_aliases)"", ""result"": {""value_trace"": [{""full_code"": ""num_key_aliases = 0"", ""line"": 567, ""func_name"": ""CopyKeyAliasesToKeymap""}, {""full_code"": ""num_key_aliases++"", ""line"": 590, ""func_name"": ""CopyKeyAliasesToKeymap""}], ""struct_var"": ""num_key_aliases"", ""struct_type"": ""unsigned"", ""struct_definition"": ""unsigned""}}]","src/xkbcomp/keycodes.c: The loop over info->aliases in CopyKeyAliasesToKeymap (lines 597-597) was executed without checking if num_key_aliases > 0. When invalid aliases are provided (e.g., aliases pointing to real keys), alias->real is set to XKB_ATOM_NONE (line 580-597), and num_key_aliases remains zero. Since key_aliases is only allocated if num_key_aliases > 0 (line 597), the loop dereferences a NULL pointer. The patch moves the loop into the num_key_aliases > 0 block to prevent this.",0.95,./github/other_context/CVE-2018-15858
57,CVE-2018-15855,CWE-476,c_cpp,"Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because the XkbFile for an xkb_geometry section was mishandled.",https://github.com/xkbcommon/libxkbcommon/commit/917636b1d0d70205a13f89062b95e3a0fc31d4ff,"xkbcomp: fix crash when parsing an xkb_geometry section\n\nxkb_geometry sections are ignored; previously the had done so by\nreturning NULL for the section's XkbFile, however some sections of the\ncode do not expect this. Instead, create an XkbFile for it, it will\nnever be processes and discarded later.\n\nCaught with the afl fuzzer.\n\nSigned-off-by: Ran Benita <ran234@gmail.com>",1,"[{""func_name"": ""CompileKeymap"", ""file_path"": ""src/xkbcomp/keymap.c"", ""func_code"": ""bool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \""More than one %s section in keymap file; \""\n                    \""All sections after the first ignored\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \""Required section %s missing from keymap\\n\"",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \""Compiling %s \\\""%s\\\""\\n\"",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \""Failed to compile %s\\n\"",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}"", ""target"": 0}]","[{""func_name"": ""CompileKeymap"", ""file_path"": ""src/xkbcomp/keymap.c"", ""func_code"": ""bool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \""Geometry sections are not supported; ignoring\\n\"");\n            } else {\n                log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \""More than one %s section in keymap file; \""\n                    \""All sections after the first ignored\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \""Required section %s missing from keymap\\n\"",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \""Compiling %s \\\""%s\\\""\\n\"",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \""Failed to compile %s\\n\"",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}""}]","{""code"": 2, ""function"": 1}","[{""source"": ""code_info(file:keymap.c, lines:242-272)"", ""result"": ""        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \""More than one %s section in keymap file; \""\n                    \""All sections after the first ignored\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \""Required section %s missing from keymap\\n\"",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n""}, {""source"": ""func_info(file:keymap.c, func:CompileKeymap)"", ""result"": [{""code"": ""bool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb"", ""start_line"": 231, ""end_line"": 293, ""full_name"": ""CompileKeymap"", ""file_path"": ""src/xkbcomp/keymap.c""}]}, {""source"": ""code_info(file:keymap.c, lines:273-293)"", ""result"": ""    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \""Compiling %s \\\""%s\\\""\\n\"",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \""Failed to compile %s\\n\"",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}\n""}]","The vulnerability was caused by a NULL pointer dereference in src/xkbcomp/keymap.c:277. Before the patch, geometry sections returned NULL for XkbFile. The code in CompileKeymap (src/xkbcomp/keymap.c:273-293) iterated over files[type], accessing files[type]->name without checking for NULL. This led to a crash when files[type] was NULL (e.g., for geometry sections). The patch ensures files[type] is always non-NULL by creating a dummy XkbFile for geometry sections, preventing the dereference.",0.95,./github/other_context/CVE-2018-15855
58,CVE-2018-17293,CWE-476,c_cpp,"An issue was discovered in WAVM before 2018-09-16. The run function in Programs/wavm/wavm.cpp does not check whether there is Emscripten memory to store the command-line arguments passed by the input WebAssembly file's main function, which allows attackers to cause a denial of service (application crash by NULL pointer dereference) or possibly have unspecified other impact by crafting certain WebAssembly files.",https://github.com/WAVM/WAVM/commit/31d670b6489e6d708c3b04b911cdf14ac43d846d,Fix dereferencing null pointer when running wavm with WebAssembly main function that takes command-line arguments but no Emscripten memory to write them to,1,"[{""func_name"": ""run"", ""file_path"": ""Programs/wavm/wavm.cpp"", ""func_code"": ""static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \""wavm.precompiled_object\"")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Input file did not contain 'wavm.precompiled_object' section\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""env\"", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""asm2wasm\"", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""global\"", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\""threadTest\"", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \""Failed to link module:\\n\"");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""Missing import: module=\\\""%s\\\"" export=\\\""%s\\\"" type=\\\""%s\\\""\\n\"",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""main\""));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""_main\"")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export main function\\n\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export '%s'\\n\"", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);\n\t\t\tif(!defaultMemory)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\""Module does not declare a default memory object to put arguments in.\\n\"");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tstd::vector<const char*> argStrings;\n\t\t\targStrings.push_back(options.filename);\n\t\t\tchar** args = options.args;\n\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""WebAssembly function requires %\"" PRIu64\n\t\t\t\t\t\t\"" argument(s), but only 0 or 2 can be passed!\"",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\""Cannot parse command-line argument for %s function parameter\"",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\""Invoked function\"", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\""%s returned: %s\\n\"",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""run"", ""file_path"": ""Programs/wavm/wavm.cpp"", ""func_code"": ""static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \""wavm.precompiled_object\"")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Input file did not contain 'wavm.precompiled_object' section\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""env\"", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""asm2wasm\"", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""global\"", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\""threadTest\"", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \""Failed to link module:\\n\"");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""Missing import: module=\\\""%s\\\"" export=\\\""%s\\\"" type=\\\""%s\\\""\\n\"",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""main\""));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""_main\"")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export main function\\n\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export '%s'\\n\"", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tif(!emscriptenInstance)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\""Module does not declare a default memory object to put arguments in.\\n\"");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::vector<const char*> argStrings;\n\t\t\t\targStrings.push_back(options.filename);\n\t\t\t\tchar** args = options.args;\n\t\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\t\twavmAssert(emscriptenInstance);\n\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t\t}\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""WebAssembly function requires %\"" PRIu64\n\t\t\t\t\t\t\"" argument(s), but only 0 or 2 can be passed!\"",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\""Cannot parse command-line argument for %s function parameter\"",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\""Invoked function\"", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\""%s returned: %s\\n\"",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}""}]","{""value"": 1, ""function"": 1}","[{""source"": ""value_info(file:wavm.cpp, value:emscriptenInstance)"", ""result"": {""value_trace"": [{""full_code"": ""* emscriptenInstance = nullptr"", ""line"": 174, ""func_name"": ""run:int(CommandLineOptions&)""}, {""full_code"": ""emscriptenInstance = Emscripten::instantiate(compartment, irModule)"", ""line"": 177, ""func_name"": ""run:int(CommandLineOptions&)""}], ""struct_var"": ""emscriptenInstance"", ""struct_type"": ""Emscripten.Instance*"", ""struct_definition"": null}}, {""source"": ""func_info(func:instantiate)"", ""result"": [{""code"": ""Emscripten::Instance* Emscripten::instantiate(Compartment* compartment, const IR::Module& module)\n{\n\tMemoryType memoryType(false, SizeConstraints{0, 0});\n\tif(module.memories.imports.size() && module.memories.imports[0].moduleName == \""env\""\n\t   && module.memories.imports[0].exportName == \""memory\"")\n\t{\n\t\tmemoryType = module.memories.imports[0].type;\n\t\tif(memoryType.size.max >= minStaticEmscriptenMemoryPages)\n\t\t{\n\t\t\tif(memoryType.size.min <= minStaticEmscriptenMemoryPages)\n\t\t\t{\n\t\t\t\t// Enlarge the initial memory to make space for the stack and mutable globals.\n\t\t\t\tmemoryType.size.min = minStaticEmscriptenMemoryPages;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLog::printf(Log::error, \""module's memory is too small for Emscripten emulation\"");\n\t\t\treturn nullptr;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn nullptr;\n\t}\n\n\tTableType tableType(ReferenceType::anyfunc, false, SizeConstraints{0, 0});\n\tif(module.tables.imports.size() && module.tables.imports[0].moduleName == \""env\""\n\t   && module.tables.imports[0].exportName == \""table\"")\n\t{ tableType = module.tables.imports[0].type; }\n\n\tMemoryInstance* memory = Runtime::createMemory(compartment, memoryType);\n\tTableInstance* table = Runtime::createTable(compartment, tableType);\n\n\tHashMap<std::string, Runtime::Object*> extraEnvExports = {\n\t\t{\""memory\"", Runtime::asObject(memory)},\n\t\t{\""table\"", Runtime::asObject(table)},\n\t};\n\n\tInstance* instance = new Instance;\n\tinstance->env = Intrinsics::instantiateModule(\n\t\tcompartment, INTRINSIC_MODULE_REF(env), \""env\"", extraEnvExports);\n\tinstance->asm2wasm\n\t\t= Intrinsics::instantiateModule(compartment, INTRINSIC_MODULE_REF(asm2wasm), \""asm2wasm\"");\n\tinstance->global\n\t\t= Intrinsics::instantiateModule(compartment, INTRINSIC_MODULE_REF(global), \""global\"");\n\n\tMutableGlobals& mutableGlobals = memoryRef<MutableGlobals>(memory, MutableGlobals::address);\n\n\tmutableGlobals.DYNAMICTOP_PTR = STACK_MAX.getValue().i32;\n\tmutableGlobals._stderr = (U32)ioStreamVMHandle::StdErr;\n\tmutableGlobals._stdin = (U32)ioStreamVMHandle::StdIn;\n\tmutableGlobals._stdout = (U32)ioStreamVMHandle::StdOut;\n\n\tinstance->emscriptenMemory = memory;\n\n\treturn instance;\n}\n"", ""start_line"": 627, ""end_line"": 684, ""full_name"": ""Emscripten.instantiate:Emscripten.Instance*(Runtime.Compartment*,IR.Module&)"", ""file_path"": ""Lib/Emscripten/Emscripten.cpp""}, {""code"": ""Runtime::FunctionInstance* Intrinsics::Function::instantiate(Runtime::Compartment* compartment)\n{\n\treturn new Runtime::FunctionInstance(nullptr, type, nativeFunction, callingConvention, name);\n}"", ""start_line"": 52, ""end_line"": 55, ""full_name"": ""Intrinsics.Function.instantiate:Runtime.FunctionInstance*(Runtime.Compartment*)"", ""file_path"": ""Lib/Runtime/Intrinsics.cpp""}, {""code"": ""Runtime::GlobalInstance* Intrinsics::Global::instantiate(Runtime::Compartment* compartment)\n{\n\treturn Runtime::createGlobal(compartment, IR::GlobalType(type, false), value);\n}"", ""start_line"": 70, ""end_line"": 73, ""full_name"": ""Intrinsics.Global.instantiate:Runtime.GlobalInstance*(Runtime.Compartment*)"", ""file_path"": ""Lib/Runtime/Intrinsics.cpp""}]}]","The root cause is the absence of proper validation in `Emscripten::instantiate(Lib/Emscripten/Emscripten.cpp:627-684)` for required memory imports. If a module does not declare an `env.memory` import with sufficient size, `Emscripten::instantiate()` returns `nullptr`, leaving `emscriptenInstance` unassigned in `wavm.cpp:177`. This null value is later dereferenced in `wavm.cpp:251-255` during `Emscripten::injectCommandArgs()` without sufficient checks, causing a NULL pointer dereference.",0.95,./github/other_context/CVE-2018-17293
59,CVE-2018-20360,"CWE-119, CWE-476",c_cpp,"An invalid memory address dereference was discovered in the sbr_process_channel function of libfaad/sbr_dec.c in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.",https://github.com/knik0/faad2/commit/6823e6610c9af1b0080cb22b9da03efb208d7d57,"ps_dec: sanitize iid_index before mixing\n\nindex range is supposed to be withing -7 and 7 or -15 and 15 depending on\niid_mode (see Table 8.24, ISO/IEC 14496-3:2005).\n\nIndexes outside these boundaries are likely to be errors and should be\nsanitized to avoid memory corruption. Replace any index under\n-no_iid_steps (-7 or -15 depending on iid_mode) by -no_iid_steps. Replace\nany index above no_iid_steps by no_iid_steps. Try to process further.\n\nThis commit addresses CVE-2019-6956 (fixes #39).",2,"[{""func_name"": ""ps_mix_phase"", ""file_path"": ""libfaad/ps_dec.c"", ""func_code"": ""static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],\n                         qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])\n{\n    uint8_t n;\n    uint8_t gr;\n    uint8_t bk = 0;\n    uint8_t sb, maxsb;\n    uint8_t env;\n    uint8_t nr_ipdopd_par;\n    complex_t h11, h12, h21, h22;\n    complex_t H11, H12, H21, H22;\n    complex_t deltaH11, deltaH12, deltaH21, deltaH22;\n    complex_t tempLeft;\n    complex_t tempRight;\n    complex_t phaseLeft;\n    complex_t phaseRight;\n    real_t L;\n    const real_t *sf_iid;\n    uint8_t no_iid_steps;\n\n    if (ps->iid_mode >= 3)\n    {\n        no_iid_steps = 15;\n        sf_iid = sf_iid_fine;\n    } else {\n        no_iid_steps = 7;\n        sf_iid = sf_iid_normal;\n    }\n\n    if (ps->ipd_mode == 0 || ps->ipd_mode == 3)\n    {\n        nr_ipdopd_par = 11; /* resolution */\n    } else {\n        nr_ipdopd_par = ps->nr_ipdopd_par;\n    }\n\n    for (gr = 0; gr < ps->num_groups; gr++)\n    {\n        bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];\n\n        /* use one channel per group in the subqmf domain */\n        maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];\n\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->icc_mode < 3)\n            {\n                /* type 'A' mixing as described in 8.6.4.6.2.1 */\n                real_t c_1, c_2;\n                real_t cosa, sina;\n                real_t cosb, sinb;\n                real_t ab1, ab2;\n                real_t ab3, ab4;\n\n                /*\n                c_1 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps + iid_index] / 10.0)));\n                c_2 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps - iid_index] / 10.0)));\n                alpha = 0.5 * acos(quant_rho[icc_index]);\n                beta = alpha * ( c_1 - c_2 ) / sqrt(2.0);\n                */\n\n                //printf(\""%d\\n\"", ps->iid_index[env][bk]);\n\n                /* calculate the scalefactors c_1 and c_2 from the intensity differences */\n                c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];\n                c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];\n\n                /* calculate alpha and beta using the ICC parameters */\n                cosa = cos_alphas[ps->icc_index[env][bk]];\n                sina = sin_alphas[ps->icc_index[env][bk]];\n\n                if (ps->iid_mode >= 3)\n                {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                } else {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                }\n\n                ab1 = MUL_C(cosb, cosa);\n                ab2 = MUL_C(sinb, sina);\n                ab3 = MUL_C(sinb, cosa);\n                ab4 = MUL_C(cosb, sina);\n\n                /* h_xy: COEF */\n                RE(h11) = MUL_C(c_2, (ab1 - ab2));\n                RE(h12) = MUL_C(c_1, (ab1 + ab2));\n                RE(h21) = MUL_C(c_2, (ab3 + ab4));\n                RE(h22) = MUL_C(c_1, (ab3 - ab4));\n            } else {\n                /* type 'B' mixing as described in 8.6.4.6.2.2 */\n                real_t sina, cosa;\n                real_t cosg, sing;\n\n                /*\n                real_t c, rho, mu, alpha, gamma;\n                uint8_t i;\n\n                i = ps->iid_index[env][bk];\n                c = (real_t)pow(10.0, ((i)?(((i>0)?1:-1)*quant_iid[((i>0)?i:-i)-1]):0.)/20.0);\n                rho = quant_rho[ps->icc_index[env][bk]];\n\n                if (rho == 0.0f && c == 1.)\n                {\n                    alpha = (real_t)M_PI/4.0f;\n                    rho = 0.05f;\n                } else {\n                    if (rho <= 0.05f)\n                    {\n                        rho = 0.05f;\n                    }\n                    alpha = 0.5f*(real_t)atan( (2.0f*c*rho) / (c*c-1.0f) );\n\n                    if (alpha < 0.)\n                    {\n                        alpha += (real_t)M_PI/2.0f;\n                    }\n                    if (rho < 0.)\n                    {\n                        alpha += (real_t)M_PI;\n                    }\n                }\n                mu = c+1.0f/c;\n                mu = 1+(4.0f*rho*rho-4.0f)/(mu*mu);\n                gamma = (real_t)atan(sqrt((1.0f-sqrt(mu))/(1.0f+sqrt(mu))));\n                */\n\n                if (ps->iid_mode >= 3)\n                {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                } else {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                }\n\n                RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));\n                RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));\n                RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));\n                RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));\n            }\n\n            /* calculate phase rotation parameters H_xy */\n            /* note that the imaginary part of these parameters are only calculated when\n               IPD and OPD are enabled\n             */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                int8_t i;\n                real_t xy, pq, xypq;\n\n                /* ringbuffer index */\n                i = ps->phase_hist;\n\n                /* previous value */\n#ifdef FIXED_POINT\n                /* divide by 4, shift right 2 bits */\n                RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;\n                IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;\n                RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;\n                IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;\n#else\n                RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n#endif\n\n                /* save current value */\n                RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];\n                IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];\n                RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];\n                IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];\n\n                /* add current value */\n                RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);\n                IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);\n                RE(tempRight) += RE(ps->opd_prev[bk][i]);\n                IM(tempRight) += IM(ps->opd_prev[bk][i]);\n\n                /* ringbuffer index */\n                if (i == 0)\n                {\n                    i = 2;\n                }\n                i--;\n\n                /* get value before previous */\n#ifdef FIXED_POINT\n                /* dividing by 2, shift right 1 bit */\n                RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);\n                IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);\n                RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);\n                IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);\n#else\n                RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* original code */\n                ipd = (float)atan2(IM(tempLeft), RE(tempLeft));\n                opd = (float)atan2(IM(tempRight), RE(tempRight));\n\n                /* phase rotation */\n                RE(phaseLeft) = (float)cos(opd);\n                IM(phaseLeft) = (float)sin(opd);\n                opd -= ipd;\n                RE(phaseRight) = (float)cos(opd);\n                IM(phaseRight) = (float)sin(opd);\n#else\n\n                // x = IM(tempLeft)\n                // y = RE(tempLeft)\n                // p = IM(tempRight)\n                // q = RE(tempRight)\n                // cos(atan2(x,y)) = y/sqrt((x*x) + (y*y))\n                // sin(atan2(x,y)) = x/sqrt((x*x) + (y*y))\n                // cos(atan2(x,y)-atan2(p,q)) = (y*q + x*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n                // sin(atan2(x,y)-atan2(p,q)) = (x*q - y*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n\n                xy = magnitude_c(tempRight);\n                pq = magnitude_c(tempLeft);\n\n                if (xy != 0)\n                {\n                    RE(phaseLeft) = DIV_R(RE(tempRight), xy);\n                    IM(phaseLeft) = DIV_R(IM(tempRight), xy);\n                } else {\n                    RE(phaseLeft) = 0;\n                    IM(phaseLeft) = 0;\n                }\n\n                xypq = MUL_R(xy, pq);\n\n                if (xypq != 0)\n                {\n                    real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));\n                    real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));\n\n                    RE(phaseRight) = DIV_R(tmp1, xypq);\n                    IM(phaseRight) = DIV_R(tmp2, xypq);\n                } else {\n                    RE(phaseRight) = 0;\n                    IM(phaseRight) = 0;\n                }\n\n#endif\n\n                /* MUL_F(COEF, REAL) = COEF */\n                IM(h11) = MUL_R(RE(h11), IM(phaseLeft));\n                IM(h12) = MUL_R(RE(h12), IM(phaseRight));\n                IM(h21) = MUL_R(RE(h21), IM(phaseLeft));\n                IM(h22) = MUL_R(RE(h22), IM(phaseRight));\n\n                RE(h11) = MUL_R(RE(h11), RE(phaseLeft));\n                RE(h12) = MUL_R(RE(h12), RE(phaseRight));\n                RE(h21) = MUL_R(RE(h21), RE(phaseLeft));\n                RE(h22) = MUL_R(RE(h22), RE(phaseRight));\n            }\n\n            /* length of the envelope n_e+1 - n_e (in time samples) */\n            /* 0 < L <= 32: integer */\n            L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);\n\n            /* obtain final H_xy by means of linear interpolation */\n            RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;\n            RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;\n            RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;\n            RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;\n\n            RE(H11) = RE(ps->h11_prev[gr]);\n            RE(H12) = RE(ps->h12_prev[gr]);\n            RE(H21) = RE(ps->h21_prev[gr]);\n            RE(H22) = RE(ps->h22_prev[gr]);\n\n            RE(ps->h11_prev[gr]) = RE(h11);\n            RE(ps->h12_prev[gr]) = RE(h12);\n            RE(ps->h21_prev[gr]) = RE(h21);\n            RE(ps->h22_prev[gr]) = RE(h22);\n\n            /* only calculate imaginary part when needed */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                /* obtain final H_xy by means of linear interpolation */\n                IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;\n                IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;\n                IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;\n                IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;\n\n                IM(H11) = IM(ps->h11_prev[gr]);\n                IM(H12) = IM(ps->h12_prev[gr]);\n                IM(H21) = IM(ps->h21_prev[gr]);\n                IM(H22) = IM(ps->h22_prev[gr]);\n\n                if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)\n                {\n                    IM(deltaH11) = -IM(deltaH11);\n                    IM(deltaH12) = -IM(deltaH12);\n                    IM(deltaH21) = -IM(deltaH21);\n                    IM(deltaH22) = -IM(deltaH22);\n\n                    IM(H11) = -IM(H11);\n                    IM(H12) = -IM(H12);\n                    IM(H21) = -IM(H21);\n                    IM(H22) = -IM(H22);\n                }\n\n                IM(ps->h11_prev[gr]) = IM(h11);\n                IM(ps->h12_prev[gr]) = IM(h12);\n                IM(ps->h21_prev[gr]) = IM(h21);\n                IM(ps->h22_prev[gr]) = IM(h22);\n            }\n\n            /* apply H_xy to the current envelope band of the decorrelated subband */\n            for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)\n            {\n                /* addition finalises the interpolation over every n */\n                RE(H11) += RE(deltaH11);\n                RE(H12) += RE(deltaH12);\n                RE(H21) += RE(deltaH21);\n                RE(H22) += RE(deltaH22);\n                if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                {\n                    IM(H11) += IM(deltaH11);\n                    IM(H12) += IM(deltaH12);\n                    IM(H21) += IM(deltaH21);\n                    IM(H22) += IM(deltaH22);\n                }\n\n                /* channel is an alias to the subband */\n                for (sb = ps->group_border[gr]; sb < maxsb; sb++)\n                {\n                    complex_t inLeft, inRight;\n\n                    /* load decorrelated samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(inLeft) =  RE(X_hybrid_left[n][sb]);\n                        IM(inLeft) =  IM(X_hybrid_left[n][sb]);\n                        RE(inRight) = RE(X_hybrid_right[n][sb]);\n                        IM(inRight) = IM(X_hybrid_right[n][sb]);\n                    } else {\n                        RE(inLeft) =  RE(X_left[n][sb]);\n                        IM(inLeft) =  IM(X_left[n][sb]);\n                        RE(inRight) = RE(X_right[n][sb]);\n                        IM(inRight) = IM(X_right[n][sb]);\n                    }\n\n                    /* apply mixing */\n                    RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));\n                    IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));\n                    RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));\n                    IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));\n\n                    /* only perform imaginary operations when needed */\n                    if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                    {\n                        /* apply rotation */\n                        RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));\n                        IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));\n                        RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));\n                        IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));\n                    }\n\n                    /* store final samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(X_hybrid_left[n][sb])  = RE(tempLeft);\n                        IM(X_hybrid_left[n][sb])  = IM(tempLeft);\n                        RE(X_hybrid_right[n][sb]) = RE(tempRight);\n                        IM(X_hybrid_right[n][sb]) = IM(tempRight);\n                    } else {\n                        RE(X_left[n][sb])  = RE(tempLeft);\n                        IM(X_left[n][sb])  = IM(tempLeft);\n                        RE(X_right[n][sb]) = RE(tempRight);\n                        IM(X_right[n][sb]) = IM(tempRight);\n                    }\n                }\n            }\n\n            /* shift phase smoother's circular buffer index */\n            ps->phase_hist++;\n            if (ps->phase_hist == 2)\n            {\n                ps->phase_hist = 0;\n            }\n        }\n    }\n}"", ""target"": 0}, {""func_name"": ""reconstruct_single_channel"", ""file_path"": ""libfaad/specrec.c"", ""func_code"": ""uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \""suddenly\"" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency */\n\n        /* this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        /* reset the allocation */\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n\n        //return 21;\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""ps_mix_phase"", ""file_path"": ""libfaad/ps_dec.c"", ""func_code"": ""static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],\n                         qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])\n{\n    uint8_t n;\n    uint8_t gr;\n    uint8_t bk = 0;\n    uint8_t sb, maxsb;\n    uint8_t env;\n    uint8_t nr_ipdopd_par;\n    complex_t h11, h12, h21, h22;\n    complex_t H11, H12, H21, H22;\n    complex_t deltaH11, deltaH12, deltaH21, deltaH22;\n    complex_t tempLeft;\n    complex_t tempRight;\n    complex_t phaseLeft;\n    complex_t phaseRight;\n    real_t L;\n    const real_t *sf_iid;\n    uint8_t no_iid_steps;\n\n    if (ps->iid_mode >= 3)\n    {\n        no_iid_steps = 15;\n        sf_iid = sf_iid_fine;\n    } else {\n        no_iid_steps = 7;\n        sf_iid = sf_iid_normal;\n    }\n\n    if (ps->ipd_mode == 0 || ps->ipd_mode == 3)\n    {\n        nr_ipdopd_par = 11; /* resolution */\n    } else {\n        nr_ipdopd_par = ps->nr_ipdopd_par;\n    }\n\n    for (gr = 0; gr < ps->num_groups; gr++)\n    {\n        bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];\n\n        /* use one channel per group in the subqmf domain */\n        maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];\n\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->icc_mode < 3)\n            {\n                /* type 'A' mixing as described in 8.6.4.6.2.1 */\n                real_t c_1, c_2;\n                real_t cosa, sina;\n                real_t cosb, sinb;\n                real_t ab1, ab2;\n                real_t ab3, ab4;\n\n                /*\n                c_1 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps + iid_index] / 10.0)));\n                c_2 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps - iid_index] / 10.0)));\n                alpha = 0.5 * acos(quant_rho[icc_index]);\n                beta = alpha * ( c_1 - c_2 ) / sqrt(2.0);\n                */\n\n                //printf(\""%d\\n\"", ps->iid_index[env][bk]);\n\n                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode\n                   (Table 8.24, ISO/IEC 14496-3:2005).\n                   if it is outside these boundaries, this is most likely an error. sanitize\n                   it and try to process further. */\n                if (ps->iid_index[env][bk] < -no_iid_steps) {\n                    fprintf(stderr, \""Warning: invalid iid_index: %d < %d\\n\"", ps->iid_index[env][bk],\n                        -no_iid_steps);\n                    ps->iid_index[env][bk] = -no_iid_steps;\n                } else if (ps->iid_index[env][bk] > no_iid_steps) {\n                    fprintf(stderr, \""Warning: invalid iid_index: %d > %d\\n\"", ps->iid_index[env][bk],\n                        no_iid_steps);\n                    ps->iid_index[env][bk] = no_iid_steps;\n                }\n\n                /* calculate the scalefactors c_1 and c_2 from the intensity differences */\n                c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];\n                c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];\n\n                /* calculate alpha and beta using the ICC parameters */\n                cosa = cos_alphas[ps->icc_index[env][bk]];\n                sina = sin_alphas[ps->icc_index[env][bk]];\n\n                if (ps->iid_mode >= 3)\n                {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                } else {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                }\n\n                ab1 = MUL_C(cosb, cosa);\n                ab2 = MUL_C(sinb, sina);\n                ab3 = MUL_C(sinb, cosa);\n                ab4 = MUL_C(cosb, sina);\n\n                /* h_xy: COEF */\n                RE(h11) = MUL_C(c_2, (ab1 - ab2));\n                RE(h12) = MUL_C(c_1, (ab1 + ab2));\n                RE(h21) = MUL_C(c_2, (ab3 + ab4));\n                RE(h22) = MUL_C(c_1, (ab3 - ab4));\n            } else {\n                /* type 'B' mixing as described in 8.6.4.6.2.2 */\n                real_t sina, cosa;\n                real_t cosg, sing;\n\n                /*\n                real_t c, rho, mu, alpha, gamma;\n                uint8_t i;\n\n                i = ps->iid_index[env][bk];\n                c = (real_t)pow(10.0, ((i)?(((i>0)?1:-1)*quant_iid[((i>0)?i:-i)-1]):0.)/20.0);\n                rho = quant_rho[ps->icc_index[env][bk]];\n\n                if (rho == 0.0f && c == 1.)\n                {\n                    alpha = (real_t)M_PI/4.0f;\n                    rho = 0.05f;\n                } else {\n                    if (rho <= 0.05f)\n                    {\n                        rho = 0.05f;\n                    }\n                    alpha = 0.5f*(real_t)atan( (2.0f*c*rho) / (c*c-1.0f) );\n\n                    if (alpha < 0.)\n                    {\n                        alpha += (real_t)M_PI/2.0f;\n                    }\n                    if (rho < 0.)\n                    {\n                        alpha += (real_t)M_PI;\n                    }\n                }\n                mu = c+1.0f/c;\n                mu = 1+(4.0f*rho*rho-4.0f)/(mu*mu);\n                gamma = (real_t)atan(sqrt((1.0f-sqrt(mu))/(1.0f+sqrt(mu))));\n                */\n\n                if (ps->iid_mode >= 3)\n                {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                } else {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                }\n\n                RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));\n                RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));\n                RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));\n                RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));\n            }\n\n            /* calculate phase rotation parameters H_xy */\n            /* note that the imaginary part of these parameters are only calculated when\n               IPD and OPD are enabled\n             */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                int8_t i;\n                real_t xy, pq, xypq;\n\n                /* ringbuffer index */\n                i = ps->phase_hist;\n\n                /* previous value */\n#ifdef FIXED_POINT\n                /* divide by 4, shift right 2 bits */\n                RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;\n                IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;\n                RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;\n                IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;\n#else\n                RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n#endif\n\n                /* save current value */\n                RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];\n                IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];\n                RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];\n                IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];\n\n                /* add current value */\n                RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);\n                IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);\n                RE(tempRight) += RE(ps->opd_prev[bk][i]);\n                IM(tempRight) += IM(ps->opd_prev[bk][i]);\n\n                /* ringbuffer index */\n                if (i == 0)\n                {\n                    i = 2;\n                }\n                i--;\n\n                /* get value before previous */\n#ifdef FIXED_POINT\n                /* dividing by 2, shift right 1 bit */\n                RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);\n                IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);\n                RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);\n                IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);\n#else\n                RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* original code */\n                ipd = (float)atan2(IM(tempLeft), RE(tempLeft));\n                opd = (float)atan2(IM(tempRight), RE(tempRight));\n\n                /* phase rotation */\n                RE(phaseLeft) = (float)cos(opd);\n                IM(phaseLeft) = (float)sin(opd);\n                opd -= ipd;\n                RE(phaseRight) = (float)cos(opd);\n                IM(phaseRight) = (float)sin(opd);\n#else\n\n                // x = IM(tempLeft)\n                // y = RE(tempLeft)\n                // p = IM(tempRight)\n                // q = RE(tempRight)\n                // cos(atan2(x,y)) = y/sqrt((x*x) + (y*y))\n                // sin(atan2(x,y)) = x/sqrt((x*x) + (y*y))\n                // cos(atan2(x,y)-atan2(p,q)) = (y*q + x*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n                // sin(atan2(x,y)-atan2(p,q)) = (x*q - y*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n\n                xy = magnitude_c(tempRight);\n                pq = magnitude_c(tempLeft);\n\n                if (xy != 0)\n                {\n                    RE(phaseLeft) = DIV_R(RE(tempRight), xy);\n                    IM(phaseLeft) = DIV_R(IM(tempRight), xy);\n                } else {\n                    RE(phaseLeft) = 0;\n                    IM(phaseLeft) = 0;\n                }\n\n                xypq = MUL_R(xy, pq);\n\n                if (xypq != 0)\n                {\n                    real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));\n                    real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));\n\n                    RE(phaseRight) = DIV_R(tmp1, xypq);\n                    IM(phaseRight) = DIV_R(tmp2, xypq);\n                } else {\n                    RE(phaseRight) = 0;\n                    IM(phaseRight) = 0;\n                }\n\n#endif\n\n                /* MUL_F(COEF, REAL) = COEF */\n                IM(h11) = MUL_R(RE(h11), IM(phaseLeft));\n                IM(h12) = MUL_R(RE(h12), IM(phaseRight));\n                IM(h21) = MUL_R(RE(h21), IM(phaseLeft));\n                IM(h22) = MUL_R(RE(h22), IM(phaseRight));\n\n                RE(h11) = MUL_R(RE(h11), RE(phaseLeft));\n                RE(h12) = MUL_R(RE(h12), RE(phaseRight));\n                RE(h21) = MUL_R(RE(h21), RE(phaseLeft));\n                RE(h22) = MUL_R(RE(h22), RE(phaseRight));\n            }\n\n            /* length of the envelope n_e+1 - n_e (in time samples) */\n            /* 0 < L <= 32: integer */\n            L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);\n\n            /* obtain final H_xy by means of linear interpolation */\n            RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;\n            RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;\n            RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;\n            RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;\n\n            RE(H11) = RE(ps->h11_prev[gr]);\n            RE(H12) = RE(ps->h12_prev[gr]);\n            RE(H21) = RE(ps->h21_prev[gr]);\n            RE(H22) = RE(ps->h22_prev[gr]);\n\n            RE(ps->h11_prev[gr]) = RE(h11);\n            RE(ps->h12_prev[gr]) = RE(h12);\n            RE(ps->h21_prev[gr]) = RE(h21);\n            RE(ps->h22_prev[gr]) = RE(h22);\n\n            /* only calculate imaginary part when needed */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                /* obtain final H_xy by means of linear interpolation */\n                IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;\n                IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;\n                IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;\n                IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;\n\n                IM(H11) = IM(ps->h11_prev[gr]);\n                IM(H12) = IM(ps->h12_prev[gr]);\n                IM(H21) = IM(ps->h21_prev[gr]);\n                IM(H22) = IM(ps->h22_prev[gr]);\n\n                if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)\n                {\n                    IM(deltaH11) = -IM(deltaH11);\n                    IM(deltaH12) = -IM(deltaH12);\n                    IM(deltaH21) = -IM(deltaH21);\n                    IM(deltaH22) = -IM(deltaH22);\n\n                    IM(H11) = -IM(H11);\n                    IM(H12) = -IM(H12);\n                    IM(H21) = -IM(H21);\n                    IM(H22) = -IM(H22);\n                }\n\n                IM(ps->h11_prev[gr]) = IM(h11);\n                IM(ps->h12_prev[gr]) = IM(h12);\n                IM(ps->h21_prev[gr]) = IM(h21);\n                IM(ps->h22_prev[gr]) = IM(h22);\n            }\n\n            /* apply H_xy to the current envelope band of the decorrelated subband */\n            for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)\n            {\n                /* addition finalises the interpolation over every n */\n                RE(H11) += RE(deltaH11);\n                RE(H12) += RE(deltaH12);\n                RE(H21) += RE(deltaH21);\n                RE(H22) += RE(deltaH22);\n                if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                {\n                    IM(H11) += IM(deltaH11);\n                    IM(H12) += IM(deltaH12);\n                    IM(H21) += IM(deltaH21);\n                    IM(H22) += IM(deltaH22);\n                }\n\n                /* channel is an alias to the subband */\n                for (sb = ps->group_border[gr]; sb < maxsb; sb++)\n                {\n                    complex_t inLeft, inRight;\n\n                    /* load decorrelated samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(inLeft) =  RE(X_hybrid_left[n][sb]);\n                        IM(inLeft) =  IM(X_hybrid_left[n][sb]);\n                        RE(inRight) = RE(X_hybrid_right[n][sb]);\n                        IM(inRight) = IM(X_hybrid_right[n][sb]);\n                    } else {\n                        RE(inLeft) =  RE(X_left[n][sb]);\n                        IM(inLeft) =  IM(X_left[n][sb]);\n                        RE(inRight) = RE(X_right[n][sb]);\n                        IM(inRight) = IM(X_right[n][sb]);\n                    }\n\n                    /* apply mixing */\n                    RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));\n                    IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));\n                    RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));\n                    IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));\n\n                    /* only perform imaginary operations when needed */\n                    if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                    {\n                        /* apply rotation */\n                        RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));\n                        IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));\n                        RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));\n                        IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));\n                    }\n\n                    /* store final samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(X_hybrid_left[n][sb])  = RE(tempLeft);\n                        IM(X_hybrid_left[n][sb])  = IM(tempLeft);\n                        RE(X_hybrid_right[n][sb]) = RE(tempRight);\n                        IM(X_hybrid_right[n][sb]) = IM(tempRight);\n                    } else {\n                        RE(X_left[n][sb])  = RE(tempLeft);\n                        IM(X_left[n][sb])  = IM(tempLeft);\n                        RE(X_right[n][sb]) = RE(tempRight);\n                        IM(X_right[n][sb]) = IM(tempRight);\n                    }\n                }\n            }\n\n            /* shift phase smoother's circular buffer index */\n            ps->phase_hist++;\n            if (ps->phase_hist == 2)\n            {\n                ps->phase_hist = 0;\n            }\n        }\n    }\n}""}, {""func_name"": ""reconstruct_single_channel"", ""file_path"": ""libfaad/specrec.c"", ""func_code"": ""uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \""suddenly\"" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency\n         * this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        if (hDecoder->fr_channels == 1) {\n            /* reset the allocation */\n            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n        } else {\n            return 21;\n        }\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}""}]","{""value"": 7, ""function"": 3, ""code"": 2}","[{""source"": ""value_info(file:ps_dec.c, value:ps->iid_index)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_index[0][bin] = ps->iid_index_prev[bin]"", ""line"": 867, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[0][bin] = 0"", ""line"": 870, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 900, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 926, ""func_name"": ""ps_data_decode""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ps_dec.c, value:no_iid_steps)"", ""result"": {""value_trace"": [{""full_code"": ""no_iid_steps = 15"", ""line"": 1470, ""func_name"": ""ps_mix_phase""}, {""full_code"": ""no_iid_steps = 7"", ""line"": 1473, ""func_name"": ""ps_mix_phase""}], ""struct_var"": ""no_iid_steps"", ""struct_type"": ""uint8_t"", ""struct_definition"": ""typedef unsigned char uint8_t;""}}, {""source"": ""value_info(file:ps_dec.c, value:ps->iid_index)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_index[0][bin] = ps->iid_index_prev[bin]"", ""line"": 867, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[0][bin] = 0"", ""line"": 870, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 900, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 926, ""func_name"": ""ps_data_decode""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ps_dec.c, value:iid_mode)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_mode = (uint8_t)faad_getbits(ld, 3\n                DEBUGVAR(1,1002,\""ps_data(): iid_mode\""))"", ""line"": 351, ""func_name"": ""ps_data""}], ""struct_var"": ""iid_mode"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ps_dec.c, value:no_iid_steps)"", ""result"": {""value_trace"": [{""full_code"": ""no_iid_steps = 15"", ""line"": 1470, ""func_name"": ""ps_mix_phase""}, {""full_code"": ""no_iid_steps = 7"", ""line"": 1473, ""func_name"": ""ps_mix_phase""}], ""struct_var"": ""no_iid_steps"", ""struct_type"": ""uint8_t"", ""struct_definition"": ""typedef unsigned char uint8_t;""}}, {""source"": ""func_info(file:ps_dec.c, func:ps_data_decode)"", ""result"": [{""code"": ""static void ps_data_decode(ps_info *ps)\n{\n    uint8_t env, bin;\n\n    /* ps data not available, use data from previous frame */\n    if (ps->ps_data_available == 0)\n    {\n        ps->num_env = 0;\n    }\n\n    for (env = 0; env < ps->num_env; env++)\n    {\n        int8_t *iid_index_prev;\n        int8_t *icc_index_prev;\n        int8_t *ipd_index_prev;\n        int8_t *opd_index_prev;\n\n        int8_t num_iid_steps = (ps->iid_mode < 3) ? 7 : 15 /*fine quant*/;\n\n        if (env == 0)\n        {\n            /* take last envelope from previous frame */\n            iid_index_prev = ps->iid_index_prev;\n            icc_index_prev = ps->icc_index_prev;\n            ipd_index_prev = ps->ipd_index_prev;\n            opd_index_prev = ps->opd_index_prev;\n        } else {\n            /* take index values from previous envelope */\n            iid_index_prev = ps->iid_index[env - 1];\n            icc_index_prev = ps->icc_index[env - 1];\n            ipd_index_prev = ps->ipd_index[env - 1];\n            opd_index_prev = ps->opd_index[env - 1];\n        }\n\n//        iid = 1;\n        /* delta decode iid parameters */\n        delta_decode(ps->enable_iid, ps->iid_index[env], iid_index_prev,\n            ps->iid_dt[env], ps->nr_iid_par,\n            (ps->iid_mode == 0 || ps->iid_mode == 3) ? 2 : 1,\n            -num_iid_steps, num_iid_steps);\n//        iid = 0;\n\n        /* delta decode icc parameters */\n        delta_decode(ps->enable_icc, ps->icc_index[env], icc_index_prev,\n            ps->icc_dt[env], ps->nr_icc_par,\n            (ps->icc_mode == 0 || ps->icc_mode == 3) ? 2 : 1,\n            0, 7);\n\n        /* delta modulo decode ipd parameters */\n        delta_modulo_decode(ps->enable_ipdopd, ps->ipd_index[env], ipd_index_prev,\n            ps->ipd_dt[env], ps->nr_ipdopd_par, 1, 7);\n\n        /* delta modulo decode opd parameters */\n        delta_modulo_decode(ps->enable_ipdopd, ps->opd_index[env], opd_index_prev,\n            ps->opd_dt[env], ps->nr_ipdopd_par, 1, 7);\n    }\n\n    /* handle error case */\n    if (ps->num_env == 0)\n    {\n        /* force to 1 */\n        ps->num_env = 1;\n\n        if (ps->enable_iid)\n        {\n            for (bin = 0; bin < 34; bin++)\n                ps->iid_index[0][bin] = ps->iid_index_prev[bin];\n        } else {\n            for (bin = 0; bin < 34; bin++)\n                ps->iid_index[0][bin] = 0;\n        }\n\n        if (ps->enable_icc)\n        {\n            for (bin = 0; bin < 34; bin++)\n                ps->icc_index[0][bin] = ps->icc_index_prev[bin];\n        } else {\n            for (bin = 0; bin < 34; bin++)\n                ps->icc_index[0][bin] = 0;\n        }\n\n        if (ps->enable_ipdopd)\n        {\n            for (bin = 0; bin < 17; bin++)\n            {\n                ps->ipd_index[0][bin] = ps->ipd_index_prev[bin];\n                ps->opd_index[0][bin] = ps->opd_index_prev[bin];\n            }\n        } else {\n            for (bin = 0; bin < 17; bin++)\n            {\n                ps->ipd_index[0][bin] = 0;\n                ps->opd_index[0][bin] = 0;\n            }\n        }\n    }\n\n    /* update previous indices */\n    for (bin = 0; bin < 34; bin++)\n        ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 34; bin++)\n        ps->icc_index_prev[bin] = ps->icc_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 17; bin++)\n    {\n        ps->ipd_index_prev[bin] = ps->ipd_index[ps->num_env-1][bin];\n        ps->opd_index_prev[bin] = ps->opd_index[ps->num_env-1][bin];\n    }\n\n    ps->ps_data_available = 0;\n\n    if (ps->frame_class == 0)\n    {\n        ps->border_position[0] = 0;\n        for (env = 1; env < ps->num_env; env++)\n        {\n            ps->border_position[env] = (env * ps->numTimeSlotsRate) / ps->num_env;\n        }\n        ps->border_position[ps->num_env] = ps->numTimeSlotsRate;\n    } else {\n        ps->border_position[0] = 0;\n\n        if (ps->border_position[ps->num_env] < ps->numTimeSlotsRate)\n        {\n            for (bin = 0; bin < 34; bin++)\n            {\n                ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin];\n                ps->icc_index[ps->num_env][bin] = ps->icc_index[ps->num_env-1][bin];\n            }\n            for (bin = 0; bin < 17; bin++)\n            {\n                ps->ipd_index[ps->num_env][bin] = ps->ipd_index[ps->num_env-1][bin];\n                ps->opd_index[ps->num_env][bin] = ps->opd_index[ps->num_env-1][bin];\n            }\n            ps->num_env++;\n            ps->border_position[ps->num_env] = ps->numTimeSlotsRate;\n        }\n\n        for (env = 1; env < ps->num_env; env++)\n        {\n            int8_t thr = ps->numTimeSlotsRate - (ps->num_env - env);\n\n            if (ps->border_position[env] > thr)\n            {\n                ps->border_position[env] = thr;\n            } else {\n                thr = ps->border_position[env-1]+1;\n                if (ps->border_position[env] < thr)\n                {\n                    ps->border_position[env] = thr;\n                }\n            }\n        }\n    }\n\n    /* make sure that the indices of all parameters can be mapped\n     * to the same hybrid synthesis filterbank\n     */\n#ifdef PS_LOW_POWER\n    for (env = 0; env < ps->num_env; env++)\n    {\n        if (ps->iid_mode == 2 || ps->iid_mode == 5)\n            map34indexto20(ps->iid_index[env], 34);\n        if (ps->icc_mode == 2 || ps->icc_mode == 5)\n            map34indexto20(ps->icc_index[env], 34);\n\n        /* disable ipd/opd */\n        for (bin = 0; bin < 17; bin++)\n        {\n            ps->aaIpdIndex[env][bin] = 0;\n            ps->aaOpdIndex[env][bin] = 0;\n        }\n    }\n#else\n    if (ps->use34hybrid_bands)\n    {\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->iid_mode != 2 && ps->iid_mode != 5)\n                map20indexto34(ps->iid_index[env], 34);\n            if (ps->icc_mode != 2 && ps->icc_mode != 5)\n                map20indexto34(ps->icc_index[env], 34);\n            if (ps->ipd_mode != 2 && ps->ipd_mode != 5)\n            {\n                map20indexto34(ps->ipd_index[env], 17);\n                map20indexto34(ps->opd_index[env], 17);\n            }\n        }\n    }\n#endif\n\n#if 0\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""iid[env:%d]:\"", env);\n        for (bin = 0; bin < 34; bin++)\n        {\n            printf(\"" %d\"", ps->iid_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""icc[env:%d]:\"", env);\n        for (bin = 0; bin < 34; bin++)\n        {\n            printf(\"" %d\"", ps->icc_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""ipd[env:%d]:\"", env);\n        for (bin = 0; bin < 17; bin++)\n        {\n            printf(\"" %d\"", ps->ipd_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""opd[env:%d]:\"", env);\n        for (bin = 0; bin < 17; bin++)\n        {\n            printf(\"" %d\"", ps->opd_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    printf(\""\\n\"");\n#endif\n}\n"", ""start_line"": 801, ""end_line"": 1030, ""full_name"": ""ps_data_decode"", ""file_path"": ""libfaad/ps_dec.c""}]}, {""source"": ""code_info(file:ps_dec.c, lines:867-870)"", ""result"": ""                ps->iid_index[0][bin] = ps->iid_index_prev[bin];\n        } else {\n            for (bin = 0; bin < 34; bin++)\n                ps->iid_index[0][bin] = 0;\n""}, {""source"": ""code_info(file:ps_dec.c, lines:900-926)"", ""result"": ""        ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 34; bin++)\n        ps->icc_index_prev[bin] = ps->icc_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 17; bin++)\n    {\n        ps->ipd_index_prev[bin] = ps->ipd_index[ps->num_env-1][bin];\n        ps->opd_index_prev[bin] = ps->opd_index[ps->num_env-1][bin];\n    }\n\n    ps->ps_data_available = 0;\n\n    if (ps->frame_class == 0)\n    {\n        ps->border_position[0] = 0;\n        for (env = 1; env < ps->num_env; env++)\n        {\n            ps->border_position[env] = (env * ps->numTimeSlotsRate) / ps->num_env;\n        }\n        ps->border_position[ps->num_env] = ps->numTimeSlotsRate;\n    } else {\n        ps->border_position[0] = 0;\n\n        if (ps->border_position[ps->num_env] < ps->numTimeSlotsRate)\n        {\n            for (bin = 0; bin < 34; bin++)\n            {\n                ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin];\n""}, {""source"": ""value_info(file:ps_dec.c, value:ps->iid_index)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_index[0][bin] = ps->iid_index_prev[bin]"", ""line"": 867, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[0][bin] = 0"", ""line"": 870, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 900, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 926, ""func_name"": ""ps_data_decode""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:ps_dec.c, func:delta_decode)"", ""result"": [{""code"": ""static void delta_decode(uint8_t enable, int8_t *index, int8_t *index_prev,\n                         uint8_t dt_flag, uint8_t nr_par, uint8_t stride,\n                         int8_t min_index, int8_t max_index)\n{\n    int8_t i;\n\n    if (enable == 1)\n    {\n        if (dt_flag == 0)\n        {\n            /* delta coded in frequency direction */\n            index[0] = 0 + index[0];\n            index[0] = delta_clip(index[0], min_index, max_index);\n\n            for (i = 1; i < nr_par; i++)\n            {\n                index[i] = index[i-1] + index[i];\n                index[i] = delta_clip(index[i], min_index, max_index);\n            }\n        } else {\n            /* delta coded in time direction */\n            for (i = 0; i < nr_par; i++)\n            {\n                //int8_t tmp2;\n                //int8_t tmp = index[i];\n\n                //printf(\""%d %d\\n\"", index_prev[i*stride], index[i]);\n                //printf(\""%d\\n\"", index[i]);\n\n                index[i] = index_prev[i*stride] + index[i];\n                //tmp2 = index[i];\n                index[i] = delta_clip(index[i], min_index, max_index);\n\n                //if (iid)\n                //{\n                //    if (index[i] == 7)\n                //    {\n                //        printf(\""%d %d %d\\n\"", index_prev[i*stride], tmp, tmp2);\n                //    }\n                //}\n            }\n        }\n    } else {\n        /* set indices to zero */\n        for (i = 0; i < nr_par; i++)\n        {\n            index[i] = 0;\n        }\n    }\n\n    /* coarse */\n    if (stride == 2)\n    {\n        for (i = (nr_par<<1)-1; i > 0; i--)\n        {\n            index[i] = index[i>>1];\n        }\n    }\n}\n"", ""start_line"": 620, ""end_line"": 678, ""full_name"": ""delta_decode"", ""file_path"": ""libfaad/ps_dec.c""}]}, {""source"": ""value_info(file:ps_dec.c, value:ps->iid_mode)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_mode = (uint8_t)faad_getbits(ld, 3\n                DEBUGVAR(1,1002,\""ps_data(): iid_mode\""))"", ""line"": 351, ""func_name"": ""ps_data""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:ps_dec.c, func:delta_clip)"", ""result"": [{""code"": ""static int8_t delta_clip(int8_t i, int8_t min, int8_t max)\n{\n    if (i < min)\n        return min;\n    else if (i > max)\n        return max;\n    else\n        return i;\n}"", ""start_line"": 607, ""end_line"": 615, ""full_name"": ""delta_clip"", ""file_path"": ""libfaad/ps_dec.c""}]}]","libfaad/ps_dec.c:1521-1522: Out-of-bounds access in `sf_iid[no_iid_steps + ps->iid_index[]]` occurs when `ps->iid_index` contains values outside [-no_iid_steps, no_iid_steps]. The root cause is incorrect handling of `dt_flag == 0` in `delta_decode` (libfaad/ps_dec.c:620-678), which does not use `index_prev` for the first element, leading to potential unclamped values. `ps->iid_index` is populated in `ps_data_decode` (libfaad/ps_dec.c:867,870,900,926) via `delta_decode`, which relies on `delta_clip` (libfaad/ps_dec.c:607-615) to enforce bounds. The patch in `ps_mix_phase` clamps `iid_index` to prevent OOB access.",0.95,./github/other_context/CVE-2018-20360
60,CVE-2018-6197,CWE-476,c_cpp,w3m through 0.5.3 is prone to a NULL pointer dereference flaw in formUpdateBuffer in form.c.,https://github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8,Prevent invalid columnPos() call in formUpdateBuffer()\n\nBug-Debian: https://github.com/tats/w3m/issues/89,1,"[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}"", ""target"": 0}]","[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}""}]","{""code"": 2, ""value"": 2}","[{""source"": ""code_info(file:form.c, lines:450-490)"", ""result"": ""\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n""}, {""source"": ""value_info(file:form.c, value:l)"", ""result"": {""value_trace"": [{""full_code"": ""l = New(struct form_list)"", ""line"": 69, ""func_name"": ""newFormList""}, {""full_code"": ""l = buf->currentLine"", ""line"": 470, ""func_name"": ""formUpdateBuffer""}, {""full_code"": ""l = l->prev"", ""line"": 476, ""func_name"": ""formUpdateBuffer""}, {""full_code"": ""l = l->prev"", ""line"": 478, ""func_name"": ""formUpdateBuffer""}, {""full_code"": ""l = l->next"", ""line"": 484, ""func_name"": ""formUpdateBuffer""}], ""struct_var"": ""l"", ""struct_type"": ""form_list*"", ""struct_definition"": ""typedef struct form_list {\n    struct form_item_list *item;\n    struct form_item_list *lastitem;\n    int method;\n    Str action;\n    char *target;\n    char *name;\n#ifdef USE_M17N\n    wc_ces charset;\n#endif\n    int enctype;\n    struct form_list *next;\n    int nitems;\n    char *body;\n    char *boundary;\n    unsigned long length;\n}\n\nstruct form_list\n\nstruct form_list\n\nextern struct form_list""}}, {""source"": ""code_info(file:form.c, lines:100-150)"", ""result"": ""    item = New(struct form_item_list);\n    item->type = FORM_UNKNOWN;\n    item->size = -1;\n    item->rows = 0;\n    item->checked = item->init_checked = 0;\n    item->accept = 0;\n    item->name = NULL;\n    item->value = item->init_value = NULL;\n    item->readonly = 0;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\titem->type = formtype(p);\n\tif (item->size < 0 &&\n\t    (item->type == FORM_INPUT_TEXT ||\n\t     item->type == FORM_INPUT_FILE ||\n\t     item->type == FORM_INPUT_PASSWORD))\n\t    item->size = FORM_I_TEXT_DEFAULT_SIZE;\n    }\n    if (parsedtag_get_value(tag, ATTR_NAME, &p))\n\titem->name = Strnew_charp(p);\n    if (parsedtag_get_value(tag, ATTR_VALUE, &p))\n\titem->value = item->init_value = Strnew_charp(p);\n    item->checked = item->init_checked = parsedtag_exists(tag, ATTR_CHECKED);\n    item->accept = parsedtag_exists(tag, ATTR_ACCEPT);\n    parsedtag_get_value(tag, ATTR_SIZE, &item->size);\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &item->maxlength);\n    item->readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER, &i)\n\t&& i >= 0 && i < max_textarea)\n\titem->value = item->init_value = textarea_str[i];\n#ifdef MENU_SELECT\n    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &i)\n\t&& i >= 0 && i < max_select)\n\titem->select_option = select_option[i].first;\n#endif\t\t\t\t/* MENU_SELECT */\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p))\n\titem->rows = atoi(p);\n    if (item->type == FORM_UNKNOWN) {\n\t/* type attribute is missing. Ignore the tag. */\n\treturn NULL;\n    }\n#ifdef MENU_SELECT\n    if (item->type == FORM_SELECT) {\n\tchooseSelectOption(item, item->select_option);\n\titem->init_selected = item->selected;\n\titem->init_value = item->value;\n\titem->init_label = item->label;\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (item->type == FORM_INPUT_FILE && item->value && item->value->length) {\n\t/* security hole ! */\n\treturn NULL;\n""}, {""source"": ""value_info(file:form.c, value:form->rows)"", ""result"": {""value_trace"": [{""full_code"": ""a_form->rows = 1 + top + bottom"", ""line"": 5908, ""func_name"": ""HTMLlineproc2body""}], ""struct_var"": ""form"", ""struct_type"": null, ""struct_definition"": null}}]","form.c:483-487: Loop iterates 'rows' times (from form->rows) with l = l->next without NULL check. If the line list (buf->currentLine) is shorter than rows, l becomes NULL. form.c:100-150 shows form->rows is initialized via parsedtag_get_value(ATTR_ROWS) → atoi(p) without validation, allowing attacker-controlled large values. This creates a NULL dereference in columnPos(l, col) when l is NULL.",0.95,./github/other_context/CVE-2018-6197
61,CVE-2019-11459,"CWE-908, CWE-754",c_cpp,"The tiff_document_render() and tiff_document_get_thumbnail() functions in the TIFF document backend in GNOME Evince through 3.32.0 did not handle errors from TIFFReadRGBAImageOriented(), leading to uninitialized memory use when processing certain TIFF image files.",https://github.com/GNOME/evince/commit/3e38d5ad724a042eebadcba8c2d57b0f48b7a8c7,tiff: Handle failure from TIFFReadRGBAImageOriented\n\nThe TIFFReadRGBAImageOriented function returns zero if it was unable to\nread the image. Return NULL in this case instead of displaying\nuninitialized memory.\n\nFixes #1129,2,"[{""func_name"": ""tiff_document_render"", ""file_path"": ""backend/tiff/tiff-document.c"", ""func_code"": ""static cairo_surface_t *\ntiff_document_render (EvDocument      *document,\n\t\t      EvRenderContext *rc)\n{\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tint width, height;\n\tint scaled_width, scaled_height;\n\tfloat x_res, y_res;\n\tgint rowstride, bytes;\n\tguchar *pixels = NULL;\n\tguchar *p;\n\tint orientation;\n\tcairo_surface_t *surface;\n\tcairo_surface_t *rotated_surface;\n\tstatic const cairo_user_data_key_t key;\n\t\n\tg_return_val_if_fail (TIFF_IS_DOCUMENT (document), NULL);\n\tg_return_val_if_fail (tiff_document->tiff != NULL, NULL);\n  \n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, rc->page->index) != 1) {\n\t\tpop_handlers ();\n\t\tg_warning(\""Failed to select page %d\"", rc->page->index);\n\t\treturn NULL;\n\t}\n\n\tif (!TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &width)) {\n\t\tpop_handlers ();\n\t\tg_warning(\""Failed to read image width\"");\n\t\treturn NULL;\n\t}\n\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tpop_handlers ();\n\t\tg_warning(\""Failed to read image height\"");\n\t\treturn NULL;\n\t}\n\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_ORIENTATION, &orientation)) {\n\t\torientation = ORIENTATION_TOPLEFT;\n\t}\n\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\t\n\tpop_handlers ();\n  \n\t/* Sanity check the doc */\n\tif (width <= 0 || height <= 0) {\n\t\tg_warning(\""Invalid width or height.\"");\n\t\treturn NULL;\n\t}\n\n\trowstride = cairo_format_stride_for_width (CAIRO_FORMAT_RGB24, width);\n\tif (rowstride / 4 != width) {\n\t\tg_warning(\""Overflow while rendering document.\"");\n\t\t/* overflow, or cairo was changed in an unsupported way */\n\t\treturn NULL;                \n\t}\n\t\n\tif (height >= INT_MAX / rowstride) {\n\t\tg_warning(\""Overflow while rendering document.\"");\n\t\t/* overflow */\n\t\treturn NULL;\n\t}\n\tbytes = height * rowstride;\n\t\n\tpixels = g_try_malloc (bytes);\n\tif (!pixels) {\n\t\tg_warning(\""Failed to allocate memory for rendering.\"");\n\t\treturn NULL;\n\t}\n\t\n\tsurface = cairo_image_surface_create_for_data (pixels,\n\t\t\t\t\t\t       CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t       width, height,\n\t\t\t\t\t\t       rowstride);\n\tcairo_surface_set_user_data (surface, &key,\n\t\t\t\t     pixels, (cairo_destroy_func_t)g_free);\n\n\tTIFFReadRGBAImageOriented (tiff_document->tiff,\n\t\t\t\t   width, height,\n\t\t\t\t   (uint32 *)pixels,\n\t\t\t\t   orientation, 0);\n\tpop_handlers ();\n\n\t/* Convert the format returned by libtiff to\n\t* what cairo expects\n\t*/\n\tp = pixels;\n\twhile (p < pixels + bytes) {\n\t\tguint32 *pixel = (guint32*)p;\n\t\tguint8 r = TIFFGetR(*pixel);\n\t\tguint8 g = TIFFGetG(*pixel);\n\t\tguint8 b = TIFFGetB(*pixel);\n\t\tguint8 a = TIFFGetA(*pixel);\n\n\t\t*pixel = (a << 24) | (r << 16) | (g << 8) | b;\n\n\t\tp += 4;\n\t}\n\n\tev_render_context_compute_scaled_size (rc, width, height * (x_res / y_res),\n\t\t\t\t\t       &scaled_width, &scaled_height);\n\trotated_surface = ev_document_misc_surface_rotate_and_scale (surface,\n\t\t\t\t\t\t\t\t     scaled_width, scaled_height,\n\t\t\t\t\t\t\t\t     rc->rotation);\n\tcairo_surface_destroy (surface);\n\t\n\treturn rotated_surface;\n}"", ""target"": 1}, {""func_name"": ""tiff_document_get_thumbnail"", ""file_path"": ""backend/tiff/tiff-document.c"", ""func_code"": ""static GdkPixbuf *\ntiff_document_get_thumbnail (EvDocument      *document,\n\t\t\t     EvRenderContext *rc)\n{\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tint width, height;\n\tint scaled_width, scaled_height;\n\tfloat x_res, y_res;\n\tgint rowstride, bytes;\n\tguchar *pixels = NULL;\n\tGdkPixbuf *pixbuf;\n\tGdkPixbuf *scaled_pixbuf;\n\tGdkPixbuf *rotated_pixbuf;\n\t\n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, rc->page->index) != 1) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\n\tif (!TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &width)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\t\n\tpop_handlers ();\n  \n\t/* Sanity check the doc */\n\tif (width <= 0 || height <= 0)\n\t\treturn NULL;                \n\n\tif (width >= INT_MAX / 4)\n\t\t/* overflow */\n\t\treturn NULL;                \n\trowstride = width * 4;\n        \n\tif (height >= INT_MAX / rowstride)\n\t\t/* overflow */\n\t\treturn NULL;                \n\tbytes = height * rowstride;\n\t\n\tpixels = g_try_malloc (bytes);\n\tif (!pixels)\n\t\treturn NULL;\n\t\n\tpixbuf = gdk_pixbuf_new_from_data (pixels, GDK_COLORSPACE_RGB, TRUE, 8, \n\t\t\t\t\t   width, height, rowstride,\n\t\t\t\t\t   (GdkPixbufDestroyNotify) g_free, NULL);\n\tTIFFReadRGBAImageOriented (tiff_document->tiff,\n\t\t\t\t   width, height,\n\t\t\t\t   (uint32 *)pixels,\n\t\t\t\t   ORIENTATION_TOPLEFT, 0);\n\tpop_handlers ();\n\n\tev_render_context_compute_scaled_size (rc, width, height * (x_res / y_res),\n\t\t\t\t\t       &scaled_width, &scaled_height);\n\tscaled_pixbuf = gdk_pixbuf_scale_simple (pixbuf,\n\t\t\t\t\t\t scaled_width, scaled_height,\n\t\t\t\t\t\t GDK_INTERP_BILINEAR);\n\tg_object_unref (pixbuf);\n\t\n\trotated_pixbuf = gdk_pixbuf_rotate_simple (scaled_pixbuf, 360 - rc->rotation);\n\tg_object_unref (scaled_pixbuf);\n\t\n\treturn rotated_pixbuf;\n}"", ""target"": 0}]","[{""func_name"": ""tiff_document_render"", ""file_path"": ""backend/tiff/tiff-document.c"", ""func_code"": ""static cairo_surface_t *\ntiff_document_render (EvDocument      *document,\n\t\t      EvRenderContext *rc)\n{\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tint width, height;\n\tint scaled_width, scaled_height;\n\tfloat x_res, y_res;\n\tgint rowstride, bytes;\n\tguchar *pixels = NULL;\n\tguchar *p;\n\tint orientation;\n\tcairo_surface_t *surface;\n\tcairo_surface_t *rotated_surface;\n\tstatic const cairo_user_data_key_t key;\n\t\n\tg_return_val_if_fail (TIFF_IS_DOCUMENT (document), NULL);\n\tg_return_val_if_fail (tiff_document->tiff != NULL, NULL);\n  \n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, rc->page->index) != 1) {\n\t\tpop_handlers ();\n\t\tg_warning(\""Failed to select page %d\"", rc->page->index);\n\t\treturn NULL;\n\t}\n\n\tif (!TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &width)) {\n\t\tpop_handlers ();\n\t\tg_warning(\""Failed to read image width\"");\n\t\treturn NULL;\n\t}\n\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tpop_handlers ();\n\t\tg_warning(\""Failed to read image height\"");\n\t\treturn NULL;\n\t}\n\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_ORIENTATION, &orientation)) {\n\t\torientation = ORIENTATION_TOPLEFT;\n\t}\n\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\t\n\tpop_handlers ();\n  \n\t/* Sanity check the doc */\n\tif (width <= 0 || height <= 0) {\n\t\tg_warning(\""Invalid width or height.\"");\n\t\treturn NULL;\n\t}\n\n\trowstride = cairo_format_stride_for_width (CAIRO_FORMAT_RGB24, width);\n\tif (rowstride / 4 != width) {\n\t\tg_warning(\""Overflow while rendering document.\"");\n\t\t/* overflow, or cairo was changed in an unsupported way */\n\t\treturn NULL;                \n\t}\n\t\n\tif (height >= INT_MAX / rowstride) {\n\t\tg_warning(\""Overflow while rendering document.\"");\n\t\t/* overflow */\n\t\treturn NULL;\n\t}\n\tbytes = height * rowstride;\n\t\n\tpixels = g_try_malloc (bytes);\n\tif (!pixels) {\n\t\tg_warning(\""Failed to allocate memory for rendering.\"");\n\t\treturn NULL;\n\t}\n\n\tif (!TIFFReadRGBAImageOriented (tiff_document->tiff,\n\t\t\t\t\twidth, height,\n\t\t\t\t\t(uint32 *)pixels,\n\t\t\t\t\torientation, 0)) {\n\t\tg_warning (\""Failed to read TIFF image.\"");\n\t\tg_free (pixels);\n\t\treturn NULL;\n\t}\n\n\tsurface = cairo_image_surface_create_for_data (pixels,\n\t\t\t\t\t\t       CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t       width, height,\n\t\t\t\t\t\t       rowstride);\n\tcairo_surface_set_user_data (surface, &key,\n\t\t\t\t     pixels, (cairo_destroy_func_t)g_free);\n\tpop_handlers ();\n\n\t/* Convert the format returned by libtiff to\n\t* what cairo expects\n\t*/\n\tp = pixels;\n\twhile (p < pixels + bytes) {\n\t\tguint32 *pixel = (guint32*)p;\n\t\tguint8 r = TIFFGetR(*pixel);\n\t\tguint8 g = TIFFGetG(*pixel);\n\t\tguint8 b = TIFFGetB(*pixel);\n\t\tguint8 a = TIFFGetA(*pixel);\n\n\t\t*pixel = (a << 24) | (r << 16) | (g << 8) | b;\n\n\t\tp += 4;\n\t}\n\n\tev_render_context_compute_scaled_size (rc, width, height * (x_res / y_res),\n\t\t\t\t\t       &scaled_width, &scaled_height);\n\trotated_surface = ev_document_misc_surface_rotate_and_scale (surface,\n\t\t\t\t\t\t\t\t     scaled_width, scaled_height,\n\t\t\t\t\t\t\t\t     rc->rotation);\n\tcairo_surface_destroy (surface);\n\t\n\treturn rotated_surface;\n}""}, {""func_name"": ""tiff_document_get_thumbnail"", ""file_path"": ""backend/tiff/tiff-document.c"", ""func_code"": ""static GdkPixbuf *\ntiff_document_get_thumbnail (EvDocument      *document,\n\t\t\t     EvRenderContext *rc)\n{\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tint width, height;\n\tint scaled_width, scaled_height;\n\tfloat x_res, y_res;\n\tgint rowstride, bytes;\n\tguchar *pixels = NULL;\n\tGdkPixbuf *pixbuf;\n\tGdkPixbuf *scaled_pixbuf;\n\tGdkPixbuf *rotated_pixbuf;\n\t\n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, rc->page->index) != 1) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\n\tif (!TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &width)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\t\n\tpop_handlers ();\n  \n\t/* Sanity check the doc */\n\tif (width <= 0 || height <= 0)\n\t\treturn NULL;                \n\n\tif (width >= INT_MAX / 4)\n\t\t/* overflow */\n\t\treturn NULL;                \n\trowstride = width * 4;\n        \n\tif (height >= INT_MAX / rowstride)\n\t\t/* overflow */\n\t\treturn NULL;                \n\tbytes = height * rowstride;\n\t\n\tpixels = g_try_malloc (bytes);\n\tif (!pixels)\n\t\treturn NULL;\n\t\n\tif (!TIFFReadRGBAImageOriented (tiff_document->tiff,\n\t\t\t\t\twidth, height,\n\t\t\t\t\t(uint32 *)pixels,\n\t\t\t\t\tORIENTATION_TOPLEFT, 0)) {\n\t\tg_free (pixels);\n\t\treturn NULL;\n\t}\n\n\tpixbuf = gdk_pixbuf_new_from_data (pixels, GDK_COLORSPACE_RGB, TRUE, 8, \n\t\t\t\t\t   width, height, rowstride,\n\t\t\t\t\t   (GdkPixbufDestroyNotify) g_free, NULL);\n\tpop_handlers ();\n\n\tev_render_context_compute_scaled_size (rc, width, height * (x_res / y_res),\n\t\t\t\t\t       &scaled_width, &scaled_height);\n\tscaled_pixbuf = gdk_pixbuf_scale_simple (pixbuf,\n\t\t\t\t\t\t scaled_width, scaled_height,\n\t\t\t\t\t\t GDK_INTERP_BILINEAR);\n\tg_object_unref (pixbuf);\n\t\n\trotated_pixbuf = gdk_pixbuf_rotate_simple (scaled_pixbuf, 360 - rc->rotation);\n\tg_object_unref (scaled_pixbuf);\n\t\n\treturn rotated_pixbuf;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:tiff-document.c, lines:370-385)"", ""result"": ""\tif (width <= 0 || height <= 0)\n\t\treturn NULL;                \n\n\tif (width >= INT_MAX / 4)\n\t\t/* overflow */\n\t\treturn NULL;                \n\trowstride = width * 4;\n        \n\tif (height >= INT_MAX / rowstride)\n\t\t/* overflow */\n\t\treturn NULL;                \n\tbytes = height * rowstride;\n\t\n\tpixels = g_try_malloc (bytes);\n\tif (!pixels)\n\t\treturn NULL;\n""}, {""source"": ""value_info(file:tiff-document.c, value:pixels)"", ""result"": {""value_trace"": [{""full_code"": ""*pixels = NULL"", ""line"": 233, ""func_name"": ""tiff_document_render""}, {""full_code"": ""pixels = g_try_malloc (bytes)"", ""line"": 290, ""func_name"": ""tiff_document_render""}, {""full_code"": ""*pixels = NULL"", ""line"": 344, ""func_name"": ""tiff_document_get_thumbnail""}, {""full_code"": ""pixels = g_try_malloc (bytes)"", ""line"": 383, ""func_name"": ""tiff_document_get_thumbnail""}], ""struct_var"": ""pixels"", ""struct_type"": ""guchar*"", ""struct_definition"": ""guchar""}}]","backend/tiff/tiff-document.c:385-391: Failure to check the return value of TIFFReadRGBAImageOriented() allowed uninitialized 'pixels' to be used in gdk_pixbuf_new_from_data(). Allocation of 'pixels' occurs via 'g_try_malloc' in lines 370-385 (backend/tiff/tiff-document.c), with error handling for allocation failure. The vulnerability existed because TIFFReadRGBAImageOriented() failure was not checked, leaving 'pixels' data potentially uninitialized.",0.95,./github/other_context/CVE-2019-11459
62,CVE-2019-11338,CWE-476,c_cpp,"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",https://github.com/FFmpeg/FFmpeg/commit/9ccc633068c6fe76989f487c8932bd11886ad65b,avcodec/hevcdec: Avoid only partly skiping duplicate first slices\n\nFixes: NULL pointer dereference and out of array access\nFixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432\nFixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304\n\nThis also fixes the return code for explode mode\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg\nReviewed-by: James Almer <jamrial@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 54655623a82632e7624714d7b2a3e039dc5faa7e)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>,2,"[{""func_name"": ""decode_nal_unit"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \""First slice in a frame missing.\\n\"");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Non-matching NAL types of the VCL NALUs: %d %d\\n\"",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Error constructing the reference lists for the current slice.\\n\"");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \""Skipping NAL unit %d\\n\"", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""hls_slice_header"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int hls_slice_header(HEVCContext *s)\n{\n    GetBitContext *gb = &s->HEVClc->gb;\n    SliceHeader *sh   = &s->sh;\n    int i, ret;\n\n    // Coded parameters\n    sh->first_slice_in_pic_flag = get_bits1(gb);\n    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        if (IS_IDR(s))\n            ff_hevc_clear_refs(s);\n    }\n    sh->no_output_of_prior_pics_flag = 0;\n    if (IS_IRAP(s))\n        sh->no_output_of_prior_pics_flag = get_bits1(gb);\n\n    sh->pps_id = get_ue_golomb_long(gb);\n    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS id out of range: %d\\n\"", sh->pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sh->first_slice_in_pic_flag &&\n        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS changed between slices.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;\n    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)\n        sh->no_output_of_prior_pics_flag = 1;\n\n    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {\n        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;\n        const HEVCSPS *last_sps = s->ps.sps;\n        enum AVPixelFormat pix_fmt;\n\n        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {\n            if (sps->width != last_sps->width || sps->height != last_sps->height ||\n                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=\n                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)\n                sh->no_output_of_prior_pics_flag = 0;\n        }\n        ff_hevc_clear_refs(s);\n\n        pix_fmt = get_format(s, sps);\n        if (pix_fmt < 0)\n            return pix_fmt;\n\n        ret = set_sps(s, sps, pix_fmt);\n        if (ret < 0)\n            return ret;\n\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n    }\n\n    sh->dependent_slice_segment_flag = 0;\n    if (!sh->first_slice_in_pic_flag) {\n        int slice_address_length;\n\n        if (s->ps.pps->dependent_slice_segments_enabled_flag)\n            sh->dependent_slice_segment_flag = get_bits1(gb);\n\n        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *\n                                            s->ps.sps->ctb_height);\n        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Invalid slice segment address: %u.\\n\"",\n                   sh->slice_segment_addr);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!sh->dependent_slice_segment_flag) {\n            sh->slice_addr = sh->slice_segment_addr;\n            s->slice_idx++;\n        }\n    } else {\n        sh->slice_segment_addr = sh->slice_addr = 0;\n        s->slice_idx           = 0;\n        s->slice_initialized   = 0;\n    }\n\n    if (!sh->dependent_slice_segment_flag) {\n        s->slice_initialized = 0;\n\n        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)\n            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]\n\n        sh->slice_type = get_ue_golomb_long(gb);\n        if (!(sh->slice_type == HEVC_SLICE_I ||\n              sh->slice_type == HEVC_SLICE_P ||\n              sh->slice_type == HEVC_SLICE_B)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Unknown slice type: %d.\\n\"",\n                   sh->slice_type);\n            return AVERROR_INVALIDDATA;\n        }\n        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Inter slices in an IRAP frame.\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n\n        // when flag is not present, picture is inferred to be output\n        sh->pic_output_flag = 1;\n        if (s->ps.pps->output_flag_present_flag)\n            sh->pic_output_flag = get_bits1(gb);\n\n        if (s->ps.sps->separate_colour_plane_flag)\n            sh->colour_plane_id = get_bits(gb, 2);\n\n        if (!IS_IDR(s)) {\n            int poc, pos;\n\n            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);\n            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);\n            if (!sh->first_slice_in_pic_flag && poc != s->poc) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Ignoring POC change between slices: %d -> %d\\n\"", s->poc, poc);\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n                poc = s->poc;\n            }\n            s->poc = poc;\n\n            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);\n            pos = get_bits_left(gb);\n            if (!sh->short_term_ref_pic_set_sps_flag) {\n                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);\n                if (ret < 0)\n                    return ret;\n\n                sh->short_term_rps = &sh->slice_rps;\n            } else {\n                int numbits, rps_idx;\n\n                if (!s->ps.sps->nb_st_rps) {\n                    av_log(s->avctx, AV_LOG_ERROR, \""No ref lists in the SPS.\\n\"");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);\n                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;\n                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];\n            }\n            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            pos = get_bits_left(gb);\n            ret = decode_lt_rps(s, &sh->long_term_rps, gb);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Invalid long term RPS.\\n\"");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            if (s->ps.sps->sps_temporal_mvp_enabled_flag)\n                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);\n            else\n                sh->slice_temporal_mvp_enabled_flag = 0;\n        } else {\n            s->sh.short_term_rps = NULL;\n            s->poc               = 0;\n        }\n\n        /* 8.3.1 */\n        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&\n            s->nal_unit_type != HEVC_NAL_TRAIL_N &&\n            s->nal_unit_type != HEVC_NAL_TSA_N   &&\n            s->nal_unit_type != HEVC_NAL_STSA_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_R  &&\n            s->nal_unit_type != HEVC_NAL_RASL_N  &&\n            s->nal_unit_type != HEVC_NAL_RASL_R)\n            s->pocTid0 = s->poc;\n\n        if (s->ps.sps->sao_enabled) {\n            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);\n            if (s->ps.sps->chroma_format_idc) {\n                sh->slice_sample_adaptive_offset_flag[1] =\n                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);\n            }\n        } else {\n            sh->slice_sample_adaptive_offset_flag[0] = 0;\n            sh->slice_sample_adaptive_offset_flag[1] = 0;\n            sh->slice_sample_adaptive_offset_flag[2] = 0;\n        }\n\n        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;\n        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {\n            int nb_refs;\n\n            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;\n\n            if (get_bits1(gb)) { // num_ref_idx_active_override_flag\n                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;\n            }\n            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Too many refs: %d/%d.\\n\"",\n                       sh->nb_refs[L0], sh->nb_refs[L1]);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->rpl_modification_flag[0] = 0;\n            sh->rpl_modification_flag[1] = 0;\n            nb_refs = ff_hevc_frame_nb_refs(s);\n            if (!nb_refs) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Zero refs for a frame with P or B slices.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {\n                sh->rpl_modification_flag[0] = get_bits1(gb);\n                if (sh->rpl_modification_flag[0]) {\n                    for (i = 0; i < sh->nb_refs[L0]; i++)\n                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n\n                if (sh->slice_type == HEVC_SLICE_B) {\n                    sh->rpl_modification_flag[1] = get_bits1(gb);\n                    if (sh->rpl_modification_flag[1] == 1)\n                        for (i = 0; i < sh->nb_refs[L1]; i++)\n                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n            }\n\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->mvd_l1_zero_flag = get_bits1(gb);\n\n            if (s->ps.pps->cabac_init_present_flag)\n                sh->cabac_init_flag = get_bits1(gb);\n            else\n                sh->cabac_init_flag = 0;\n\n            sh->collocated_ref_idx = 0;\n            if (sh->slice_temporal_mvp_enabled_flag) {\n                sh->collocated_list = L0;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->collocated_list = !get_bits1(gb);\n\n                if (sh->nb_refs[sh->collocated_list] > 1) {\n                    sh->collocated_ref_idx = get_ue_golomb_long(gb);\n                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \""Invalid collocated_ref_idx: %d.\\n\"",\n                               sh->collocated_ref_idx);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||\n                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {\n                int ret = pred_weight_table(s, gb);\n                if (ret < 0)\n                    return ret;\n            }\n\n            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);\n            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \""Invalid number of merging MVP candidates: %d.\\n\"",\n                       sh->max_num_merge_cand);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        sh->slice_qp_delta = get_se_golomb(gb);\n\n        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {\n            sh->slice_cb_qp_offset = get_se_golomb(gb);\n            sh->slice_cr_qp_offset = get_se_golomb(gb);\n        } else {\n            sh->slice_cb_qp_offset = 0;\n            sh->slice_cr_qp_offset = 0;\n        }\n\n        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)\n            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);\n        else\n            sh->cu_chroma_qp_offset_enabled_flag = 0;\n\n        if (s->ps.pps->deblocking_filter_control_present_flag) {\n            int deblocking_filter_override_flag = 0;\n\n            if (s->ps.pps->deblocking_filter_override_enabled_flag)\n                deblocking_filter_override_flag = get_bits1(gb);\n\n            if (deblocking_filter_override_flag) {\n                sh->disable_deblocking_filter_flag = get_bits1(gb);\n                if (!sh->disable_deblocking_filter_flag) {\n                    int beta_offset_div2 = get_se_golomb(gb);\n                    int tc_offset_div2   = get_se_golomb(gb) ;\n                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||\n                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                            \""Invalid deblock filter offsets: %d, %d\\n\"",\n                            beta_offset_div2, tc_offset_div2);\n                        return AVERROR_INVALIDDATA;\n                    }\n                    sh->beta_offset = beta_offset_div2 * 2;\n                    sh->tc_offset   =   tc_offset_div2 * 2;\n                }\n            } else {\n                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;\n                sh->beta_offset                    = s->ps.pps->beta_offset;\n                sh->tc_offset                      = s->ps.pps->tc_offset;\n            }\n        } else {\n            sh->disable_deblocking_filter_flag = 0;\n            sh->beta_offset                    = 0;\n            sh->tc_offset                      = 0;\n        }\n\n        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&\n            (sh->slice_sample_adaptive_offset_flag[0] ||\n             sh->slice_sample_adaptive_offset_flag[1] ||\n             !sh->disable_deblocking_filter_flag)) {\n            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n        } else {\n            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;\n        }\n    } else if (!s->slice_initialized) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Independent slice segment missing.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->num_entry_point_offsets = 0;\n    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {\n        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);\n        // It would be possible to bound this tighter but this here is simpler\n        if (num_entry_point_offsets > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""num_entry_point_offsets %d is invalid\\n\"", num_entry_point_offsets);\n            return AVERROR_INVALIDDATA;\n        }\n\n        sh->num_entry_point_offsets = num_entry_point_offsets;\n        if (sh->num_entry_point_offsets > 0) {\n            int offset_len = get_ue_golomb_long(gb) + 1;\n\n            if (offset_len < 1 || offset_len > 32) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""offset_len %d is invalid\\n\"", offset_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            av_freep(&sh->entry_point_offset);\n            av_freep(&sh->offset);\n            av_freep(&sh->size);\n            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));\n            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            if (!sh->entry_point_offset || !sh->offset || !sh->size) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""Failed to allocate memory\\n\"");\n                return AVERROR(ENOMEM);\n            }\n            for (i = 0; i < sh->num_entry_point_offsets; i++) {\n                unsigned val = get_bits_long(gb, offset_len);\n                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size\n            }\n            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {\n                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here\n                s->threads_number = 1;\n            } else\n                s->enable_parallel_tiles = 0;\n        } else\n            s->enable_parallel_tiles = 0;\n    }\n\n    if (s->ps.pps->slice_header_extension_present_flag) {\n        unsigned int length = get_ue_golomb_long(gb);\n        if (length*8LL > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""too many slice_header_extension_data_bytes\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < length; i++)\n            skip_bits(gb, 8);  // slice_header_extension_data_byte\n    }\n\n    // Inferred parameters\n    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;\n    if (sh->slice_qp > 51 ||\n        sh->slice_qp < -s->ps.sps->qp_bd_offset) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""The slice_qp %d is outside the valid range \""\n               \""[%d, 51].\\n\"",\n               sh->slice_qp,\n               -s->ps.sps->qp_bd_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->slice_ctb_addr_rs = sh->slice_segment_addr;\n\n    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Impossible slice segment.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (get_bits_left(gb) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""Overread slice header by %d bits\\n\"", -get_bits_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;\n\n    if (!s->ps.pps->cu_qp_delta_enabled_flag)\n        s->HEVClc->qp_y = s->sh.slice_qp;\n\n    s->slice_initialized = 1;\n    s->HEVClc->tu.cu_qp_offset_cb = 0;\n    s->HEVClc->tu.cu_qp_offset_cr = 0;\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""decode_nal_unit"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \""First slice in a frame missing.\\n\"");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Non-matching NAL types of the VCL NALUs: %d %d\\n\"",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Error constructing the reference lists for the current slice.\\n\"");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \""Skipping NAL unit %d\\n\"", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}""}, {""func_name"": ""hls_slice_header"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int hls_slice_header(HEVCContext *s)\n{\n    GetBitContext *gb = &s->HEVClc->gb;\n    SliceHeader *sh   = &s->sh;\n    int i, ret;\n\n    // Coded parameters\n    sh->first_slice_in_pic_flag = get_bits1(gb);\n    if (s->ref && sh->first_slice_in_pic_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n        return 1; // This slice will be skiped later, do not corrupt state\n    }\n\n    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        if (IS_IDR(s))\n            ff_hevc_clear_refs(s);\n    }\n    sh->no_output_of_prior_pics_flag = 0;\n    if (IS_IRAP(s))\n        sh->no_output_of_prior_pics_flag = get_bits1(gb);\n\n    sh->pps_id = get_ue_golomb_long(gb);\n    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS id out of range: %d\\n\"", sh->pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sh->first_slice_in_pic_flag &&\n        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS changed between slices.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;\n    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)\n        sh->no_output_of_prior_pics_flag = 1;\n\n    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {\n        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;\n        const HEVCSPS *last_sps = s->ps.sps;\n        enum AVPixelFormat pix_fmt;\n\n        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {\n            if (sps->width != last_sps->width || sps->height != last_sps->height ||\n                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=\n                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)\n                sh->no_output_of_prior_pics_flag = 0;\n        }\n        ff_hevc_clear_refs(s);\n\n        pix_fmt = get_format(s, sps);\n        if (pix_fmt < 0)\n            return pix_fmt;\n\n        ret = set_sps(s, sps, pix_fmt);\n        if (ret < 0)\n            return ret;\n\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n    }\n\n    sh->dependent_slice_segment_flag = 0;\n    if (!sh->first_slice_in_pic_flag) {\n        int slice_address_length;\n\n        if (s->ps.pps->dependent_slice_segments_enabled_flag)\n            sh->dependent_slice_segment_flag = get_bits1(gb);\n\n        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *\n                                            s->ps.sps->ctb_height);\n        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Invalid slice segment address: %u.\\n\"",\n                   sh->slice_segment_addr);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!sh->dependent_slice_segment_flag) {\n            sh->slice_addr = sh->slice_segment_addr;\n            s->slice_idx++;\n        }\n    } else {\n        sh->slice_segment_addr = sh->slice_addr = 0;\n        s->slice_idx           = 0;\n        s->slice_initialized   = 0;\n    }\n\n    if (!sh->dependent_slice_segment_flag) {\n        s->slice_initialized = 0;\n\n        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)\n            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]\n\n        sh->slice_type = get_ue_golomb_long(gb);\n        if (!(sh->slice_type == HEVC_SLICE_I ||\n              sh->slice_type == HEVC_SLICE_P ||\n              sh->slice_type == HEVC_SLICE_B)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Unknown slice type: %d.\\n\"",\n                   sh->slice_type);\n            return AVERROR_INVALIDDATA;\n        }\n        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Inter slices in an IRAP frame.\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n\n        // when flag is not present, picture is inferred to be output\n        sh->pic_output_flag = 1;\n        if (s->ps.pps->output_flag_present_flag)\n            sh->pic_output_flag = get_bits1(gb);\n\n        if (s->ps.sps->separate_colour_plane_flag)\n            sh->colour_plane_id = get_bits(gb, 2);\n\n        if (!IS_IDR(s)) {\n            int poc, pos;\n\n            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);\n            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);\n            if (!sh->first_slice_in_pic_flag && poc != s->poc) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Ignoring POC change between slices: %d -> %d\\n\"", s->poc, poc);\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n                poc = s->poc;\n            }\n            s->poc = poc;\n\n            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);\n            pos = get_bits_left(gb);\n            if (!sh->short_term_ref_pic_set_sps_flag) {\n                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);\n                if (ret < 0)\n                    return ret;\n\n                sh->short_term_rps = &sh->slice_rps;\n            } else {\n                int numbits, rps_idx;\n\n                if (!s->ps.sps->nb_st_rps) {\n                    av_log(s->avctx, AV_LOG_ERROR, \""No ref lists in the SPS.\\n\"");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);\n                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;\n                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];\n            }\n            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            pos = get_bits_left(gb);\n            ret = decode_lt_rps(s, &sh->long_term_rps, gb);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Invalid long term RPS.\\n\"");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            if (s->ps.sps->sps_temporal_mvp_enabled_flag)\n                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);\n            else\n                sh->slice_temporal_mvp_enabled_flag = 0;\n        } else {\n            s->sh.short_term_rps = NULL;\n            s->poc               = 0;\n        }\n\n        /* 8.3.1 */\n        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&\n            s->nal_unit_type != HEVC_NAL_TRAIL_N &&\n            s->nal_unit_type != HEVC_NAL_TSA_N   &&\n            s->nal_unit_type != HEVC_NAL_STSA_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_R  &&\n            s->nal_unit_type != HEVC_NAL_RASL_N  &&\n            s->nal_unit_type != HEVC_NAL_RASL_R)\n            s->pocTid0 = s->poc;\n\n        if (s->ps.sps->sao_enabled) {\n            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);\n            if (s->ps.sps->chroma_format_idc) {\n                sh->slice_sample_adaptive_offset_flag[1] =\n                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);\n            }\n        } else {\n            sh->slice_sample_adaptive_offset_flag[0] = 0;\n            sh->slice_sample_adaptive_offset_flag[1] = 0;\n            sh->slice_sample_adaptive_offset_flag[2] = 0;\n        }\n\n        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;\n        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {\n            int nb_refs;\n\n            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;\n\n            if (get_bits1(gb)) { // num_ref_idx_active_override_flag\n                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;\n            }\n            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Too many refs: %d/%d.\\n\"",\n                       sh->nb_refs[L0], sh->nb_refs[L1]);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->rpl_modification_flag[0] = 0;\n            sh->rpl_modification_flag[1] = 0;\n            nb_refs = ff_hevc_frame_nb_refs(s);\n            if (!nb_refs) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Zero refs for a frame with P or B slices.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {\n                sh->rpl_modification_flag[0] = get_bits1(gb);\n                if (sh->rpl_modification_flag[0]) {\n                    for (i = 0; i < sh->nb_refs[L0]; i++)\n                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n\n                if (sh->slice_type == HEVC_SLICE_B) {\n                    sh->rpl_modification_flag[1] = get_bits1(gb);\n                    if (sh->rpl_modification_flag[1] == 1)\n                        for (i = 0; i < sh->nb_refs[L1]; i++)\n                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n            }\n\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->mvd_l1_zero_flag = get_bits1(gb);\n\n            if (s->ps.pps->cabac_init_present_flag)\n                sh->cabac_init_flag = get_bits1(gb);\n            else\n                sh->cabac_init_flag = 0;\n\n            sh->collocated_ref_idx = 0;\n            if (sh->slice_temporal_mvp_enabled_flag) {\n                sh->collocated_list = L0;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->collocated_list = !get_bits1(gb);\n\n                if (sh->nb_refs[sh->collocated_list] > 1) {\n                    sh->collocated_ref_idx = get_ue_golomb_long(gb);\n                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \""Invalid collocated_ref_idx: %d.\\n\"",\n                               sh->collocated_ref_idx);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||\n                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {\n                int ret = pred_weight_table(s, gb);\n                if (ret < 0)\n                    return ret;\n            }\n\n            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);\n            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \""Invalid number of merging MVP candidates: %d.\\n\"",\n                       sh->max_num_merge_cand);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        sh->slice_qp_delta = get_se_golomb(gb);\n\n        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {\n            sh->slice_cb_qp_offset = get_se_golomb(gb);\n            sh->slice_cr_qp_offset = get_se_golomb(gb);\n        } else {\n            sh->slice_cb_qp_offset = 0;\n            sh->slice_cr_qp_offset = 0;\n        }\n\n        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)\n            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);\n        else\n            sh->cu_chroma_qp_offset_enabled_flag = 0;\n\n        if (s->ps.pps->deblocking_filter_control_present_flag) {\n            int deblocking_filter_override_flag = 0;\n\n            if (s->ps.pps->deblocking_filter_override_enabled_flag)\n                deblocking_filter_override_flag = get_bits1(gb);\n\n            if (deblocking_filter_override_flag) {\n                sh->disable_deblocking_filter_flag = get_bits1(gb);\n                if (!sh->disable_deblocking_filter_flag) {\n                    int beta_offset_div2 = get_se_golomb(gb);\n                    int tc_offset_div2   = get_se_golomb(gb) ;\n                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||\n                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                            \""Invalid deblock filter offsets: %d, %d\\n\"",\n                            beta_offset_div2, tc_offset_div2);\n                        return AVERROR_INVALIDDATA;\n                    }\n                    sh->beta_offset = beta_offset_div2 * 2;\n                    sh->tc_offset   =   tc_offset_div2 * 2;\n                }\n            } else {\n                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;\n                sh->beta_offset                    = s->ps.pps->beta_offset;\n                sh->tc_offset                      = s->ps.pps->tc_offset;\n            }\n        } else {\n            sh->disable_deblocking_filter_flag = 0;\n            sh->beta_offset                    = 0;\n            sh->tc_offset                      = 0;\n        }\n\n        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&\n            (sh->slice_sample_adaptive_offset_flag[0] ||\n             sh->slice_sample_adaptive_offset_flag[1] ||\n             !sh->disable_deblocking_filter_flag)) {\n            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n        } else {\n            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;\n        }\n    } else if (!s->slice_initialized) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Independent slice segment missing.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->num_entry_point_offsets = 0;\n    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {\n        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);\n        // It would be possible to bound this tighter but this here is simpler\n        if (num_entry_point_offsets > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""num_entry_point_offsets %d is invalid\\n\"", num_entry_point_offsets);\n            return AVERROR_INVALIDDATA;\n        }\n\n        sh->num_entry_point_offsets = num_entry_point_offsets;\n        if (sh->num_entry_point_offsets > 0) {\n            int offset_len = get_ue_golomb_long(gb) + 1;\n\n            if (offset_len < 1 || offset_len > 32) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""offset_len %d is invalid\\n\"", offset_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            av_freep(&sh->entry_point_offset);\n            av_freep(&sh->offset);\n            av_freep(&sh->size);\n            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));\n            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            if (!sh->entry_point_offset || !sh->offset || !sh->size) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""Failed to allocate memory\\n\"");\n                return AVERROR(ENOMEM);\n            }\n            for (i = 0; i < sh->num_entry_point_offsets; i++) {\n                unsigned val = get_bits_long(gb, offset_len);\n                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size\n            }\n            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {\n                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here\n                s->threads_number = 1;\n            } else\n                s->enable_parallel_tiles = 0;\n        } else\n            s->enable_parallel_tiles = 0;\n    }\n\n    if (s->ps.pps->slice_header_extension_present_flag) {\n        unsigned int length = get_ue_golomb_long(gb);\n        if (length*8LL > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""too many slice_header_extension_data_bytes\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < length; i++)\n            skip_bits(gb, 8);  // slice_header_extension_data_byte\n    }\n\n    // Inferred parameters\n    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;\n    if (sh->slice_qp > 51 ||\n        sh->slice_qp < -s->ps.sps->qp_bd_offset) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""The slice_qp %d is outside the valid range \""\n               \""[%d, 51].\\n\"",\n               sh->slice_qp,\n               -s->ps.sps->qp_bd_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->slice_ctb_addr_rs = sh->slice_segment_addr;\n\n    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Impossible slice segment.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (get_bits_left(gb) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""Overread slice header by %d bits\\n\"", -get_bits_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;\n\n    if (!s->ps.pps->cu_qp_delta_enabled_flag)\n        s->HEVClc->qp_y = s->sh.slice_qp;\n\n    s->slice_initialized = 1;\n    s->HEVClc->tu.cu_qp_offset_cb = 0;\n    s->HEVClc->tu.cu_qp_offset_cr = 0;\n\n    return 0;\n}""}]","{""value"": 4, ""code"": 4, ""function"": 5}","[{""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:hevcdec.c, lines:2800-2820)"", ""result"": ""\n    if (!s->avctx->hwaccel)\n        ff_thread_finish_setup(s->avctx);\n\n    return 0;\n\nfail:\n    if (s->ref)\n        ff_hevc_unref_frame(s, s->ref, ~0);\n    s->ref = NULL;\n    return ret;\n}\n\nstatic int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n""}, {""source"": ""func_info(file:hevcdec.c, func:hevc_frame_start)"", ""result"": [{""code"": ""static int hevc_frame_start(HEVCContext *s)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    int pic_size_in_ctb  = ((s->ps.sps->width  >> s->ps.sps->log2_min_cb_size) + 1) *\n                           ((s->ps.sps->height >> s->ps.sps->log2_min_cb_size) + 1);\n    int ret;\n\n    memset(s->horizontal_bs, 0, s->bs_width * s->bs_height);\n    memset(s->vertical_bs,   0, s->bs_width * s->bs_height);\n    memset(s->cbf_luma,      0, s->ps.sps->min_tb_width * s->ps.sps->min_tb_height);\n    memset(s->is_pcm,        0, (s->ps.sps->min_pu_width + 1) * (s->ps.sps->min_pu_height + 1));\n    memset(s->tab_slice_address, -1, pic_size_in_ctb * sizeof(*s->tab_slice_address));\n\n    s->is_decoded        = 0;\n    s->first_nal_type    = s->nal_unit_type;\n\n    s->no_rasl_output_flag = IS_IDR(s) || IS_BLA(s) || (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos);\n\n    if (s->ps.pps->tiles_enabled_flag)\n        lc->end_of_tiles_x = s->ps.pps->column_width[0] << s->ps.sps->log2_ctb_size;\n\n    ret = ff_hevc_set_new_ref(s, &s->frame, s->poc);\n    if (ret < 0)\n        goto fail;\n\n    ret = ff_hevc_frame_rps(s);\n    if (ret < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Error constructing the frame RPS.\\n\"");\n        goto fail;\n    }\n\n    s->ref->frame->key_frame = IS_IRAP(s);\n\n    ret = set_side_data(s);\n    if (ret < 0)\n        goto fail;\n\n    s->frame->pict_type = 3 - s->sh.slice_type;\n\n    if (!IS_IRAP(s))\n        ff_hevc_bump_frame(s);\n\n    av_frame_unref(s->output_frame);\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n    if (ret < 0)\n        goto fail;\n\n    if (!s->avctx->hwaccel)\n        ff_thread_finish_setup(s->avctx);\n\n    return 0;\n\nfail:\n    if (s->ref)\n        ff_hevc_unref_frame(s, s->ref, ~0);\n    s->ref = NULL;\n    return ret;\n}\n"", ""start_line"": 2754, ""end_line"": 2811, ""full_name"": ""hevc_frame_start"", ""file_path"": ""libavcodec/hevcdec.c""}]}, {""source"": ""func_info(file:hevcdec.c, func:hls_slice_header)"", ""result"": [{""code"": ""static int hls_slice_header(HEVCContext *s)\n{\n    GetBitContext *gb = &s->HEVClc->gb;\n    SliceHeader *sh   = &s->sh;\n    int i, ret;\n\n    // Coded parameters\n    sh->first_slice_in_pic_flag = get_bits1(gb);\n    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        if (IS_IDR(s))\n            ff_hevc_clear_refs(s);\n    }\n    sh->no_output_of_prior_pics_flag = 0;\n    if (IS_IRAP(s))\n        sh->no_output_of_prior_pics_flag = get_bits1(gb);\n\n    sh->pps_id = get_ue_golomb_long(gb);\n    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS id out of range: %d\\n\"", sh->pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sh->first_slice_in_pic_flag &&\n        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS changed between slices.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;\n    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)\n        sh->no_output_of_prior_pics_flag = 1;\n\n    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {\n        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;\n        const HEVCSPS *last_sps = s->ps.sps;\n        enum AVPixelFormat pix_fmt;\n\n        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {\n            if (sps->width != last_sps->width || sps->height != last_sps->height ||\n                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=\n                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)\n                sh->no_output_of_prior_pics_flag = 0;\n        }\n        ff_hevc_clear_refs(s);\n\n        pix_fmt = get_format(s, sps);\n        if (pix_fmt < 0)\n            return pix_fmt;\n\n        ret = set_sps(s, sps, pix_fmt);\n        if (ret < 0)\n            return ret;\n\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n    }\n\n    sh->dependent_slice_segment_flag = 0;\n    if (!sh->first_slice_in_pic_flag) {\n        int slice_address_length;\n\n        if (s->ps.pps->dependent_slice_segments_enabled_flag)\n            sh->dependent_slice_segment_flag = get_bits1(gb);\n\n        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *\n                                            s->ps.sps->ctb_height);\n        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Invalid slice segment address: %u.\\n\"",\n                   sh->slice_segment_addr);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!sh->dependent_slice_segment_flag) {\n            sh->slice_addr = sh->slice_segment_addr;\n            s->slice_idx++;\n        }\n    } else {\n        sh->slice_segment_addr = sh->slice_addr = 0;\n        s->slice_idx           = 0;\n        s->slice_initialized   = 0;\n    }\n\n    if (!sh->dependent_slice_segment_flag) {\n        s->slice_initialized = 0;\n\n        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)\n            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]\n\n        sh->slice_type = get_ue_golomb_long(gb);\n        if (!(sh->slice_type == HEVC_SLICE_I ||\n              sh->slice_type == HEVC_SLICE_P ||\n              sh->slice_type == HEVC_SLICE_B)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Unknown slice type: %d.\\n\"",\n                   sh->slice_type);\n            return AVERROR_INVALIDDATA;\n        }\n        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Inter slices in an IRAP frame.\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n\n        // when flag is not present, picture is inferred to be output\n        sh->pic_output_flag = 1;\n        if (s->ps.pps->output_flag_present_flag)\n            sh->pic_output_flag = get_bits1(gb);\n\n        if (s->ps.sps->separate_colour_plane_flag)\n            sh->colour_plane_id = get_bits(gb, 2);\n\n        if (!IS_IDR(s)) {\n            int poc, pos;\n\n            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);\n            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);\n            if (!sh->first_slice_in_pic_flag && poc != s->poc) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Ignoring POC change between slices: %d -> %d\\n\"", s->poc, poc);\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n                poc = s->poc;\n            }\n            s->poc = poc;\n\n            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);\n            pos = get_bits_left(gb);\n            if (!sh->short_term_ref_pic_set_sps_flag) {\n                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);\n                if (ret < 0)\n                    return ret;\n\n                sh->short_term_rps = &sh->slice_rps;\n            } else {\n                int numbits, rps_idx;\n\n                if (!s->ps.sps->nb_st_rps) {\n                    av_log(s->avctx, AV_LOG_ERROR, \""No ref lists in the SPS.\\n\"");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);\n                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;\n                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];\n            }\n            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            pos = get_bits_left(gb);\n            ret = decode_lt_rps(s, &sh->long_term_rps, gb);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Invalid long term RPS.\\n\"");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            if (s->ps.sps->sps_temporal_mvp_enabled_flag)\n                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);\n            else\n                sh->slice_temporal_mvp_enabled_flag = 0;\n        } else {\n            s->sh.short_term_rps = NULL;\n            s->poc               = 0;\n        }\n\n        /* 8.3.1 */\n        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&\n            s->nal_unit_type != HEVC_NAL_TRAIL_N &&\n            s->nal_unit_type != HEVC_NAL_TSA_N   &&\n            s->nal_unit_type != HEVC_NAL_STSA_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_R  &&\n            s->nal_unit_type != HEVC_NAL_RASL_N  &&\n            s->nal_unit_type != HEVC_NAL_RASL_R)\n            s->pocTid0 = s->poc;\n\n        if (s->ps.sps->sao_enabled) {\n            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);\n            if (s->ps.sps->chroma_format_idc) {\n                sh->slice_sample_adaptive_offset_flag[1] =\n                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);\n            }\n        } else {\n            sh->slice_sample_adaptive_offset_flag[0] = 0;\n            sh->slice_sample_adaptive_offset_flag[1] = 0;\n            sh->slice_sample_adaptive_offset_flag[2] = 0;\n        }\n\n        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;\n        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {\n            int nb_refs;\n\n            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;\n\n            if (get_bits1(gb)) { // num_ref_idx_active_override_flag\n                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;\n            }\n            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Too many refs: %d/%d.\\n\"",\n                       sh->nb_refs[L0], sh->nb_refs[L1]);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->rpl_modification_flag[0] = 0;\n            sh->rpl_modification_flag[1] = 0;\n            nb_refs = ff_hevc_frame_nb_refs(s);\n            if (!nb_refs) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Zero refs for a frame with P or B slices.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {\n                sh->rpl_modification_flag[0] = get_bits1(gb);\n                if (sh->rpl_modification_flag[0]) {\n                    for (i = 0; i < sh->nb_refs[L0]; i++)\n                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n\n                if (sh->slice_type == HEVC_SLICE_B) {\n                    sh->rpl_modification_flag[1] = get_bits1(gb);\n                    if (sh->rpl_modification_flag[1] == 1)\n                        for (i = 0; i < sh->nb_refs[L1]; i++)\n                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n            }\n\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->mvd_l1_zero_flag = get_bits1(gb);\n\n            if (s->ps.pps->cabac_init_present_flag)\n                sh->cabac_init_flag = get_bits1(gb);\n            else\n                sh->cabac_init_flag = 0;\n\n            sh->collocated_ref_idx = 0;\n            if (sh->slice_temporal_mvp_enabled_flag) {\n                sh->collocated_list = L0;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->collocated_list = !get_bits1(gb);\n\n                if (sh->nb_refs[sh->collocated_list] > 1) {\n                    sh->collocated_ref_idx = get_ue_golomb_long(gb);\n                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \""Invalid collocated_ref_idx: %d.\\n\"",\n                               sh->collocated_ref_idx);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||\n                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {\n                int ret = pred_weight_table(s, gb);\n                if (ret < 0)\n                    return ret;\n            }\n\n            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);\n            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \""Invalid number of merging MVP candidates: %d.\\n\"",\n                       sh->max_num_merge_cand);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        sh->slice_qp_delta = get_se_golomb(gb);\n\n        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {\n            sh->slice_cb_qp_offset = get_se_golomb(gb);\n            sh->slice_cr_qp_offset = get_se_golomb(gb);\n        } else {\n            sh->slice_cb_qp_offset = 0;\n            sh->slice_cr_qp_offset = 0;\n        }\n\n        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)\n            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);\n        else\n            sh->cu_chroma_qp_offset_enabled_flag = 0;\n\n        if (s->ps.pps->deblocking_filter_control_present_flag) {\n            int deblocking_filter_override_flag = 0;\n\n            if (s->ps.pps->deblocking_filter_override_enabled_flag)\n                deblocking_filter_override_flag = get_bits1(gb);\n\n            if (deblocking_filter_override_flag) {\n                sh->disable_deblocking_filter_flag = get_bits1(gb);\n                if (!sh->disable_deblocking_filter_flag) {\n                    int beta_offset_div2 = get_se_golomb(gb);\n                    int tc_offset_div2   = get_se_golomb(gb) ;\n                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||\n                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                            \""Invalid deblock filter offsets: %d, %d\\n\"",\n                            beta_offset_div2, tc_offset_div2);\n                        return AVERROR_INVALIDDATA;\n                    }\n                    sh->beta_offset = beta_offset_div2 * 2;\n                    sh->tc_offset   =   tc_offset_div2 * 2;\n                }\n            } else {\n                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;\n                sh->beta_offset                    = s->ps.pps->beta_offset;\n                sh->tc_offset                      = s->ps.pps->tc_offset;\n            }\n        } else {\n            sh->disable_deblocking_filter_flag = 0;\n            sh->beta_offset                    = 0;\n            sh->tc_offset                      = 0;\n        }\n\n        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&\n            (sh->slice_sample_adaptive_offset_flag[0] ||\n             sh->slice_sample_adaptive_offset_flag[1] ||\n             !sh->disable_deblocking_filter_flag)) {\n            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n        } else {\n            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;\n        }\n    } else if (!s->slice_initialized) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Independent slice segment missing.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->num_entry_point_offsets = 0;\n    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {\n        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);\n        // It would be possible to bound this tighter but this here is simpler\n        if (num_entry_point_offsets > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""num_entry_point_offsets %d is invalid\\n\"", num_entry_point_offsets);\n            return AVERROR_INVALIDDATA;\n        }\n\n        sh->num_entry_point_offsets = num_entry_point_offsets;\n        if (sh->num_entry_point_offsets > 0) {\n            int offset_len = get_ue_golomb_long(gb) + 1;\n\n            if (offset_len < 1 || offset_len > 32) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""offset_len %d is invalid\\n\"", offset_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            av_freep(&sh->entry_point_offset);\n            av_freep(&sh->offset);\n            av_freep(&sh->size);\n            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));\n            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            if (!sh->entry_point_offset || !sh->offset || !sh->size) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""Failed to allocate memory\\n\"");\n                return AVERROR(ENOMEM);\n            }\n            for (i = 0; i < sh->num_entry_point_offsets; i++) {\n                unsigned val = get_bits_long(gb, offset_len);\n                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size\n            }\n            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {\n                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here\n                s->threads_number = 1;\n            } else\n                s->enable_parallel_tiles = 0;\n        } else\n            s->enable_parallel_tiles = 0;\n    }\n\n    if (s->ps.pps->slice_header_extension_present_flag) {\n        unsigned int length = get_ue_golomb_long(gb);\n        if (length*8LL > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""too many slice_header_extension_data_bytes\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < length; i++)\n            skip_bits(gb, 8);  // slice_header_extension_data_byte\n    }\n\n    // Inferred parameters\n    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;\n    if (sh->slice_qp > 51 ||\n        sh->slice_qp < -s->ps.sps->qp_bd_offset) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""The slice_qp %d is outside the valid range \""\n               \""[%d, 51].\\n\"",\n               sh->slice_qp,\n               -s->ps.sps->qp_bd_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->slice_ctb_addr_rs = sh->slice_segment_addr;\n\n    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Impossible slice segment.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (get_bits_left(gb) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""Overread slice header by %d bits\\n\"", -get_bits_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;\n\n    if (!s->ps.pps->cu_qp_delta_enabled_flag)\n        s->HEVClc->qp_y = s->sh.slice_qp;\n\n    s->slice_initialized = 1;\n    s->HEVClc->tu.cu_qp_offset_cb = 0;\n    s->HEVClc->tu.cu_qp_offset_cr = 0;\n\n    return 0;\n}\n"", ""start_line"": 467, ""end_line"": 886, ""full_name"": ""hls_slice_header"", ""file_path"": ""libavcodec/hevcdec.c""}]}, {""source"": ""func_info(func:ff_hevc_set_new_ref)"", ""result"": [{""code"": ""int ff_hevc_set_new_ref(HEVCContext *s, AVFrame **frame, int poc)\n{\n    HEVCFrame *ref;\n    int i;\n\n    /* check that this POC doesn't already exist */\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        HEVCFrame *frame = &s->DPB[i];\n\n        if (frame->frame->buf[0] && frame->sequence == s->seq_decode &&\n            frame->poc == poc) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Duplicate POC in a sequence: %d.\\n\"",\n                   poc);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    ref = alloc_frame(s);\n    if (!ref)\n        return AVERROR(ENOMEM);\n\n    *frame = ref->frame;\n    s->ref = ref;\n\n    if (s->sh.pic_output_flag)\n        ref->flags = HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_SHORT_REF;\n    else\n        ref->flags = HEVC_FRAME_FLAG_SHORT_REF;\n\n    ref->poc      = poc;\n    ref->sequence = s->seq_decode;\n    ref->frame->crop_left   = s->ps.sps->output_window.left_offset;\n    ref->frame->crop_right  = s->ps.sps->output_window.right_offset;\n    ref->frame->crop_top    = s->ps.sps->output_window.top_offset;\n    ref->frame->crop_bottom = s->ps.sps->output_window.bottom_offset;\n\n    return 0;\n}\n"", ""start_line"": 135, ""end_line"": 172, ""full_name"": ""ff_hevc_set_new_ref"", ""file_path"": ""libavcodec/hevc_refs.c""}]}, {""source"": ""code_info(file:hevcdec.c, lines:2700-2750)"", ""result"": ""\n        av_log(s->avctx, AV_LOG_DEBUG, \""Mastering Display Metadata:\\n\"");\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \""r(%5.4f,%5.4f) g(%5.4f,%5.4f) b(%5.4f %5.4f) wp(%5.4f, %5.4f)\\n\"",\n               av_q2d(metadata->display_primaries[0][0]),\n               av_q2d(metadata->display_primaries[0][1]),\n               av_q2d(metadata->display_primaries[1][0]),\n               av_q2d(metadata->display_primaries[1][1]),\n               av_q2d(metadata->display_primaries[2][0]),\n               av_q2d(metadata->display_primaries[2][1]),\n               av_q2d(metadata->white_point[0]), av_q2d(metadata->white_point[1]));\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \""min_luminance=%f, max_luminance=%f\\n\"",\n               av_q2d(metadata->min_luminance), av_q2d(metadata->max_luminance));\n    }\n    // Decrement the mastering display flag when IRAP frame has no_rasl_output_flag=1\n    // so the side data persists for the entire coded video sequence.\n    if (s->sei.content_light.present > 0 &&\n        IS_IRAP(s) && s->no_rasl_output_flag) {\n        s->sei.content_light.present--;\n    }\n    if (s->sei.content_light.present) {\n        AVContentLightMetadata *metadata =\n            av_content_light_metadata_create_side_data(out);\n        if (!metadata)\n            return AVERROR(ENOMEM);\n        metadata->MaxCLL  = s->sei.content_light.max_content_light_level;\n        metadata->MaxFALL = s->sei.content_light.max_pic_average_light_level;\n\n        av_log(s->avctx, AV_LOG_DEBUG, \""Content Light Level Metadata:\\n\"");\n        av_log(s->avctx, AV_LOG_DEBUG, \""MaxCLL=%d, MaxFALL=%d\\n\"",\n               metadata->MaxCLL, metadata->MaxFALL);\n    }\n\n    if (s->sei.a53_caption.a53_caption) {\n        AVFrameSideData* sd = av_frame_new_side_data(out,\n                                                     AV_FRAME_DATA_A53_CC,\n                                                     s->sei.a53_caption.a53_caption_size);\n        if (sd)\n            memcpy(sd->data, s->sei.a53_caption.a53_caption, s->sei.a53_caption.a53_caption_size);\n        av_freep(&s->sei.a53_caption.a53_caption);\n        s->sei.a53_caption.a53_caption_size = 0;\n        s->avctx->properties |= FF_CODEC_PROPERTY_CLOSED_CAPTIONS;\n    }\n\n    if (s->sei.alternative_transfer.present &&\n        av_color_transfer_name(s->sei.alternative_transfer.preferred_transfer_characteristics) &&\n        s->sei.alternative_transfer.preferred_transfer_characteristics != AVCOL_TRC_UNSPECIFIED) {\n        s->avctx->color_trc = out->color_trc = s->sei.alternative_transfer.preferred_transfer_characteristics;\n    }\n\n""}, {""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:ff_hevc_unref_frame)"", ""result"": [{""code"": ""void ff_hevc_unref_frame(HEVCContext *s, HEVCFrame *frame, int flags)\n{\n    /* frame->frame can be NULL if context init failed */\n    if (!frame->frame || !frame->frame->buf[0])\n        return;\n\n    frame->flags &= ~flags;\n    if (!frame->flags) {\n        ff_thread_release_buffer(s->avctx, &frame->tf);\n\n        av_buffer_unref(&frame->tab_mvf_buf);\n        frame->tab_mvf = NULL;\n\n        av_buffer_unref(&frame->rpl_buf);\n        av_buffer_unref(&frame->rpl_tab_buf);\n        frame->rpl_tab    = NULL;\n        frame->refPicList = NULL;\n\n        frame->collocated_ref = NULL;\n\n        av_buffer_unref(&frame->hwaccel_priv_buf);\n        frame->hwaccel_picture_private = NULL;\n    }\n}"", ""start_line"": 32, ""end_line"": 55, ""full_name"": ""ff_hevc_unref_frame"", ""file_path"": ""libavcodec/hevc_refs.c""}]}, {""source"": ""code_info(file:hevcdec.c, lines:3000-3100)"", ""result"": ""\nfail:\n    if (s->ref && s->threads_type == FF_THREAD_FRAME)\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    return ret;\n}\n\nstatic void print_md5(void *log_ctx, int level, uint8_t md5[16])\n{\n    int i;\n    for (i = 0; i < 16; i++)\n        av_log(log_ctx, level, \""%02\""PRIx8, md5[i]);\n}\n\nstatic int verify_md5(HEVCContext *s, AVFrame *frame)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n    int pixel_shift;\n    int i, j;\n\n    if (!desc)\n        return AVERROR(EINVAL);\n\n    pixel_shift = desc->comp[0].depth > 8;\n\n    av_log(s->avctx, AV_LOG_DEBUG, \""Verifying checksum for frame with POC %d: \"",\n           s->poc);\n\n    /* the checksums are LE, so we have to byteswap for >8bpp formats\n     * on BE arches */\n#if HAVE_BIGENDIAN\n    if (pixel_shift && !s->checksum_buf) {\n        av_fast_malloc(&s->checksum_buf, &s->checksum_buf_size,\n                       FFMAX3(frame->linesize[0], frame->linesize[1],\n                              frame->linesize[2]));\n        if (!s->checksum_buf)\n            return AVERROR(ENOMEM);\n    }\n#endif\n\n    for (i = 0; frame->data[i]; i++) {\n        int width  = s->avctx->coded_width;\n        int height = s->avctx->coded_height;\n        int w = (i == 1 || i == 2) ? (width  >> desc->log2_chroma_w) : width;\n        int h = (i == 1 || i == 2) ? (height >> desc->log2_chroma_h) : height;\n        uint8_t md5[16];\n\n        av_md5_init(s->sei.picture_hash.md5_ctx);\n        for (j = 0; j < h; j++) {\n            const uint8_t *src = frame->data[i] + j * frame->linesize[i];\n#if HAVE_BIGENDIAN\n            if (pixel_shift) {\n                s->bdsp.bswap16_buf((uint16_t *) s->checksum_buf,\n                                    (const uint16_t *) src, w);\n                src = s->checksum_buf;\n            }\n#endif\n            av_md5_update(s->sei.picture_hash.md5_ctx, src, w << pixel_shift);\n        }\n        av_md5_final(s->sei.picture_hash.md5_ctx, md5);\n\n        if (!memcmp(md5, s->sei.picture_hash.md5[i], 16)) {\n            av_log   (s->avctx, AV_LOG_DEBUG, \""plane %d - correct \"", i);\n            print_md5(s->avctx, AV_LOG_DEBUG, md5);\n            av_log   (s->avctx, AV_LOG_DEBUG, \""; \"");\n        } else {\n            av_log   (s->avctx, AV_LOG_ERROR, \""mismatching checksum of plane %d - \"", i);\n            print_md5(s->avctx, AV_LOG_ERROR, md5);\n            av_log   (s->avctx, AV_LOG_ERROR, \"" != \"");\n            print_md5(s->avctx, AV_LOG_ERROR, s->sei.picture_hash.md5[i]);\n            av_log   (s->avctx, AV_LOG_ERROR, \""\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    av_log(s->avctx, AV_LOG_DEBUG, \""\\n\"");\n\n    return 0;\n}\n\nstatic int hevc_decode_extradata(HEVCContext *s, uint8_t *buf, int length, int first)\n{\n    int ret, i;\n\n    ret = ff_hevc_decode_extradata(buf, length, &s->ps, &s->sei, &s->is_nalff,\n                                   &s->nal_length_size, s->avctx->err_recognition,\n                                   s->apply_defdispwin, s->avctx);\n    if (ret < 0)\n        return ret;\n\n    /* export stream parameters from the first SPS */\n    for (i = 0; i < FF_ARRAY_ELEMS(s->ps.sps_list); i++) {\n        if (first && s->ps.sps_list[i]) {\n            const HEVCSPS *sps = (const HEVCSPS*)s->ps.sps_list[i]->data;\n            export_stream_params(s->avctx, &s->ps, sps);\n            break;\n        }\n    }\n\n    return 0;\n""}, {""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:hevc_refs.c, lines:10-30)"", ""result"": "" * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \""libavutil/avassert.h\""\n#include \""libavutil/pixdesc.h\""\n\n#include \""internal.h\""\n#include \""thread.h\""\n#include \""hevc.h\""\n#include \""hevcdec.h\""\n""}, {""source"": ""func_info(file:hevcdec.c, func:hevc_decode_frame)"", ""result"": [{""code"": ""static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output,\n                             AVPacket *avpkt)\n{\n    int ret;\n    int new_extradata_size;\n    uint8_t *new_extradata;\n    HEVCContext *s = avctx->priv_data;\n\n    if (!avpkt->size) {\n        ret = ff_hevc_output_frame(s, data, 1);\n        if (ret < 0)\n            return ret;\n\n        *got_output = ret;\n        return 0;\n    }\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                            &new_extradata_size);\n    if (new_extradata && new_extradata_size > 0) {\n        ret = hevc_decode_extradata(s, new_extradata, new_extradata_size, 0);\n        if (ret < 0)\n            return ret;\n    }\n\n    s->ref = NULL;\n    ret    = decode_nal_units(s, avpkt->data, avpkt->size);\n    if (ret < 0)\n        return ret;\n\n    if (avctx->hwaccel) {\n        if (s->ref && (ret = avctx->hwaccel->end_frame(avctx)) < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \""hardware accelerator failed to decode picture\\n\"");\n            ff_hevc_unref_frame(s, s->ref, ~0);\n            return ret;\n        }\n    } else {\n        /* verify the SEI checksum */\n        if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded &&\n            s->sei.picture_hash.is_md5) {\n            ret = verify_md5(s, s->ref->frame);\n            if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) {\n                ff_hevc_unref_frame(s, s->ref, ~0);\n                return ret;\n            }\n        }\n    }\n    s->sei.picture_hash.is_md5 = 0;\n\n    if (s->is_decoded) {\n        av_log(avctx, AV_LOG_DEBUG, \""Decoded frame with POC %d.\\n\"", s->poc);\n        s->is_decoded = 0;\n    }\n\n    if (s->output_frame->buf[0]) {\n        av_frame_move_ref(data, s->output_frame);\n        *got_output = 1;\n    }\n\n    return avpkt->size;\n}\n"", ""start_line"": 3103, ""end_line"": 3164, ""full_name"": ""hevc_decode_frame"", ""file_path"": ""libavcodec/hevcdec.c""}]}]","When processing a HEVC slice, `hls_slice_header` (libavcodec/hevcdec.c:473-477) checks if `s->ref` is already set to detect duplicate `first_slice_in_pic_flag`. If so, it returns 1, which `decode_nal_unit` (libavcodec/hevcdec.c:2863-2867) converts to an error. Before the patch, if `s->ref` was not reset (e.g., due to error paths or invalid state), subsequent code could dereference NULL or access invalid memory. `s->ref` is initialized to NULL in `hevc_frame_start` (libavcodec/hevcdec.c:2809) and assigned via `ff_hevc_set_new_ref` (libavcodec/hevc_refs.c:135-172).",0.95,./github/other_context/CVE-2019-11338
63,CVE-2019-12481,"CWE-787, CWE-476",c_cpp,"An issue was discovered in GPAC 0.7.1. There is a NULL pointer dereference in the function GetESD at isomedia/track.c in libgpac.a, as demonstrated by MP4Box.",https://github.com/gpac/gpac/commit/f40aaaf959d4d1f7fa0dcd04c0666592e615c8f1,fixed a few memory issues (#1249),6,"[{""func_name"": ""gf_isom_get_original_format_type"", ""file_path"": ""src/isomedia/drm_sample.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tMedia_GetSampleDesc(trak->Media, sampleDescriptionIndex, &sea, NULL);\n\tif (!sea) return GF_BAD_PARAM;\n\n\tsinf = (GF_ProtectionSchemeInfoBox*)gf_list_get(sea->protections, 0);\n\tif (outOriginalFormat && sinf->original_format) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""gf_media_get_rfc_6381_codec_name"", ""file_path"": ""src/media_tools/dash_segmenter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tGF_ESD *esd;\n\tGF_AVCConfig *avcc;\n#ifndef GPAC_DISABLE_HEVC\n\tGF_HEVCConfig *hvcc;\n#endif\n\n\tu32 subtype = gf_isom_get_media_subtype(movie, track, 1);\n\n\tif (subtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tGF_Err e;\n\t\tu32 originalFormat=0;\n\t\tif (gf_isom_is_ismacryp_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_ismacryp_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if (gf_isom_is_omadrm_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_omadrm_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if(gf_isom_is_cenc_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_cenc_info(movie, track, 1, &originalFormat, NULL, NULL, NULL);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] Unknown protection scheme type %s\\n\"", gf_4cc_to_str( gf_isom_is_media_encrypted(movie, track, 1)) ));\n\t\t\te = gf_isom_get_original_format_type(movie, track, 1, &originalFormat);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\""[ISOM Tools] Error fetching protection information\\n\""));\n\t\t\treturn e;\n\t\t}\n\n\t\tif (originalFormat) subtype = originalFormat;\n\t}\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\tesd = gf_isom_get_esd(movie, track, 1);\n\t\tif (esd) {\n\t\t\tswitch (esd->decoderConfig->streamType) {\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\tu8 audio_object_type;\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo->dataLength < 2) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381-AAC] invalid DSI size %u < 2\\n\"", esd->decoderConfig->decoderSpecificInfo->dataLength));\n\t\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t}\n\t\t\t\t\t/*5 first bits of AAC config*/\n\t\t\t\t\taudio_object_type = (esd->decoderConfig->decoderSpecificInfo->data[0] & 0xF8) >> 3;\n\t\t\t\t\tif (audio_object_type == 31) { /*escape code*/\n\t\t\t\t\t\tconst u8 audio_object_type_ext = ((esd->decoderConfig->decoderSpecificInfo->data[0] & 0x07) << 3) + ((esd->decoderConfig->decoderSpecificInfo->data[1] & 0xE0) >> 5);\n\t\t\t\t\t\taudio_object_type = 32 + audio_object_type_ext;\n\t\t\t\t\t}\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (force_sbr && (audio_object_type==2) ) {\n\t\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\t\tGF_Err e = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\tif (a_cfg.sbr_sr)\n\t\t\t\t\t\t\t\taudio_object_type = a_cfg.sbr_object_type;\n\t\t\t\t\t\t\tif (a_cfg.has_ps)\n\t\t\t\t\t\t\t\taudio_object_type = 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t#endif\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X.%01d\"", esd->decoderConfig->objectTypeIndication, audio_object_type);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_VISUAL:\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X.%01x\"", esd->decoderConfig->objectTypeIndication, dsi.VideoPL);\n\t\t\t\t} else\n\t#endif\n\t\t\t\t{\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4s.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381] Cannot find ESD. Aborting.\\n\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tavcc = gf_isom_avc_config_get(movie, track, 1);\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC4_H264;\n\t\t}\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tavcc = gf_isom_mvc_config_get(movie, track, 1);\n\t\tif (!avcc) avcc = gf_isom_svc_config_get(movie, track, 1);\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n#ifndef GPAC_DISABLE_HEVC\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_HVC1) subtype = GF_ISOM_SUBTYPE_HEV1;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_HVC2) subtype = GF_ISOM_SUBTYPE_HEV2;\n\t\t}\n\t\thvcc = gf_isom_hevc_config_get(movie, track, 1);\n\t\tif (!hvcc) {\n\t\t\thvcc = gf_isom_lhvc_config_get(movie, track, 1);\n\t\t}\n\t\tif (subtype==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\tu32 refTrack;\n\t\t\tgf_isom_get_reference(movie, track, GF_ISOM_REF_TBAS, 1, &refTrack);\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\thvcc = gf_isom_hevc_config_get(movie, refTrack, 1);\n\t\t}\n\t\tif (hvcc) {\n\t\t\tu8 c;\n\t\t\tchar szTemp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.\"", gf_4cc_to_str(subtype));\n\t\t\tif (hvcc->profile_space==1) strcat(szCodec, \""A\"");\n\t\t\telse if (hvcc->profile_space==2) strcat(szCodec, \""B\"");\n\t\t\telse if (hvcc->profile_space==3) strcat(szCodec, \""C\"");\n\t\t\t//profile idc encoded as a decimal number\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->profile_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\t//general profile compatibility flags: hexa, bit-reversed\n\t\t\t{\n\t\t\t\tu32 val = hvcc->general_profile_compatibility_flags;\n\t\t\t\tu32 i, res = 0;\n\t\t\t\tfor (i=0; i<32; i++) {\n\t\t\t\t\tres |= val & 1;\n\t\t\t\t\tif (i==31) break;\n\t\t\t\t\tres <<= 1;\n\t\t\t\t\tval >>=1;\n\t\t\t\t}\n\t\t\t\tsprintf(szTemp, \"".%X\"", res);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t}\n\n\t\t\tif (hvcc->tier_flag) strcat(szCodec, \"".H\"");\n\t\t\telse strcat(szCodec, \"".L\"");\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->level_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\n\t\t\tc = hvcc->progressive_source_flag << 7;\n\t\t\tc |= hvcc->interlaced_source_flag << 6;\n\t\t\tc |= hvcc->non_packed_constraint_flag << 5;\n\t\t\tc |= hvcc->frame_only_constraint_flag << 4;\n\t\t\tc |= (hvcc->constraint_indicator_flags >> 40);\n\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\tif (hvcc->constraint_indicator_flags & 0xFFFFFFFF) {\n\t\t\t\tc = (hvcc->constraint_indicator_flags >> 32) & 0xFF;\n\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\tif (hvcc->constraint_indicator_flags & 0x00FFFFFF) {\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 24) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x0000FFFF) {\n\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 16) & 0xFF;\n\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x000000FF) {\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 8) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags ) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t} else {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\t}\n\t\treturn GF_OK;\n#endif /*GPAC_DISABLE_HEVC*/\n\n#ifndef GPAC_DISABLE_AV1\n\tcase GF_ISOM_SUBTYPE_AV01: {\n\t\tGF_AV1Config *av1c = NULL;\n\t\tAV1State av1_state;\n\t\tGF_BitStream *bs = NULL;\n\t\tGF_Err e = GF_OK;\n\t\tu32 i = 0;\n\n\t\tmemset(&av1_state, 0, sizeof(AV1State));\n\t\tav1c = gf_isom_av1_config_get(movie, track, 1);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for AV1 file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tav1_state.config = av1c;\n\n\t\tfor (i = 0; i < gf_list_count(av1c->obu_array); ++i) {\n\t\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(av1c->obu_array, i);\n\t\t\tbs = gf_bs_new(a->obu, a->obu_length, GF_BITSTREAM_READ);\n\t\t\tif (!av1_is_obu_header(a->obu_type))\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] AV1: unexpected obu_type %d when computing RFC6381. PArsing anyway.\\n\"", a->obu_type, gf_4cc_to_str(subtype)));\n\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1_state);\n\t\t\tgf_bs_del(bs); bs = NULL;\n\t\t\tif (e) {\n\t\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%01u.%02u%c.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tav1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M',\n\t\t\tav1_state.bit_depth);\n\t\t\n\t\t/* \""All the other fields [...] are optional, mutually inclusive (all or none) fields.\"" https://aomediacodec.github.io/av1-isobmff/ */\n\t\tif (av1_state.color_description_present_flag) {\n\t\t\tchar tmp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(tmp, RFC6381_CODEC_NAME_SIZE_MAX, \""%01u.%01u.%01u.%01u.%01u.%01u%01u%01u\"",\n\t\t\t\tav1_state.config->monochrome,\n\t\t\t\tav1_state.config->chroma_subsampling_x, av1_state.config->chroma_subsampling_y,\n\t\t\t\tav1_state.config->chroma_subsampling_x && av1_state.config->chroma_subsampling_y ? av1_state.config->chroma_sample_position : 0,\n\t\t\t\tav1_state.color_primaries, av1_state.transfer_characteristics, av1_state.matrix_coefficients, av1_state.color_range);\n\t\t\tstrcat(szCodec, tmp);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t\tav1_reset_frame_state(&av1_state.frame_state);\n\t\treturn GF_OK;\n\t}\n#endif /*GPAC_DISABLE_AV1*/\n\n\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\t{\n\t\tGF_VPConfig *vpcc = NULL;\n\n\t\tvpcc = gf_isom_vp_config_get(movie, track, 1);\n\t\tif (!vpcc) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for VP file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02u.%02u.%02u.%02u.%02u.%02u.%02u.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tvpcc->profile,\n\t\t\tvpcc->level,\n\t\t\tvpcc->bit_depth,\n\t\t\tvpcc->chroma_subsampling,\n\t\t\tvpcc->colour_primaries,\n\t\t\tvpcc->transfer_characteristics,\n\t\t\tvpcc->matrix_coefficients,\n\t\t\tvpcc->video_fullRange_flag);\n\n\n\t\tgf_odf_vp_cfg_del(vpcc);\n\n\t\treturn GF_OK;\n\t}\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] codec parameters not known - setting codecs string to default value \\\""%s\\\""\\n\"", gf_4cc_to_str(subtype) ));\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""iSLT_Write"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err iSLT_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t\n\tgf_bs_write_u64(bs, ptr->salt);\n\treturn GF_OK;\n}"", ""target"": 1}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tu32 samp_count;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tsamp_count = i+1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (trak) samp_count += trak->sample_count_at_seg_start;\n#endif\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, samp_count, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", samp_count, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\t//while this would technically be correct, senc mandates that sample_count = all samples in traf/track\n\t\t//regardless of their encryption state\n\t\t//if (is_encrypted)\n\t\t{\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""audio_sample_entry_Read"", ""file_path"": ""src/isomedia/box_code_base.c"", ""func_code"": ""GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC(data[i+4], data[i+5], data[i+6], data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}"", ""target"": 0}, {""func_name"": ""ReadGF_IPMPX_RemoveToolNotificationListener"", ""file_path"": ""src/odf/ipmpx_code.c"", ""func_code"": ""static GF_Err ReadGF_IPMPX_RemoveToolNotificationListener(GF_BitStream *bs, GF_IPMPX_Data *_p, u32 size)\n{\n\tu32 i;\n\tGF_IPMPX_RemoveToolNotificationListener*p = (GF_IPMPX_RemoveToolNotificationListener*)_p;\n\tp->eventTypeCount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<p->eventTypeCount; i++) p->eventType[i] = gf_bs_read_int(bs, 8);\n\treturn GF_OK;\n}"", ""target"": 0}]","[{""func_name"": ""gf_isom_get_original_format_type"", ""file_path"": ""src/isomedia/drm_sample.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tMedia_GetSampleDesc(trak->Media, sampleDescriptionIndex, &sea, NULL);\n\tif (!sea) return GF_BAD_PARAM;\n\n\tsinf = (GF_ProtectionSchemeInfoBox*)gf_list_get(sea->protections, 0);\n\tif (outOriginalFormat && sinf && sinf->original_format) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""gf_media_get_rfc_6381_codec_name"", ""file_path"": ""src/media_tools/dash_segmenter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tGF_ESD *esd;\n\tGF_AVCConfig *avcc;\n#ifndef GPAC_DISABLE_HEVC\n\tGF_HEVCConfig *hvcc;\n#endif\n\n\tu32 subtype = gf_isom_get_media_subtype(movie, track, 1);\n\n\tif (subtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tGF_Err e;\n\t\tu32 originalFormat=0;\n\t\tif (gf_isom_is_ismacryp_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_ismacryp_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if (gf_isom_is_omadrm_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_omadrm_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if(gf_isom_is_cenc_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_cenc_info(movie, track, 1, &originalFormat, NULL, NULL, NULL);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] Unknown protection scheme type %s\\n\"", gf_4cc_to_str( gf_isom_is_media_encrypted(movie, track, 1)) ));\n\t\t\te = gf_isom_get_original_format_type(movie, track, 1, &originalFormat);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\""[ISOM Tools] Error fetching protection information\\n\""));\n\t\t\treturn e;\n\t\t}\n\n\t\tif (originalFormat) subtype = originalFormat;\n\t}\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\tesd = gf_isom_get_esd(movie, track, 1);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tswitch (esd->decoderConfig->streamType) {\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\tu8 audio_object_type;\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo->dataLength < 2) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381-AAC] invalid DSI size %u < 2\\n\"", esd->decoderConfig->decoderSpecificInfo->dataLength));\n\t\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t}\n\t\t\t\t\t/*5 first bits of AAC config*/\n\t\t\t\t\taudio_object_type = (esd->decoderConfig->decoderSpecificInfo->data[0] & 0xF8) >> 3;\n\t\t\t\t\tif (audio_object_type == 31) { /*escape code*/\n\t\t\t\t\t\tconst u8 audio_object_type_ext = ((esd->decoderConfig->decoderSpecificInfo->data[0] & 0x07) << 3) + ((esd->decoderConfig->decoderSpecificInfo->data[1] & 0xE0) >> 5);\n\t\t\t\t\t\taudio_object_type = 32 + audio_object_type_ext;\n\t\t\t\t\t}\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (force_sbr && (audio_object_type==2) ) {\n\t\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\t\tGF_Err e = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\tif (a_cfg.sbr_sr)\n\t\t\t\t\t\t\t\taudio_object_type = a_cfg.sbr_object_type;\n\t\t\t\t\t\t\tif (a_cfg.has_ps)\n\t\t\t\t\t\t\t\taudio_object_type = 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t#endif\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X.%01d\"", esd->decoderConfig->objectTypeIndication, audio_object_type);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_VISUAL:\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X.%01x\"", esd->decoderConfig->objectTypeIndication, dsi.VideoPL);\n\t\t\t\t} else\n\t#endif\n\t\t\t\t{\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4s.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381] Cannot find ESD. Aborting.\\n\""));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tavcc = gf_isom_avc_config_get(movie, track, 1);\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC4_H264;\n\t\t}\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tavcc = gf_isom_mvc_config_get(movie, track, 1);\n\t\tif (!avcc) avcc = gf_isom_svc_config_get(movie, track, 1);\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n#ifndef GPAC_DISABLE_HEVC\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_HVC1) subtype = GF_ISOM_SUBTYPE_HEV1;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_HVC2) subtype = GF_ISOM_SUBTYPE_HEV2;\n\t\t}\n\t\thvcc = gf_isom_hevc_config_get(movie, track, 1);\n\t\tif (!hvcc) {\n\t\t\thvcc = gf_isom_lhvc_config_get(movie, track, 1);\n\t\t}\n\t\tif (subtype==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\tu32 refTrack;\n\t\t\tgf_isom_get_reference(movie, track, GF_ISOM_REF_TBAS, 1, &refTrack);\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\thvcc = gf_isom_hevc_config_get(movie, refTrack, 1);\n\t\t}\n\t\tif (hvcc) {\n\t\t\tu8 c;\n\t\t\tchar szTemp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.\"", gf_4cc_to_str(subtype));\n\t\t\tif (hvcc->profile_space==1) strcat(szCodec, \""A\"");\n\t\t\telse if (hvcc->profile_space==2) strcat(szCodec, \""B\"");\n\t\t\telse if (hvcc->profile_space==3) strcat(szCodec, \""C\"");\n\t\t\t//profile idc encoded as a decimal number\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->profile_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\t//general profile compatibility flags: hexa, bit-reversed\n\t\t\t{\n\t\t\t\tu32 val = hvcc->general_profile_compatibility_flags;\n\t\t\t\tu32 i, res = 0;\n\t\t\t\tfor (i=0; i<32; i++) {\n\t\t\t\t\tres |= val & 1;\n\t\t\t\t\tif (i==31) break;\n\t\t\t\t\tres <<= 1;\n\t\t\t\t\tval >>=1;\n\t\t\t\t}\n\t\t\t\tsprintf(szTemp, \"".%X\"", res);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t}\n\n\t\t\tif (hvcc->tier_flag) strcat(szCodec, \"".H\"");\n\t\t\telse strcat(szCodec, \"".L\"");\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->level_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\n\t\t\tc = hvcc->progressive_source_flag << 7;\n\t\t\tc |= hvcc->interlaced_source_flag << 6;\n\t\t\tc |= hvcc->non_packed_constraint_flag << 5;\n\t\t\tc |= hvcc->frame_only_constraint_flag << 4;\n\t\t\tc |= (hvcc->constraint_indicator_flags >> 40);\n\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\tif (hvcc->constraint_indicator_flags & 0xFFFFFFFF) {\n\t\t\t\tc = (hvcc->constraint_indicator_flags >> 32) & 0xFF;\n\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\tif (hvcc->constraint_indicator_flags & 0x00FFFFFF) {\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 24) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x0000FFFF) {\n\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 16) & 0xFF;\n\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x000000FF) {\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 8) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags ) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t} else {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\t}\n\t\treturn GF_OK;\n#endif /*GPAC_DISABLE_HEVC*/\n\n#ifndef GPAC_DISABLE_AV1\n\tcase GF_ISOM_SUBTYPE_AV01: {\n\t\tGF_AV1Config *av1c = NULL;\n\t\tAV1State av1_state;\n\t\tGF_BitStream *bs = NULL;\n\t\tGF_Err e = GF_OK;\n\t\tu32 i = 0;\n\n\t\tmemset(&av1_state, 0, sizeof(AV1State));\n\t\tav1c = gf_isom_av1_config_get(movie, track, 1);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for AV1 file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tav1_state.config = av1c;\n\n\t\tfor (i = 0; i < gf_list_count(av1c->obu_array); ++i) {\n\t\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(av1c->obu_array, i);\n\t\t\tbs = gf_bs_new(a->obu, a->obu_length, GF_BITSTREAM_READ);\n\t\t\tif (!av1_is_obu_header(a->obu_type))\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] AV1: unexpected obu_type %d when computing RFC6381. PArsing anyway.\\n\"", a->obu_type, gf_4cc_to_str(subtype)));\n\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1_state);\n\t\t\tgf_bs_del(bs); bs = NULL;\n\t\t\tif (e) {\n\t\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%01u.%02u%c.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tav1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M',\n\t\t\tav1_state.bit_depth);\n\n\t\t/* \""All the other fields [...] are optional, mutually inclusive (all or none) fields.\"" https://aomediacodec.github.io/av1-isobmff/ */\n\t\tif (av1_state.color_description_present_flag) {\n\t\t\tchar tmp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(tmp, RFC6381_CODEC_NAME_SIZE_MAX, \""%01u.%01u.%01u.%01u.%01u.%01u%01u%01u\"",\n\t\t\t\tav1_state.config->monochrome,\n\t\t\t\tav1_state.config->chroma_subsampling_x, av1_state.config->chroma_subsampling_y,\n\t\t\t\tav1_state.config->chroma_subsampling_x && av1_state.config->chroma_subsampling_y ? av1_state.config->chroma_sample_position : 0,\n\t\t\t\tav1_state.color_primaries, av1_state.transfer_characteristics, av1_state.matrix_coefficients, av1_state.color_range);\n\t\t\tstrcat(szCodec, tmp);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t\tav1_reset_frame_state(&av1_state.frame_state);\n\t\treturn GF_OK;\n\t}\n#endif /*GPAC_DISABLE_AV1*/\n\n\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\t{\n\t\tGF_VPConfig *vpcc = NULL;\n\n\t\tvpcc = gf_isom_vp_config_get(movie, track, 1);\n\t\tif (!vpcc) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for VP file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02u.%02u.%02u.%02u.%02u.%02u.%02u.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tvpcc->profile,\n\t\t\tvpcc->level,\n\t\t\tvpcc->bit_depth,\n\t\t\tvpcc->chroma_subsampling,\n\t\t\tvpcc->colour_primaries,\n\t\t\tvpcc->transfer_characteristics,\n\t\t\tvpcc->matrix_coefficients,\n\t\t\tvpcc->video_fullRange_flag);\n\n\n\t\tgf_odf_vp_cfg_del(vpcc);\n\n\t\treturn GF_OK;\n\t}\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] codec parameters not known - setting codecs string to default value \\\""%s\\\""\\n\"", gf_4cc_to_str(subtype) ));\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""iSLT_Write"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err iSLT_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u64(bs, ptr->salt);\n\treturn GF_OK;\n}""}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tu32 samp_count;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tsamp_count = i+1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (trak) samp_count += trak->sample_count_at_seg_start;\n#endif\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, samp_count, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", samp_count, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\t//while this would technically be correct, senc mandates that sample_count = all samples in traf/track\n\t\t//regardless of their encryption state\n\t\t//if (is_encrypted)\n\t\t{\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}""}, {""func_name"": ""audio_sample_entry_Read"", ""file_path"": ""src/isomedia/box_code_base.c"", ""func_code"": ""GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tif (!e) gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}""}, {""func_name"": ""ReadGF_IPMPX_RemoveToolNotificationListener"", ""file_path"": ""src/odf/ipmpx_code.c"", ""func_code"": ""static GF_Err ReadGF_IPMPX_RemoveToolNotificationListener(GF_BitStream *bs, GF_IPMPX_Data *_p, u32 size)\n{\n\tu32 i;\n\tu8 count;\n\tGF_IPMPX_RemoveToolNotificationListener*p = (GF_IPMPX_RemoveToolNotificationListener*)_p;\n\tp->eventTypeCount = 0;\n\tcount = gf_bs_read_int(bs, 8);\n\tif (count > ARRAY_LENGTH(p->eventType))\n\t\treturn GF_CORRUPTED_DATA;\n\n\tp->eventTypeCount = count;\n\tfor (i=0; i<p->eventTypeCount; i++) p->eventType[i] = gf_bs_read_int(bs, 8);\n\treturn GF_OK;\n}""}]","{""function"": 5, ""code"": 2}","[{""source"": ""func_info(func:gf_isom_get_esd)"", ""result"": [{""code"": ""GF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionI"", ""start_line"": 1121, ""end_line"": 1132, ""full_name"": ""gf_isom_get_esd"", ""file_path"": ""src/isomedia/isom_read.c""}]}, {""source"": ""func_info(file:track.c, func:GetESD)"", ""result"": [{""code"": ""GF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_"", ""start_line"": 66, ""end_line"": 312, ""full_name"": ""GetESD"", ""file_path"": ""src/isomedia/track.c""}]}, {""source"": ""func_info(file:track.c, func:GetESD)"", ""result"": [{""code"": ""GF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_"", ""start_line"": 66, ""end_line"": 312, ""full_name"": ""GetESD"", ""file_path"": ""src/isomedia/track.c""}]}, {""source"": ""code_info(file:track.c, lines:66-312)"", ""result"": ""GF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_SLConfig *slc;\n\tGF_MPEGSampleEntryBox *entry;\n\n\tif (!moov) return GF_ISOM_INVALID_FILE;\n\n\ttrack_num = gf_isom_get_tracknum_from_id(moov, trackID);\n\tdpnd = NULL;\n\t*outESD = NULL;\n\n\ttrak = gf_isom_get_track(moov, track_num);\n\tif (!trak) return GF_ISOM_INVALID_FILE;\n\n\te = Media_GetESD(trak->Media, StreamDescIndex, &esd, 0);\n\tif (e) return e;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescIndex, (GF_SampleEntryBox **) &entry, NULL);\n\tif (e) return e;\n\t//set the ID\n\tesd->ESID = trackID;\n\n\t//find stream dependencies: dpnd, sbas and scal\n\tfor (k=0; k<3; k++) {\n\t\tu32 ref = GF_ISOM_BOX_TYPE_DPND;\n\t\tif (k==1) ref = GF_ISOM_REF_BASE;\n\t\telse if (k==2) ref = GF_ISOM_REF_SCAL;\n\n\t\te = Track_FindRef(trak, ref , &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\t//ONLY ONE STREAM DEPENDENCY IS ALLOWED\n\t\t\tif (!k && (dpnd->trackIDCount != 1)) return GF_ISOM_INVALID_MEDIA;\n\t\t\t//fix the spec: where is the index located ??\n\t\t\tesd->dependsOnESID = dpnd->trackIDs[0];\n\t\t\tbreak;\n\t\t} else {\n\t\t\tesd->dependsOnESID = 0;\n\t\t}\n\t}\n\n\tif (trak->udta) {\n\t\tGF_UserDataMap *map;\n\t\tu32 i = 0;\n\t\twhile ((map = (GF_UserDataMap*)gf_list_enum(trak->udta->recordList, &i))) {\n\t\t\tif (map->boxType == GF_ISOM_BOX_TYPE_AUXV) {\n\t\t\t\tGF_Descriptor *d = gf_odf_desc_new(GF_ODF_AUX_VIDEO_DATA);\n\t\t\t\tgf_list_add(esd->extensionDescriptors, d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//OK, get the OCR (in a REAL MP4File, OCR is 0 in ESD and is specified through track reference\n\tdpnd = NULL;\n\tOCRTrack = NULL;\n\t//find OCR dependencies\n\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\tif (e) return e;\n\tif (dpnd) {\n\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\tesd->OCRESID = dpnd->trackIDs[0];\n\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\n\t\twhile (OCRTrack) {\n\t\t\t/*if we have a dependency on a track that doesn't have OCR dep, remove that dependency*/\n\t\t\te = Track_FindRef(OCRTrack, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\t\t\tif (e || !dpnd || !dpnd->trackIDCount) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*this is explicit desync*/\n\t\t\tif (dpnd && ((dpnd->trackIDs[0]==0) || (dpnd->trackIDs[0]==OCRTrack->Header->trackID))) break;\n\t\t\t/*loop in OCRs, break it*/\n\t\t\tif (esd->ESID == OCRTrack->Header->trackID) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*check next*/\n\t\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\t\t}\n\t\tif (!OCRTrack) goto default_sync;\n\t} else {\ndefault_sync:\n\t\t/*all tracks are sync'ed by default*/\n\t\tif (trak->moov->mov->es_id_default_sync<0) {\n\t\t\tif (esd->OCRESID)\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->OCRESID;\n\t\t\telse\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->ESID;\n\t\t}\n\t\tif (trak->moov->mov->es_id_default_sync) esd->OCRESID = (u16) trak->moov->mov->es_id_default_sync;\n\t\t/*cf ESD writer*/\n\t\tif (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\t}\n\n\n\n\t//update the IPI stuff if needed\n\tif (esd->ipiPtr != NULL) {\n\t\tdpnd = NULL;\n\t\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_IPIR, &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\tif (esd->ipiPtr->tag != GF_ODF_ISOM_IPI_PTR_TAG) return GF_ISOM_INVALID_FILE;\n\t\t\t//OK, retrieve the ID: the IPI_ES_Id is currently the ref track\n\t\t\tesd->ipiPtr->IPI_ES_Id = dpnd->trackIDs[esd->ipiPtr->IPI_ES_Id - 1];\n\t\t\t//and change the tag\n\t\t\tesd->ipiPtr->tag = GF_ODF_IPI_PTR_TAG;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif ((trak->Media->mediaHeader->packedLanguage[0] != 'u')\n\t        || (trak->Media->mediaHeader->packedLanguage[1] != 'n')\n\t        || (trak->Media->mediaHeader->packedLanguage[2] != 'd') ) {\n\t\tif (!esd->langDesc) esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\n\t\tesd->langDesc->langCode = trak->Media->mediaHeader->packedLanguage[0];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[1];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[2];\n\t}\n\n\n\t{\n\t\tu16 rvc_predefined;\n\t\tchar *rvc_cfg_data;\n\t\tconst char *mime_type;\n\t\tu32 rvc_cfg_size;\n\t\te = gf_isom_get_rvc_config(moov->mov, track_num, 1, &rvc_predefined, &rvc_cfg_data, &rvc_cfg_size, &mime_type);\n\t\tif (e==GF_OK) {\n\t\t\tif (rvc_predefined) {\n\t\t\t\tesd->decoderConfig->predefined_rvc_config = rvc_predefined;\n\t\t\t} else {\n\t\t\t\tesd->decoderConfig->rvc_config = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\t\t\tif (mime_type && !strcmp(mime_type, \""application/rvc-config+xml+gz\"") ) {\n#if !defined(GPAC_DISABLE_CORE_TOOLS) && !defined(GPAC_DISABLE_ZLIB)\n\t\t\t\t\tgf_gz_decompress_payload(rvc_cfg_data, rvc_cfg_size, &esd->decoderConfig->rvc_config->data, &esd->decoderConfig->rvc_config->dataLength);\n\t\t\t\t\tgf_free(rvc_cfg_data);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tesd->decoderConfig->rvc_config->data = rvc_cfg_data;\n\t\t\t\t\tesd->decoderConfig->rvc_config->dataLength = rvc_cfg_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*normally all files shall be stored with predefined=SLPredef_MP4, but of course some are broken (philips)\n\tso we just check the ESD_URL. If set, use the given cfg, otherwise always rewrite it*/\n\tif (esd->URLString != NULL) {\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\n\t//if we are in publishing mode and we have an SLConfig specified, use it as is\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tslc = entry->slc;\n\t\tbreak;\n\tdefault:\n\t\tslc = NULL;\n\t\tbreak;\n\t}\n\tif (slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)esd->slConfig);\n\t\tgf_odf_desc_copy((GF_Descriptor *)slc, (GF_Descriptor **)&esd->slConfig);\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\t//otherwise use the regular mapping\n\n\t//this is a desc for a media in the file, let's rewrite some param\n\tesd->slConfig->timestampLength = 32;\n\tesd->slConfig->timestampResolution = trak->Media->mediaHeader->timeScale;\n\t//NO OCR from MP4File streams (eg, constant OC Res one)\n\tesd->slConfig->OCRLength = 0;\n\tesd->slConfig->OCRResolution = 0;\n//\tif (OCRTrack) esd->slConfig->OCRResolution = OCRTrack->Media->mediaHeader->timeScale;\n\n\tstbl = trak->Media->information->sampleTable;\n\t// a little optimization here: if all our samples are sync,\n\t//set the RAPOnly to true... for external users...\n\tif (! stbl->SyncSample) {\n\t\tif (\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t    moov->mvex &&\n#endif\n\t\t    (esd->decoderConfig->streamType==GF_STREAM_VISUAL)) {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 1;\n\t\t\tif (trak->moov->mov->openMode!=GF_ISOM_OPEN_READ)\n\t\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSS);\n\t\t} else {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 0;\n\t\t}\n\t} else {\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t//signal we are NOT using sync points if no info is present in the table\n\t\tesd->slConfig->useRandomAccessPointFlag = stbl->SyncSample->nb_entries ? 1 : 0;\n\t}\n\t//do we have DegradationPriority ?\n\tif (stbl->DegradationPriority) {\n\t\tesd->slConfig->degradationPriorityLength = 15;\n\t} else {\n\t\tesd->slConfig->degradationPriorityLength = 0;\n\t}\n\t//paddingBits\n\tif (stbl->PaddingBits) {\n\t\tesd->slConfig->usePaddingFlag = 1;\n\t}\n\t//change to support reflecting OD streams\n\tesd->slConfig->useAccessUnitEndFlag = 1;\n\tesd->slConfig->useAccessUnitStartFlag = 1;\n\n\t//signal we do have padding flag (since we only use logical SL packet\n\t//the user can decide whether to use the info or not\n\tesd->slConfig->usePaddingFlag = stbl->PaddingBits ? 1 : 0;\n\n\t//same with degradation priority\n\tesd->slConfig->degradationPriorityLength = stbl->DegradationPriority ? 32 : 0;\n\n\t//this new SL will be OUT OF THE FILE. Let's set its predefined to 0\n\tesd->slConfig->predefined = 0;\n\n\n\t*outESD = esd;\n\treturn GF_OK;\n}\n\n""}, {""source"": ""func_info(file:media.c, func:Media_GetESD)"", ""result"": [{""code"": ""GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_SampleDescriptionBox *sts"", ""start_line"": 149, ""end_line"": 360, ""full_name"": ""Media_GetESD"", ""file_path"": ""src/isomedia/media.c""}]}, {""source"": ""func_info(file:media.c, func:Media_GetESD)"", ""result"": [{""code"": ""GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_SampleDescriptionBox *sts"", ""start_line"": 149, ""end_line"": 360, ""full_name"": ""Media_GetESD"", ""file_path"": ""src/isomedia/media.c""}]}, {""source"": ""code_info(file:media.c, lines:149-360)"", ""result"": ""GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->other_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->other_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->other_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) esd = (GF_ESD *) ESDa->desc;\n            else {\n                // Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n                GF_M4ADecSpecInfo aacinfo;\n                memset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n                aacinfo.nb_chan = ase->channel_count;\n                aacinfo.base_object_type = GF_M4A_AAC_LC;\n                aacinfo.base_sr = ase->samplerate_hi;\n                *out_esd = gf_odf_desc_esd_new(0);\n                (*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n                (*out_esd)->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n                gf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tESDa = entry->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t{\n\t\tGF_BitStream *bs;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_SCENE_VTT_MP4;\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, entry->type);\n\t\tgf_isom_box_write((GF_Box *)((GF_WebVTTSampleEntryBox*)entry)->config, bs);\n\t\tgf_bs_get_content(bs, & esd->decoderConfig->decoderSpecificInfo->data, & esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS: {\n\t\tGF_OpusSpecificBox *e = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tGF_BitStream *bs_out;\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""ESD not found for Opus\\n)\""));\n\t\t\tbreak;\n\t\t}\n\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_OPUS;\n\n\t\t//serialize box with header - compatibility with ffmpeg\n\t\tbs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_isom_box_size((GF_Box *) e);\n\t\tgf_isom_box_write((GF_Box *) e, bs_out);\n\t\tgf_bs_get_content(bs_out, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs_out);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_BitStream *bs;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, entry->type);\n\t\t\tgf_bs_write_u16(bs, ((GF_MPEGVisualSampleEntryBox*)entry)->Width);\n\t\t\tgf_bs_write_u16(bs, ((GF_MPEGVisualSampleEntryBox*)entry)->Height);\n\t\t\tgf_bs_get_content(bs, & esd->decoderConfig->decoderSpecificInfo->data, & esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_MPEG1;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_SCENE_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}\n\n""}]","The vulnerability chain is as follows: 1. `Media_GetESD` (media.c:149-360) returns an error if `sampleDescIndex` is invalid or the corresponding sample entry is missing. 2. `GetESD` (track.c:66-312) propagates this error, leading to a NULL `esd` in `gf_isom_get_esd` (isom_read.c:1121-1132). 3. The NULL `esd` is dereferenced in `gf_media_get_rfc_6381_codec_name` (dash_segmenter.c:478) without a check in the vulnerable version. Patches added checks for `esd && esd->decoderConfig` to prevent the dereference.",0.95,./github/other_context/CVE-2019-12481
64,CVE-2019-15900,"CWE-863, CWE-252, CWE-908, CWE-754",c_cpp,"An issue was discovered in slicer69 doas before 6.2 on certain platforms other than OpenBSD. On platforms without strtonum(3), sscanf was used without checking for error cases. Instead, the uninitialized variable errstr was checked and in some cases returned success even if sscanf failed. The result was that, instead of reporting that the supplied username or group name did not exist, it would execute the command as root.",https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531,Added optimization to Makefile (can be set/overruled using OPT).\nAdded flag to display all warnings during compiling.\nAdded status checks when parsing user/group IDs for Linux.\nMake sure Linux drops original user's groups when running as another user.,2,"[{""func_name"": ""parsegid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \""%d\"", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""parseuid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \""%d\"", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"", ""target"": 1}]","[{""func_name"": ""parsegid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \""%d\"", gid);\n        if (status != 1)\n            return -1;\n\t#endif\n\treturn 0;\n}""}, {""func_name"": ""parseuid"", ""file_path"": ""doas.c"", ""func_code"": ""static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \""%d\"", uid);\n        if (status != 1)\n           return -1;\n\t#endif\n\treturn 0;\n}""}]","{""caller"": 3}","[{""source"": ""caller_info(file:doas.c, func:parsegid)"", ""result"": [{""call_line"": 144, ""call_code"": ""parsegid(r->ident + 1, &rgid)"", ""caller_code"": ""static int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"", ""caller_start"": 136, ""file_path"": ""doas.c""}]}, {""source"": ""caller_info(file:doas.c, func:match)"", ""result"": [{""call_line"": 184, ""call_code"": ""match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i])"", ""caller_code"": ""static int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}"", ""caller_start"": 176, ""file_path"": ""doas.c""}]}, {""source"": ""caller_info(file:doas.c, func:permit)"", ""result"": [{""call_line"": 241, ""call_code"": ""permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)"", ""caller_code"": ""static void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\""doas: Unable to set UID\\n\"");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\""permit%s\\n\"", (rule->options & NOPASS) ? \"" nopass\"" : \""\"");\n\t\texit(0);\n\t} else {\n\t\tprintf(\""deny\\n\"");\n\t\texit(1);\n\t}\n}"", ""caller_start"": 220, ""file_path"": ""doas.c""}, {""call_line"": 416, ""call_code"": ""permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)"", ""caller_code"": ""int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\""doas\"");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \""a:C:nsu:\"")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \""a:C:Lnsu:\"")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\""/dev/tty\"", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \""unknown user\"");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \""getpwuid failed\"");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \""pw_name too long\"");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \""can't get groups\"");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\""SHELL\"");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \""not installed setuid\"");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \"" \"", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \""failed command for %s: %s\"", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \""Authorization required\"");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \""%s: %s\"", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\""%s: %s\"", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \""dup\"");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \""dup\"");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \""dup2\"");\n/* #endif */\n\n\t\tpam_err = pam_start(\""doas\"", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\""pam_start\"");\n\t\t\tsyslog(LOG_ERR, \""pam_start failed: %s\"",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \""pam_start failed\"");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\""pam_chauthtok\"");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \""failed auth for %s\"", myname);\n                                errx(EXIT_FAILURE, \""second authentication failed\"");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\""pam_acct_mgmt\"");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \""failed auth for %s\"", myname);\n                        errx(EXIT_FAILURE, \""authentication failed\"");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\""pam_authenticate\"");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \""dup2\"");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \""dup2\"");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\""stdio rpath getpw exec id\"", NULL) == -1)\n\t\terr(1, \""pledge\"");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \""no passwd entry for target\"");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \""failed to set user context for target\"");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \""setresgid\"");\n\t#else\n\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \""setregid\"");\n\t#endif\n\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n\t\terr(1, \""initgroups\"");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, \""setresuid\"");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, \""setreuid\"");\n\t#endif\n#endif\n        /*\n\tif (pledge(\""stdio rpath exec\"", NULL) == -1)\n\t\terr(1, \""pledge\"");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \""(failed)\"";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\""stdio exec\"", NULL) == -1)\n\t\terr(1, \""pledge\"");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \""%s ran command %s as %s from %s\"",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\""PATH\"", safepath, 1) == -1)\n\t\t\terr(1, \""failed to set PATH '%s'\"", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \""%s: command not found\"", cmd);\n\terr(1, \""%s\"", cmd);\n}\n"", ""caller_start"": 299, ""file_path"": ""doas.c""}]}]",doas.c:128-133: sscanf() used without return value check in parsegid() for non-OpenBSD/NetBSD platforms. Vulnerable logic allowed invalid GID inputs to be accepted as valid. Patch adds status = sscanf(...) and 'if (status != 1)' check. Caller match() at doas.c:144 uses parsegid() return value to validate group membership. permit() at doas.c:176 aggregates match() results. main() at doas.c:416 calls permit() and executes command as root if permitted.,0.95,./github/other_context/CVE-2019-15900
65,CVE-2019-3552,CWE-755,c_cpp,"C++ Facebook Thrift servers (using cpp2) would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.02.18.00.",https://github.com/facebook/fbthrift/commit/c5d6e07588cd03061bc54d451a7fa6e84883d62b,"Throw on bad types during skipping data\n\nSummary:\nThe current code silently returns on bad types. In case when we have an invalid data, we may get a container of a large size with a bad type, this would lead to us running long loop doing nothing (though we already can say that the data is invalid).\n\nThe new code would throw an exception as soon as we try to skip a value of invalid type.\n\nFixes CVE-2019-3552\n\nReviewed By: yfeldblum, stevegury\n\nDifferential Revision: D8344920\n\nfbshipit-source-id: f12e8f3442f7ad5e1a81d822380701e929b80f0d",1,"[{""func_name"": ""skip"", ""file_path"": ""thrift/lib/cpp2/protocol/Protocol.h"", ""func_code"": ""void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}"", ""target"": 0}]","[{""func_name"": ""skip"", ""file_path"": ""thrift/lib/cpp2/protocol/Protocol.h"", ""func_code"": ""void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}""}]","{""value"": 2, ""caller"": 1, ""function"": 2}","[{""source"": ""value_info(file:Protocol.h, value:arg_type)"", ""result"": {""value_trace"": [{""full_code"": ""arg_type = field->get_type()"", ""line"": 642, ""func_name"": ""t_mstch_py3_generator.add_per_type_data:void(t_program&,mstch.map&)""}, {""full_code"": ""arg_type = field->get_type()"", ""line"": 262, ""func_name"": ""t_mstch_pyi_generator.add_container_types:void(t_program&,mstch.map&)""}], ""struct_var"": ""arg_type"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""caller_info(file:Protocol.h, func:skip)"", ""result"": [{""call_line"": 91, ""call_code"": ""tap.skip(T_STRUCT)"", ""caller_code"": ""int main(int argc, char *argv[]) {\n  if (argc <= 1) {\n    usage();\n  }\n\n  shared_ptr<TTransport> stdin_trans(new TFDTransport(STDIN_FILENO));\n  shared_ptr<TTransport> itrans;\n\n  bool buffered = false;\n  bool rawStructures = false;\n  bool framed = false;\n  bool compact = false;\n  for (int i = 1; i < argc; i++) {\n    buffered |= argv[i] == std::string(\""-b\"");\n    rawStructures |= argv[i] == std::string(\""-s\"");\n    framed |= argv[i] == std::string(\""-f\"");\n    compact |= argv[i] == std::string(\""-c\"");\n  }\n\n  if (buffered || rawStructures) {\n    itrans = std::make_shared<TBufferedTransport>(stdin_trans);\n  } else if (framed) {\n    itrans = std::make_shared<TFramedTransport>(stdin_trans);\n  } else {\n    usage();\n  }\n\n  shared_ptr<TProtocol> iprot;\n  if (compact) {\n    iprot = std::make_shared<TCompactProtocol>(itrans);\n  } else {\n    iprot = std::make_shared<TBinaryProtocol>(itrans);\n  }\n\n  auto oprot = std::make_shared<TDebugProtocol>(\n    std::make_shared<TBufferedTransport>(\n      std::make_shared<TFDTransport>(STDOUT_FILENO)));\n\n  TProtocolTap tap(iprot, oprot);\n\n  try {\n    if (rawStructures) {\n      for (;;) {\n        tap.skip(T_STRUCT);\n      }\n    } else {\n      std::string name;\n      TMessageType messageType;\n      int32_t seqid;\n      for (;;) {\n        tap.readMessageBegin(name, messageType, seqid);\n        tap.skip(T_STRUCT);\n        tap.readMessageEnd();\n      }\n    }\n  } catch (const TProtocolException &exn) {\n    cout << \""Protocol Exception: \"" << exn.what() << endl;\n  } catch (...) {\n    oprot->getTransport()->flush();\n  }\n\n  cout << endl;\n\n  return 0;\n}\n"", ""caller_start"": 48, ""file_path"": ""thrift/contrib/thrift_dump.cpp""}, {""call_line"": 99, ""call_code"": ""tap.skip(T_STRUCT)"", ""caller_code"": ""int main(int argc, char *argv[]) {\n  if (argc <= 1) {\n    usage();\n  }\n\n  shared_ptr<TTransport> stdin_trans(new TFDTransport(STDIN_FILENO));\n  shared_ptr<TTransport> itrans;\n\n  bool buffered = false;\n  bool rawStructures = false;\n  bool framed = false;\n  bool compact = false;\n  for (int i = 1; i < argc; i++) {\n    buffered |= argv[i] == std::string(\""-b\"");\n    rawStructures |= argv[i] == std::string(\""-s\"");\n    framed |= argv[i] == std::string(\""-f\"");\n    compact |= argv[i] == std::string(\""-c\"");\n  }\n\n  if (buffered || rawStructures) {\n    itrans = std::make_shared<TBufferedTransport>(stdin_trans);\n  } else if (framed) {\n    itrans = std::make_shared<TFramedTransport>(stdin_trans);\n  } else {\n    usage();\n  }\n\n  shared_ptr<TProtocol> iprot;\n  if (compact) {\n    iprot = std::make_shared<TCompactProtocol>(itrans);\n  } else {\n    iprot = std::make_shared<TBinaryProtocol>(itrans);\n  }\n\n  auto oprot = std::make_shared<TDebugProtocol>(\n    std::make_shared<TBufferedTransport>(\n      std::make_shared<TFDTransport>(STDOUT_FILENO)));\n\n  TProtocolTap tap(iprot, oprot);\n\n  try {\n    if (rawStructures) {\n      for (;;) {\n        tap.skip(T_STRUCT);\n      }\n    } else {\n      std::string name;\n      TMessageType messageType;\n      int32_t seqid;\n      for (;;) {\n        tap.readMessageBegin(name, messageType, seqid);\n        tap.skip(T_STRUCT);\n        tap.readMessageEnd();\n      }\n    }\n  } catch (const TProtocolException &exn) {\n    cout << \""Protocol Exception: \"" << exn.what() << endl;\n  } catch (...) {\n    oprot->getTransport()->flush();\n  }\n\n  cout << endl;\n\n  return 0;\n}\n"", ""caller_start"": 48, ""file_path"": ""thrift/contrib/thrift_dump.cpp""}, {""call_line"": 55, ""call_code"": ""protocol::skip(proto, protocol::T_STRUCT)"", ""caller_code"": ""bool tryReadUnframed(uint8_t* buffer,\n                     uint32_t bufferLength,\n                     uint32_t* messageLength,\n                     bool strictRead) {\n  // Try unframed message.\n  TMemoryBuffer memBuffer(buffer, bufferLength, TMemoryBuffer::OBSERVE);\n  TBinaryProtocolT<TBufferBase> proto(&memBuffer);\n  proto.setStrict(strictRead, true);\n  try {\n    std::string name;\n    protocol::TMessageType messageType;\n    int32_t seqid;\n    proto.readMessageBegin(name, messageType, seqid);\n    protocol::skip(proto, protocol::T_STRUCT);\n    proto.readMessageEnd();\n  } catch (const TTransportException& ex) {\n    if (ex.getType() == TTransportException::END_OF_FILE) {\n      // We're not at the end of the message yet.\n      return false;\n    }\n    throw;\n  }\n\n  *messageLength = memBuffer.readEnd();\n  return true;\n}"", ""caller_start"": 42, ""file_path"": ""thrift/lib/cpp/async/TBinaryAsyncChannel.cpp""}, {""call_line"": 121, ""call_code"": ""protocol::skip(proto, protocol::T_STRUCT)"", ""caller_code"": ""unique_ptr<IOBuf> THeader::removeUnframed(IOBufQueue* queue, size_t& needed) {\n  auto buf = queue->move();\n  auto range = buf->coalesce();\n  queue->append(std::move(buf));\n\n  // Test skip using the protocol to detect the end of the message\n  TMemoryBuffer memBuffer(\n      const_cast<uint8_t*>(range.begin()),\n      range.size(),\n      TMemoryBuffer::OBSERVE);\n  protoId_ = ProtocolID;\n  ProtocolClass<TBufferBase> proto(&memBuffer);\n  uint32_t msgSize = 0;\n  try {\n    std::string name;\n    protocol::TMessageType messageType;\n    int32_t seqid;\n    msgSize += proto.readMessageBegin(name, messageType, seqid);\n    msgSize += protocol::skip(proto, protocol::T_STRUCT);\n    msgSize += proto.readMessageEnd();\n  } catch (const TTransportException& ex) {\n    if (ex.getType() == TTransportException::END_OF_FILE) {\n      // We don't have the full data yet.  We can't tell exactly\n      // how many bytes we need, but it is at least one.\n      needed = 1;\n      return nullptr;\n    }\n  }\n\n  return queue->split(msgSize);\n}\n"", ""caller_start"": 103, ""file_path"": ""thrift/lib/cpp/transport/THeader.cpp""}]}, {""source"": ""value_info(file:Protocol.h, value:arg_type)"", ""result"": {""value_trace"": [{""full_code"": ""arg_type = field->get_type()"", ""line"": 642, ""func_name"": ""t_mstch_py3_generator.add_per_type_data:void(t_program&,mstch.map&)""}, {""full_code"": ""arg_type = field->get_type()"", ""line"": 262, ""func_name"": ""t_mstch_pyi_generator.add_container_types:void(t_program&,mstch.map&)""}], ""struct_var"": ""arg_type"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(func:readListBegin)"", ""result"": [{""code"": ""uint32_t TBinaryProtocolT<Transport_>::readListBegin(TType& elemType,\n                                                     uint32_t& size,\n                                                     bool& sizeUnknown) {\n  int8_t e;\n  uint32_t result = 0;\n  int32_t sizei;\n  result += readByte(e);\n  elemType = (TType)e;\n  result += readI32(sizei);\n  if (sizei < 0) {\n    throw TProtocolException(TProtocolException::NEGATIVE_SIZE);\n  } else if (this->container_limit_ && sizei > this->container_limit_) {\n    throw TProtocolException(TProtocolException::SIZE_LIMIT);\n  }\n  size = (uint32_t)sizei;\n  sizeUnknown = false;\n  return result;\n}"", ""start_line"": 308, ""end_line"": 325, ""full_name"": ""TBinaryProtocolT.readListBegin:uint32_t(TType&,uint32_t&,bool&)"", ""file_path"": ""thrift/lib/cpp/protocol/TBinaryProtocol.tcc""}, {""code"": ""uint32_t THeaderProtocol::readListBegin(TType& elemType,\n                                        uint32_t& size,\n                                        bool& sizeUnknown) {\n  return proto_->readListBegin(elemType, size, sizeUnknown);\n}"", ""start_line"": 212, ""end_line"": 216, ""full_name"": ""THeaderProtocol.readListBegin:uint32_t(TType&,uint32_t&,bool&)"", ""file_path"": ""thrift/lib/cpp/protocol/THeaderProtocol.cpp""}, {""code"": ""uint32_t TJSONProtocol::readListBegin(TType& elemType,\n                                      uint32_t& size,\n                                      bool& sizeUnknown) {\n  uint64_t tmpVal = 0;\n  std::string tmpStr;\n  uint32_t result = readJSONArrayStart();\n  result += readJSONString(tmpStr);\n  elemType = getTypeIDForTypeName(tmpStr);\n  result += readJSONInteger(tmpVal);\n  size = tmpVal;\n  sizeUnknown = false;\n  return result;\n}"", ""start_line"": 1093, ""end_line"": 1105, ""full_name"": ""TJSONProtocol.readListBegin:uint32_t(TType&,uint32_t&,bool&)"", ""file_path"": ""thrift/lib/cpp/protocol/TJSONProtocol.cpp""}]}, {""source"": ""func_info(func:readMapBegin)"", ""result"": [{""code"": ""uint32_t TBinaryProtocolT<Transport_>::readMapBegin(TType& keyType,\n                                                    TType& valType,\n                                                    uint32_t& size,\n                                                    bool& sizeUnknown) {\n  int8_t k, v;\n  uint32_t result = 0;\n  int32_t sizei;\n  result += readByte(k);\n  keyType = (TType)k;\n  result += readByte(v);\n  valType = (TType)v;\n  result += readI32(sizei);\n  if (sizei < 0) {\n    throw TProtocolException(TProtocolException::NEGATIVE_SIZE);\n  } else if (this->container_limit_ && sizei > this->container_limit_) {\n    throw TProtocolException(TProtocolException::SIZE_LIMIT);\n  }\n  size = (uint32_t)sizei;\n  sizeUnknown = false;\n  return result;\n}"", ""start_line"": 280, ""end_line"": 300, ""full_name"": ""TBinaryProtocolT.readMapBegin:uint32_t(TType&,TType&,uint32_t&,bool&)"", ""file_path"": ""thrift/lib/cpp/protocol/TBinaryProtocol.tcc""}, {""code"": ""uint32_t THeaderProtocol::readMapBegin(TType& keyType,\n                                       TType& valType,\n                                       uint32_t& size,\n                                       bool& sizeUnknown) {\n  return proto_->readMapBegin(keyType, valType, size, sizeUnknown);\n}"", ""start_line"": 201, ""end_line"": 206, ""full_name"": ""THeaderProtocol.readMapBegin:uint32_t(TType&,TType&,uint32_t&,bool&)"", ""file_path"": ""thrift/lib/cpp/protocol/THeaderProtocol.cpp""}, {""code"": ""uint32_t TJSONProtocol::readMapBegin(TType& keyType,\n                                     TType& valType,\n                                     uint32_t& size,\n                                     bool& sizeUnknown) {\n  uint64_t tmpVal = 0;\n  std::string tmpStr;\n  uint32_t result = readJSONArrayStart();\n  result += readJSONString(tmpStr);\n  keyType = getTypeIDForTypeName(tmpStr);\n  result += readJSONString(tmpStr);\n  valType = getTypeIDForTypeName(tmpStr);\n  result += readJSONInteger(tmpVal);\n  size = tmpVal;\n  result += readJSONObjectStart();\n  sizeUnknown = false;\n  return result;\n}"", ""start_line"": 1071, ""end_line"": 1087, ""full_name"": ""TJSONProtocol.readMapBegin:uint32_t(TType&,TType&,uint32_t&,bool&)"", ""file_path"": ""thrift/lib/cpp/protocol/TJSONProtocol.cpp""}]}]","thrift/lib/cpp2/protocol/Protocol.h:365-367: The 'skip' function previously silently returned on invalid types (e.g., unknown container element types) instead of throwing. This allowed malicious clients to send messages with containers of invalid types, causing the server to enter long parsing loops. The 'readListBegin' (thrift/lib/cpp/protocol/TBinaryProtocol.tcc:308-325) and 'readMapBegin' (thrift/lib/cpp/protocol/TBinaryProtocol.tcc:280-300) functions set 'elemType' and 'valType' from incoming data. If a client sends an unknown type, 'skip' would process each element in a large container, leading to excessive CPU usage. The patch throws 'TProtocolException' on invalid types, preventing the loop.",0.95,./github/other_context/CVE-2019-3552
66,CVE-2020-16125,CWE-754,c_cpp,gdm3 versions before 3.36.2 or 3.38.2 would start gnome-initial-setup if gdm3 can't contact the accountservice service via dbus in a timely manner; on Ubuntu (and potentially derivatives) this could be be chained with an additional issue that could allow a local user to create a new privileged account.,https://github.com/GNOME/gdm/commit/dc8235128c3a1fcd5da8f30ab6839d413d353f28,"display: Exit with failure if loading existing users fails\n\nGiven not having users may make GDM to launch initial setup, that\nallows to create new users (potentially with sudo capabilities), it's\nbetter to make look_for_existing_users() to return its status and only\nif it didn't fail continue the gdm execution.\n\nGHSL-2020-202\nCVE-2020-16125\n\nFixes #642",2,"[{""func_name"": ""look_for_existing_users_sync"", ""file_path"": ""daemon/gdm-display.c"", ""func_code"": ""static void\nlook_for_existing_users_sync (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        GError *error = NULL;\n        GVariant *call_result;\n        GVariant *user_list;\n\n        priv = gdm_display_get_instance_private (self);\n        priv->accountsservice_proxy = g_dbus_proxy_new_sync (priv->connection,\n                                                             0, NULL,\n                                                             \""org.freedesktop.Accounts\"",\n                                                             \""/org/freedesktop/Accounts\"",\n                                                             \""org.freedesktop.Accounts\"",\n                                                             NULL,\n                                                             &error);\n\n        if (!priv->accountsservice_proxy) {\n                g_warning (\""Failed to contact accountsservice: %s\"", error->message);\n                goto out;\n        }\n\n        call_result = g_dbus_proxy_call_sync (priv->accountsservice_proxy,\n                                              \""ListCachedUsers\"",\n                                              NULL,\n                                              0,\n                                              -1,\n                                              NULL,\n                                              &error);\n\n        if (!call_result) {\n                g_warning (\""Failed to list cached users: %s\"", error->message);\n                goto out;\n        }\n\n        g_variant_get (call_result, \""(@ao)\"", &user_list);\n        priv->have_existing_user_accounts = g_variant_n_children (user_list) > 0;\n        g_variant_unref (user_list);\n        g_variant_unref (call_result);\nout:\n        g_clear_error (&error);\n}"", ""target"": 0}, {""func_name"": ""gdm_display_prepare"", ""file_path"": ""daemon/gdm-display.c"", ""func_code"": ""gboolean\ngdm_display_prepare (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        gboolean ret;\n\n        g_return_val_if_fail (GDM_IS_DISPLAY (self), FALSE);\n\n        priv = gdm_display_get_instance_private (self);\n\n        g_debug (\""GdmDisplay: Preparing display: %s\"", priv->id);\n\n        /* FIXME: we should probably do this in a more global place,\n         * asynchronously\n         */\n        look_for_existing_users_sync (self);\n\n        priv->doing_initial_setup = wants_initial_setup (self);\n\n        g_object_ref (self);\n        ret = GDM_DISPLAY_GET_CLASS (self)->prepare (self);\n        g_object_unref (self);\n\n        return ret;\n}"", ""target"": 0}]","[{""func_name"": ""look_for_existing_users_sync"", ""file_path"": ""daemon/gdm-display.c"", ""func_code"": ""static gboolean\nlook_for_existing_users_sync (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        GError *error = NULL;\n        GVariant *call_result;\n        GVariant *user_list;\n\n        priv = gdm_display_get_instance_private (self);\n        priv->accountsservice_proxy = g_dbus_proxy_new_sync (priv->connection,\n                                                             0, NULL,\n                                                             \""org.freedesktop.Accounts\"",\n                                                             \""/org/freedesktop/Accounts\"",\n                                                             \""org.freedesktop.Accounts\"",\n                                                             NULL,\n                                                             &error);\n\n        if (!priv->accountsservice_proxy) {\n                g_critical (\""Failed to contact accountsservice: %s\"", error->message);\n                goto out;\n        }\n\n        call_result = g_dbus_proxy_call_sync (priv->accountsservice_proxy,\n                                              \""ListCachedUsers\"",\n                                              NULL,\n                                              0,\n                                              -1,\n                                              NULL,\n                                              &error);\n\n        if (!call_result) {\n                g_critical (\""Failed to list cached users: %s\"", error->message);\n                goto out;\n        }\n\n        g_variant_get (call_result, \""(@ao)\"", &user_list);\n        priv->have_existing_user_accounts = g_variant_n_children (user_list) > 0;\n        g_variant_unref (user_list);\n        g_variant_unref (call_result);\nout:\n        g_clear_error (&error);\n        return priv->accountsservice_proxy != NULL && call_result != NULL;\n}""}, {""func_name"": ""gdm_display_prepare"", ""file_path"": ""daemon/gdm-display.c"", ""func_code"": ""gboolean\ngdm_display_prepare (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        gboolean ret;\n\n        g_return_val_if_fail (GDM_IS_DISPLAY (self), FALSE);\n\n        priv = gdm_display_get_instance_private (self);\n\n        g_debug (\""GdmDisplay: Preparing display: %s\"", priv->id);\n\n        /* FIXME: we should probably do this in a more global place,\n         * asynchronously\n         */\n        if (!look_for_existing_users_sync (self)) {\n                exit (EXIT_FAILURE);\n        }\n\n        priv->doing_initial_setup = wants_initial_setup (self);\n\n        g_object_ref (self);\n        ret = GDM_DISPLAY_GET_CLASS (self)->prepare (self);\n        g_object_unref (self);\n\n        return ret;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:gdm-display.c, func:wants_initial_setup)"", ""result"": [{""code"": ""static gboolean\nwants_initial_setup (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        gboolean enabled = FALSE;\n        gboolean forced = FALSE;\n\n        priv = gdm_display_get_instance_private (self);\n\n        if (already_done_initial_setup_on_this_boot ()) {\n                return FALSE;\n        }\n\n        if (kernel_cmdline_initial_setup_force_state (&forced)) {\n                if (forced) {\n                        g_debug (\""GdmDisplay: Forcing gnome-initial-setup\"");\n                        return TRUE;\n                }\n\n                g_debug (\""GdmDisplay: Forcing no gnome-initial-setup\"");\n                return FALSE;\n        }\n\n        /* don't run initial-setup on remote displays\n         */\n        if (!priv->is_local) {\n                return FALSE;\n        }\n\n        /* don't run if the system has existing users */\n        if (priv->have_existing_user_accounts) {\n                return FALSE;\n        }\n\n        /* don't run if initial-setup is unavailable */\n        if (!can_create_environment (\""gnome-initial-setup\"")) {\n                return FALSE;\n        }\n\n        if (!gdm_settings_direct_get_boolean (GDM_KEY_INITIAL_SETUP_ENABLE, &enabled)) {\n                return FALSE;\n        }\n\n        return enabled;\n}\n"", ""start_line"": 1618, ""end_line"": 1662, ""full_name"": ""wants_initial_setup"", ""file_path"": ""daemon/gdm-display.c""}]}, {""source"": ""code_info(file:gdm-display.c, lines:514-555)"", ""result"": ""look_for_existing_users_sync (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        GError *error = NULL;\n        GVariant *call_result;\n        GVariant *user_list;\n\n        priv = gdm_display_get_instance_private (self);\n        priv->accountsservice_proxy = g_dbus_proxy_new_sync (priv->connection,\n                                                             0, NULL,\n                                                             \""org.freedesktop.Accounts\"",\n                                                             \""/org/freedesktop/Accounts\"",\n                                                             \""org.freedesktop.Accounts\"",\n                                                             NULL,\n                                                             &error);\n\n        if (!priv->accountsservice_proxy) {\n                g_warning (\""Failed to contact accountsservice: %s\"", error->message);\n                goto out;\n        }\n\n        call_result = g_dbus_proxy_call_sync (priv->accountsservice_proxy,\n                                              \""ListCachedUsers\"",\n                                              NULL,\n                                              0,\n                                              -1,\n                                              NULL,\n                                              &error);\n\n        if (!call_result) {\n                g_warning (\""Failed to list cached users: %s\"", error->message);\n                goto out;\n        }\n\n        g_variant_get (call_result, \""(@ao)\"", &user_list);\n        priv->have_existing_user_accounts = g_variant_n_children (user_list) > 0;\n        g_variant_unref (user_list);\n        g_variant_unref (call_result);\nout:\n        g_clear_error (&error);\n}\n\n""}]","Original code in `look_for_existing_users_sync` (daemon/gdm-display.c:529-531, 542-544) logged warnings but continued execution when accountsservice was unavailable, leaving `priv->have_existing_user_accounts` unset. This allowed `wants_initial_setup` (daemon/gdm-display.c:1618-1662) to assume no existing users and trigger gnome-initial-setup. The patch (daemon/gdm-display.c:552, 569-571) changes this to a critical error, exiting and preventing initial setup.",0.95,./github/other_context/CVE-2020-16125
67,CVE-2020-16293,CWE-476,c_cpp,A null pointer dereference vulnerability in compose_group_nonknockout_nonblend_isolated_allmask_common() in base/gxblend.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.,https://github.com/ArtifexSoftware/ghostpdl/commit/7870f4951bcc6a153f317e3439e14d0e929fd231,Bug 701795: Segv due to image mask issue,2,"[{""func_name"": ""do_compose_group16"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group16(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n                   int x0, int x1, int y0, int y1, int n_chan, bool additive,\n                   const pdf14_nonseparable_blending_procs_t * pblend_procs,\n                   bool has_matte, bool overprint, gx_color_index drawn_comps,\n                   gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    uint16_t alpha = tos->alpha;\n    uint16_t shape = tos->shape;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    uint16_t *tos_ptr =\n        (uint16_t *)(void *)(tos->data + (x0 - tos->rect.p.x)*2 +\n                             (y0 - tos->rect.p.y) * tos->rowstride);\n    uint16_t *nos_ptr =\n        (uint16_t *)(void *)(nos->data + (x0 - nos->rect.p.x)*2 +\n                             (y0 - nos->rect.p.y) * nos->rowstride);\n    uint16_t *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    uint16_t mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    uint16_t *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    const uint16_t *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool has_mask = false;\n    uint16_t *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n#if RAW_DUMP\n    uint16_t *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group16_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + (nos_alpha_g_offset>>1);\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr =\n            (uint16_t *)(void *)(nos->backdrop + (x0 - nos->rect.p.x)*2 +\n                                 (y0 - nos->rect.p.y) * nos->rowstride);\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        unsigned int tmp;\n        mask_tr_fn = (uint16_t *)maskbuf->transfer_fn;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr =\n                (uint16_t *)(void *)(maskbuf->data + (x0 - maskbuf->rect.p.x)*2 +\n                                     (y0 - maskbuf->rect.p.y) * maskbuf->rowstride);\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = interp16(mask_tr_fn, mask_bg_alpha);\n        tmp = alpha * mask_bg_alpha + 0x8000;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", (byte *)tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", (byte *)nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group16_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group16_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask || maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1)\n                    fn = &compose_group16_nonknockout_nonblend_isolated_allmask_common;\n                else\n                    fn = &compose_group16_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group16_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group16_nonknockout_noblend_general;\n\n    tos_planestride >>= 1;\n    tos_shape_offset >>= 1;\n    tos_alpha_g_offset >>= 1;\n    tos_tag_offset >>= 1;\n    nos_planestride >>= 1;\n    nos_shape_offset >>= 1;\n    nos_tag_offset >>= 1;\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride>>1, alpha, shape, blend_mode, tos->has_shape,\n                  tos_shape_offset, tos_alpha_g_offset, tos_tag_offset, tos_has_tag,\n                  nos_ptr, nos_isolated, nos_planestride, nos->rowstride>>1, nos_alpha_g_ptr, nos_knockout,\n                  nos_shape_offset, nos_tag_offset,\n                  mask_row_ptr, has_mask, maskbuf, mask_bg_alpha, mask_tr_fn,\n                  backdrop_ptr,\n                  has_matte, n_chan, additive, num_spots, overprint, drawn_comps, x0, y0, x1, y1,\n                  pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride<<1, nos->rowstride,\n                    \""eComposed\"", (byte *)composed_ptr, nos->deep);\n    global_index++;\n#endif\n}"", ""target"": 1}, {""func_name"": ""do_compose_group"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n              int x0, int x1, int y0, int y1, int n_chan, bool additive,\n              const pdf14_nonseparable_blending_procs_t * pblend_procs,\n              bool has_matte, bool overprint, gx_color_index drawn_comps,\n              gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    byte alpha = tos->alpha>>8;\n    byte shape = tos->shape>>8;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    byte *tos_ptr = tos->data + x0 - tos->rect.p.x +\n        (y0 - tos->rect.p.y) * tos->rowstride;\n    byte *nos_ptr = nos->data + x0 - nos->rect.p.x +\n        (y0 - nos->rect.p.y) * nos->rowstride;\n    byte *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    byte mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    byte *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    byte *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool is_ident = true;\n    bool has_mask = false;\n    byte *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n\n\n#if RAW_DUMP\n    byte *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + nos_alpha_g_offset;\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr = nos->backdrop + x0 - nos->rect.p.x +\n                       (y0 - nos->rect.p.y) * nos->rowstride;\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        int tmp;\n\n        mask_tr_fn = maskbuf->transfer_fn;\n\n        is_ident = maskbuf->is_ident;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr = maskbuf->data + x0 - maskbuf->rect.p.x +\n                    (y0 - maskbuf->rect.p.y) * maskbuf->rowstride;\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha>>8;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = mask_tr_fn[mask_bg_alpha];\n        tmp = alpha * mask_bg_alpha + 0x80;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask || maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1) {\n                    /* AVX and SSE accelerations only valid if maskbuf transfer\n                       function is identity and we have no matte color replacement */\n                    if (is_ident && !has_matte) {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n#ifdef WITH_CAL\n\t\t\tfn = (art_pdf_compose_group_fn)cal_get_compose_group(\n\t\t\t\t\t memory->gs_lib_ctx->core->cal_ctx,\n\t\t\t\t\t (cal_composer_proc_t *)fn,\n\t\t\t\t\t tos->n_chan-1);\n#endif\n                    } else {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n                    }\n                } else\n                    fn = &compose_group_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group_nonknockout_noblend_general;\n\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride, alpha, shape,\n        blend_mode, tos->has_shape, tos_shape_offset, tos_alpha_g_offset,\n        tos_tag_offset, tos_has_tag, nos_ptr, nos_isolated, nos_planestride,\n        nos->rowstride, nos_alpha_g_ptr, nos_knockout, nos_shape_offset,\n        nos_tag_offset, mask_row_ptr, has_mask, maskbuf, mask_bg_alpha,\n        mask_tr_fn, backdrop_ptr, has_matte, n_chan, additive, num_spots,\n        overprint, drawn_comps, x0, y0, x1, y1, pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""eComposed\"", composed_ptr, nos->deep);\n    global_index++;\n#endif\n}"", ""target"": 0}]","[{""func_name"": ""do_compose_group16"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group16(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n                   int x0, int x1, int y0, int y1, int n_chan, bool additive,\n                   const pdf14_nonseparable_blending_procs_t * pblend_procs,\n                   bool has_matte, bool overprint, gx_color_index drawn_comps,\n                   gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    uint16_t alpha = tos->alpha;\n    uint16_t shape = tos->shape;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    uint16_t *tos_ptr =\n        (uint16_t *)(void *)(tos->data + (x0 - tos->rect.p.x)*2 +\n                             (y0 - tos->rect.p.y) * tos->rowstride);\n    uint16_t *nos_ptr =\n        (uint16_t *)(void *)(nos->data + (x0 - nos->rect.p.x)*2 +\n                             (y0 - nos->rect.p.y) * nos->rowstride);\n    uint16_t *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    uint16_t mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    uint16_t *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    const uint16_t *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool has_mask = false;\n    uint16_t *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n#if RAW_DUMP\n    uint16_t *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group16_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + (nos_alpha_g_offset>>1);\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr =\n            (uint16_t *)(void *)(nos->backdrop + (x0 - nos->rect.p.x)*2 +\n                                 (y0 - nos->rect.p.y) * nos->rowstride);\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        unsigned int tmp;\n        mask_tr_fn = (uint16_t *)maskbuf->transfer_fn;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr =\n                (uint16_t *)(void *)(maskbuf->data + (x0 - maskbuf->rect.p.x)*2 +\n                                     (y0 - maskbuf->rect.p.y) * maskbuf->rowstride);\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = interp16(mask_tr_fn, mask_bg_alpha);\n        tmp = alpha * mask_bg_alpha + 0x8000;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", (byte *)tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", (byte *)nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group16_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group16_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask && maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1)\n                    fn = &compose_group16_nonknockout_nonblend_isolated_allmask_common;\n                else\n                    fn = &compose_group16_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group16_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group16_nonknockout_noblend_general;\n\n    tos_planestride >>= 1;\n    tos_shape_offset >>= 1;\n    tos_alpha_g_offset >>= 1;\n    tos_tag_offset >>= 1;\n    nos_planestride >>= 1;\n    nos_shape_offset >>= 1;\n    nos_tag_offset >>= 1;\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride>>1, alpha, shape, blend_mode, tos->has_shape,\n                  tos_shape_offset, tos_alpha_g_offset, tos_tag_offset, tos_has_tag,\n                  nos_ptr, nos_isolated, nos_planestride, nos->rowstride>>1, nos_alpha_g_ptr, nos_knockout,\n                  nos_shape_offset, nos_tag_offset,\n                  mask_row_ptr, has_mask, maskbuf, mask_bg_alpha, mask_tr_fn,\n                  backdrop_ptr,\n                  has_matte, n_chan, additive, num_spots, overprint, drawn_comps, x0, y0, x1, y1,\n                  pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride<<1, nos->rowstride,\n                    \""eComposed\"", (byte *)composed_ptr, nos->deep);\n    global_index++;\n#endif\n}""}, {""func_name"": ""do_compose_group"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n              int x0, int x1, int y0, int y1, int n_chan, bool additive,\n              const pdf14_nonseparable_blending_procs_t * pblend_procs,\n              bool has_matte, bool overprint, gx_color_index drawn_comps,\n              gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    byte alpha = tos->alpha>>8;\n    byte shape = tos->shape>>8;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    byte *tos_ptr = tos->data + x0 - tos->rect.p.x +\n        (y0 - tos->rect.p.y) * tos->rowstride;\n    byte *nos_ptr = nos->data + x0 - nos->rect.p.x +\n        (y0 - nos->rect.p.y) * nos->rowstride;\n    byte *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    byte mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    byte *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    byte *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool is_ident = true;\n    bool has_mask = false;\n    byte *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n\n\n#if RAW_DUMP\n    byte *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + nos_alpha_g_offset;\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr = nos->backdrop + x0 - nos->rect.p.x +\n                       (y0 - nos->rect.p.y) * nos->rowstride;\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        int tmp;\n\n        mask_tr_fn = maskbuf->transfer_fn;\n\n        is_ident = maskbuf->is_ident;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr = maskbuf->data + x0 - maskbuf->rect.p.x +\n                    (y0 - maskbuf->rect.p.y) * maskbuf->rowstride;\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha>>8;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = mask_tr_fn[mask_bg_alpha];\n        tmp = alpha * mask_bg_alpha + 0x80;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask && maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1) {\n                    /* AVX and SSE accelerations only valid if maskbuf transfer\n                       function is identity and we have no matte color replacement */\n                    if (is_ident && !has_matte) {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n#ifdef WITH_CAL\n\t\t\tfn = (art_pdf_compose_group_fn)cal_get_compose_group(\n\t\t\t\t\t memory->gs_lib_ctx->core->cal_ctx,\n\t\t\t\t\t (cal_composer_proc_t *)fn,\n\t\t\t\t\t tos->n_chan-1);\n#endif\n                    } else {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n                    }\n                } else\n                    fn = &compose_group_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group_nonknockout_noblend_general;\n\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride, alpha, shape,\n        blend_mode, tos->has_shape, tos_shape_offset, tos_alpha_g_offset,\n        tos_tag_offset, tos_has_tag, nos_ptr, nos_isolated, nos_planestride,\n        nos->rowstride, nos_alpha_g_ptr, nos_knockout, nos_shape_offset,\n        nos_tag_offset, mask_row_ptr, has_mask, maskbuf, mask_bg_alpha,\n        mask_tr_fn, backdrop_ptr, has_matte, n_chan, additive, num_spots,\n        overprint, drawn_comps, x0, y0, x1, y1, pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""eComposed\"", composed_ptr, nos->deep);\n    global_index++;\n#endif\n}""}]","{""value"": 2, ""code"": 3}","[{""source"": ""value_info(file:gxblend.c, value:has_mask)"", ""result"": {""value_trace"": [{""full_code"": ""has_mask = false"", ""line"": 3363, ""func_name"": ""do_compose_group""}, {""full_code"": ""has_mask = true"", ""line"": 3410, ""func_name"": ""do_compose_group""}, {""full_code"": ""has_mask = false"", ""line"": 4136, ""func_name"": ""do_compose_group16""}, {""full_code"": ""has_mask = true"", ""line"": 4180, ""func_name"": ""do_compose_group16""}, {""full_code"": ""has_mask = false"", ""line"": 4341, ""func_name"": ""do_compose_alphaless_group""}], ""struct_var"": ""has_mask"", ""struct_type"": ""bool"", ""struct_definition"": ""typedef int bool;\n\ntypedef int bool;\n\ntypedef unsigned char bool;\n\ntypedef int bool;\n\ntypedef int bool;""}}, {""source"": ""value_info(file:gxblend.c, value:maskbuf)"", ""result"": {""value_trace"": [{""full_code"": ""maskbuf = mask_stack->rc_mask->mask_buf"", ""line"": 974, ""func_name"": ""template_transform_color_buffer""}, {""full_code"": ""maskbuf = NULL"", ""line"": 1506, ""func_name"": ""pdf14_pop_transparency_group""}, {""full_code"": ""maskbuf = mask_stack->rc_mask->mask_buf"", ""line"": 1508, ""func_name"": ""pdf14_pop_transparency_group""}], ""struct_var"": ""maskbuf"", ""struct_type"": ""pdf14_buf*"", ""struct_definition"": ""typedef struct pdf14_buf_s pdf14_buf;""}}, {""source"": ""code_info(file:gxblend.c, lines:3400-3420)"", ""result"": ""    if (maskbuf != NULL) {\n        int tmp;\n\n        mask_tr_fn = maskbuf->transfer_fn;\n\n        is_ident = maskbuf->is_ident;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr = maskbuf->data + x0 - maskbuf->rect.p.x +\n                    (y0 - maskbuf->rect.p.y) * maskbuf->rowstride;\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha>>8;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = mask_tr_fn[mask_bg_alpha];\n        tmp = alpha * mask_bg_alpha + 0x80;\n""}, {""source"": ""code_info(file:gxblend.c, lines:4170-4190)"", ""result"": ""        overprint = false;\n\n    if (maskbuf != NULL) {\n        unsigned int tmp;\n        mask_tr_fn = (uint16_t *)maskbuf->transfer_fn;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr =\n                (uint16_t *)(void *)(maskbuf->data + (x0 - maskbuf->rect.p.x)*2 +\n                                     (y0 - maskbuf->rect.p.y) * maskbuf->rowstride);\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = interp16(mask_tr_fn, mask_bg_alpha);\n        tmp = alpha * mask_bg_alpha + 0x8000;\n""}, {""source"": ""code_info(file:gxblend.c, lines:4330-4350)"", ""result"": ""    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    byte *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    const byte *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool has_mask = false;\n    byte *backdrop_ptr = NULL;\n#if RAW_DUMP\n    byte *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n""}]","In `gxblend.c:3477`, the original condition `has_mask || maskbuf` allowed execution if either was true. `has_mask` is set to true in `do_compose_group` (line 3410) and `do_compose_group16` (line 4180) *only if* `maskbuf` is non-null and valid (i.e., `maskbuf != NULL && maskbuf->data != NULL`). However, `maskbuf` can later be set to NULL (e.g., via `pdf14_pop_transparency_group` lines 1506/1508), leaving `has_mask` still true. The code at line 3477 then proceeds to dereference the NULL `maskbuf`, causing a segv. The patch fixes this by requiring both `has_mask && maskbuf`, ensuring `maskbuf` is valid at use time.",0.95,./github/other_context/CVE-2020-16293
68,CVE-2020-25602,CWE-755,c_cpp,"An issue was discovered in Xen through 4.14.x. An x86 PV guest can trigger a host OS crash when handling guest access to MSR_MISC_ENABLE. When a guest accesses certain Model Specific Registers, Xen first reads the value from hardware to use as the basis for auditing the guest access. For the MISC_ENABLE MSR, which is an Intel specific MSR, this MSR read is performed without error handling for a #GP fault, which is the consequence of trying to read this MSR on non-Intel hardware. A buggy or malicious PV guest administrator can crash Xen, resulting in a host Denial of Service. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only Xen versions 4.11 and onwards are vulnerable. 4.10 and earlier are not vulnerable. Only x86 systems that do not implement the MISC_ENABLE MSR (0x1a0) are vulnerable. AMD and Hygon systems do not implement this MSR and are vulnerable. Intel systems do implement this MSR and are not vulnerable. Other manufacturers have not been checked. Only x86 PV guests can exploit the vulnerability. x86 HVM/PVH guests cannot exploit the vulnerability.",https://github.com/xen-project/xen/commit/e71301ecd50f2d3bd1b960bbf7dcf850d02e7e8a,"x86/pv: Handle the Intel-specific MSR_MISC_ENABLE correctly\n\nThis MSR doesn't exist on AMD hardware, and switching away from the safe\nfunctions in the common MSR path was an erroneous change.\n\nPartially revert the change.\n\nThis is XSA-333.\n\nFixes: 4fdc932b3cc (""x86/Intel: drop another 32-bit leftover"")\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Wei Liu <wl@xen.org>",2,"[{""func_name"": ""write_msr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int write_msr(unsigned int reg, uint64_t val,\n                     struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_wrmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n        uint64_t temp;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrfsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsshadow(val);\n        curr->arch.pv.gs_base_user = val;\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        /*\n         * Reject writes which change the value, but Linux depends on being\n         * able to write back the current value.\n         */\n        if ( val != guest_efer(currd) )\n            break;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n    case MSR_K8_HWCR:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_NB_CFG:\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) ||\n             ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 )\n            break;\n        if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ?\n             temp != val :\n             ((temp ^ val) &\n              ~(FAM10H_MMIO_CONF_ENABLE |\n                (FAM10H_MMIO_CONF_BUSRANGE_MASK <<\n                 FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n                ((u64)FAM10H_MMIO_CONF_BASE_MASK <<\n                 FAM10H_MMIO_CONF_BASE_SHIFT))) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, temp);\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n    case MSR_IA32_APERF:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_INTEL | X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_PERF_CTL:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_THERM_CONTROL:\n    case MSR_IA32_ENERGY_PERF_BIAS:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) || wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( (vpmu_mode & XENPMU_MODE_ALL) &&\n                     !is_hardware_domain(currd) )\n                    return X86EMUL_OKAY;\n\n                if ( vpmu_do_wrmsr(reg, val, 0) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING,\n                 \""WRMSR 0x%08x val 0x%016\""PRIx64\"" unimplemented\\n\"",\n                 reg, val);\n        break;\n\n    invalid:\n        gdprintk(XENLOG_WARNING,\n                 \""Domain attempted WRMSR 0x%08x from 0x%016\""PRIx64\"" to 0x%016\""PRIx64\""\\n\"",\n                 reg, temp, val);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}"", ""target"": 0}, {""func_name"": ""read_msr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int read_msr(unsigned int reg, uint64_t *val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n    case MSR_APIC_BASE:\n        /* Linux PV guests will attempt to read APIC_BASE. */\n        *val = APIC_BASE_ENABLE | APIC_DEFAULT_PHYS_BASE;\n        if ( !curr->vcpu_id )\n            *val |= APIC_BASE_BSP;\n        return X86EMUL_OKAY;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdfsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdgsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = curr->arch.pv.gs_base_user;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_TSC:\n        *val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        *val = guest_efer(currd);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_CR_PAT:\n        *val = XEN_MSR_PAT;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( unlikely(is_cpufreq_controller(currd)) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        /* fall through */\n    case MSR_AMD64_NB_CFG:\n        if ( is_hwdom_pinned_vcpu(curr) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, *val);\n        *val = guest_misc_enable(*val);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_PERF_CAPABILITIES:\n        /* No extra capabilities are supported. */\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n            /* fall through */\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( vpmu_do_rdmsr(reg, val) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING, \""RDMSR 0x%08x unimplemented\\n\"", reg);\n        break;\n\n    normal:\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}"", ""target"": 0}]","[{""func_name"": ""write_msr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int write_msr(unsigned int reg, uint64_t val,\n                     struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_wrmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n        uint64_t temp;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrfsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsshadow(val);\n        curr->arch.pv.gs_base_user = val;\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        /*\n         * Reject writes which change the value, but Linux depends on being\n         * able to write back the current value.\n         */\n        if ( val != guest_efer(currd) )\n            break;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n    case MSR_K8_HWCR:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_NB_CFG:\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) ||\n             ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 )\n            break;\n        if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ?\n             temp != val :\n             ((temp ^ val) &\n              ~(FAM10H_MMIO_CONF_ENABLE |\n                (FAM10H_MMIO_CONF_BUSRANGE_MASK <<\n                 FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n                ((u64)FAM10H_MMIO_CONF_BASE_MASK <<\n                 FAM10H_MMIO_CONF_BASE_SHIFT))) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_MISC_ENABLE:\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n    case MSR_IA32_APERF:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_INTEL | X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_PERF_CTL:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_THERM_CONTROL:\n    case MSR_IA32_ENERGY_PERF_BIAS:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) || wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( (vpmu_mode & XENPMU_MODE_ALL) &&\n                     !is_hardware_domain(currd) )\n                    return X86EMUL_OKAY;\n\n                if ( vpmu_do_wrmsr(reg, val, 0) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING,\n                 \""WRMSR 0x%08x val 0x%016\""PRIx64\"" unimplemented\\n\"",\n                 reg, val);\n        break;\n\n    invalid:\n        gdprintk(XENLOG_WARNING,\n                 \""Domain attempted WRMSR 0x%08x from 0x%016\""PRIx64\"" to 0x%016\""PRIx64\""\\n\"",\n                 reg, temp, val);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}""}, {""func_name"": ""read_msr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int read_msr(unsigned int reg, uint64_t *val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n    case MSR_APIC_BASE:\n        /* Linux PV guests will attempt to read APIC_BASE. */\n        *val = APIC_BASE_ENABLE | APIC_DEFAULT_PHYS_BASE;\n        if ( !curr->vcpu_id )\n            *val |= APIC_BASE_BSP;\n        return X86EMUL_OKAY;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdfsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdgsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = curr->arch.pv.gs_base_user;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_TSC:\n        *val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        *val = guest_efer(currd);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_CR_PAT:\n        *val = XEN_MSR_PAT;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( unlikely(is_cpufreq_controller(currd)) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        /* fall through */\n    case MSR_AMD64_NB_CFG:\n        if ( is_hwdom_pinned_vcpu(curr) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        *val = guest_misc_enable(*val);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_PERF_CAPABILITIES:\n        /* No extra capabilities are supported. */\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n            /* fall through */\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( vpmu_do_rdmsr(reg, val) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING, \""RDMSR 0x%08x unimplemented\\n\"", reg);\n        break;\n\n    normal:\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}""}]","{""code"": 4, ""value"": 1}","[{""source"": ""code_info(file:emul-priv-op.c, lines:1100-1110)"", ""result"": ""        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, temp);\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n""}, {""source"": ""code_info(file:emul-priv-op.c, lines:955-965)"", ""result"": ""    case MSR_AMD64_NB_CFG:\n        if ( is_hwdom_pinned_vcpu(curr) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, *val);\n        *val = guest_misc_enable(*val);\n        return X86EMUL_OKAY;\n\n""}, {""source"": ""value_info(file:emul-priv-op.c, value:reg)"", ""result"": {""value_trace"": [{""full_code"": ""reg = instr & 7"", ""line"": 100, ""func_name"": ""decode_thumb""}, {""full_code"": ""reg = readl_gicd(offset + (irqd->irq / 32) * 4) & (1U << (irqd->irq % 32))"", ""line"": 250, ""func_name"": ""gicv2_peek_irq""}, {""full_code"": ""reg &= ~GENMASK(51, 16)"", ""line"": 166, ""func_name"": ""encode_rdbase""}, {""full_code"": ""reg |= gicv3_get_redist_address(cpu, hw_its->flags & HOST_ITS_USES_PTA)"", ""line"": 168, ""func_name"": ""encode_rdbase""}, {""full_code"": ""reg  = GIC_BASER_InnerShareable << GITS_BASER_SHAREABILITY_SHIFT"", ""line"": 305, ""func_name"": ""its_map_cbaser""}], ""struct_var"": ""reg"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:msr.h, lines:1-50)"", ""result"": ""#ifndef __ASM_MSR_H\n#define __ASM_MSR_H\n\n#include \""msr-index.h\""\n\n#include <xen/types.h>\n#include <xen/percpu.h>\n#include <xen/errno.h>\n\n#include <xen/lib/x86/msr.h>\n\n#include <asm/asm_defns.h>\n#include <asm/cpufeature.h>\n#include <asm/processor.h>\n\n#define rdmsr(msr,val1,val2) \\\n     __asm__ __volatile__(\""rdmsr\"" \\\n\t\t\t  : \""=a\"" (val1), \""=d\"" (val2) \\\n\t\t\t  : \""c\"" (msr))\n\n#define rdmsrl(msr,val) do { unsigned long a__,b__; \\\n       __asm__ __volatile__(\""rdmsr\"" \\\n\t\t\t    : \""=a\"" (a__), \""=d\"" (b__) \\\n\t\t\t    : \""c\"" (msr)); \\\n       val = a__ | ((u64)b__<<32); \\\n} while(0)\n\n#define wrmsr(msr,val1,val2) \\\n     __asm__ __volatile__(\""wrmsr\"" \\\n\t\t\t  : /* no outputs */ \\\n\t\t\t  : \""c\"" (msr), \""a\"" (val1), \""d\"" (val2))\n\nstatic inline void wrmsrl(unsigned int msr, __u64 val)\n{\n        __u32 lo, hi;\n        lo = (__u32)val;\n        hi = (__u32)(val >> 32);\n        wrmsr(msr, lo, hi);\n}\n\n/* rdmsr with exception handling */\n#define rdmsr_safe(msr,val) ({\\\n    int rc_; \\\n    uint32_t lo_, hi_; \\\n    __asm__ __volatile__( \\\n        \""1: rdmsr\\n2:\\n\"" \\\n        \"".section .fixup,\\\""ax\\\""\\n\"" \\\n        \""3: xorl %0,%0\\n; xorl %1,%1\\n\"" \\\n        \""   movl %5,%2\\n; jmp 2b\\n\"" \\\n        \"".previous\\n\"" \\\n""}, {""source"": ""code_info(file:msr.h, lines:51-100)"", ""result"": ""        _ASM_EXTABLE(1b, 3b) \\\n        : \""=a\"" (lo_), \""=d\"" (hi_), \""=&r\"" (rc_) \\\n        : \""c\"" (msr), \""2\"" (0), \""i\"" (-EFAULT)); \\\n    val = lo_ | ((uint64_t)hi_ << 32); \\\n    rc_; })\n\n/* wrmsr with exception handling */\nstatic inline int wrmsr_safe(unsigned int msr, uint64_t val)\n{\n    int rc;\n    uint32_t lo, hi;\n    lo = (uint32_t)val;\n    hi = (uint32_t)(val >> 32);\n\n    __asm__ __volatile__(\n        \""1: wrmsr\\n2:\\n\""\n        \"".section .fixup,\\\""ax\\\""\\n\""\n        \""3: movl %5,%0\\n; jmp 2b\\n\""\n        \"".previous\\n\""\n        _ASM_EXTABLE(1b, 3b)\n        : \""=&r\"" (rc)\n        : \""c\"" (msr), \""a\"" (lo), \""d\"" (hi), \""0\"" (0), \""i\"" (-EFAULT));\n    return rc;\n}\n\nstatic inline uint64_t msr_fold(const struct cpu_user_regs *regs)\n{\n    return (regs->rdx << 32) | regs->eax;\n}\n\nstatic inline void msr_split(struct cpu_user_regs *regs, uint64_t val)\n{\n    regs->rdx = val >> 32;\n    regs->rax = (uint32_t)val;\n}\n\nstatic inline uint64_t rdtsc(void)\n{\n    uint32_t low, high;\n\n    __asm__ __volatile__(\""rdtsc\"" : \""=a\"" (low), \""=d\"" (high));\n\n    return ((uint64_t)high << 32) | low;\n}\n\nstatic inline uint64_t rdtsc_ordered(void)\n{\n\t/*\n\t * The RDTSC instruction is not ordered relative to memory access.\n\t * The Intel SDM and the AMD APM are both vague on this point, but\n""}]","Original code used `rdmsrl(reg, *val)` (emul-priv-op.c:960) and `rdmsrl(reg, temp)` (emul-priv-op.c:1103) to read MSR_IA32_MISC_ENABLE without error handling. On non-Intel hardware, this triggers an unhandled #GP fault. The `rdmsr_safe` macro (msr.h:1-100) adds exception handling via `.section .fixup`, returning -EFAULT if the MSR read fails. The patch checks this return value (emul-priv-op.c:960-961, 1103-1104), preventing the crash.",0.95,./github/other_context/CVE-2020-25602
69,CVE-2020-6019,CWE-248,c_cpp,"Valve's Game Networking Sockets prior to version v1.2.0 improperly handles inlined statistics messages in function CConnectionTransportUDPBase::Received_Data(), leading to an exception thrown from libprotobuf and resulting in a crash.",https://github.com/ValveSoftware/GameNetworkingSockets/commit/d944a10808891d202bb1d5e1998de6e0423af678,Tweak pointer math to avoid possible integer overflow,1,"[{""func_name"": ""CConnectionTransportUDPBase::Received_Data"", ""file_path"": ""src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"", ""func_code"": ""void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Packet of size %d is too small.\"", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Incorrect connection ID\"" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \""Received inline stats from %s\"", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Failed to varint decode size of stats blob\"" );\n\t\t\treturn;\n\t\t}\n\t\tif ( pIn + cbStatsMsgIn > pPktEnd )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""stats message size doesn't make sense.  Stats message size %d, packet size %d\"", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""protobuf failed to parse inline stats message\"" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}"", ""target"": 0}]","[{""func_name"": ""CConnectionTransportUDPBase::Received_Data"", ""file_path"": ""src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"", ""func_code"": ""void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Packet of size %d is too small.\"", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Incorrect connection ID\"" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \""Received inline stats from %s\"", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Failed to varint decode size of stats blob\"" );\n\t\t\treturn;\n\t\t}\n\t\tif ( cbStatsMsgIn > pPktEnd - pIn )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""stats message size doesn't make sense.  Stats message size %u, packet size %d\"", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""protobuf failed to parse inline stats message\"" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}""}]","{""value"": 1, ""code"": 1, ""function"": 1}","[{""source"": ""value_info(file:steamnetworkingsockets_udp.cpp, value:cbStatsMsgIn)"", ""result"": {""value_trace"": [{""full_code"": ""cbStatsMsgIn = 0"", ""line"": 832, ""func_name"": ""SteamNetworkingSocketsLib.CConnectionTransportUDPBase.Received_Data:void(uint8*,int,SteamNetworkingMicroseconds)""}], ""struct_var"": ""cbStatsMsgIn"", ""struct_type"": ""uint32"", ""struct_definition"": ""typedef unsigned int uint32;\n\ntypedef unsigned int uint32;\n\nuint32""}}, {""source"": ""code_info(file:steamnetworkingsockets_udp.cpp, lines:832-841)"", ""result"": ""\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \""Received inline stats from %s\"", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Failed to varint decode size of stats blob\"" );\n\t\t\treturn;\n""}, {""source"": ""func_info(func:DeserializeVarInt)"", ""result"": [{""code"": ""inline byte *DeserializeVarInt( byte *p, const byte *end, T &x )\n{\n\tif ( p >= end )\n\t\treturn nullptr;\n\tT nResult = *p & 0x7f; // use local variable for working, to make sure compiler doesn't try to worry about pointer aliasing\n\tunsigned nShift = 7;\n\twhile ( *(p++) & 0x80 )\n\t{\n\t\tif ( p >= end )\n\t\t\treturn nullptr;\n\t\tnResult |= ( T( *p & 0x7f ) << nShift );\n\t\tnShift += 7;\n\t}\n\tx = nResult;\n\treturn p;\n}"", ""start_line"": 376, ""end_line"": 391, ""full_name"": ""SteamNetworkingSocketsLib.DeserializeVarInt:byte(byte*,byte*,T&)"", ""file_path"": ""src/steamnetworkingsockets/steamnetworkingsockets_internal.h""}, {""code"": ""inline const byte *DeserializeVarInt( const byte *p, const byte *end, T &x )\n{\n\treturn DeserializeVarInt( const_cast<byte*>( p ), end, x );\n}"", ""start_line"": 395, ""end_line"": 398, ""full_name"": ""SteamNetworkingSocketsLib.DeserializeVarInt<duplicate>0:byte(byte*,byte*,T&)"", ""file_path"": ""src/steamnetworkingsockets/steamnetworkingsockets_internal.h""}]}]","The vulnerability stems from unbounded varint decoding in `DeserializeVarInt` (src/steamnetworkingsockets/steamnetworkingsockets_internal.h:376-391), which assigns the decoded value to `cbStatsMsgIn` (src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp:835) without validation. The original bounds check `pIn + cbStatsMsgIn > pPktEnd` (line 841) could overflow if `cbStatsMsgIn` is large, leading to incorrect bounds validation and out-of-bounds memory access. The patch replaces the check with `cbStatsMsgIn > pPktEnd - pIn` to avoid overflow.",0.95,./github/other_context/CVE-2020-6019
70,CVE-2020-8448,CWE-476,c_cpp,"In OSSEC-HIDS 2.7 through 3.5.0, the server component responsible for log analysis (ossec-analysisd) is vulnerable to a denial of service (NULL pointer dereference) via crafted messages written directly to the analysisd UNIX domain socket by a local user.",https://github.com/ossec/ossec-hids/commit/9b8b14c88188cdc66ab25f92a26918d0cb8a7760,"analysisd: fix possible null ptr deref in OS_CleanMSG.\n\nIf the `msg` provided to `OS_CleanMSG` has a `(` after the ID, but\ndoesn't not contain a `->` or `:` it should be rejected with\na `FORMAT_ERROR`.\n\nPrev. to this commit nesting `strstr` for `->` as the first argument to\n`strchr` for `:` results in a null ptr deref when the message is\nmalformed.",1,"[{""func_name"": ""OS_CleanMSG"", ""file_path"": ""src/analysisd/cleanevent.c"", ""func_code"": ""int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \""->\""), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: M\u00e4r 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \""Sender \"", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \""Message \"", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \""Host \"", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \""%02d:%02d:%02d\"",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\""**Phase 1: Completed pre-decoding.\"");\n        print_out(\""       full event: '%s'\"", lf->full_log);\n        print_out(\""       hostname: '%s'\"", lf->hostname);\n        print_out(\""       program_name: '%s'\"", lf->program_name);\n        print_out(\""       log: '%s'\"", lf->log);\n    }\n#endif\n    return (0);\n}"", ""target"": 0}]","[{""func_name"": ""OS_CleanMSG"", ""file_path"": ""src/analysisd/cleanevent.c"", ""func_code"": ""int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strstr(msg, \""->\"");\n        if(!pieces) {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n        pieces = strchr(pieces, ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: M\u00e4r 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \""Sender \"", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \""Message \"", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \""Host \"", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \""%02d:%02d:%02d\"",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\""**Phase 1: Completed pre-decoding.\"");\n        print_out(\""       full event: '%s'\"", lf->full_log);\n        print_out(\""       hostname: '%s'\"", lf->hostname);\n        print_out(\""       program_name: '%s'\"", lf->program_name);\n        print_out(\""       log: '%s'\"", lf->log);\n    }\n#endif\n    return (0);\n}""}]","{""caller"": 1, ""code"": 4, ""value"": 3, ""function"": 2}","[{""source"": ""caller_info(file:cleanevent.c, func:OS_CleanMSG)"", ""result"": [{""call_line"": 713, ""call_code"": ""OS_CleanMSG(msg, lf)"", ""caller_code"": ""void OS_ReadMSG(int m_queue)\n#else\n__attribute__((noreturn))\nvoid OS_ReadMSG_analysisd(int m_queue)\n#endif\n{\n    int i;\n    char msg[OS_MAXSTR + 1];\n    Eventinfo *lf;\n\n    RuleInfo *stats_rule = NULL;\n\n    /* Null to global currently pointers */\n    currently_rule = NULL;\n\n    /* Initialize the logs */\n    OS_InitLog();\n\n    /* Initialize the integrity database */\n    SyscheckInit();\n\n    /* Initialize Rootcheck */\n    RootcheckInit();\n\n    /* Initialize host info */\n    HostinfoInit();\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    /* Start the active response queues */\n    if (Config.ar) {\n        /* Waiting the ARQ to settle */\n        sleep(3);\n\n#ifndef LOCAL\n        if (Config.ar & REMOTE_AR)..."", ""caller_start"": 528, ""file_path"": ""src/analysisd/analysisd.c""}, {""call_line"": 432, ""call_code"": ""OS_CleanMSG(msg, lf)"", ""caller_code"": ""void OS_ReadMSG(char *ut_str)\n{\n    char msg[OS_MAXSTR + 1];\n    int exit_code = 0;\n    char *ut_alertlevel = NULL;\n    char *ut_rulelevel = NULL;\n    char *ut_decoder_name = NULL;\n\n    if (ut_str) {\n        /* XXX Break apart string */\n        ut_rulelevel = ut_str;\n        ut_alertlevel =  strchr(ut_rulelevel, ':');\n        if (!ut_alertlevel) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_alertlevel = '\\0';\n            ut_alertlevel++;\n        }\n        ut_decoder_name = strchr(ut_alertlevel, ':');\n        if (!ut_decoder_name) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_decoder_name = '\\0';\n            ut_decoder_name++;\n        }\n    }\n\n    RuleInfoDetail *last_info_detail;\n    Eventinfo *lf;\n\n    /* Null global point..."", ""caller_start"": 332, ""file_path"": ""src/analysisd/testrule.c""}]}, {""source"": ""code_info(file:cleanevent.c, lines:1-60)"", ""result"": ""/* Copyright (C) 2009 Trend Micro Inc.\n * All rights reserved.\n *\n * This program is a free software; you can redistribute it\n * and/or modify it under the terms of the GNU General Public\n * License (version 2) as published by the FSF - Free Software\n * Foundation.\n */\n\n#include \""cleanevent.h\""\n\n#include \""shared.h\""\n#include \""os_regex/os_regex.h\""\n#include \""analysisd.h\""\n#include \""fts.h\""\n#include \""config.h\""\n\n/* To translate between month (int) to month (char) */\nstatic const char *(month[]) = {\""Jan\"", \""Feb\"", \""Mar\"", \""Apr\"", \""May\"", \""Jun\"",\n                   \""Jul\"", \""Aug\"", \""Sep\"", \""Oct\"", \""Nov\"", \""Dec\""\n                  };\n\n\n/* Format a received message in the Eventinfo structure */\nint OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \""->\""), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n""}, {""source"": ""value_info(file:cleanevent.c, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg += 2"", ""line"": 36, ""func_name"": ""OS_CleanMSG""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""code_info(file:analysisd.c, lines:528-713)"", ""result"": ""void OS_ReadMSG(int m_queue)\n#else\n__attribute__((noreturn))\nvoid OS_ReadMSG_analysisd(int m_queue)\n#endif\n{\n    int i;\n    char msg[OS_MAXSTR + 1];\n    Eventinfo *lf;\n\n    RuleInfo *stats_rule = NULL;\n\n    /* Null to global currently pointers */\n    currently_rule = NULL;\n\n    /* Initialize the logs */\n    OS_InitLog();\n\n    /* Initialize the integrity database */\n    SyscheckInit();\n\n    /* Initialize Rootcheck */\n    RootcheckInit();\n\n    /* Initialize host info */\n    HostinfoInit();\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    /* Start the active response queues */\n    if (Config.ar) {\n        /* Waiting the ARQ to settle */\n        sleep(3);\n\n#ifndef LOCAL\n        if (Config.ar & REMOTE_AR) {\n            if ((arq = StartMQ(ARQUEUE, WRITE)) < 0) {\n                merror(ARQ_ERROR, ARGV0);\n\n                /* If LOCAL_AR is set, keep it there */\n                if (Config.ar & LOCAL_AR) {\n                    Config.ar = 0;\n                    Config.ar |= LOCAL_AR;\n                } else {\n                    Config.ar = 0;\n                }\n            } else {\n                verbose(CONN_TO, ARGV0, ARQUEUE, \""active-response\"");\n            }\n        }\n#else\n        /* Only for LOCAL_ONLY installs */\n        if (Config.ar & REMOTE_AR) {\n            if (Config.ar & LOCAL_AR) {\n                Config.ar = 0;\n                Config.ar |= LOCAL_AR;\n            } else {\n                Config.ar = 0;\n            }\n        }\n#endif\n\n        if (Config.ar & LOCAL_AR) {\n            if ((execdq = StartMQ(EXECQUEUE, WRITE)) < 0) {\n                merror(ARQ_ERROR, ARGV0);\n\n                /* If REMOTE_AR is set, keep it there */\n                if (Config.ar & REMOTE_AR) {\n                    Config.ar = 0;\n                    Config.ar |= REMOTE_AR;\n                } else {\n                    Config.ar = 0;\n                }\n            } else {\n                verbose(CONN_TO, ARGV0, EXECQUEUE, \""exec\"");\n            }\n        }\n    }\n    debug1(\""%s: DEBUG: Active response Init completed.\"", ARGV0);\n\n    /* Get current time before starting */\n    c_time = time(NULL);\n\n    /* Start the hourly/weekly stats */\n    if (Start_Hour() < 0) {\n        Config.stats = 0;\n    } else {\n        /* Initialize stats rules */\n        stats_rule = zerorulemember(\n                         STATS_MODULE,\n                         Config.stats,\n                         0, 0, 0, 0, 0, 0);\n\n        if (!stats_rule) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n        stats_rule->group = \""stats,\"";\n        stats_rule->comment = \""Excessive number of events (above normal).\"";\n    }\n\n    /* Do some cleanup */\n    memset(msg, '\\0', OS_MAXSTR + 1);\n\n    /* Initialize the logs */\n    {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        if (!lf) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n        lf->year = prev_year;\n        strncpy(lf->mon, prev_month, 3);\n        lf->day = today;\n\n        if (OS_GetLogLocation(lf) < 0) {\n            ErrorExit(\""%s: Error allocating log files\"", ARGV0);\n        }\n\n        Free_Eventinfo(lf);\n    }\n\n#ifdef SQLITE_ENABLED\n    /* Open the sqlite db */\n    extern sqlite3 *conn;\n    int s_error = 0;\n    if (Config.md5_allowlist) {\n        debug2(\""Opening md5_allowlist: %s\"", Config.md5_allowlist);\n        if((s_error = sqlite3_open(Config.md5_allowlist, &conn))) {\n            merror(INVALID_IGNORE_MD5DB, ARGV0, Config.md5_allowlist);\n        }\n\n    }\n#endif\n\n    debug1(\""%s: DEBUG: Startup completed. Waiting for new messages..\"", ARGV0);\n\n    if (Config.custom_alert_output) {\n        debug1(\""%s: INFO: Custom output found.!\"", ARGV0);\n    }\n\n    /* Daemon loop */\n    while (1) {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n\n        /* This shouldn't happen */\n        if (lf == NULL) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n\n        DEBUG_MSG(\""%s: DEBUG: Waiting for msgs - %d \"", ARGV0, (int)time(0));\n\n        /* Receive message from queue */\n        if ((i = OS_RecvUnix(m_queue, OS_MAXSTR, msg))) {\n            RuleNode *rulenode_pt;\n\n            /* Get the time we received the event */\n            c_time = time(NULL);\n\n            /* Default values for the log info */\n            Zero_Eventinfo(lf);\n\n            /* Check for a valid message */\n            if (i < 4) {\n                merror(IMSG_ERROR, ARGV0, msg);\n                Free_Eventinfo(lf);\n                continue;\n            }\n\n            /* Message before extracting header */\n            DEBUG_MSG(\""%s: DEBUG: Received msg: %s \"", ARGV0, msg);\n\n            /* Clean the msg appropriately */\n            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n""}, {""source"": ""code_info(file:testrule.c, lines:332-432)"", ""result"": ""void OS_ReadMSG(char *ut_str)\n{\n    char msg[OS_MAXSTR + 1];\n    int exit_code = 0;\n    char *ut_alertlevel = NULL;\n    char *ut_rulelevel = NULL;\n    char *ut_decoder_name = NULL;\n\n    if (ut_str) {\n        /* XXX Break apart string */\n        ut_rulelevel = ut_str;\n        ut_alertlevel =  strchr(ut_rulelevel, ':');\n        if (!ut_alertlevel) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_alertlevel = '\\0';\n            ut_alertlevel++;\n        }\n        ut_decoder_name = strchr(ut_alertlevel, ':');\n        if (!ut_decoder_name) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_decoder_name = '\\0';\n            ut_decoder_name++;\n        }\n    }\n\n    RuleInfoDetail *last_info_detail;\n    Eventinfo *lf;\n\n    /* Null global pointer to current rule */\n    currently_rule = NULL;\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    __crt_ftell = 1;\n\n    /* Get current time before starting */\n    c_time = time(NULL);\n\n    /* Do some cleanup */\n    memset(msg, '\\0', OS_MAXSTR + 1);\n\n    if (!alert_only) {\n        print_out(\""%s: Type one log per line.\\n\"", ARGV0);\n    }\n\n    /* Daemon loop */\n    while (1) {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n\n\n        /* This shouldn't happen */\n        if (lf == NULL) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n\n        /* Fix the msg */\n        snprintf(msg, 15, \""1:stdin:\"");\n\n        /* Receive message from queue */\n        if (fgets(msg + 8, OS_MAXSTR - 8, stdin)) {\n            RuleNode *rulenode_pt;\n\n            /* Get the time we received the event */\n            c_time = time(NULL);\n\n            /* Remov newline */\n            if (msg[strlen(msg) - 1] == '\\n') {\n                msg[strlen(msg) - 1] = '\\0';\n            }\n\n            /* Make sure we ignore blank lines */\n            if (strlen(msg) < 10) {\n                continue;\n            }\n\n            if (!alert_only) {\n                print_out(\""\\n\"");\n            }\n\n            /* Default values for the log info */\n            Zero_Eventinfo(lf);\n\n            /* Clean the msg appropriately */\n            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n""}, {""source"": ""value_info(file:analysisd.c, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg[OS_MAXSTR + 1]"", ""line"": 535, ""func_name"": ""OS_ReadMSG""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""value_info(file:testrule.c, value:ut_str)"", ""result"": {""value_trace"": [{""full_code"": ""*ut_str = NULL"", ""line"": 64, ""func_name"": ""main<duplicate>3""}, {""full_code"": ""ut_str = optarg"", ""line"": 107, ""func_name"": ""main<duplicate>3""}], ""struct_var"": ""ut_str"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""code_info(file:analysisd.c, lines:713-720)"", ""result"": ""            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n                Free_Eventinfo(lf);\n                continue;\n            }\n\n            /* Msg cleaned */\n            DEBUG_MSG(\""%s: DEBUG: Msg cleanup: %s \"", ARGV0, lf->log);\n\n""}, {""source"": ""func_info(func:OS_RecvUnix)"", ""result"": [{""code"": ""int OS_RecvUnix(int socket, int sizet, char *ret)\n{\n    ssize_t recvd;\n    if ((recvd = recvfrom(socket, ret, sizet - 1, 0,\n                          (struct sockaddr *)&n_us, &us_l)) < 0) {\n        r"", ""start_line"": 579, ""end_line"": 589, ""full_name"": ""OS_RecvUnix"", ""file_path"": ""src/os_net/os_net.c""}]}, {""source"": ""func_info(func:StartMQ)"", ""result"": [{""code"": ""int StartMQ(const char *path, short int type)\n{\n    if (type == READ) {\n        return (OS_BindUnixDomain(path, 0660, OS_MAXSTR + 512));\n    }\n\n    /* We give up to 21 seconds for the other end to sta"", ""start_line"": 17, ""end_line"": 58, ""full_name"": ""StartMQ"", ""file_path"": ""src/shared/mq_op.c""}, {""code"": ""int StartMQ(const char *path, short int type)\n{\n    /* Connect to the server */\n    connect_server(0);\n\n    if ((path == NULL) && (type == 0)) {\n        return (0);\n    }\n\n    return (0);\n}"", ""start_line"": 449, ""end_line"": 459, ""full_name"": ""StartMQ<duplicate>0"", ""file_path"": ""src/win32/win_agent.c""}]}]","The vulnerability arises when `msg` starts with '(' but lacks '->' or ':' in OS_CleanMSG (src/analysisd/cleanevent.c line 46). The original code `strchr(strstr(msg, ""->""), "":"")` dereferences a NULL pointer if `strstr` returns NULL. The patch (lines 47-49) adds a null check. The trigger chain begins with `msg` populated via `OS_RecvUnix(m_queue, OS_MAXSTR, msg)` in OS_ReadMSG (src/analysisd/analysisd.c line 713), which receives data from a UNIX socket initialized by `StartMQ` (src/shared/mq_op.c). No further context is needed as the core path is fully evidenced.",0.95,./github/other_context/CVE-2020-8448
71,CVE-2021-28855,CWE-476,c_cpp,"In Deark before 1.5.8, a specially crafted input file can cause a NULL pointer dereference in the dbuf_write function (src/deark-dbuf.c).",https://github.com/jsummers/deark/commit/287f5ac31dfdc074669182f51ece637706070eeb,pict: Fixed a bug with ICC profile extraction\n\nCould cause a NULL pointer dereference.\n\nFound by F. Çelik.,1,"[{""func_name"": ""do_iccprofile_item"", ""file_path"": ""modules/pict.c"", ""func_code"": ""static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \""ICC profile segment, selector=%d, data len=%d\"", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""do_iccprofile_item"", ""file_path"": ""modules/pict.c"", ""func_code"": ""static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \""ICC profile segment, selector=%d, data len=%d\"", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \""Bad ICC profile segment\"");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}""}]","{""value"": 1, ""caller"": 1, ""code"": 2}","[{""source"": ""value_info(file:pict.c, value:d->iccprofile_file)"", ""result"": {""value_trace"": [{""full_code"": ""d->iccprofile_file = NULL"", ""line"": 653, ""func_name"": ""do_iccprofile_item""}, {""full_code"": ""d->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX)"", ""line"": 657, ""func_name"": ""do_iccprofile_item""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:pict.c, func:do_iccprofile_item)"", ""result"": [{""call_line"": 696, ""call_code"": ""do_iccprofile_item(c, d, data_pos+4, len)"", ""caller_code"": ""static int handler_a1(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 kind;\n\ti64 len;\n\n\tkind = de_getu16be(data_pos);\n\tlen = de_getu16be(data_pos+2);\n\tde_dbg(c, \""comment kind: %d, size: %d\"", (int)kind, (int)len);\n\t*bytes_used = 4+len;\n\n\tif(kind==100 && len>=4) {\n\t\tstruct de_fourcc sig4cc;\n\n\t\tdbuf_read_fourcc(c->infile, data_pos+4, &sig4cc, 4, 0x0);\n\t\tde_dbg(c, \""application comment, signature=0x%08x '%s'\"",\n\t\t\t(unsigned int)sig4cc.id, sig4cc.id_dbgstr);\n\t\tde_dbg_hexdump(c, c->infile, data_pos+8, len-4, 256, NULL, 0x1);\n\t}\n\telse if(kind==224) {\n\t\tdo_iccprofile_item(c, d, data_pos+4, len);\n\t}\n\telse {\n\t\tde_dbg_hexdump(c, c->infile, data_pos+4, len, 256, NULL, 0x1);\n\t}\n\n\treturn 1;\n}"", ""caller_start"": 677, ""file_path"": ""modules/pict.c""}]}, {""source"": ""code_info(file:pict.c, lines:653-660)"", ""result"": ""\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n""}, {""source"": ""code_info(file:pict.c, lines:640-660)"", ""result"": ""{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \""ICC profile segment, selector=%d, data len=%d\"", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n""}]",modules/pict.c:653 (d->iccprofile_file = NULL) → modules/pict.c:657 (conditional assignment if selector==0) → modules/pict.c:664-666 (dbuf_copy uses d->iccprofile_file without validation when selector==1) → modules/pict.c:644 (selector derived from input via de_getu32be).,0.95,./github/other_context/CVE-2021-28855
72,CVE-2021-30015,CWE-476,c_cpp,"There is a Null Pointer Dereference in function filter_core/filter_pck.c:gf_filter_pck_new_alloc_internal in GPAC 1.0.1. The pid comes from function av1dmx_parse_flush_sample, the ctx.opid maybe NULL. The result is a crash in gf_filter_pck_new_alloc_internal.",https://github.com/gpac/gpac/commit/13dad7d5ef74ca2e6fe4010f5b03eb12e9bbe0ec,fixed #1719,1,"[{""func_name"": ""av1dmx_parse_flush_sample"", ""file_path"": ""src/filters/reframe_av1.c"", ""func_code"": ""static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\""[AV1Dmx] no frame OBU, skipping OBU\\n\""));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}"", ""target"": 0}]","[{""func_name"": ""av1dmx_parse_flush_sample"", ""file_path"": ""src/filters/reframe_av1.c"", ""func_code"": ""static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\""[AV1Dmx] no frame OBU, skipping OBU\\n\""));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}""}]","{""function"": 1, ""query"": 1}","[{""source"": ""func_info(func:gf_filter_pck_new_alloc_internal)"", ""result"": [{""code"": ""static GF_FilterPacket *gf_filter_pck_new_alloc_internal(GF_FilterPid *pid, u32 data_size, u8 **data, Bool no_block_check)\n{\n\tGF_FilterPacket *pck=NULL;\n\tGF_FilterPacket *closest=NULL;\n\tu32 count, max_reservoir_size;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\""Attempt to allocate a packet on an input PID in filter %s\\n\"", pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (!no_block_check && gf_filter_pid_would_block(pid))\n\t\treturn NULL;\n\n\tcount = gf_fq_count(pid->filter->pcks_alloc_reservoir);\n\tif (count) {\n\t\tGF_PckQueueEnum pck_enum_state;\n\t\tmemset(&pck_enum_state, 0, sizeof(GF_PckQueueEnum));\n\t\tpck_enum_state.data_size = data_size;\n\t\tgf_fq_enum(pid->filter->pcks_alloc_reservoir, pck_queue_enum, &pck_enum_state);\n\t\tpck = pck_enum_state.pck;\n\t\tclosest = pck_enum_state.closest;\n\t}\n\n\t//stop allocating after a while - TODO we for sur can design a better algo...\n\tmax_reservoir_size = pid->num_destinations ? 10 : 1;\n\t//if pid is file, force 1 max\n\tif (!pck && (pid->stream_type==GF_STREAM_FILE))\n\t\tmax_reservoir_size = 1;\n\n\tif (!pck && (count>=max_reservoir_size)) {\n\t\tassert(closest);\n\t\tclosest->alloc_size = data_size;\n\t\tclosest->data = gf_realloc(closest->data, closest->alloc_size);\n\t\tpck = closest;\n#ifdef GPAC_MEMORY_TRACKING\n\t\tpid->filter->session->nb_realloc_pck++;\n#endif\n\t}\n\n\tif (!pck) {\n\t\tGF_SAFEALLOC(pck, GF_FilterPacket);\n\t\tif (!pck)\n\t\t\treturn NULL;\n\t\tpck->data = gf_malloc(sizeof(char)*data_size);\n\t\tpck->alloc_size = data_size;\n#ifdef GPAC_MEMORY_TRACKING\n\t\tpid->filter->session->nb_alloc_pck+=2;\n#endif\n\t} else {\n\t\t//pop first item and swap pointers. We can safely do this since this filter\n\t\t//is the only one accessing the queue in pop mode, all others are just pushing to it\n\t\t//this may however imply that we don't get the best matching block size if new packets\n\t\t//were added to the list\n\n\t\tGF_FilterPacket *head_pck = gf_fq_pop(pid->filter->pcks_alloc_reservoir);\n\t\tchar *pck_data = pck->data;\n\t\tu32 alloc_size = pck->alloc_size;\n\t\tpck->data = head_pck->data;\n\t\tpck->alloc_size = head_pck->alloc_size;\n\t\thead_pck->data = pck_data;\n\t\thead_pck->alloc_size = alloc_size;\n\t\tpck = head_pck;\n\t}\n\n\tpck->pck = pck;\n\tpck->data_length = data_size;\n\tif (data) *data = pck->data;\n\tpck->filter_owns_mem = 0;\n\n\tgf_filter_pck_reset_props(pck, pid);\n\treturn pck;\n}\n"", ""start_line"": 98, ""end_line"": 169, ""full_name"": ""gf_filter_pck_new_alloc_internal"", ""file_path"": ""src/filter_core/filter_pck.c""}]}, {""source"": ""query_info(query:cpg.method.name(\""gf_filter_pck_new_alloc_internal\""...)"", ""result"": [{""name"": ""PID_IS_INPUT"", ""signature"": """", ""code"": ""PID_IS_INPUT(pid)"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""src/filter_core/filter_session.h:41:41:PID_IS_INPUT:1"", ""dispatchType"": ""INLINED"", ""columnNumber"": 6, ""argumentIndex"": -1}, {""name"": ""<operator>.conditional"", ""signature"": """", ""code"": ""(pid->pid == pid) ? GF_FALSE : GF_TRUE"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""<operator>.conditional"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.equals"", ""signature"": """", ""code"": ""pid->pid == pid"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""<operator>.equals"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->pid"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""GF_LOG"", ""signature"": """", ""code"": ""GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\""Attempt to allocate a packet on an input PID in filter %s\\n\"", pid->filter->name))"", ""typeFullName"": ""ANY"", ""lineNumber"": 105, ""methodFullName"": ""GF_LOG"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->name"", ""typeFullName"": ""ANY"", ""lineNumber"": 105, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 103, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 105, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 103, ""argumentIndex"": 1}, {""name"": ""<operator>.logicalAnd"", ""signature"": """", ""code"": ""!no_block_check && gf_filter_pid_would_block(pid)"", ""typeFullName"": ""ANY"", ""lineNumber"": 108, ""methodFullName"": ""<operator>.logicalAnd"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": -1}, {""name"": ""gf_filter_pid_would_block"", ""signature"": """", ""code"": ""gf_filter_pid_would_block(pid)"", ""typeFullName"": ""ANY"", ""lineNumber"": 108, ""methodFullName"": ""gf_filter_pid_would_block"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 25, ""argumentIndex"": 2}, {""name"": ""<operator>.assignment"", ""signature"": """", ""code"": ""count = gf_fq_count(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""<operator>.assignment"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""gf_fq_count"", ""signature"": """", ""code"": ""gf_fq_count(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""gf_fq_count"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 10, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->pcks_alloc_reservoir"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 22, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 22, ""argumentIndex"": 1}, {""name"": ""gf_fq_enum"", ""signature"": """", ""code"": ""gf_fq_enum(pid->filter->pcks_alloc_reservoir, pck_queue_enum, &pck_enum_state)"", ""typeFullName"": ""void"", ""lineNumber"": 116, ""methodFullName"": ""gf_fq_enum"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->pcks_alloc_reservoir"", ""typeFullName"": ""ANY"", ""lineNumber"": 116, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 14, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 116, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 14, ""argumentIndex"": 1}, {""name"": ""<operator>.assignment"", ""signature"": """", ""code"": ""max_reservoir_size = pid->num_destinations ? 10 : 1"", ""typeFullName"": ""ANY"", ""lineNumber"": 122, ""methodFullName"": ""<operator>.assignment"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""<operator>.conditional"", ""signature"": """", ""code"": ""pid->num_destinations ? 10 : 1"", ""typeFullName"": ""ANY"", ""lineNumber"": 122, ""methodFullName"": ""<operator>.conditional"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 23, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->num_destinations"", ""typeFullName"": ""ANY"", ""lineNumber"": 122, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 23, ""argumentIndex"": 1}, {""name"": ""<operator>.logicalAnd"", ""signature"": """", ""code"": ""!pck && (pid->stream_type==GF_STREAM_FILE)"", ""typeFullName"": ""ANY"", ""lineNumber"": 124, ""methodFullName"": ""<operator>.logicalAnd"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": -1}, {""name"": ""<operator>.equals"", ""signature"": """", ""code"": ""pid->stream_type==GF_STREAM_FILE"", ""typeFullName"": ""ANY"", ""lineNumber"": 124, ""methodFullName"": ""<operator>.equals"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 15, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->stream_type"", ""typeFullName"": ""ANY"", ""lineNumber"": 124, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 15, ""argumentIndex"": 1}, {""name"": ""<operator>.assignment"", ""signature"": """", ""code"": ""*head_pck = gf_fq_pop(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""GF_FilterPacket*"", ""lineNumber"": 152, ""methodFullName"": ""<operator>.assignment"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 19, ""argumentIndex"": 2}, {""name"": ""gf_fq_pop"", ""signature"": """", ""code"": ""gf_fq_pop(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""void*"", ""lineNumber"": 152, ""methodFullName"": ""gf_fq_pop"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 31, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->pcks_alloc_reservoir"", ""typeFullName"": ""ANY"", ""lineNumber"": 152, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 41, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 152, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 41, ""argumentIndex"": 1}, {""name"": ""gf_filter_pck_reset_props"", ""signature"": """", ""code"": ""gf_filter_pck_reset_props(pck, pid)"", ""typeFullName"": ""void"", ""lineNumber"": 167, ""methodFullName"": ""gf_filter_pck_reset_props"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}]}]","av1dmx_parse_flush_sample() in src/filters/reframe_av1.c:740-743 (patched) passes 'ctx->opid' to gf_filter_pck_new_alloc_internal() without validation. gf_filter_pck_new_alloc_internal() in src/filter_core/filter_pck.c:104-105 (via PID_IS_INPUT(pid)) dereferences 'pid->pid' and 'pid->filter->name', causing a NULL pointer dereference if 'pid' is NULL.",0.95,./github/other_context/CVE-2021-30015
73,CVE-2021-32276,CWE-476,c_cpp,An issue was discovered in faad2 through 2.10.0. A NULL pointer dereference exists in the function get_sample() located in output.c. It allows an attacker to cause Denial of Service.,https://github.com/knik0/faad2/commit/b58840121d1827b4b6c7617e2431589af1776ddc,Check for error after each channel decode.\n\nhInfo->error is reset within the decode_* functions. This caused the decoder\nto ignore errors for some channels in the error resilience (ER) code path.\n\nFixes #58.,2,"[{""func_name"": ""raw_data_block"", ""file_path"": ""libfaad/syntax.c"", ""func_code"": ""void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\""NeAACDecDecode(): id_syn_ele\""))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}"", ""target"": 0}, {""func_name"": ""decodeAACfile"", ""file_path"": ""frontend/main.c"", ""func_code"": ""static int decodeAACfile(char *aacfile, char *sndfile, char *adts_fn, int to_stdout,\n                  int def_srate, int object_type, int outputFormat, int fileType,\n                  int downMatrix, int infoOnly, int adts_out, int old_format,\n                  float *song_length)\n{\n    int tagsize;\n    unsigned long samplerate;\n    unsigned char channels;\n    void *sample_buffer;\n\n    audio_file *aufile = NULL;\n\n    FILE *adtsFile = NULL;\n    unsigned char *adtsData;\n    int adtsDataSize;\n\n    NeAACDecHandle hDecoder;\n    NeAACDecFrameInfo frameInfo;\n    NeAACDecConfigurationPtr config;\n\n    char percents[MAX_PERCENTS];\n    int percent, old_percent = -1;\n    int bread, fileread;\n    int header_type = 0;\n    int bitrate = 0;\n    float length = 0;\n\n    int first_time = 1;\n    int retval;\n    int streaminput = 0;\n\n    aac_buffer b;\n\n    memset(&b, 0, sizeof(aac_buffer));\n\n    if (adts_out)\n    {\n        adtsFile = faad_fopen(adts_fn, \""wb\"");\n        if (adtsFile == NULL)\n        {\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", adts_fn);\n            return 1;\n        }\n    }\n\n    if (0 == strcmp(aacfile, \""-\""))\n    {\n        b.infile = stdin;\n#ifdef _WIN32\n        _setmode(_fileno(stdin), O_BINARY);\n#endif\n\n    }\n    else\n    {\n        b.infile = faad_fopen(aacfile, \""rb\"");\n        if (b.infile == NULL)\n        {\n            /* unable to open file */\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", aacfile);\n            return 1;\n        }\n    }\n\n    retval = fseek(b.infile, 0, SEEK_END);\n#ifdef _WIN32\n    if (0 == strcmp(aacfile, \""-\"")) {\n        retval = -1;\n    }\n#endif\n    if (retval )\n    {\n        faad_fprintf(stderr, \""Input not seekable %s\\n\"", aacfile);\n        fileread = -1;\n        streaminput = 1;\n    } else {\n        fileread = ftell(b.infile);\n        fseek(b.infile, 0, SEEK_SET);\n    };\n\n    if (!(b.buffer = (unsigned char*)malloc(FAAD_MIN_STREAMSIZE*MAX_CHANNELS)))\n    {\n        faad_fprintf(stderr, \""Memory allocation error\\n\"");\n        return 0;\n    }\n    memset(b.buffer, 0, FAAD_MIN_STREAMSIZE*MAX_CHANNELS);\n\n    bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n    b.bytes_into_buffer = bread;\n    b.bytes_consumed = 0;\n    b.file_offset = 0;\n\n    if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n        b.at_eof = 1;\n\n    tagsize = 0;\n    if (!memcmp(b.buffer, \""ID3\"", 3))\n    {\n        /* high bit is not used */\n        tagsize = (b.buffer[6] << 21) | (b.buffer[7] << 14) |\n            (b.buffer[8] <<  7) | (b.buffer[9] <<  0);\n\n        tagsize += 10;\n        advance_buffer(&b, tagsize);\n        fill_buffer(&b);\n    }\n\n    hDecoder = NeAACDecOpen();\n\n    /* Set the default object type and samplerate */\n    /* This is useful for RAW AAC files */\n    config = NeAACDecGetCurrentConfiguration(hDecoder);\n    if (def_srate)\n        config->defSampleRate = def_srate;\n    config->defObjectType = object_type;\n    config->outputFormat = outputFormat;\n    config->downMatrix = downMatrix;\n    config->useOldADTSFormat = old_format;\n    //config->dontUpSampleImplicitSBR = 1;\n    NeAACDecSetConfiguration(hDecoder, config);\n\n    /* get AAC infos for printing */\n    header_type = 0;\n    if (streaminput == 1)\n        lookforheader(&b);\n\n    if ((b.buffer[0] == 0xFF) && ((b.buffer[1] & 0xF6) == 0xF0))\n    {\n        if (streaminput == 1)\n        {\n            int /*frames,*/ frame_length;\n            int samplerate;\n            float frames_per_sec, bytes_per_frame;\n            channels = 2;\n            samplerate = adts_sample_rates[(b.buffer[2]&0x3c)>>2];\n            frame_length = ((((unsigned int)b.buffer[3] & 0x3)) << 11)\n                | (((unsigned int)b.buffer[4]) << 3) | (b.buffer[5] >> 5);\n            frames_per_sec = (float)samplerate/1024.0f;\n            bytes_per_frame = (float)frame_length/(float)(1000);\n            bitrate = (int)(8. * bytes_per_frame * frames_per_sec + 0.5);\n            length = 1;\n            faad_fprintf(stderr, \""Streamed input format  samplerate %d channels %d.\\n\"", samplerate, channels);\n        } else {\n            adts_parse(&b, &bitrate, &length);\n            fseek(b.infile, tagsize, SEEK_SET);\n\n            bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n            if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n                b.at_eof = 1;\n            else\n                b.at_eof = 0;\n            b.bytes_into_buffer = bread;\n            b.bytes_consumed = 0;\n            b.file_offset = tagsize;\n        }\n\n        header_type = 1;\n    }\n    else if (memcmp(b.buffer, \""ADIF\"", 4) == 0)\n    {\n        int skip_size = (b.buffer[4] & 0x80) ? 9 : 0;\n        bitrate = ((unsigned int)(b.buffer[4 + skip_size] & 0x0F)<<19) |\n            ((unsigned int)b.buffer[5 + skip_size]<<11) |\n            ((unsigned int)b.buffer[6 + skip_size]<<3) |\n            ((unsigned int)b.buffer[7 + skip_size] & 0xE0);\n\n        length = (float)fileread;\n        if (length != 0)\n        {\n            length = ((float)length*8.f)/((float)bitrate) + 0.5f;\n        }\n\n        bitrate = (int)((float)bitrate/1000.0f + 0.5f);\n\n        header_type = 2;\n    }\n\n    *song_length = length;\n\n    fill_buffer(&b);\n    if ((bread = NeAACDecInit(hDecoder, b.buffer,\n        b.bytes_into_buffer, &samplerate, &channels)) < 0)\n    {\n        /* If some error initializing occured, skip the file */\n        faad_fprintf(stderr, \""Error initializing decoder library.\\n\"");\n        if (b.buffer)\n            free(b.buffer);\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        return 1;\n    }\n    advance_buffer(&b, bread);\n    fill_buffer(&b);\n\n    /* print AAC file info */\n    faad_fprintf(stderr, \""%s file info:\\n\"", aacfile);\n    switch (header_type)\n    {\n    case 0:\n        faad_fprintf(stderr, \""RAW\\n\\n\"");\n        break;\n    case 1:\n        faad_fprintf(stderr, \""ADTS, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    case 2:\n        faad_fprintf(stderr, \""ADIF, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    }\n\n    if (infoOnly)\n    {\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        if (b.buffer)\n            free(b.buffer);\n        return 0;\n    }\n\n    do\n    {\n        sample_buffer = NeAACDecDecode(hDecoder, &frameInfo,\n            b.buffer, b.bytes_into_buffer);\n\n        if (adts_out == 1)\n        {\n            int skip = (old_format) ? 8 : 7;\n            adtsData = MakeAdtsHeader(&adtsDataSize, &frameInfo, old_format);\n\n            /* write the adts header */\n            fwrite(adtsData, 1, adtsDataSize, adtsFile);\n\n            /* write the frame data */\n            if (frameInfo.header_type == ADTS)\n                fwrite(b.buffer + skip, 1, frameInfo.bytesconsumed - skip, adtsFile);\n            else\n                fwrite(b.buffer, 1, frameInfo.bytesconsumed, adtsFile);\n        }\n\n        /* update buffer indices */\n        advance_buffer(&b, frameInfo.bytesconsumed);\n\n        if (frameInfo.error > 0)\n        {\n            faad_fprintf(stderr, \""Error: %s\\n\"",\n                NeAACDecGetErrorMessage(frameInfo.error));\n        }\n\n        /* open the sound file now that the number of channels are known */\n        if (first_time && !frameInfo.error)\n        {\n            /* print some channel info */\n            print_channel_info(&frameInfo);\n\n            if (!adts_out)\n            {\n                /* open output file */\n                if (!to_stdout)\n                {\n                    aufile = open_audio_file(sndfile, frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                } else {\n                    aufile = open_audio_file(\""-\"", frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                }\n                if (aufile == NULL)\n                {\n                    if (b.buffer)\n                        free(b.buffer);\n                    NeAACDecClose(hDecoder);\n                    if (b.infile != stdin)\n                        fclose(b.infile);\n                    return 0;\n                }\n            } else {\n                faad_fprintf(stderr, \""Writing output MPEG-4 AAC ADTS file.\\n\\n\"");\n            }\n            first_time = 0;\n        }\n\n        percent = min((int)(b.file_offset*100)/fileread, 100);\n        if (percent > old_percent)\n        {\n            old_percent = percent;\n            snprintf(percents, MAX_PERCENTS, \""%d%% decoding %s.\"", percent, aacfile);\n            faad_fprintf(stderr, \""%s\\r\"", percents);\n#ifdef _WIN32\n            SetConsoleTitle(percents);\n#endif\n        }\n\n        if ((frameInfo.error == 0) && (frameInfo.samples > 0) && (!adts_out))\n        {\n            if (write_audio_file(aufile, sample_buffer, frameInfo.samples, 0) == 0)\n                break;\n        }\n\n        /* fill buffer */\n        fill_buffer(&b);\n\n        if (b.bytes_into_buffer == 0)\n            sample_buffer = NULL; /* to make sure it stops now */\n\n    } while (sample_buffer != NULL);\n\n    NeAACDecClose(hDecoder);\n\n    if (adts_out == 1)\n    {\n        fclose(adtsFile);\n    }\n\n    if (b.infile != stdin)\n        fclose(b.infile);\n\n    if (!first_time && !adts_out)\n        close_audio_file(aufile);\n\n    if (b.buffer)\n        free(b.buffer);\n\n    return frameInfo.error;\n}"", ""target"": 1}]","[{""func_name"": ""raw_data_block"", ""file_path"": ""libfaad/syntax.c"", ""func_code"": ""void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\""NeAACDecDecode(): id_syn_ele\""))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}""}, {""func_name"": ""decodeAACfile"", ""file_path"": ""frontend/main.c"", ""func_code"": ""static int decodeAACfile(char *aacfile, char *sndfile, char *adts_fn, int to_stdout,\n                  int def_srate, int object_type, int outputFormat, int fileType,\n                  int downMatrix, int infoOnly, int adts_out, int old_format,\n                  float *song_length)\n{\n    int tagsize;\n    unsigned long samplerate;\n    unsigned char channels;\n    void *sample_buffer;\n\n    audio_file *aufile = NULL;\n\n    FILE *adtsFile = NULL;\n    unsigned char *adtsData;\n    int adtsDataSize;\n\n    NeAACDecHandle hDecoder;\n    NeAACDecFrameInfo frameInfo;\n    NeAACDecConfigurationPtr config;\n\n    char percents[MAX_PERCENTS];\n    int percent, old_percent = -1;\n    int bread, fileread;\n    int header_type = 0;\n    int bitrate = 0;\n    float length = 0;\n\n    int first_time = 1;\n    int retval;\n    int streaminput = 0;\n\n    aac_buffer b;\n\n    memset(&b, 0, sizeof(aac_buffer));\n\n    if (adts_out)\n    {\n        adtsFile = faad_fopen(adts_fn, \""wb\"");\n        if (adtsFile == NULL)\n        {\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", adts_fn);\n            return 1;\n        }\n    }\n\n    if (0 == strcmp(aacfile, \""-\""))\n    {\n        b.infile = stdin;\n#ifdef _WIN32\n        _setmode(_fileno(stdin), O_BINARY);\n#endif\n\n    }\n    else\n    {\n        b.infile = faad_fopen(aacfile, \""rb\"");\n        if (b.infile == NULL)\n        {\n            /* unable to open file */\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", aacfile);\n            return 1;\n        }\n    }\n\n    retval = fseek(b.infile, 0, SEEK_END);\n#ifdef _WIN32\n    if (0 == strcmp(aacfile, \""-\"")) {\n        retval = -1;\n    }\n#endif\n    if (retval )\n    {\n        faad_fprintf(stderr, \""Input not seekable %s\\n\"", aacfile);\n        fileread = -1;\n        streaminput = 1;\n    } else {\n        fileread = ftell(b.infile);\n        fseek(b.infile, 0, SEEK_SET);\n    };\n\n    if (!(b.buffer = (unsigned char*)malloc(FAAD_MIN_STREAMSIZE*MAX_CHANNELS)))\n    {\n        faad_fprintf(stderr, \""Memory allocation error\\n\"");\n        return 0;\n    }\n    memset(b.buffer, 0, FAAD_MIN_STREAMSIZE*MAX_CHANNELS);\n\n    bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n    b.bytes_into_buffer = bread;\n    b.bytes_consumed = 0;\n    b.file_offset = 0;\n\n    if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n        b.at_eof = 1;\n\n    tagsize = 0;\n    if (!memcmp(b.buffer, \""ID3\"", 3))\n    {\n        /* high bit is not used */\n        tagsize = (b.buffer[6] << 21) | (b.buffer[7] << 14) |\n            (b.buffer[8] <<  7) | (b.buffer[9] <<  0);\n\n        tagsize += 10;\n        advance_buffer(&b, tagsize);\n        fill_buffer(&b);\n    }\n\n    hDecoder = NeAACDecOpen();\n\n    /* Set the default object type and samplerate */\n    /* This is useful for RAW AAC files */\n    config = NeAACDecGetCurrentConfiguration(hDecoder);\n    if (def_srate)\n        config->defSampleRate = def_srate;\n    config->defObjectType = object_type;\n    config->outputFormat = outputFormat;\n    config->downMatrix = downMatrix;\n    config->useOldADTSFormat = old_format;\n    //config->dontUpSampleImplicitSBR = 1;\n    NeAACDecSetConfiguration(hDecoder, config);\n\n    /* get AAC infos for printing */\n    header_type = 0;\n    if (streaminput == 1)\n        lookforheader(&b);\n\n    if ((b.buffer[0] == 0xFF) && ((b.buffer[1] & 0xF6) == 0xF0))\n    {\n        if (streaminput == 1)\n        {\n            int /*frames,*/ frame_length;\n            int samplerate;\n            float frames_per_sec, bytes_per_frame;\n            channels = 2;\n            samplerate = adts_sample_rates[(b.buffer[2]&0x3c)>>2];\n            frame_length = ((((unsigned int)b.buffer[3] & 0x3)) << 11)\n                | (((unsigned int)b.buffer[4]) << 3) | (b.buffer[5] >> 5);\n            frames_per_sec = (float)samplerate/1024.0f;\n            bytes_per_frame = (float)frame_length/(float)(1000);\n            bitrate = (int)(8. * bytes_per_frame * frames_per_sec + 0.5);\n            length = 1;\n            faad_fprintf(stderr, \""Streamed input format  samplerate %d channels %d.\\n\"", samplerate, channels);\n        } else {\n            adts_parse(&b, &bitrate, &length);\n            fseek(b.infile, tagsize, SEEK_SET);\n\n            bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n            if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n                b.at_eof = 1;\n            else\n                b.at_eof = 0;\n            b.bytes_into_buffer = bread;\n            b.bytes_consumed = 0;\n            b.file_offset = tagsize;\n        }\n\n        header_type = 1;\n    }\n    else if (memcmp(b.buffer, \""ADIF\"", 4) == 0)\n    {\n        int skip_size = (b.buffer[4] & 0x80) ? 9 : 0;\n        bitrate = ((unsigned int)(b.buffer[4 + skip_size] & 0x0F)<<19) |\n            ((unsigned int)b.buffer[5 + skip_size]<<11) |\n            ((unsigned int)b.buffer[6 + skip_size]<<3) |\n            ((unsigned int)b.buffer[7 + skip_size] & 0xE0);\n\n        length = (float)fileread;\n        if (length != 0)\n        {\n            length = ((float)length*8.f)/((float)bitrate) + 0.5f;\n        }\n\n        bitrate = (int)((float)bitrate/1000.0f + 0.5f);\n\n        header_type = 2;\n    }\n\n    *song_length = length;\n\n    fill_buffer(&b);\n    if ((bread = NeAACDecInit(hDecoder, b.buffer,\n        b.bytes_into_buffer, &samplerate, &channels)) < 0)\n    {\n        /* If some error initializing occured, skip the file */\n        faad_fprintf(stderr, \""Error initializing decoder library.\\n\"");\n        if (b.buffer)\n            free(b.buffer);\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        return 1;\n    }\n    advance_buffer(&b, bread);\n    fill_buffer(&b);\n\n    /* print AAC file info */\n    faad_fprintf(stderr, \""%s file info:\\n\"", aacfile);\n    switch (header_type)\n    {\n    case 0:\n        faad_fprintf(stderr, \""RAW\\n\\n\"");\n        break;\n    case 1:\n        faad_fprintf(stderr, \""ADTS, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    case 2:\n        faad_fprintf(stderr, \""ADIF, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    }\n\n    if (infoOnly)\n    {\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        if (b.buffer)\n            free(b.buffer);\n        return 0;\n    }\n\n    do\n    {\n        sample_buffer = NeAACDecDecode(hDecoder, &frameInfo,\n            b.buffer, b.bytes_into_buffer);\n\n        if (adts_out == 1)\n        {\n            int skip = (old_format) ? 8 : 7;\n            adtsData = MakeAdtsHeader(&adtsDataSize, &frameInfo, old_format);\n\n            /* write the adts header */\n            fwrite(adtsData, 1, adtsDataSize, adtsFile);\n\n            /* write the frame data */\n            if (frameInfo.header_type == ADTS)\n                fwrite(b.buffer + skip, 1, frameInfo.bytesconsumed - skip, adtsFile);\n            else\n                fwrite(b.buffer, 1, frameInfo.bytesconsumed, adtsFile);\n        }\n\n        /* update buffer indices */\n        advance_buffer(&b, frameInfo.bytesconsumed);\n\n        /* check if the inconsistent number of channels */\n        if (aufile != NULL && frameInfo.channels != aufile->channels)\n            frameInfo.error = 12;\n\n        if (frameInfo.error > 0)\n        {\n            faad_fprintf(stderr, \""Error: %s\\n\"",\n                NeAACDecGetErrorMessage(frameInfo.error));\n        }\n\n        /* open the sound file now that the number of channels are known */\n        if (first_time && !frameInfo.error)\n        {\n            /* print some channel info */\n            print_channel_info(&frameInfo);\n\n            if (!adts_out)\n            {\n                /* open output file */\n                if (!to_stdout)\n                {\n                    aufile = open_audio_file(sndfile, frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                } else {\n                    aufile = open_audio_file(\""-\"", frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                }\n                if (aufile == NULL)\n                {\n                    if (b.buffer)\n                        free(b.buffer);\n                    NeAACDecClose(hDecoder);\n                    if (b.infile != stdin)\n                        fclose(b.infile);\n                    return 0;\n                }\n            } else {\n                faad_fprintf(stderr, \""Writing output MPEG-4 AAC ADTS file.\\n\\n\"");\n            }\n            first_time = 0;\n        }\n\n        percent = min((int)(b.file_offset*100)/fileread, 100);\n        if (percent > old_percent)\n        {\n            old_percent = percent;\n            snprintf(percents, MAX_PERCENTS, \""%d%% decoding %s.\"", percent, aacfile);\n            faad_fprintf(stderr, \""%s\\r\"", percents);\n#ifdef _WIN32\n            SetConsoleTitle(percents);\n#endif\n        }\n\n        if ((frameInfo.error == 0) && (frameInfo.samples > 0) && (!adts_out))\n        {\n            if (write_audio_file(aufile, sample_buffer, frameInfo.samples, 0) == 0)\n                break;\n        }\n\n        /* fill buffer */\n        fill_buffer(&b);\n\n        if (b.bytes_into_buffer == 0)\n            sample_buffer = NULL; /* to make sure it stops now */\n\n    } while (sample_buffer != NULL);\n\n    NeAACDecClose(hDecoder);\n\n    if (adts_out == 1)\n    {\n        fclose(adtsFile);\n    }\n\n    if (b.infile != stdin)\n        fclose(b.infile);\n\n    if (!first_time && !adts_out)\n        close_audio_file(aufile);\n\n    if (b.buffer)\n        free(b.buffer);\n\n    return frameInfo.error;\n}""}]","{""function"": 1, ""value"": 4, ""code"": 3}","[{""source"": ""func_info(func:get_sample)"", ""result"": [{""code"": ""static INLINE real_t get_sample(real_t **input, uint8_t channel, uint16_t sample,\n                                uint8_t down_matrix, uint8_t *internal_channel)\n{\n    if (!down_matrix)\n        return input[internal_channel[channel]][sample];\n\n    if (channel == 0)\n    {\n        return DM_MUL * (input[internal_channel[1]][sample] +\n            input[internal_channel[0]][sample] * RSQRT2 +\n            input[internal_channel[3]][sample] * RSQRT2);\n    } else {\n        return DM_MUL * (input[internal_channel[2]][sample] +\n            input[internal_channel[0]][sample] * RSQRT2 +\n            input[internal_channel[4]][sample] * RSQRT2);\n    }\n}"", ""start_line"": 45, ""end_line"": 61, ""full_name"": ""get_sample"", ""file_path"": ""libfaad/output.c""}, {""code"": ""static INLINE real_t get_sample(real_t **input, uint8_t channel, uint16_t sample,\n                                uint8_t down_matrix, uint8_t up_matrix,\n                                uint8_t *internal_channel)\n{\n    if (up_matrix == 1)\n        return input[internal_channel[0]][sample];\n\n    if (!down_matrix)\n        return input[internal_channel[channel]][sample];\n\n    if (channel == 0)\n    {\n        real_t C   = MUL_F(input[internal_channel[0]][sample], RSQRT2);\n        real_t L_S = MUL_F(input[internal_channel[3]][sample], RSQRT2);\n        real_t cum = input[internal_channel[1]][sample] + C + L_S;\n        return MUL_F(cum, DM_MUL);\n    } else {\n        real_t C   = MUL_F(input[internal_channel[0]][sample], RSQRT2);\n        real_t R_S = MUL_F(input[internal_channel[4]][sample], RSQRT2);\n        real_t cum = input[internal_channel[2]][sample] + C + R_S;\n        return MUL_F(cum, DM_MUL);\n    }\n}"", ""start_line"": 444, ""end_line"": 466, ""full_name"": ""get_sample<duplicate>0"", ""file_path"": ""libfaad/output.c""}]}, {""source"": ""value_info(file:syntax.c, value:hInfo->error)"", ""result"": {""value_trace"": [{""full_code"": ""hInfo->error = 12"", ""line"": 334, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = 13"", ""line"": 339, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = 21"", ""line"": 351, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag)"", ""line"": 359, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = 12"", ""line"": 386, ""func_name"": ""decode_cpe""}], ""struct_var"": ""hInfo"", ""struct_type"": ""NeAACDecFrameInfo*"", ""struct_definition"": ""typedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n}\n\ntypedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n} NeAACDecFrameInfo;\n\ntypedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n}\n\ntypedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n} NeAACDecFrameInfo;""}}, {""source"": ""code_info(file:output.c, lines:100-200)"", ""result"": ""        for(i = 0; i < frame_len; i++)\n        {\n            real_t inp = input[hDecoder->internal_channel[0]][i];\n\n            CLIP(inp, 32767.0f, -32768.0f);\n\n            (*sample_buffer)[i] = (int16_t)lrintf(inp);\n        }\n        break;\n    case CONV(2,0):\n        if (hDecoder->upMatrix)\n        {\n            ch  = hDecoder->internal_channel[0];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch][i];\n\n                CLIP(inp0, 32767.0f, -32768.0f);\n\n                (*sample_buffer)[(i*2)+0] = (int16_t)lrintf(inp0);\n                (*sample_buffer)[(i*2)+1] = (int16_t)lrintf(inp0);\n            }\n        } else {\n            ch  = hDecoder->internal_channel[0];\n            ch1 = hDecoder->internal_channel[1];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch ][i];\n                real_t inp1 = input[ch1][i];\n\n                CLIP(inp0, 32767.0f, -32768.0f);\n                CLIP(inp1, 32767.0f, -32768.0f);\n\n                (*sample_buffer)[(i*2)+0] = (int16_t)lrintf(inp0);\n                (*sample_buffer)[(i*2)+1] = (int16_t)lrintf(inp1);\n            }\n        }\n        break;\n    default:\n        for (ch = 0; ch < channels; ch++)\n        {\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp = get_sample(input, ch, i, hDecoder->downMatrix, hDecoder->internal_channel);\n\n                CLIP(inp, 32767.0f, -32768.0f);\n\n                (*sample_buffer)[(i*channels)+ch] = (int16_t)lrintf(inp);\n            }\n        }\n        break;\n    }\n}\n\nstatic void to_PCM_24bit(NeAACDecStruct *hDecoder, real_t **input,\n                         uint8_t channels, uint16_t frame_len,\n                         int32_t **sample_buffer)\n{\n    uint8_t ch, ch1;\n    uint16_t i;\n\n    switch (CONV(channels,hDecoder->downMatrix))\n    {\n    case CONV(1,0):\n    case CONV(1,1):\n        for(i = 0; i < frame_len; i++)\n        {\n            real_t inp = input[hDecoder->internal_channel[0]][i];\n\n            inp *= 256.0f;\n            CLIP(inp, 8388607.0f, -8388608.0f);\n\n            (*sample_buffer)[i] = (int32_t)lrintf(inp);\n        }\n        break;\n    case CONV(2,0):\n        if (hDecoder->upMatrix)\n        {\n            ch = hDecoder->internal_channel[0];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch][i];\n\n                inp0 *= 256.0f;\n                CLIP(inp0, 8388607.0f, -8388608.0f);\n\n                (*sample_buffer)[(i*2)+0] = (int32_t)lrintf(inp0);\n                (*sample_buffer)[(i*2)+1] = (int32_t)lrintf(inp0);\n            }\n        } else {\n            ch  = hDecoder->internal_channel[0];\n            ch1 = hDecoder->internal_channel[1];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch ][i];\n                real_t inp1 = input[ch1][i];\n\n                inp0 *= 256.0f;\n                inp1 *= 256.0f;\n                CLIP(inp0, 8388607.0f, -8388608.0f);\n                CLIP(inp1, 8388607.0f, -8388608.0f);\n""}, {""source"": ""value_info(file:output.c, value:internal_channel)"", ""result"": {""value_trace"": [{""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 365, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels+1] = channels+1"", ""line"": 366, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels"", ""line"": 369, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 371, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels"", ""line"": 423, ""func_name"": ""decode_cpe""}], ""struct_var"": ""internal_channel"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:syntax.c, lines:300-400)"", ""result"": ""    {\n        pce->cc_element_is_ind_sw[i] = faad_get1bit(ld\n            DEBUGVAR(1,34,\""program_config_element(): cc_element_is_ind_sw\""));\n        pce->valid_cc_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,35,\""program_config_element(): valid_cc_element_tag_select\""));\n    }\n\n    faad_byte_align(ld);\n\n    pce->comment_field_bytes = (uint8_t)faad_getbits(ld, 8\n        DEBUGVAR(1,36,\""program_config_element(): comment_field_bytes\""));\n\n    for (i = 0; i < pce->comment_field_bytes; i++)\n    {\n        pce->comment_field_data[i] = (uint8_t)faad_getbits(ld, 8\n            DEBUGVAR(1,37,\""program_config_element(): comment_field_data\""));\n    }\n    pce->comment_field_data[i] = 0;\n\n    if (pce->channels > MAX_CHANNELS)\n        return 22;\n\n    return 0;\n}\n\nstatic void decode_sce_lfe(NeAACDecStruct *hDecoder,\n                           NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+1 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for SCE hDecoder->element_output_channels[] is not set here because this\n       can become 2 when some form of Parametric Stereo coding is used\n    */\n\n    if (hDecoder->element_id[hDecoder->fr_ch_ele] != INVALID_ELEMENT_ID &&\n        hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele)\n    {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag);\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        if (hDecoder->pce_set)\n            hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels;\n        else\n            hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n}\n\nstatic void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n""}, {""source"": ""value_info(file:syntax.c, value:hDecoder->internal_channel)"", ""result"": {""value_trace"": [{""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 365, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels+1] = channels+1"", ""line"": 366, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels"", ""line"": 369, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 371, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels"", ""line"": 423, ""func_name"": ""decode_cpe""}], ""struct_var"": ""hDecoder"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:syntax.c, lines:100-200)"", ""result"": ""static uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,\n                         bitfile *ld, ic_stream *ics, uint8_t scal_flag);\n#ifdef DRM\nstatic int8_t DRM_aac_scalable_main_header(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                           bitfile *ld, uint8_t this_layer_stereo);\n#endif\n\n\n/* Table 4.4.1 */\nint8_t GASpecificConfig(bitfile *ld, mp4AudioSpecificConfig *mp4ASC,\n                        program_config *pce_out)\n{\n    program_config pce;\n\n    /* 1024 or 960 */\n    mp4ASC->frameLengthFlag = faad_get1bit(ld\n        DEBUGVAR(1,138,\""GASpecificConfig(): FrameLengthFlag\""));\n#ifndef ALLOW_SMALL_FRAMELENGTH\n    if (mp4ASC->frameLengthFlag == 1)\n        return -3;\n#endif\n\n    mp4ASC->dependsOnCoreCoder = faad_get1bit(ld\n        DEBUGVAR(1,139,\""GASpecificConfig(): DependsOnCoreCoder\""));\n    if (mp4ASC->dependsOnCoreCoder == 1)\n    {\n        mp4ASC->coreCoderDelay = (uint16_t)faad_getbits(ld, 14\n            DEBUGVAR(1,140,\""GASpecificConfig(): CoreCoderDelay\""));\n    }\n\n    mp4ASC->extensionFlag = faad_get1bit(ld DEBUGVAR(1,141,\""GASpecificConfig(): ExtensionFlag\""));\n    if (mp4ASC->channelsConfiguration == 0)\n    {\n        if (program_config_element(&pce, ld))\n            return -3;\n        //mp4ASC->channelsConfiguration = pce.channels;\n\n        if (pce_out != NULL)\n            memcpy(pce_out, &pce, sizeof(program_config));\n\n        /*\n        if (pce.num_valid_cc_elements)\n            return -3;\n        */\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (mp4ASC->extensionFlag == 1)\n    {\n        /* Error resilience not supported yet */\n        if (mp4ASC->objectTypeIndex >= ER_OBJECT_START)\n        {\n            mp4ASC->aacSectionDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,144,\""GASpecificConfig(): aacSectionDataResilienceFlag\""));\n            mp4ASC->aacScalefactorDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,145,\""GASpecificConfig(): aacScalefactorDataResilienceFlag\""));\n            mp4ASC->aacSpectralDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,146,\""GASpecificConfig(): aacSpectralDataResilienceFlag\""));\n        }\n        /* 1 bit: extensionFlag3 */\n        faad_getbits(ld, 1);\n\t}\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.2 */\n/* An MPEG-4 Audio decoder is only required to follow the Program\n   Configuration Element in GASpecificConfig(). The decoder shall ignore\n   any Program Configuration Elements that may occur in raw data blocks.\n   PCEs transmitted in raw data blocks cannot be used to convey decoder\n   configuration information.\n*/\nstatic uint8_t program_config_element(program_config *pce, bitfile *ld)\n{\n    uint8_t i;\n\n    memset(pce, 0, sizeof(program_config));\n\n    pce->channels = 0;\n\n    pce->element_instance_tag = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,10,\""program_config_element(): element_instance_tag\""));\n\n    pce->object_type = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,11,\""program_config_element(): object_type\""));\n    pce->sf_index = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,12,\""program_config_element(): sf_index\""));\n    pce->num_front_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,13,\""program_config_element(): num_front_channel_elements\""));\n    pce->num_side_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,14,\""program_config_element(): num_side_channel_elements\""));\n    pce->num_back_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,15,\""program_config_element(): num_back_channel_elements\""));\n    pce->num_lfe_channel_elements = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,16,\""program_config_element(): num_lfe_channel_elements\""));\n    pce->num_assoc_data_elements = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,17,\""program_config_element(): num_assoc_data_elements\""));\n    pce->num_valid_cc_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,18,\""program_config_element(): num_valid_cc_elements\""));\n""}, {""source"": ""value_info(file:syntax.c, value:hDecoder->internal_channel)"", ""result"": {""value_trace"": [{""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 365, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels+1] = channels+1"", ""line"": 366, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels"", ""line"": 369, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 371, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels"", ""line"": 423, ""func_name"": ""decode_cpe""}], ""struct_var"": ""hDecoder"", ""struct_type"": null, ""struct_definition"": null}}]","libfaad/syntax.c:540-575: Missing error checks after decode_* calls allowed processing to continue despite hInfo->error being set. This caused hDecoder->internal_channel assignments in decode_sce_lfe (syntax.c:365-366, 369, 371) and decode_cpe (syntax.c:423) to be skipped during error conditions. When get_sample() (output.c:45-61, 444-466) later accessed hDecoder->internal_channel[channel], it dereferenced uninitialized/invalid indices. The error resilience code path failed to reset the decoder state, propagating corrupted indices.",0.95,./github/other_context/CVE-2021-32276
74,CVE-2021-36146,CWE-476,c_cpp,ACRN before 2.5 has a devicemodel/hw/pci/xhci.c NULL Pointer Dereference for a trb pointer.,https://github.com/projectacrn/acrn-hypervisor/commit/330359921e2e4c2f3f3a10b5bab86942d63c4428,"DM: xHCI: Check trb pointer before use it\n\nThe trb pointer may be NULL when get the address from user space, add\nthe pointer check before use the trb.\n\nTracked-On: #6172\nSigned-off-by: Liu Long <long.liu@intel.com>\nReviewed-by: Shuo A Liu <shuo.a.liu@intel.com>\nAcked-by: Yu Wang <yu1.wang@intel.com>",1,"[{""func_name"": ""pci_xhci_complete_commands"", ""file_path"": ""devicemodel/hw/pci/xhci.c"", ""func_code"": ""static int\npci_xhci_complete_commands(struct pci_xhci_vdev *xdev)\n{\n\tstruct xhci_trb\tevtrb;\n\tstruct xhci_trb\t*trb;\n\tuint64_t\tcrcr;\n\tuint32_t\tccs;\t\t/* cycle state (XHCI 4.9.2) */\n\tuint32_t\ttype;\n\tuint32_t\tslot;\n\tuint32_t\tcmderr;\n\n\txdev->opregs.crcr |= XHCI_CRCR_LO_CRR;\n\n\ttrb = xdev->opregs.cr_p;\n\tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n\tcrcr = xdev->opregs.crcr & ~0xF;\n\n\twhile (1) {\n\t\txdev->opregs.cr_p = trb;\n\n\t\ttype = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);\n\n\t\tif ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=\n\t\t    (ccs & XHCI_TRB_3_CYCLE_BIT))\n\t\t\tbreak;\n\n\t\tUPRINTF(LDBG, \""cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\""\n\t\t\t\"" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\"",\n\t\t\ttype, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,\n\t\t\ttrb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);\n\n\t\tcmderr = XHCI_TRB_ERROR_SUCCESS;\n\t\tevtrb.dwTrb2 = 0;\n\t\tevtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |\n\t\t      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);\n\t\tslot = 0;\n\n\t\tswitch (type) {\n\t\tcase XHCI_TRB_TYPE_LINK:\t\t\t/* 0x06 */\n\t\t\tif (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)\n\t\t\t\tccs ^= XHCI_CRCR_LO_RCS;\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ENABLE_SLOT:\t\t\t/* 0x09 */\n\t\t\t/*\n\t\t\t *From xHCI spec 4.5.3.2, the only command that\n\t\t\t *software is allowed to issue for the slot in\n\t\t\t *disabled state is the Enable Slot Command.\n\t\t\t * */\n\t\t\tcmderr = pci_xhci_cmd_enable_slot(xdev, &slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_DISABLE_SLOT:\t\t/* 0x0A */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_disable_slot(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ADDRESS_DEVICE:\t\t/* 0x0B */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_address_device(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_CONFIGURE_EP:\t\t/* 0x0C */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_EVALUATE_CTX:\t\t/* 0x0D */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_EP:\t\t\t/* 0x0E */\n\t\t\tUPRINTF(LDBG, \""Reset Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_STOP_EP:\t\t\t/* 0x0F */\n\t\t\tUPRINTF(LDBG, \""Stop Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_TR_DEQUEUE:\t\t/* 0x10 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_DEVICE:\t\t/* 0x11 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_device(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_EVENT:\t\t\t/* 0x12 */\n\t\t\t/* TODO: */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NEGOTIATE_BW:\t\t/* 0x13 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_LATENCY_TOL:\t\t/* 0x14 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_GET_PORT_BW:\t\t\t/* 0x15 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_HEADER:\t\t/* 0x16 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NOOP_CMD:\t\t\t/* 0x17 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(LDBG, \""unsupported cmd %x\\r\\n\"", type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type != XHCI_TRB_TYPE_LINK) {\n\t\t\t/*\n\t\t\t * insert command completion event and assert intr\n\t\t\t */\n\t\t\tevtrb.qwTrb0 = crcr;\n\t\t\tevtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);\n\t\t\tevtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);\n\t\t\tUPRINTF(LDBG, \""command 0x%x result: 0x%x\\r\\n\"",\n\t\t\t\ttype, cmderr);\n\t\t\tif (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {\n\t\t\t\tUPRINTF(LFTL, \""Failed to inject command completion event!\\r\\n\"");\n\t\t\t\treturn -ENAVAIL;\n\t\t\t}\n\t\t}\n\n\t\ttrb = pci_xhci_trb_next(xdev, trb, &crcr);\n\t\tif (!trb) {\n\t\t\tUPRINTF(LDBG, \""Get the invalid trb in %s!\\r\\n\"", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n\txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""pci_xhci_complete_commands"", ""file_path"": ""devicemodel/hw/pci/xhci.c"", ""func_code"": ""static int\npci_xhci_complete_commands(struct pci_xhci_vdev *xdev)\n{\n\tstruct xhci_trb\tevtrb;\n\tstruct xhci_trb\t*trb;\n\tuint64_t\tcrcr;\n\tuint32_t\tccs;\t\t/* cycle state (XHCI 4.9.2) */\n\tuint32_t\ttype;\n\tuint32_t\tslot;\n\tuint32_t\tcmderr;\n\n\txdev->opregs.crcr |= XHCI_CRCR_LO_CRR;\n\n\ttrb = xdev->opregs.cr_p;\n\tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n\tcrcr = xdev->opregs.crcr & ~0xF;\n\tif (!trb) {\n\t\tUPRINTF(LDBG, \""Get the invalid guest address!\\r\\n\"");\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\txdev->opregs.cr_p = trb;\n\n\t\ttype = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);\n\n\t\tif ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=\n\t\t    (ccs & XHCI_TRB_3_CYCLE_BIT))\n\t\t\tbreak;\n\n\t\tUPRINTF(LDBG, \""cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\""\n\t\t\t\"" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\"",\n\t\t\ttype, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,\n\t\t\ttrb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);\n\n\t\tcmderr = XHCI_TRB_ERROR_SUCCESS;\n\t\tevtrb.dwTrb2 = 0;\n\t\tevtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |\n\t\t      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);\n\t\tslot = 0;\n\n\t\tswitch (type) {\n\t\tcase XHCI_TRB_TYPE_LINK:\t\t\t/* 0x06 */\n\t\t\tif (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)\n\t\t\t\tccs ^= XHCI_CRCR_LO_RCS;\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ENABLE_SLOT:\t\t\t/* 0x09 */\n\t\t\t/*\n\t\t\t *From xHCI spec 4.5.3.2, the only command that\n\t\t\t *software is allowed to issue for the slot in\n\t\t\t *disabled state is the Enable Slot Command.\n\t\t\t * */\n\t\t\tcmderr = pci_xhci_cmd_enable_slot(xdev, &slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_DISABLE_SLOT:\t\t/* 0x0A */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_disable_slot(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ADDRESS_DEVICE:\t\t/* 0x0B */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_address_device(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_CONFIGURE_EP:\t\t/* 0x0C */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_EVALUATE_CTX:\t\t/* 0x0D */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_EP:\t\t\t/* 0x0E */\n\t\t\tUPRINTF(LDBG, \""Reset Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_STOP_EP:\t\t\t/* 0x0F */\n\t\t\tUPRINTF(LDBG, \""Stop Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_TR_DEQUEUE:\t\t/* 0x10 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_DEVICE:\t\t/* 0x11 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_device(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_EVENT:\t\t\t/* 0x12 */\n\t\t\t/* TODO: */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NEGOTIATE_BW:\t\t/* 0x13 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_LATENCY_TOL:\t\t/* 0x14 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_GET_PORT_BW:\t\t\t/* 0x15 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_HEADER:\t\t/* 0x16 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NOOP_CMD:\t\t\t/* 0x17 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(LDBG, \""unsupported cmd %x\\r\\n\"", type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type != XHCI_TRB_TYPE_LINK) {\n\t\t\t/*\n\t\t\t * insert command completion event and assert intr\n\t\t\t */\n\t\t\tevtrb.qwTrb0 = crcr;\n\t\t\tevtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);\n\t\t\tevtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);\n\t\t\tUPRINTF(LDBG, \""command 0x%x result: 0x%x\\r\\n\"",\n\t\t\t\ttype, cmderr);\n\t\t\tif (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {\n\t\t\t\tUPRINTF(LFTL, \""Failed to inject command completion event!\\r\\n\"");\n\t\t\t\treturn -ENAVAIL;\n\t\t\t}\n\t\t}\n\n\t\ttrb = pci_xhci_trb_next(xdev, trb, &crcr);\n\t\tif (!trb) {\n\t\t\tUPRINTF(LDBG, \""Get the invalid trb in %s!\\r\\n\"", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n\txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n\treturn 0;\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:xhci.c, value:xdev->opregs.cr_p)"", ""result"": {""value_trace"": [{""full_code"": ""xdev->opregs.cr_p = trb"", ""line"": 2632, ""func_name"": ""pci_xhci_complete_commands""}, {""full_code"": ""xdev->opregs.cr_p = XHCI_GADDR(xdev,\n\t\t\t\t\t  xdev->opregs.crcr & ~0xF)"", ""line"": 3572, ""func_name"": ""pci_xhci_hostop_write""}], ""struct_var"": ""xdev"", ""struct_type"": ""pci_xhci_opregs"", ""struct_definition"": ""struct pci_xhci_opregs {\n\tuint32_t\tusbcmd;\t\t/* usb command */\n\tuint32_t\tusbsts;\t\t/* usb status */\n\tuint32_t\tpgsz;\t\t/* page size */\n\tuint32_t\tdnctrl;\t\t/* device notification control */\n\tuint64_t\tcrcr;\t\t/* command ring control */\n\tuint64_t\tdcbaap;\t\t/* device ctx base addr array ptr */\n\tuint32_t\tconfig;\t\t/* configure */\n\n\t/* guest mapped addresses: */\n\tstruct xhci_trb\t*cr_p;\t\t/* crcr dequeue */\n\tstruct xhci_dcbaa *dcbaa_p;\t/* dev ctx array ptr */\n}\n\nstruct pci_xhci_opregs""}}]","devicemodel/hw/pci/xhci.c:2628: 'trb' is assigned from 'xdev->opregs.cr_p' (unvalidated guest input). devicemodel/hw/pci/xhci.c:3572: 'xdev->opregs.cr_p' is set via 'XHCI_GADDR' from 'xdev->opregs.crcr', which is populated by guest writes to the CRCR register. Guest can set CRCR to 0, causing 'trb' to be NULL and triggering a dereference in 'pci_xhci_complete_commands' before the patch.",0.95,./github/other_context/CVE-2021-36146
75,CVE-2022-1341,CWE-476,c_cpp,An issue was discovered in in bwm-ng v0.6.2. An arbitrary null write exists in get_cmdln_options() function in src/options.c.,https://github.com/vgropp/bwm-ng/commit/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17,Fix https://github.com/vgropp/bwm-ng/issues/26,1,"[{""func_name"": ""get_cmdln_options"", ""file_path"": ""src/options.c"", ""func_code"": ""void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\""timeout\"", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\""procfile\"",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\""diskstatsfile\"",1,0,1000},\n\t\t\t{\""partitionsfile\"",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\""netstat\"",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\""longdisknames\"",0,0,1002},\n#endif\n        {\""input\"",1,0,'i'},\n        {\""dynamic\"",1,0,'d'},\n        {\""help\"", 0, 0, 'h'},\n        {\""version\"",0,0,'V'},\n        {\""allif\"",1,0,'a'},\n        {\""unit\"",1,0,'u'},\n\t\t  {\""ansiout\"",0,0,'N'},\n#if EXTENDED_STATS        \n        {\""type\"",1,0,'T'},\n        {\""avglength\"",1,0,'A'},\n#endif        \n        {\""interfaces\"",1,0,'I'},\n        {\""sumhidden\"",1,0,'S'},\n        {\""output\"",1,0,'o'},\n#ifdef CSV\n        {\""csvchar\"",1,0,'C'},\n        {\""csvfile\"",1,0,'F'},\n#endif\n        {\""count\"",1,0,'c'},\n        {\""daemon\"",1,0,'D'},\n#ifdef HTML\n        {\""htmlrefresh\"",1,0,'R'},\n        {\""htmlheader\"",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\""/etc/bwm-ng.conf\"");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\""%s/.bwm-ng.conf\"",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\""unknown option: %s\\n\"",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\""-a\"") || !strcasecmp(argv[optind-1],\""--allif\"")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\""-d\"") || !strcasecmp(argv[optind-1],\""--dynamic\""))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\""-D\"") || !strcasecmp(argv[optind-1],\""--daemon\""))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\""-H\"") || !strcasecmp(argv[optind-1],\""--htmlheader\""))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\""-S\"") || !strcasecmp(argv[optind-1],\""--sumhidden\""))\n                            sumhidden=1;    \n                          else {\n                              printf(\""%s requires an argument!\\n\"",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\""a\""); \n                    if (!out_file) deinit(1, \""failed to open outfile\\n\"");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \""avglength needs to be a least twice the value of timeout\\n\"");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}"", ""target"": 0}]","[{""func_name"": ""get_cmdln_options"", ""file_path"": ""src/options.c"", ""func_code"": ""void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\""timeout\"", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\""procfile\"",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\""diskstatsfile\"",1,0,1000},\n\t\t\t{\""partitionsfile\"",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\""netstat\"",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\""longdisknames\"",0,0,1002},\n#endif\n        {\""input\"",1,0,'i'},\n        {\""dynamic\"",1,0,'d'},\n        {\""help\"", 0, 0, 'h'},\n        {\""version\"",0,0,'V'},\n        {\""allif\"",1,0,'a'},\n        {\""unit\"",1,0,'u'},\n\t\t  {\""ansiout\"",0,0,'N'},\n#if EXTENDED_STATS        \n        {\""type\"",1,0,'T'},\n        {\""avglength\"",1,0,'A'},\n#endif        \n        {\""interfaces\"",1,0,'I'},\n        {\""sumhidden\"",1,0,'S'},\n        {\""output\"",1,0,'o'},\n#ifdef CSV\n        {\""csvchar\"",1,0,'C'},\n        {\""csvfile\"",1,0,'F'},\n#endif\n        {\""count\"",1,0,'c'},\n        {\""daemon\"",1,0,'D'},\n#ifdef HTML\n        {\""htmlrefresh\"",1,0,'R'},\n        {\""htmlheader\"",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\""/etc/bwm-ng.conf\"");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            if(!str) {\n              printf(\""Fatal: failed to allocate %zu bytes.\\n\"", strlen(pwd_entry->pw_dir)+14);\n              exit(EXIT_FAILURE);\n            }\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\""%s/.bwm-ng.conf\"",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\""unknown option: %s\\n\"",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\""-a\"") || !strcasecmp(argv[optind-1],\""--allif\"")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\""-d\"") || !strcasecmp(argv[optind-1],\""--dynamic\""))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\""-D\"") || !strcasecmp(argv[optind-1],\""--daemon\""))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\""-H\"") || !strcasecmp(argv[optind-1],\""--htmlheader\""))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\""-S\"") || !strcasecmp(argv[optind-1],\""--sumhidden\""))\n                            sumhidden=1;    \n                          else {\n                              printf(\""%s requires an argument!\\n\"",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\""a\""); \n                    if (!out_file) deinit(1, \""failed to open outfile\\n\"");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \""avglength needs to be a least twice the value of timeout\\n\"");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}""}]",{},[],"Original code flow: `str=(char*)malloc(...)` at `src/options.c:336` allocates memory without checking for failure. If `malloc` returns NULL, `snprintf(str, ...)` at the same file:line would attempt to write to a NULL pointer, causing an arbitrary null write. The patch introduces a NULL check for `str` and exits on failure, directly addressing this unsafe usage.",0.95,./github/other_context/CVE-2022-1341
